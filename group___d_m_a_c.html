<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: Transfer (r_dmac)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
    $(document).ready(function() {
        $("tr.tree_lvl_1").nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
		$("tr.tree_lvl_1").data("expanded","0");
		$("tr.tree_lvl_2").data("expanded","0");
		$("tr.tree_lvl_3").data("expanded","0");
		$("tr.tree_lvl_4").data("expanded","0");
		$("tr.tree_lvl_5").data("expanded","0");
        $("tr.tree_lvl_1").click(function() {
		    var lvl_1_is_open = $(this).data("expanded");
		    if (lvl_1_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2, tr.tree_lvl_1_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_2").click(function() {
		    var lvl_2_is_open = $(this).data("expanded");
		    if (lvl_2_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3, tr.tree_lvl_2_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_3").click(function() {
		    var lvl_3_is_open = $(this).data("expanded");
		    if (lvl_3_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_3_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_4").click(function() {
		    var lvl_4_is_open = $(this).data("expanded");
		    if (lvl_4_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5, tr.tree_lvl_4_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_5").click(function() {
		    var lvl_5_is_open = $(this).data("expanded");
		    if (lvl_5_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4_item,tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
     });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v6.2.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">

    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text">
      </span>
      <span class="right">
          &nbsp;
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___d_m_a_c.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body.
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len));
            }
          }
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element.
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle">
<div class="title">Transfer (r_dmac)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___t_r_a_n_s_f_e_r___m_o_d_u_l_e_s.html">Transfer</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga448a013ad5b91097e45833313d5df354"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ga448a013ad5b91097e45833313d5df354">R_DMAC_Open</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__cfg__t">transfer_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:ga448a013ad5b91097e45833313d5df354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ecb4ad0414589e60ec2b8d45c88d9bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ga5ecb4ad0414589e60ec2b8d45c88d9bf">R_DMAC_Reconfigure</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__info__t">transfer_info_t</a> *p_info)</td></tr>
<tr class="separator:ga5ecb4ad0414589e60ec2b8d45c88d9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac8f15eacf61325ad50ca0778cfc7ffd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#gaac8f15eacf61325ad50ca0778cfc7ffd">R_DMAC_Reset</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_api_ctrl, void const *volatile p_src, void *volatile p_dest, uint16_t const num_transfers)</td></tr>
<tr class="separator:gaac8f15eacf61325ad50ca0778cfc7ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga476c8ffd7c603f3c298a422e4f39b571"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ga476c8ffd7c603f3c298a422e4f39b571">R_DMAC_SoftwareStart</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga11917a0ab2cb8b878937c97691b07fd9">transfer_start_mode_t</a> mode)</td></tr>
<tr class="separator:ga476c8ffd7c603f3c298a422e4f39b571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a306937010d51313cec844047e9d622"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ga4a306937010d51313cec844047e9d622">R_DMAC_SoftwareStop</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:ga4a306937010d51313cec844047e9d622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf72221183919d50cbd8ee1ca528aa20b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#gaf72221183919d50cbd8ee1ca528aa20b">R_DMAC_Enable</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:gaf72221183919d50cbd8ee1ca528aa20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b64368039ad6617f091a20b5ac16206"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ga6b64368039ad6617f091a20b5ac16206">R_DMAC_Disable</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:ga6b64368039ad6617f091a20b5ac16206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade7f6c387756ca9728194ac15f01fc43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#gade7f6c387756ca9728194ac15f01fc43">R_DMAC_InfoGet</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__properties__t">transfer_properties_t</a> *const p_info)</td></tr>
<tr class="separator:gade7f6c387756ca9728194ac15f01fc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga697b9273351d29eb3e0c9319dce2e382"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ga697b9273351d29eb3e0c9319dce2e382">R_DMAC_Reload</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_api_ctrl, void const *p_src, void *p_dest, uint32_t const num_transfers)</td></tr>
<tr class="separator:ga697b9273351d29eb3e0c9319dce2e382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga077f508a90dcb91ca3b65b164bbd17d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ga077f508a90dcb91ca3b65b164bbd17d0">R_DMAC_CallbackSet</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_api_ctrl, void(*p_callback)(<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__callback__args__t">dmac_callback_args_t</a> *), void *const p_context, <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__callback__args__t">dmac_callback_args_t</a> *const p_callback_memory)</td></tr>
<tr class="separator:ga077f508a90dcb91ca3b65b164bbd17d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3423bb11f0d76dbe760ed01cf03ccd45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ga3423bb11f0d76dbe760ed01cf03ccd45">R_DMAC_Close</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:ga3423bb11f0d76dbe760ed01cf03ccd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the DMAC peripheral on RA MCUs. This module implements the <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html">Transfer Interface</a>. </p>
<h1><a class="anchor" id="r-dmac-overview"></a>
Overview</h1>
<p>The Direct Memory Access Controller (DMAC) transfers data from one memory location to another without using the CPU.</p>
<h2><a class="anchor" id="r-dmac-features"></a>
Features</h2>
<ul>
<li>Supports multiple transfer modes<ul>
<li>Normal transfer</li>
<li>Repeat transfer</li>
<li>Block transfer</li>
<li>Repeat-Block transfer (Not available on all MCUs)</li>
</ul>
</li>
<li>Address increment, decrement, fixed, or offset modes<a class="anchor" id="um_transfer_address_inc_dec_fixed"></a></li>
<li>Triggered by ELC events<ul>
<li>Some exceptions apply, see the Event table in the Event Numbers section of the Interrupt Controller Unit chapter of the hardware manual</li>
</ul>
</li>
<li>Supports 1, 2, and 4 byte data units<a class="anchor" id="um_transfer_unit"></a></li>
</ul>
<h1><a class="anchor" id="r-dmac-configuration"></a>
Configuration</h1>
<p><a class="anchor" id="um_transfer_normal_mode"></a><a class="anchor" id="um_transfer_repeat_mode"></a><a class="anchor" id="um_transfer_block_mode"></a><a class="anchor" id="um_transfer_activation_source"></a><a class="anchor" id="um_transfer_block_repeat_area"></a><a class="anchor" id="um_transfer_repeat_area"></a><a class="anchor" id="um_dmac_each_block_interrupt"></a><a class="anchor" id="um_dmac_end_interrupt"></a><a class="anchor" id="um_dmac_offset_mode"></a> <h2>Build Time Configurations for r_dmac</h2>
The following build time configurations are defined in fsp_cfg/r_dmac_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
</table>
 <h2>Configurations for Transfer &gt; Transfer (r_dmac)</h2>
This module can be added to the Stacks tab via New Stack &gt; Transfer &gt; Transfer (r_dmac).<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Name</td><td>Name must be a valid C symbol</td><td>g_transfer0 </td><td>Module name. </td></tr>
<tr class="tree_none">
<td>Channel</td><td>Value must be a non-negative integer</td><td>0 </td><td>Specify the hardware channel. </td></tr>
<tr class="tree_none">
<td>Mode</td><td>MCU Specific Options</td><td></td><td>Select the transfer mode. Normal: One transfer per activation, transfer ends after Number of Transfers; Repeat: One transfer per activation, Repeat Area address reset after Number of Transfers, transfer ends after Number of Blocks; Block: Number of Blocks per activation, Repeat Area address reset after Number of Transfers, transfer ends after Number of Blocks. </td></tr>
<tr class="tree_none">
<td>Transfer Size</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1 Byte</li>
<li>
2 Bytes</li>
<li>
4 Bytes</li>
</ul>
</td><td>2 Bytes </td><td>Select the transfer size. </td></tr>
<tr class="tree_none">
<td>Destination Address Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Fixed</li>
<li>
Offset addition</li>
<li>
Incremented</li>
<li>
Decremented</li>
</ul>
</td><td>Fixed </td><td>Select the address mode for the destination. </td></tr>
<tr class="tree_none">
<td>Source Address Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Fixed</li>
<li>
Offset addition</li>
<li>
Incremented</li>
<li>
Decremented</li>
</ul>
</td><td>Fixed </td><td>Select the address mode for the source. </td></tr>
<tr class="tree_none">
<td>Repeat Area (Unused in Normal Mode)</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Destination</li>
<li>
Source</li>
</ul>
</td><td>Source </td><td>Select the repeat area. Either the source or destination address resets to its initial value after completing Number of Transfers in Repeat or Block mode. </td></tr>
<tr class="tree_none">
<td>Number of Transfers</td><td>Value must be a non-negative integer</td><td>1 </td><td>Specify the number of transfers for repeat and normal mode or block size for repeat-block transfer mode. </td></tr>
<tr class="tree_none">
<td>Number of Blocks (Valid only in Repeat,Block or Repeat-Block Mode)</td><td>Value must be a non-negative integer</td><td>0 </td><td>Specify the number of blocks to transfer in Repeat,Block or Repeat-Block mode. </td></tr>
<tr class="tree_none">
<td>Activation Source</td><td>MCU Specific Options</td><td></td><td>Select the DMAC transfer start event. If no ELC event is chosen then software start can be used. </td></tr>
<tr class="tree_none">
<td>Callback</td><td>Name must be a valid C symbol</td><td>NULL </td><td>A user callback that is called at the end of the transfer. </td></tr>
<tr class="tree_none">
<td>Transfer End Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select the transfer end interrupt priority. </td></tr>
<tr class="tree_none">
<td>Interrupt Frequency</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Interrupt after all transfers have completed</li>
<li>
Interrupt after each block, or repeat size is transferred</li>
</ul>
</td><td>Interrupt after all transfers have completed </td><td>Select to have interrupt after each transfer or after last transfer. </td></tr>
<tr class="tree_none">
<td>Offset value (Valid only when address mode is Offset addition)</td><td>Value must be a 24 bit signed integer.</td><td>1 </td><td>Offset value is added to the address after each transfer. </td></tr>
<tr class="tree_none">
<td>Source Buffer Size</td><td>Value must be a non-negative integer with a maximum configurable value of 65535.</td><td>1 </td><td>Specify the size of whole source buffer (valid only for Repeat-Block transfer mode with source address update mode other than offset addition). </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-dmac-clock-configuration"></a>
Clock Configuration</h2>
<p>The DMAC peripheral module uses ICLK as the clock source. The ICLK frequency is set by using the <b>Clocks</b> tab of the RA Configuration editor prior to a build, or by using the CGC module at run-time.</p>
<h2><a class="anchor" id="r-dmac-pin-configuration"></a>
Pin Configuration</h2>
<p>This module does not use I/O pins.</p>
<h1><a class="anchor" id="r-dmac-usage_notes"></a>
Usage Notes</h1>
<h2>Source and Destination Configuration</h2>
<p><a class="el" href="group___d_m_a_c.html#gaac8f15eacf61325ad50ca0778cfc7ffd">R_DMAC_Reset()</a> API function should be called to set the source and destination before starting transfer operation.</p>
<h2>Transfer Modes</h2>
<p>The DMAC Module supports three modes of operation.</p>
<ul>
<li><b>Normal Mode</b> - In normal mode, a single data unit is transferred every time the configured ELC event is received by the DMAC channel. A data unit can be 1-byte, 2-bytes, or 4-bytes. The source and destination addresses can be fixed, increment, decrement, or add an offset to the next data unit after each transfer. A 16-bit counter decrements after each transfer. When the counter reaches 0, transfers will no longer be triggered by the ELC event and the CPU can be interrupted to signal that all transfers have finished.</li>
<li><b>Repeat Mode</b> - Repeat mode works the same way as normal mode, however the length is limited to an integer in the range[1,1024]. When the transfer counter reaches 0, the counter is reset to its configured value, the repeat area (source or destination address) resets to its starting address and the block count remaining will decrement by 1. When the block count reaches 0, transfers will no longer be triggered by the ELC event and the CPU may be interrupted to signal that all transfers have finished.</li>
<li><b>Block Mode</b> - In block mode, the amount of data units transferred by each interrupt can be set to an integer in the range [1,1024]. The number of blocks to transfer can also be configured to a 16-bit number. After each block transfer the repeat area (source or destination address) will reset to the original address and the other address will be incremented or decremented to the next block.</li>
<li><b>Repeat-Block Mode</b> - In repeat-block mode, the amount of data units transferred by each interrupt can be set to an integer in the range [1,1024]. The number of blocks to transfer can be configured to a 16 bit number. If the destination address mode is offset mode, maximum configurable number of blocks is 0xFFFF for block size(length) of one with data transfer size as byte,0x7FFF for block size of one with data transfer size as half word and 0x3FFF for block size of one with data size as word. After each block transfer the source address and the destination address will be incremented or decremented to the next block address. In case of offset address mode for source address, the source address size is the total size of source buffer after which the source area is rolled over, block size can be smaller than the source buffer size.For source address mode as offset mode, the maximum configurable source buffer size is 0xFFFF for transfer data size of a byte,0x7FFF for transfer data size of half word and 0x3FFF for transfer data size of word. Repeat-block mode can be used to implement single ring buffer to multiple ring buffer transfer type design.</li>
</ul>
<h2>Selecting the DTC or DMAC</h2>
<p>The Transfer API is implemented by both DTC and the DMAC so that applications can switch between the DTC and the DMAC. When selecting between them, consider these factors:</p>
<table class="doxtable">
<tr>
<th></th><th>DTC </th><th>DMAC  </th></tr>
<tr>
<td>Repeat Mode </td><td><ul>
<li>
Repeats forever</li>
<li>
Max repeat size is 256 x 4 bytes</li>
</ul>
</td><td><ul>
<li>
Configurable number of repeats</li>
<li>
Max repeat size is 1024 x 4 bytes</li>
</ul>
</td></tr>
<tr>
<td>Block Mode </td><td><ul>
<li>
Max block size is 256 x 4 bytes</li>
</ul>
</td><td><ul>
<li>
Max block size is 1024 x 4 bytes</li>
</ul>
</td></tr>
<tr>
<td>Channels </td><td><ul>
<li>
One instance per interrupt</li>
</ul>
</td><td><ul>
<li>
MCU specific (8 channels or less)</li>
</ul>
</td></tr>
<tr>
<td>Chained Transfers </td><td><ul>
<li>
Supported</li>
</ul>
</td><td><ul>
<li>
Not Supported</li>
</ul>
</td></tr>
<tr>
<td>Software Trigger </td><td><ul>
<li>
Must use the software ELC event</li>
</ul>
</td><td><ul>
<li>
Has support for software trigger without using software ELC event</li>
<li>
Supports TRANSFER_START_MODE_SINGLE and TRANSFER_START_MODE_REPEAT</li>
</ul>
</td></tr>
<tr>
<td>Offset Address Mode </td><td><ul>
<li>
Not supported</li>
</ul>
</td><td><ul>
<li>
Supported</li>
</ul>
</td></tr>
</table>
<h3>Interrupts</h3>
<p>The DTC and DMAC interrupts behave differently. The DTC uses the configured IELSR event IRQ as the interrupt source whereas each DMAC channel has its own IRQ.</p>
<p>The transfer_info_t::irq setting also behaves a little differently depending on which mode is selected.</p>
<h4>Normal Mode</h4>
<table class="doxtable">
<tr>
<th></th><th>DTC </th><th>DMAC  </th></tr>
<tr>
<td>TRANSFER_IRQ_EACH </td><td>Interrupt after each transfer </td><td>N/A </td></tr>
<tr>
<td>TRANSFER_IRQ_END </td><td>Interrupt after last transfer </td><td>Interrupt after last transfer </td></tr>
</table>
<h4>Repeat Mode</h4>
<table class="doxtable">
<tr>
<th></th><th>DTC </th><th>DMAC  </th></tr>
<tr>
<td>TRANSFER_IRQ_EACH </td><td>Interrupt after each transfer </td><td>Interrupt after each repeat </td></tr>
<tr>
<td>TRANSFER_IRQ_END </td><td>Interrupt after each repeat </td><td>Interrupt after last transfer </td></tr>
</table>
<h4>Block Mode</h4>
<table class="doxtable">
<tr>
<th></th><th>DTC </th><th>DMAC  </th></tr>
<tr>
<td>TRANSFER_IRQ_EACH </td><td>Interrupt after each block </td><td>Interrupt after each block </td></tr>
<tr>
<td>TRANSFER_IRQ_END </td><td>Interrupt after last block </td><td>Interrupt after last block </td></tr>
</table>
<h4>Repeat-block Mode</h4>
<table class="doxtable">
<tr>
<th></th><th>DTC </th><th>DMAC  </th></tr>
<tr>
<td>TRANSFER_IRQ_EACH </td><td>N/A </td><td>N/A </td></tr>
<tr>
<td>TRANSFER_IRQ_END </td><td>N/A </td><td>Interrupt after last block </td></tr>
</table>
<h3>Additional Considerations</h3>
<ul>
<li>The DTC requires a moderate amount of RAM (one <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__info__t">transfer_info_t</a> struct per open instance + DTC_VECTOR_TABLE_SIZE).</li>
<li>The DTC stores transfer information in RAM and writes back to RAM after each transfer whereas the DMAC stores all transfer information in registers.</li>
<li>When transfers are configured for more than one activation source, the DTC must fetch the transfer info from RAM on each interrupt. This can cause a higher latency between transfers.</li>
</ul>
<h2>Offset Address Mode</h2>
<p>When the source or destination mode is configured to offset mode, a configurable offset is added to the source or destination pointer after each transfer. The offset is a signed 24 bit number.</p>
<h1><a class="anchor" id="r-dmac-examples"></a>
Examples</h1>
<h2>Basic Example</h2>
<p>This is a basic example of minimal use of the DMAC in an application. In this case, one or more events have been routed to the DMAC for handling so it only needs to be enabled to start accepting transfers.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> dmac_minimal_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line"></div><div class="line">    <span class="comment">/* Open the transfer instance with initial configuration. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___d_m_a_c.html#ga448a013ad5b91097e45833313d5df354">R_DMAC_Open</a>(&amp;g_transfer_ctrl, &amp;g_transfer_cfg);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Enable the DMAC so that it responds to transfer requests. */</span></div><div class="line">    err = <a class="code" href="group___d_m_a_c.html#gaf72221183919d50cbd8ee1ca528aa20b">R_DMAC_Enable</a>(&amp;g_transfer_ctrl);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>CRC32 Example</h2>
<p>In this example the DMAC is used to feed the CRC peripheral to perform a CRC32 operation.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keyword">volatile</span> <span class="keywordtype">bool</span> g_transfer_complete = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> dmac_callback (<a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__callback__args__t">dmac_callback_args_t</a> * cb_data)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gaf0afcbc9a110ac9366a811d96ee06029">FSP_PARAMETER_NOT_USED</a>(cb_data);</div><div class="line"></div><div class="line">    g_transfer_complete = <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> dmac_crc_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint8_t p_src[TRANSFER_LENGTH];</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize p_src to [ABC..OP] */</span></div><div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; TRANSFER_LENGTH; i++)</div><div class="line">    {</div><div class="line">        p_src[i] = (uint8_t) (<span class="charliteral">&#39;A&#39;</span> + (i % 26));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Set transfer source address to p_src */</span></div><div class="line">    g_transfer_cfg.p_info-&gt;p_src = (<span class="keywordtype">void</span> *) p_src;</div><div class="line"></div><div class="line">    <span class="comment">/* Set transfer destination address to the CRC data input register */</span></div><div class="line">    g_transfer_cfg.p_info-&gt;p_dest = (<span class="keywordtype">void</span> *) &amp;R_CRC-&gt;CRCDIR;</div><div class="line"></div><div class="line">    <span class="comment">/* Open the transfer instance with initial configuration. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___d_m_a_c.html#ga448a013ad5b91097e45833313d5df354">R_DMAC_Open</a>(&amp;g_transfer_ctrl, &amp;g_transfer_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable DMAC transfers. */</span></div><div class="line">    (void) <a class="code" href="group___d_m_a_c.html#gaf72221183919d50cbd8ee1ca528aa20b">R_DMAC_Enable</a>(&amp;g_transfer_ctrl);</div><div class="line"></div><div class="line">    <span class="comment">/* Open the CRC module. */</span></div><div class="line">    err = <a class="code" href="group___c_r_c.html#gae4cc2bba5d6aeaadd9f4d43948fca5ac">R_CRC_Open</a>(&amp;g_crc_ctrl, &amp;g_crc_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Clear the transfer complete flag. */</span></div><div class="line">    g_transfer_complete = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Trigger the transfer using software. */</span></div><div class="line">    err = <a class="code" href="group___d_m_a_c.html#ga476c8ffd7c603f3c298a422e4f39b571">R_DMAC_SoftwareStart</a>(&amp;g_transfer_ctrl, <a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#gga11917a0ab2cb8b878937c97691b07fd9aca210983d734307a694af55fbf11ed7e">TRANSFER_START_MODE_SINGLE</a>);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (!g_transfer_complete)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait for transfer complete interrupt */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Get CRC result and perform final XOR. */</span></div><div class="line">    uint32_t crc32;</div><div class="line">    (void) <a class="code" href="group___c_r_c.html#ga5bb7766a9c3217d2da7b77ea203b8c74">R_CRC_CalculatedValueGet</a>(&amp;g_crc_ctrl, &amp;crc32);</div><div class="line">    crc32 ^= CRC32_FINAL_XOR_VALUE;</div><div class="line"></div><div class="line">    <span class="comment">/* Verify that the CRC32 is calculated correctly. */</span></div><div class="line">    <span class="comment">/* CRC32(&quot;ABCD...NOP&quot;) = 0xE0E8FF4D. */</span></div><div class="line">    <span class="keyword">const</span> uint32_t expected_crc32 = 0xE0E8FF4D;</div><div class="line">    <span class="keywordflow">if</span> (expected_crc32 != crc32)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Handle any CRC errors. This function should be defined by the user. */</span></div><div class="line">        handle_crc_error();</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structdmac__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#structdmac__instance__ctrl__t">dmac_instance_ctrl_t</a></td></tr>
<tr class="separator:structdmac__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structdmac__extended__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#structdmac__extended__cfg__t">dmac_extended_cfg_t</a></td></tr>
<tr class="separator:structdmac__extended__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga1e459d63cbd5b7c819ca786a55093307"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ga1e459d63cbd5b7c819ca786a55093307">DMAC_MAX_NORMAL_TRANSFER_LENGTH</a></td></tr>
<tr class="separator:ga1e459d63cbd5b7c819ca786a55093307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga786c4e53754be810f4483273fd1b2e35"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ga786c4e53754be810f4483273fd1b2e35">DMAC_MAX_REPEAT_TRANSFER_LENGTH</a></td></tr>
<tr class="separator:ga786c4e53754be810f4483273fd1b2e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4cd4e308943601114ffcafdc621c116"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#gab4cd4e308943601114ffcafdc621c116">DMAC_MAX_BLOCK_TRANSFER_LENGTH</a></td></tr>
<tr class="separator:gab4cd4e308943601114ffcafdc621c116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga023cdeb9d88a44b02c482fdc2eea872a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ga023cdeb9d88a44b02c482fdc2eea872a">DMAC_MAX_REPEAT_COUNT</a></td></tr>
<tr class="separator:ga023cdeb9d88a44b02c482fdc2eea872a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga131d20a9c197907bac9d399f7f8664d9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ga131d20a9c197907bac9d399f7f8664d9">DMAC_MAX_BLOCK_COUNT</a></td></tr>
<tr class="separator:ga131d20a9c197907bac9d399f7f8664d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structdmac__instance__ctrl__t" id="structdmac__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structdmac__instance__ctrl__t">&#9670;&nbsp;</a></span>dmac_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct dmac_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Control block used by driver. DO NOT INITIALIZE - this structure will be initialized in <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a84d48960cdfe867ef54fd4635a85ceeb">transfer_api_t::open</a>. </p>
</div>
</div>
</div>
<a name="structdmac__extended__cfg__t" id="structdmac__extended__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structdmac__extended__cfg__t">&#9670;&nbsp;</a></span>dmac_extended_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct dmac_extended_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>DMAC transfer configuration extension. This extension is required. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a96ee22f2e357c5098bbe67bbdf920371"><td class="memItemLeft" align="right" valign="top"><a id="a96ee22f2e357c5098bbe67bbdf920371"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#a96ee22f2e357c5098bbe67bbdf920371">channel</a></td></tr>
<tr class="memdesc:a96ee22f2e357c5098bbe67bbdf920371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Channel number, does not apply to all HAL drivers. <br /></td></tr>
<tr class="separator:a96ee22f2e357c5098bbe67bbdf920371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50d47176d2618694b18cfeb957f6036"><td class="memItemLeft" align="right" valign="top"><a id="aa50d47176d2618694b18cfeb957f6036"></a>
IRQn_Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#aa50d47176d2618694b18cfeb957f6036">irq</a></td></tr>
<tr class="memdesc:aa50d47176d2618694b18cfeb957f6036"><td class="mdescLeft">&#160;</td><td class="mdescRight">DMAC interrupt number. <br /></td></tr>
<tr class="separator:aa50d47176d2618694b18cfeb957f6036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e1360a4094cbcf9d4d171223627f4c"><td class="memItemLeft" align="right" valign="top"><a id="a01e1360a4094cbcf9d4d171223627f4c"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#a01e1360a4094cbcf9d4d171223627f4c">ipl</a></td></tr>
<tr class="memdesc:a01e1360a4094cbcf9d4d171223627f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">DMAC interrupt priority. <br /></td></tr>
<tr class="separator:a01e1360a4094cbcf9d4d171223627f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8669f5a4263d19902385b7e6b48262"><td class="memItemLeft" align="right" valign="top"><a id="a4d8669f5a4263d19902385b7e6b48262"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#a4d8669f5a4263d19902385b7e6b48262">offset</a></td></tr>
<tr class="memdesc:a4d8669f5a4263d19902385b7e6b48262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset value used with transfer_addr_mode_t::TRANSFER_ADDR_MODE_OFFSET. <br /></td></tr>
<tr class="separator:a4d8669f5a4263d19902385b7e6b48262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a54c3a163ff659e26a6f7ed319f4777"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#a6a54c3a163ff659e26a6f7ed319f4777">src_buffer_size</a></td></tr>
<tr class="separator:a6a54c3a163ff659e26a6f7ed319f4777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae520b30cee620c91a4aa4d123ef437bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___m_c_u___r_a0_e1.html#gaebe723200f2a7f181f08324128b9d7b5">elc_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ae520b30cee620c91a4aa4d123ef437bc">activation_source</a></td></tr>
<tr class="separator:ae520b30cee620c91a4aa4d123ef437bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa5df5a650e272348c4bd6c71ad4392"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#a1aa5df5a650e272348c4bd6c71ad4392">p_callback</a> )(<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__callback__args__t">dmac_callback_args_t</a> *cb_data)</td></tr>
<tr class="separator:a1aa5df5a650e272348c4bd6c71ad4392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d67e9dcb77c2929401542935579c68"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#a23d67e9dcb77c2929401542935579c68">p_context</a></td></tr>
<tr class="separator:a23d67e9dcb77c2929401542935579c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a id="a6a54c3a163ff659e26a6f7ed319f4777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a54c3a163ff659e26a6f7ed319f4777">&#9670;&nbsp;</a></span>src_buffer_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t dmac_extended_cfg_t::src_buffer_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Source ring buffer size for <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ggadfb7c2a6a73bfdf993e50505aa92992fafb43c6e62b61f0dbb9a5bcd5575e79e2">TRANSFER_MODE_REPEAT_BLOCK</a>. </p>

</div>
</div>
<a id="ae520b30cee620c91a4aa4d123ef437bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae520b30cee620c91a4aa4d123ef437bc">&#9670;&nbsp;</a></span>activation_source</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___m_c_u___r_a0_e1.html#gaebe723200f2a7f181f08324128b9d7b5">elc_event_t</a> dmac_extended_cfg_t::activation_source</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select which event will trigger the transfer. </p><dl class="section note"><dt>Note</dt><dd>Select ELC_EVENT_NONE for software activation in order to use softwareStart and softwareStart to trigger transfers. </dd></dl>

</div>
</div>
<a id="a1aa5df5a650e272348c4bd6c71ad4392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa5df5a650e272348c4bd6c71ad4392">&#9670;&nbsp;</a></span>p_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(*  dmac_extended_cfg_t::p_callback) (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__callback__args__t">dmac_callback_args_t</a> *cb_data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback for transfer end interrupt. </p>

</div>
</div>
<a id="a23d67e9dcb77c2929401542935579c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23d67e9dcb77c2929401542935579c68">&#9670;&nbsp;</a></span>p_context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dmac_extended_cfg_t::p_context</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Placeholder for user data. Passed to the user p_callback in <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__callback__args__t">transfer_callback_args_t</a>. </p>

</div>
</div>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga1e459d63cbd5b7c819ca786a55093307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e459d63cbd5b7c819ca786a55093307">&#9670;&nbsp;</a></span>DMAC_MAX_NORMAL_TRANSFER_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DMAC_MAX_NORMAL_TRANSFER_LENGTH</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Max configurable number of transfers in TRANSFER_MODE_NORMAL. </p>

</div>
</div>
<a id="ga786c4e53754be810f4483273fd1b2e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga786c4e53754be810f4483273fd1b2e35">&#9670;&nbsp;</a></span>DMAC_MAX_REPEAT_TRANSFER_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DMAC_MAX_REPEAT_TRANSFER_LENGTH</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Max number of transfers per repeat for TRANSFER_MODE_REPEAT. </p>

</div>
</div>
<a id="gab4cd4e308943601114ffcafdc621c116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4cd4e308943601114ffcafdc621c116">&#9670;&nbsp;</a></span>DMAC_MAX_BLOCK_TRANSFER_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DMAC_MAX_BLOCK_TRANSFER_LENGTH</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Max number of transfers per block in TRANSFER_MODE_BLOCK </p>

</div>
</div>
<a id="ga023cdeb9d88a44b02c482fdc2eea872a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga023cdeb9d88a44b02c482fdc2eea872a">&#9670;&nbsp;</a></span>DMAC_MAX_REPEAT_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DMAC_MAX_REPEAT_COUNT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Max configurable number of repeats to transfer in TRANSFER_MODE_REPEAT </p>

</div>
</div>
<a id="ga131d20a9c197907bac9d399f7f8664d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga131d20a9c197907bac9d399f7f8664d9">&#9670;&nbsp;</a></span>DMAC_MAX_BLOCK_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DMAC_MAX_BLOCK_COUNT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Max configurable number of blocks to transfer in TRANSFER_MODE_BLOCK </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga448a013ad5b91097e45833313d5df354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga448a013ad5b91097e45833313d5df354">&#9670;&nbsp;</a></span>R_DMAC_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DMAC_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__cfg__t">transfer_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure a DMAC channel.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful open. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input parameter is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_IP_CHANNEL_NOT_PRESENT</td><td>The configured channel is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_IRQ_BSP_DISABLED</td><td>The IRQ associated with the activation source is not enabled in the BSP. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>The control structure is already opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5ecb4ad0414589e60ec2b8d45c88d9bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ecb4ad0414589e60ec2b8d45c88d9bf">&#9670;&nbsp;</a></span>R_DMAC_Reconfigure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DMAC_Reconfigure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__info__t">transfer_info_t</a> *&#160;</td>
          <td class="paramname"><em>p_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reconfigure the transfer with new transfer info.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Transfer is configured and will start when trigger occurs. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input parameter is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_ENABLED</td><td>DMAC is not enabled. The current configuration must not be valid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Handle is not initialized. Call R_DMAC_Open to initialize the control block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaac8f15eacf61325ad50ca0778cfc7ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac8f15eacf61325ad50ca0778cfc7ffd">&#9670;&nbsp;</a></span>R_DMAC_Reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DMAC_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *volatile&#160;</td>
          <td class="paramname"><em>p_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *volatile&#160;</td>
          <td class="paramname"><em>p_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t const&#160;</td>
          <td class="paramname"><em>num_transfers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset transfer source, destination, and number of transfers.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Transfer reset successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input parameter is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_ENABLED</td><td>DMAC is not enabled. The current configuration must not be valid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Handle is not initialized. Call R_DMAC_Open to initialize the control block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga476c8ffd7c603f3c298a422e4f39b571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga476c8ffd7c603f3c298a422e4f39b571">&#9670;&nbsp;</a></span>R_DMAC_SoftwareStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DMAC_SoftwareStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga11917a0ab2cb8b878937c97691b07fd9">transfer_start_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the mode is TRANSFER_START_MODE_SINGLE initiate a single transfer with software. If the mode is TRANSFER_START_MODE_REPEAT continue triggering transfers until all of the transfers are completed.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Transfer started written successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input parameter is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Handle is not initialized. Call R_DMAC_Open to initialize the control block. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Handle was not configured for software activation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4a306937010d51313cec844047e9d622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a306937010d51313cec844047e9d622">&#9670;&nbsp;</a></span>R_DMAC_SoftwareStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DMAC_SoftwareStop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop software transfers if they were started with TRANSFER_START_MODE_REPEAT.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Transfer stopped written successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input parameter is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Handle is not initialized. Call R_DMAC_Open to initialize the control block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf72221183919d50cbd8ee1ca528aa20b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf72221183919d50cbd8ee1ca528aa20b">&#9670;&nbsp;</a></span>R_DMAC_Enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DMAC_Enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable transfers for the configured activation source.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Counter value written successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input parameter is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Handle is not initialized. Call R_DMAC_Open to initialize the control block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6b64368039ad6617f091a20b5ac16206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b64368039ad6617f091a20b5ac16206">&#9670;&nbsp;</a></span>R_DMAC_Disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DMAC_Disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable transfers so that they are no longer triggered by the activation source.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Counter value written successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input parameter is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Handle is not initialized. Call R_DMAC_Open to initialize the control block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gade7f6c387756ca9728194ac15f01fc43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade7f6c387756ca9728194ac15f01fc43">&#9670;&nbsp;</a></span>R_DMAC_InfoGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DMAC_InfoGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__properties__t">transfer_properties_t</a> *const&#160;</td>
          <td class="paramname"><em>p_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set driver specific information in provided pointer.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Information has been written to p_info. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Handle is not initialized. Call R_DMAC_Open to initialize the control block. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input parameter is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga697b9273351d29eb3e0c9319dce2e382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga697b9273351d29eb3e0c9319dce2e382">&#9670;&nbsp;</a></span>R_DMAC_Reload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DMAC_Reload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>p_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>num_transfers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>To update next transfer information without interruption during transfer.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>This feature is not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga077f508a90dcb91ca3b65b164bbd17d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga077f508a90dcb91ca3b65b164bbd17d0">&#9670;&nbsp;</a></span>R_DMAC_CallbackSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DMAC_CallbackSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__callback__args__t">dmac_callback_args_t</a> *)&#160;</td>
          <td class="paramname"><em>p_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>p_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__callback__args__t">dmac_callback_args_t</a> *const&#160;</td>
          <td class="paramname"><em>p_callback_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the user callback with the option to provide memory for the callback argument structure.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Callback updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3423bb11f0d76dbe760ed01cf03ccd45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3423bb11f0d76dbe760ed01cf03ccd45">&#9670;&nbsp;</a></span>R_DMAC_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DMAC_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable transfer and clean up internal data. Implements <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ade5973e7a8e994f9146e0db84bee8bf4">transfer_api_t::close</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful close. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input parameter is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Handle is not initialized. Call R_DMAC_Open to initialize the control block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v6.2.0 User's Manual Copyright © (2025) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
