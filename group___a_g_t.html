<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: Asynchronous General Purpose Timer (r_agt)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v1.3.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___a_g_t.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">Asynchronous General Purpose Timer (r_agt)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabe0a42cc31ae911c5ac6fe78eeb21c8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_g_t.html#gabe0a42cc31ae911c5ac6fe78eeb21c8a">R_AGT_Close</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:gabe0a42cc31ae911c5ac6fe78eeb21c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b8a21776f618aaa1b8471592b4b5464"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_g_t.html#ga1b8a21776f618aaa1b8471592b4b5464">R_AGT_PeriodSet</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl, uint32_t const period_counts)</td></tr>
<tr class="separator:ga1b8a21776f618aaa1b8471592b4b5464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25f4904a0e4ce56c413364b7c21b76a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_g_t.html#ga25f4904a0e4ce56c413364b7c21b76a3">R_AGT_DutyCycleSet</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl, uint32_t const duty_cycle_counts, uint32_t const pin)</td></tr>
<tr class="separator:ga25f4904a0e4ce56c413364b7c21b76a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ae3d1d197e2a433939dc430dad05d99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_g_t.html#ga1ae3d1d197e2a433939dc430dad05d99">R_AGT_Reset</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:ga1ae3d1d197e2a433939dc430dad05d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e5c0080a8a035351d920360d6e9fd4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_g_t.html#ga6e5c0080a8a035351d920360d6e9fd4d">R_AGT_Start</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:ga6e5c0080a8a035351d920360d6e9fd4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga548babc3a9f803374e70ba027935a086"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_g_t.html#ga548babc3a9f803374e70ba027935a086">R_AGT_Enable</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:ga548babc3a9f803374e70ba027935a086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae27f425278e24c45345242a78a10d649"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_g_t.html#gae27f425278e24c45345242a78a10d649">R_AGT_Disable</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:gae27f425278e24c45345242a78a10d649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91174b9feb94088512b85d2f020d3fe2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_g_t.html#ga91174b9feb94088512b85d2f020d3fe2">R_AGT_InfoGet</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl, <a class="el" href="group___t_i_m_e_r___a_p_i.html#structtimer__info__t">timer_info_t</a> *const p_info)</td></tr>
<tr class="separator:ga91174b9feb94088512b85d2f020d3fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11a30a7a093f91c09a340f7b301945fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_g_t.html#ga11a30a7a093f91c09a340f7b301945fd">R_AGT_StatusGet</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl, <a class="el" href="group___t_i_m_e_r___a_p_i.html#structtimer__status__t">timer_status_t</a> *const p_status)</td></tr>
<tr class="separator:ga11a30a7a093f91c09a340f7b301945fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2b20f0b2d6856813a3a76413e0083c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_g_t.html#gaa2b20f0b2d6856813a3a76413e0083c0">R_AGT_Stop</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:gaa2b20f0b2d6856813a3a76413e0083c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga499ee5459a9adb90cf73dd659ae29b46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_g_t.html#ga499ee5459a9adb90cf73dd659ae29b46">R_AGT_Open</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl, <a class="el" href="group___t_i_m_e_r___a_p_i.html#structtimer__cfg__t">timer_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:ga499ee5459a9adb90cf73dd659ae29b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6d600521cfd1134e1fd5cd5fefe2819"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_g_t.html#gad6d600521cfd1134e1fd5cd5fefe2819">R_AGT_VersionGet</a> (<a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#unionfsp__version__t">fsp_version_t</a> *const p_version)</td></tr>
<tr class="separator:gad6d600521cfd1134e1fd5cd5fefe2819"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the AGT peripheral on RA MCUs. This module implements the <a class="el" href="group___t_i_m_e_r___a_p_i.html">Timer Interface</a>. </p>
<h1><a class="anchor" id="r-agt-overview"></a>
Overview</h1>
<h2><a class="anchor" id="r-agt-features"></a>
Features</h2>
<p>The AGT module has the following features:</p><ul>
<li>Supports periodic mode, one-shot mode, and PWM mode.</li>
<li>Signal can be output to a pin.<a class="anchor" id="um_timer_output_disable"></a></li>
<li>Configurable period (counts per timer cycle).</li>
<li>Configurable duty cycle in PWM mode.</li>
<li>Configurable clock source, including PCLKB, LOCO, SUBCLK, and external sources input to AGTIO.<a class="anchor" id="um_agt_event_counter_mode"></a></li>
<li>Supports runtime reconfiguration of period.</li>
<li>Supports runtime reconfiguration of duty cycle in PWM mode.</li>
<li>Supports counting based on an external clock input to AGTIO.</li>
<li>Supports debounce filter on AGTIO pins.<a class="anchor" id="um_timer_input_debounce_filter"></a></li>
<li>Supports measuring pulse width or pulse period.</li>
<li>APIs are provided to start, stop, and reset the counter.</li>
<li>APIs are provided to get the current period, source clock frequency, and count direction.<a class="anchor" id="um_timer_count_direction"></a></li>
<li>APIs are provided to get the current timer status and counter value.<a class="anchor" id="um_timer_status"></a> </li>
</ul>
<h2><a class="anchor" id="r-agt-selecting-a-timer"></a>
Selecting a Timer</h2>
<p>RA MCUs have two timer peripherals: the General PWM Timer (GPT) and the Asynchronous General Purpose Timer (AGT). When selecting between them, consider these factors:</p>
<table class="doxtable">
<tr>
<th></th><th>GPT </th><th>AGT  </th></tr>
<tr>
<td>Low Power Modes</td><td>The GPT can operate in sleep mode.</td><td>The AGT can operate in all low power modes (when count source is LOCO or subclock). </td></tr>
<tr>
<td>Available Channels</td><td>The number of GPT channels is device specific. All currently supported MCUs have at least 7 GPT channels.</td><td>All MCUs have 2 AGT channels. </td></tr>
<tr>
<td>Timer Resolution</td><td>All MCUs have at least one 32-bit GPT timer.</td><td>The AGT timers are 16-bit timers. </td></tr>
<tr>
<td>Clock Source</td><td>The GPT runs off PCLKD with a configurable divider up to 1024. It can also be configured to count ELC events or external pulses.</td><td>The AGT runs off PCLKB, LOCO, or subclock with a configurable divider up to 8 for PCLKB or up to 128 for LOCO or subclock. </td></tr>
</table>
<h1><a class="anchor" id="r-agt-configuration"></a>
Configuration</h1>
<p><a class="anchor" id="um_timer_multiple_channels"></a> <h2>Build Time Configurations for r_agt</h2>
The following build time configurations are defined in fsp_cfg/r_agt_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr>
<td>Pin Output Support</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>If selected code for outputting a waveform to a pin is included in the build. </td></tr>
<tr>
<td>Pin Input Support</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>Enable input support to use pulse width measurement mode, pulse period measurement mode, or input from P402, P402, or AGTIO. </td></tr>
</table>
 <h2>Configurations for Driver &gt; Timers &gt; Timer Driver on r_agt</h2>
This module can be added to the Stacks tab via New Stack &gt; Driver &gt; Timers &gt; Timer Driver on r_agt:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>General &gt; Name</td><td>Name must be a valid C symbol</td><td>g_timer0 </td><td>Module name. </td></tr>
<tr>
<td>General &gt; Channel</td><td>Available AGT Channels are 0 and 1</td><td>0 </td><td>Physical hardware channel. </td></tr>
<tr>
<td>General &gt; Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Periodic</li>
<li>
One-Shot</li>
<li>
PWM</li>
</ul>
</td><td>Periodic </td><td>Mode selection. Note: One-shot mode is implemented in software. ISR's must be enabled for one shot even if callback is unused. </td></tr>
<tr>
<td>General &gt; Period</td><td>Value must be non-negative</td><td>0x10000 </td><td>Specify the timer period based on the selected unit.<br />
<br />
When the unit is set to 'Raw Counts', setting the period to 0x10000 results in the maximum period at the lowest divisor (fastest timer tick). Set the period to 0x10000 for a free running timer, pulse width measurement or pulse period measurement. Setting the period higher will automatically select a higher divider; the period can be set up to 0x80000 when counting from PCLKB or 0x800000 when counting from LOCO/subclock, which will use a divider of 8 or 128 respectively with the maximum period. </td></tr>
<tr>
<td>General &gt; Period Unit</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Raw Counts</li>
<li>
Nanoseconds</li>
<li>
Microseconds</li>
<li>
Milliseconds</li>
<li>
Seconds</li>
<li>
Hertz</li>
<li>
Kilohertz</li>
</ul>
</td><td>Raw Counts </td><td>Unit of the period specified above </td></tr>
<tr>
<td>General &gt; Count Source</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
PCLKB</li>
<li>
LOCO</li>
<li>
SUBCLOCK</li>
<li>
AGT0 Underflow</li>
<li>
P402 Input</li>
<li>
P403 Input</li>
<li>
AGTIO Input</li>
</ul>
</td><td>PCLKB </td><td>AGT counter clock source. NOTE: The divisor is calculated automatically based on the selected period. See agt_count_source_t documentation for details. </td></tr>
<tr>
<td>Output &gt; Duty Cycle Percent (only applicable in PWM mode)</td><td>Value must be between 0 and 100</td><td>50 </td><td>Specify the timer duty cycle percent. Only used in PWM mode. </td></tr>
<tr>
<td>Output &gt; AGTOA Output</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Start Level Low</li>
<li>
Start Level High</li>
</ul>
</td><td>Disabled </td><td>Configure AGTOA output. </td></tr>
<tr>
<td>Output &gt; AGTOB Output</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Start Level Low</li>
<li>
Start Level High</li>
</ul>
</td><td>Disabled </td><td>Configure AGTOB output. </td></tr>
<tr>
<td>Output &gt; AGTO Output</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Start Level Low</li>
<li>
Start Level High</li>
</ul>
</td><td>Disabled </td><td>Configure AGTO output. </td></tr>
<tr>
<td>Input &gt; Measurement Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Measure Disabled</li>
<li>
Measure Low Level Pulse Width</li>
<li>
Measure High Level Pulse Width</li>
<li>
Measure Pulse Period</li>
</ul>
</td><td>Measure Disabled </td><td>Select if the AGT should be used to measure pulse width or pulse period. In high level pulse width measurement mode, the AGT counts when AGTIO is high and starts counting immediately in the middle of a pulse if AGTIO is high when <a class="el" href="group___a_g_t.html#ga6e5c0080a8a035351d920360d6e9fd4d">R_AGT_Start()</a> is called. In low level pulse width measurement mode, the AGT counts when AGTIO is low and could start counting in the middle of a pulse if AGTIO is low when <a class="el" href="group___a_g_t.html#ga6e5c0080a8a035351d920360d6e9fd4d">R_AGT_Start()</a> is called. </td></tr>
<tr>
<td>Input &gt; Input Filter</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
No Filter</li>
<li>
Filter sampled at PCLKB</li>
<li>
Filter sampled at PCLKB / 8</li>
<li>
Filter sampled at PCLKB / 32</li>
</ul>
</td><td>No Filter </td><td>Input filter, applies AGTIO in pulse period measurement, pulse width measurement, or event counter mode. The filter requires the signal to be at the same level for 3 successive reads at the specified filter frequency. </td></tr>
<tr>
<td>Input &gt; Enable Pin</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enable Pin Not Used</li>
<li>
Enable Pin Active Low</li>
<li>
Enable Pin Active High</li>
</ul>
</td><td>Enable Pin Not Used </td><td>Select active edge for the AGTEE pin if used. Only applies if the count source is P402, P403 or AGTIO. </td></tr>
<tr>
<td>Input &gt; Trigger Edge</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Trigger Edge Rising</li>
<li>
Trigger Edge Falling</li>
<li>
Trigger Edge Both</li>
</ul>
</td><td>Trigger Edge Rising </td><td>Select the trigger edge. Applies if measurement mode is pulse period, or if the count source is P402, P403, or AGTIO. Do not select Trigger Edge Both with pulse period measurement. </td></tr>
<tr>
<td>Interrupts &gt; Callback</td><td>Name must be a valid C symbol</td><td>NULL </td><td>A user callback function. If this callback function is provided, it is called from the interrupt service routine (ISR) each time the timer period elapses. </td></tr>
<tr>
<td>Interrupts &gt; Underflow Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Timer interrupt priority. </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-agt-clock-configuration"></a>
Clock Configuration</h2>
<p>The AGT clock is based on the PCLKB, LOCO, or Subclock frequency. You can set the clock frequency using the <b>Clocks</b> tab of the RA Configuration editor or by using the CGC Interface at run-time.</p>
<h2><a class="anchor" id="r-agt-pin-configuration"></a>
Pin Configuration</h2>
<p>This module can use the AGTOA and AGTOB pins as output pins for periodic, one-shot, or PWM signals.</p>
<p>For input capture, the input signal must be applied to the AGTIOn pin.</p>
<p>For event counting, the AGTEEn enable pin is optional.</p>
<h2><a class="anchor" id="r-agt-timer-period"></a>
Timer Period</h2>
<p>The RA Configuration editor will automatically calculate the period count value and source clock divider based on the selected period time, units, and clock speed.</p>
<p>When the selected unit is "Raw counts", the maximum allowed period setting varies depending on the selected clock source:</p>
<table class="doxtable">
<tr>
<th>Clock source </th><th>Maximum period (counts)  </th></tr>
<tr>
<td>LOCO/Subclock </td><td>0x800000 </td></tr>
<tr>
<td>PCLKB </td><td>0x80000 </td></tr>
<tr>
<td>All other sources </td><td>0x10000 </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Though the AGT is a 16-bit timer, because the period interrupt occurs when the counter underflows, setting the period register to 0 results in an effective period of 1 count. For this reason all user-provided raw count values reflect the actual number of period counts (not the raw register values).</dd></dl>
<h1><a class="anchor" id="r-agt-usage_notes"></a>
Usage Notes</h1>
<h2>Starting and Stopping the AGT</h2>
<p><a class="anchor" id="um_agt_invalid_state"></a> After starting or stopping the timer, AGT registers cannot be accessed until the AGT state is updated after 3 AGTCLK cycles. If another AGT function is called before the 3 AGTCLK period elapses, the function spins waiting for the AGT state to update. The required wait time after starting or stopping the timer can be determined using the frequency of AGTCLK, which is derived from <a class="el" href="group___t_i_m_e_r___a_p_i.html#a592d3bb6a865ababe1c433ab7b83aa48" title="Source clock divider. ">timer_cfg_t::source_div</a> and <a class="el" href="group___a_g_t.html#ae95824d50fa5abbc1479dbd8939b1df1" title="AGT channel clock source. Valid values are: AGT_CLOCK_PCLKB, AGT_CLOCK_LOCO, AGT_CLOCK_FSUB. ">agt_extended_cfg_t::count_source</a>.</p>
<p>The application is responsible for ensuring required clocks are started and stable before accessing MCU peripheral registers.</p>
<dl class="section warning"><dt>Warning</dt><dd>The subclock can take seconds to stabilize. The RA startup code does not wait for subclock stabilization unless the subclock is the main clock source. When running AGT or RTC off the subclock, the application must ensure the subclock is stable before starting operation.</dd></dl>
<h2>Low Power Modes</h2>
<p>The AGT1 (channel 1 only) can be used to enter snooze mode or to wake the MCU from snooze, software standby, or deep software standby modes when a counter underflow occurs. The compare match A and B events can also be used to wake from software standby or snooze modes.</p>
<h2>One-Shot Mode</h2>
<p><a class="anchor" id="um_timer_one_shot_mode"></a> The AGT timer does not support one-shot mode natively. One-shot mode is achieved by stopping the timer in the interrupt service routine before the callback is called. If the interrupt is not serviced before the timer period expires again, the timer generates more than one event. The callback is only called once in this case, but multiple events may be generated if the timer is linked to the <a class="el" href="group___d_t_c.html">Data Transfer Controller (r_dtc)</a>.</p>
<h3>One-Shot Mode Output</h3>
<p><a class="anchor" id="um_timer_one_shot_output"></a> The output waveform in one-shot mode is one AGT clock cycle less than the configured period. The configured period must be at least 2 counts to generate an output pulse.</p>
<p>Examples of one-shot signals that can be generated by this module are shown below:</p>
<div class="image">
<object type="image/svg+xml" data="r_agt_one_shot_output.svg">r_agt_one_shot_output.svg</object>
<div class="caption">
AGT One-Shot Output</div></div>
 <h2>Periodic Output</h2>
<p><a class="anchor" id="um_timer_periodic_output"></a> The AGTOA or AGTOB pin toggles twice each time the timer expires in periodic mode. This is achieved by defining a PWM wave at a 50 percent duty cycle so that the period of the resulting square (from rising edge to rising edge) matches the period of the AGT timer. Since the periodic output is actually a PWM output, the time at the stop level is one cycle shorter than the time opposite the stop level for odd period values.</p>
<p>Examples of periodic signals that can be generated by this module are shown below:</p>
<div class="image">
<object type="image/svg+xml" data="r_agt_periodic_output.svg">r_agt_periodic_output.svg</object>
<div class="caption">
AGT Periodic Output</div></div>
 <h2>PWM Output</h2>
<p><a class="anchor" id="um_timer_pwm_output"></a> This module does not support in phase PWM output. The PWM output signal is low at the beginning of the cycle and high at the end of the cycle.</p>
<p>Examples of PWM signals that can be generated by this module are shown below:</p>
<div class="image">
<object type="image/svg+xml" data="r_agt_pwm_output.svg">r_agt_pwm_output.svg</object>
<div class="caption">
AGT PWM Output</div></div>
 <h2>Triggering ELC Events with AGT</h2>
<p>The AGT timer can trigger the start of other peripherals. The <a class="el" href="group___e_l_c.html">Event Link Controller (r_elc)</a> guide provides a list of all available peripherals.</p>
<h1><a class="anchor" id="r-agt-examples"></a>
Examples</h1>
<h2>AGT Basic Example</h2>
<p>This is a basic example of minimal use of the AGT in an application.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> agt_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___a_g_t.html#ga499ee5459a9adb90cf73dd659ae29b46">R_AGT_Open</a>(&amp;g_timer0_ctrl, &amp;g_timer0_cfg);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Start the timer. */</span></div><div class="line">    (void) <a class="code" href="group___a_g_t.html#ga6e5c0080a8a035351d920360d6e9fd4d">R_AGT_Start</a>(&amp;g_timer0_ctrl);</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>AGT Callback Example</h2>
<p>This is an example of a timer callback.</p>
<p><a class="anchor" id="um_timer_user_notification_of_events"></a> </p><div class="fragment"><div class="line"></div><div class="line"><span class="comment">/* Example callback called when timer expires. */</span></div><div class="line"><span class="keywordtype">void</span> timer_callback (<a class="code" href="group___t_i_m_e_r___a_p_i.html#structtimer__callback__args__t">timer_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___t_i_m_e_r___a_p_i.html#ggac3bee51f7c9078f794c5ac19522f91ebae310bef0d640f06765c01b4b91a5b84c">TIMER_EVENT_CYCLE_END</a> == p_args-&gt;<a class="code" href="group___t_i_m_e_r___a_p_i.html#a61b9aabfcafc5e362dce56af7ea36bcf">event</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Add application code to be called periodically here. */</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>AGT Free Running Counter Example</h2>
<p><a class="anchor" id="um_timer_reset"></a><a class="anchor" id="um_timer_start"></a><a class="anchor" id="um_timer_stop"></a><a class="anchor" id="um_timer_counter"></a> To use the AGT as a free running counter, select periodic mode and set the the Period to 0xFFFF.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> agt_counter_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___a_g_t.html#ga499ee5459a9adb90cf73dd659ae29b46">R_AGT_Open</a>(&amp;g_timer0_ctrl, &amp;g_timer0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    <span class="comment">/* Start the timer. */</span></div><div class="line">    (void) <a class="code" href="group___a_g_t.html#ga6e5c0080a8a035351d920360d6e9fd4d">R_AGT_Start</a>(&amp;g_timer0_ctrl);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Stop the timer. */</span></div><div class="line">    (void) <a class="code" href="group___a_g_t.html#gaa2b20f0b2d6856813a3a76413e0083c0">R_AGT_Stop</a>(&amp;g_timer0_ctrl);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Read the current counter value. Counter value is in status.counter. */</span></div><div class="line">    <a class="code" href="group___t_i_m_e_r___a_p_i.html#structtimer__status__t">timer_status_t</a> status;</div><div class="line">    (void) <a class="code" href="group___a_g_t.html#ga11a30a7a093f91c09a340f7b301945fd">R_AGT_StatusGet</a>(&amp;g_timer0_ctrl, &amp;status);</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>AGT Input Capture Example</h2>
<p><a class="anchor" id="um_timer_capture_pulse_width"></a><a class="anchor" id="um_timer_capture_pulse_period"></a><a class="anchor" id="um_timer_enable_disable"></a> This is an example of using the AGT to capture pulse width or pulse period measurements.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">/* Example callback called when a capture occurs. */</span></div><div class="line">uint64_t g_captured_time     = 0U;</div><div class="line">uint32_t g_capture_overflows = 0U;</div><div class="line"><span class="keywordtype">void</span> timer_capture_callback (<a class="code" href="group___t_i_m_e_r___a_p_i.html#structtimer__callback__args__t">timer_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___t_i_m_e_r___a_p_i.html#ggac3bee51f7c9078f794c5ac19522f91eba4bc1252f63147f4a01f7b7ba88afac1d">TIMER_EVENT_CAPTURE_A</a> == p_args-&gt;<a class="code" href="group___t_i_m_e_r___a_p_i.html#a61b9aabfcafc5e362dce56af7ea36bcf">event</a>)</div><div class="line">    {</div><div class="line"></div><div class="line">        <span class="comment">/* (Optional) Get the current period if not known. */</span></div><div class="line">        <a class="code" href="group___t_i_m_e_r___a_p_i.html#structtimer__info__t">timer_info_t</a> info;</div><div class="line">        (void) <a class="code" href="group___a_g_t.html#ga91174b9feb94088512b85d2f020d3fe2">R_AGT_InfoGet</a>(&amp;g_timer0_ctrl, &amp;info);</div><div class="line">        uint32_t period = info.<a class="code" href="group___t_i_m_e_r___a_p_i.html#a08b897cfbf2d0cefafe8d3abb1afc747">period_counts</a>;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">/* Process capture from AGTIO. */</span></div><div class="line">        g_captured_time     = ((uint64_t) period * g_capture_overflows) + p_args-&gt;<a class="code" href="group___t_i_m_e_r___a_p_i.html#a8abd12cdf1a993cf8054be6ba9d96a6f">capture</a>;</div><div class="line">        g_capture_overflows = 0U;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___t_i_m_e_r___a_p_i.html#ggac3bee51f7c9078f794c5ac19522f91ebae310bef0d640f06765c01b4b91a5b84c">TIMER_EVENT_CYCLE_END</a> == p_args-&gt;<a class="code" href="group___t_i_m_e_r___a_p_i.html#a61b9aabfcafc5e362dce56af7ea36bcf">event</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* An overflow occurred during capture. This must be accounted for at the application layer. */</span></div><div class="line">        g_capture_overflows++;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> agt_capture_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___a_g_t.html#ga499ee5459a9adb90cf73dd659ae29b46">R_AGT_Open</a>(&amp;g_timer0_ctrl, &amp;g_timer0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Enable captures. Captured values arrive in the interrupt. */</span></div><div class="line">    (void) <a class="code" href="group___a_g_t.html#ga548babc3a9f803374e70ba027935a086">R_AGT_Enable</a>(&amp;g_timer0_ctrl);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Disable captures. */</span></div><div class="line">    (void) <a class="code" href="group___a_g_t.html#gae27f425278e24c45345242a78a10d649">R_AGT_Disable</a>(&amp;g_timer0_ctrl);</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>AGT Period Update Example</h2>
<p><a class="anchor" id="um_timer_period_set"></a><a class="anchor" id="um_timer_clock_frequency"></a> This an example of updating the period.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define AGT_EXAMPLE_MSEC_PER_SEC           (1000)</span></div><div class="line"><span class="preprocessor">#define AGT_EXAMPLE_DESIRED_PERIOD_MSEC    (20)</span></div><div class="line"></div><div class="line"><span class="comment">/* This example shows how to calculate a new period value at runtime. */</span></div><div class="line"><span class="keywordtype">void</span> agt_period_calculation_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___a_g_t.html#ga499ee5459a9adb90cf73dd659ae29b46">R_AGT_Open</a>(&amp;g_timer0_ctrl, &amp;g_timer0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    <span class="comment">/* Start the timer. */</span></div><div class="line">    (void) <a class="code" href="group___a_g_t.html#ga6e5c0080a8a035351d920360d6e9fd4d">R_AGT_Start</a>(&amp;g_timer0_ctrl);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Get the source clock frequency (in Hz). There are several ways to do this in FSP:</span></div><div class="line"><span class="comment">     *  - If LOCO or subclock is chosen in agt_extended_cfg_t::clock_source</span></div><div class="line"><span class="comment">     *      - The source clock frequency is BSP_LOCO_HZ &gt;&gt; timer_cfg_t::source_div</span></div><div class="line"><span class="comment">     *  - If PCLKB is chosen in agt_extended_cfg_t::clock_source and the PCLKB frequency has not changed since reset,</span></div><div class="line"><span class="comment">     *      - The source clock frequency is BSP_STARTUP_PCLKB_HZ &gt;&gt; timer_cfg_t::source_div</span></div><div class="line"><span class="comment">     *  - Use the R_AGT_InfoGet function (it accounts for the clock source and divider).</span></div><div class="line"><span class="comment">     *  - Calculate the current PCLKB frequency using R_FSP_SystemClockHzGet(FSP_PRIV_CLOCK_PCLKB) and right shift</span></div><div class="line"><span class="comment">     *    by timer_cfg_t::source_div.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * This example uses the last option (R_FSP_SystemClockHzGet).</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    uint32_t timer_freq_hz = <a class="code" href="group___b_s_p___m_c_u.html#gaac289335b731d0bdb5cb8e6d243898ef">R_FSP_SystemClockHzGet</a>(FSP_PRIV_CLOCK_PCLKB) &gt;&gt; g_timer0_cfg.source_div;</div><div class="line"></div><div class="line">    <span class="comment">/* Calculate the desired period based on the current clock. Note that this calculation could overflow if the</span></div><div class="line"><span class="comment">     * desired period is larger than UINT32_MAX / pclkb_freq_hz. A cast to uint64_t is used to prevent this. */</span></div><div class="line">    uint32_t period_counts =</div><div class="line">        (uint32_t) (((uint64_t) timer_freq_hz * AGT_EXAMPLE_DESIRED_PERIOD_MSEC) / AGT_EXAMPLE_MSEC_PER_SEC);</div><div class="line"></div><div class="line">    <span class="comment">/* Set the calculated period. This will return an error if parameter checking is enabled and the calculated</span></div><div class="line"><span class="comment">     * period is larger than UINT16_MAX. */</span></div><div class="line">    err = <a class="code" href="group___a_g_t.html#ga1b8a21776f618aaa1b8471592b4b5464">R_AGT_PeriodSet</a>(&amp;g_timer0_ctrl, period_counts);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>AGT Duty Cycle Update Example</h2>
<p><a class="anchor" id="um_timer_duty_cycle_set"></a> This an example of updating the duty cycle.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define AGT_EXAMPLE_DESIRED_DUTY_CYCLE_PERCENT    (25)</span></div><div class="line"><span class="preprocessor">#define AGT_EXAMPLE_MAX_PERCENT                   (100)</span></div><div class="line"></div><div class="line"><span class="comment">/* This example shows how to calculate a new duty cycle value at runtime. */</span></div><div class="line"><span class="keywordtype">void</span> agt_duty_cycle_calculation_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___a_g_t.html#ga499ee5459a9adb90cf73dd659ae29b46">R_AGT_Open</a>(&amp;g_timer0_ctrl, &amp;g_timer0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    <span class="comment">/* Start the timer. */</span></div><div class="line">    (void) <a class="code" href="group___a_g_t.html#ga6e5c0080a8a035351d920360d6e9fd4d">R_AGT_Start</a>(&amp;g_timer0_ctrl);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Get the current period setting. */</span></div><div class="line">    <a class="code" href="group___t_i_m_e_r___a_p_i.html#structtimer__info__t">timer_info_t</a> info;</div><div class="line">    (void) <a class="code" href="group___a_g_t.html#ga91174b9feb94088512b85d2f020d3fe2">R_AGT_InfoGet</a>(&amp;g_timer0_ctrl, &amp;info);</div><div class="line">    uint32_t current_period_counts = info.<a class="code" href="group___t_i_m_e_r___a_p_i.html#a08b897cfbf2d0cefafe8d3abb1afc747">period_counts</a>;</div><div class="line"></div><div class="line">    <span class="comment">/* Calculate the desired duty cycle based on the current period. */</span></div><div class="line">    uint32_t duty_cycle_counts = (current_period_counts * AGT_EXAMPLE_DESIRED_DUTY_CYCLE_PERCENT) /</div><div class="line">                                 AGT_EXAMPLE_MAX_PERCENT;</div><div class="line"></div><div class="line">    <span class="comment">/* Set the calculated duty cycle. */</span></div><div class="line">    err = <a class="code" href="group___a_g_t.html#ga25f4904a0e4ce56c413364b7c21b76a3">R_AGT_DutyCycleSet</a>(&amp;g_timer0_ctrl, duty_cycle_counts, <a class="code" href="group___a_g_t.html#ggab3f3aa0cc9a2951751e76f493dd429eba72a6691905b605006601da6a30039ab0">AGT_OUTPUT_PIN_AGTOA</a>);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>AGT Cascaded Timers Example</h2>
<p><a class="anchor" id="um_agt_cascaded_timers"></a> This an example of using AGT0 underflow as the count source for AGT1.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">/* This example shows how use cascaded timers. The count source for AGT channel 1 is set to AGT0 underflow. */</span></div><div class="line"><span class="keywordtype">void</span> agt_cascaded_timers_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the timers in any order. */</span></div><div class="line">    err = <a class="code" href="group___a_g_t.html#ga499ee5459a9adb90cf73dd659ae29b46">R_AGT_Open</a>(&amp;g_timer_channel0_ctrl, &amp;g_timer_channel0_cfg);</div><div class="line">    handle_error(err);</div><div class="line">    err = <a class="code" href="group___a_g_t.html#ga499ee5459a9adb90cf73dd659ae29b46">R_AGT_Open</a>(&amp;g_timer_channel1_ctrl, &amp;g_timer_channel1_cfg);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    <span class="comment">/* Start AGT channel 1 first. */</span></div><div class="line">    (void) <a class="code" href="group___a_g_t.html#ga6e5c0080a8a035351d920360d6e9fd4d">R_AGT_Start</a>(&amp;g_timer_channel1_ctrl);</div><div class="line">    (void) <a class="code" href="group___a_g_t.html#ga6e5c0080a8a035351d920360d6e9fd4d">R_AGT_Start</a>(&amp;g_timer_channel0_ctrl);</div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Stop AGT channel 0 first. */</span></div><div class="line">    (void) <a class="code" href="group___a_g_t.html#gaa2b20f0b2d6856813a3a76413e0083c0">R_AGT_Stop</a>(&amp;g_timer_channel0_ctrl);</div><div class="line">    (void) <a class="code" href="group___a_g_t.html#gaa2b20f0b2d6856813a3a76413e0083c0">R_AGT_Stop</a>(&amp;g_timer_channel1_ctrl);</div><div class="line"></div><div class="line">    <span class="comment">/* Read the current counter value. Counter value is in status.counter. */</span></div><div class="line">    <a class="code" href="group___t_i_m_e_r___a_p_i.html#structtimer__status__t">timer_status_t</a> status;</div><div class="line">    (void) <a class="code" href="group___a_g_t.html#ga11a30a7a093f91c09a340f7b301945fd">R_AGT_StatusGet</a>(&amp;g_timer_channel1_ctrl, &amp;status);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structagt__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_g_t.html#structagt__instance__ctrl__t">agt_instance_ctrl_t</a></td></tr>
<tr class="separator:structagt__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structagt__extended__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_g_t.html#structagt__extended__cfg__t">agt_extended_cfg_t</a></td></tr>
<tr class="separator:structagt__extended__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga5281c5967b6830f430bdf20ac9424f1c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_g_t.html#ga5281c5967b6830f430bdf20ac9424f1c">agt_clock_t</a> </td></tr>
<tr class="separator:ga5281c5967b6830f430bdf20ac9424f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53f383c41ec6fc2cd240e67fab1b969f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_g_t.html#ga53f383c41ec6fc2cd240e67fab1b969f">agt_measure_t</a> </td></tr>
<tr class="separator:ga53f383c41ec6fc2cd240e67fab1b969f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga511738730422c0c8cc2b9de318005d1b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_g_t.html#ga511738730422c0c8cc2b9de318005d1b">agt_agtio_filter_t</a> </td></tr>
<tr class="separator:ga511738730422c0c8cc2b9de318005d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga310d73c260c901d1b8e7585dcb8f7507"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_g_t.html#ga310d73c260c901d1b8e7585dcb8f7507">agt_enable_pin_t</a> </td></tr>
<tr class="separator:ga310d73c260c901d1b8e7585dcb8f7507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d568085c1ce9738b532fde46c47d908"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_g_t.html#ga1d568085c1ce9738b532fde46c47d908">agt_trigger_edge_t</a> </td></tr>
<tr class="separator:ga1d568085c1ce9738b532fde46c47d908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3f3aa0cc9a2951751e76f493dd429eb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_g_t.html#gab3f3aa0cc9a2951751e76f493dd429eb">agt_output_pin_t</a> </td></tr>
<tr class="separator:gab3f3aa0cc9a2951751e76f493dd429eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb88a55a2156cdd322947f71189da627"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_g_t.html#gabb88a55a2156cdd322947f71189da627">agt_pin_cfg_t</a> </td></tr>
<tr class="separator:gabb88a55a2156cdd322947f71189da627"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structagt__instance__ctrl__t" id="structagt__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structagt__instance__ctrl__t">&#9670;&nbsp;</a></span>agt_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct agt_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Channel control block. DO NOT INITIALIZE. Initialization occurs when <a class="el" href="group___t_i_m_e_r___a_p_i.html#af49a90087a53c8019d642a3f7abaa8ad">timer_api_t::open</a> is called. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a47294d2091aca6d4c57e05ba78f8a069"></a>uint32_t</td>
<td class="fieldname">
open</td>
<td class="fielddoc">
Whether or not channel is open. </td></tr>
<tr><td class="fieldtype">
<a id="af45c7d6d16aabfe344c79d39811a6205"></a>const <a class="el" href="group___t_i_m_e_r___a_p_i.html#structtimer__cfg__t">timer_cfg_t</a> *</td>
<td class="fieldname">
p_cfg</td>
<td class="fielddoc">
Pointer to initial configurations. </td></tr>
<tr><td class="fieldtype">
<a id="a92df2ac4ec384e625fc22e9ed128a51d"></a>R_AGT0_Type *</td>
<td class="fieldname">
p_reg</td>
<td class="fielddoc">
Base register for this channel. </td></tr>
<tr><td class="fieldtype">
<a id="a9aa32608b915c6751ba226e6d3b184a4"></a>uint32_t</td>
<td class="fieldname">
period</td>
<td class="fielddoc">
Current timer period (counts) </td></tr>
</table>

</div>
</div>
<a name="structagt__extended__cfg__t" id="structagt__extended__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structagt__extended__cfg__t">&#9670;&nbsp;</a></span>agt_extended_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct agt_extended_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Optional AGT extension data structure. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ae95824d50fa5abbc1479dbd8939b1df1"></a><a class="el" href="group___a_g_t.html#ga5281c5967b6830f430bdf20ac9424f1c">agt_clock_t</a></td>
<td class="fieldname">
count_source</td>
<td class="fielddoc">
AGT channel clock source. Valid values are: AGT_CLOCK_PCLKB, AGT_CLOCK_LOCO, AGT_CLOCK_FSUB. </td></tr>
<tr><td class="fieldtype">
<a id="a1494be814771d9b4279a56c3bf647b6a"></a>union <a class="el" href="group___a_g_t.html#unionagt__extended__cfg__t_8____unnamed____">agt_extended_cfg_t</a></td>
<td class="fieldname">
__unnamed__</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a5e6fc342837c54c82e8ec84fee2c705a"></a><a class="el" href="group___a_g_t.html#gabb88a55a2156cdd322947f71189da627">agt_pin_cfg_t</a></td>
<td class="fieldname">
agto: 3</td>
<td class="fielddoc">
Configure AGTO pin. <dl class="section note"><dt>Note</dt><dd>AGTIO polarity is opposite AGTO </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="a4e7c2f097b585a98de264c40872b7780"></a><a class="el" href="group___a_g_t.html#ga53f383c41ec6fc2cd240e67fab1b969f">agt_measure_t</a></td>
<td class="fieldname">
measurement_mode</td>
<td class="fielddoc">
Measurement mode. </td></tr>
<tr><td class="fieldtype">
<a id="a01cf20505a0b410881c7a6ee20cfae9c"></a><a class="el" href="group___a_g_t.html#ga511738730422c0c8cc2b9de318005d1b">agt_agtio_filter_t</a></td>
<td class="fieldname">
agtio_filter</td>
<td class="fielddoc">
Input filter for AGTIO. </td></tr>
<tr><td class="fieldtype">
<a id="a1de9ee52b4fcb42c858e229c57ebe48c"></a><a class="el" href="group___a_g_t.html#ga310d73c260c901d1b8e7585dcb8f7507">agt_enable_pin_t</a></td>
<td class="fieldname">
enable_pin</td>
<td class="fielddoc">
Enable pin (event counting only) </td></tr>
<tr><td class="fieldtype">
<a id="a037c0d66459f040e08d09ef9ac75e346"></a><a class="el" href="group___a_g_t.html#ga1d568085c1ce9738b532fde46c47d908">agt_trigger_edge_t</a></td>
<td class="fieldname">
trigger_edge</td>
<td class="fielddoc">
Trigger edge to start pulse period measurement or count external event. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga5281c5967b6830f430bdf20ac9424f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5281c5967b6830f430bdf20ac9424f1c">&#9670;&nbsp;</a></span>agt_clock_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_g_t.html#ga5281c5967b6830f430bdf20ac9424f1c">agt_clock_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count source </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga5281c5967b6830f430bdf20ac9424f1ca50fe24f4105e9689a219df33fcd0b843"></a>AGT_CLOCK_PCLKB&#160;</td><td class="fielddoc"><p>PCLKB count source, division by 1, 2, or 8 allowed. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5281c5967b6830f430bdf20ac9424f1caf7d0a0fdf456dbbfef0858c256f80bc3"></a>AGT_CLOCK_LOCO&#160;</td><td class="fielddoc"><p>LOCO count source, division by 1, 2, 4, 8, 16, 32, 64, or 128 allowed. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5281c5967b6830f430bdf20ac9424f1cacf328a015a4cc13d5ab11a865e19a8da"></a>AGT_CLOCK_AGT0_UNDERFLOW&#160;</td><td class="fielddoc"><p>Underflow event signal from AGT0, division must be 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5281c5967b6830f430bdf20ac9424f1ca9656fda36718e18f399397cc0351539a"></a>AGT_CLOCK_SUBCLOCK&#160;</td><td class="fielddoc"><p>Subclock count source, division by 1, 2, 4, 8, 16, 32, 64, or 128 allowed. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5281c5967b6830f430bdf20ac9424f1cad91bcbb6c1dc31a0df73bb140170c334"></a>AGT_CLOCK_P402&#160;</td><td class="fielddoc"><p>Counts events on P402, events are counted in deep software standby mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5281c5967b6830f430bdf20ac9424f1ca394a0f7a588d28d6057351a7500a8444"></a>AGT_CLOCK_P403&#160;</td><td class="fielddoc"><p>Counts events on P403, events are counted in deep software standby mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5281c5967b6830f430bdf20ac9424f1caa2c8871cf9c88c9c9feb669fb78df673"></a>AGT_CLOCK_AGTIO&#160;</td><td class="fielddoc"><p>Counts events on AGTIOn, events are not counted in software standby modes. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga53f383c41ec6fc2cd240e67fab1b969f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53f383c41ec6fc2cd240e67fab1b969f">&#9670;&nbsp;</a></span>agt_measure_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_g_t.html#ga53f383c41ec6fc2cd240e67fab1b969f">agt_measure_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable pin for event counting mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga53f383c41ec6fc2cd240e67fab1b969fa16fa4ef970d8f5bb5c3918392078b9d2"></a>AGT_MEASURE_DISABLED&#160;</td><td class="fielddoc"><p>AGT used as a counter. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53f383c41ec6fc2cd240e67fab1b969fa06e31914849d21ab05c262d413726aac"></a>AGT_MEASURE_PULSE_WIDTH_LOW_LEVEL&#160;</td><td class="fielddoc"><p>AGT used to measure low level pulse width. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53f383c41ec6fc2cd240e67fab1b969fa8e118a74f28fec71addbc9ff60e48074"></a>AGT_MEASURE_PULSE_WIDTH_HIGH_LEVEL&#160;</td><td class="fielddoc"><p>AGT used to measure high level pulse width. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53f383c41ec6fc2cd240e67fab1b969fa87cc744a8a59564d653ee3236e370352"></a>AGT_MEASURE_PULSE_PERIOD&#160;</td><td class="fielddoc"><p>AGT used to measure pulse period. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga511738730422c0c8cc2b9de318005d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga511738730422c0c8cc2b9de318005d1b">&#9670;&nbsp;</a></span>agt_agtio_filter_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_g_t.html#ga511738730422c0c8cc2b9de318005d1b">agt_agtio_filter_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Input filter, applies AGTIO in pulse period measurement, pulse width measurement, or event counter mode. The filter requires the signal to be at the same level for 3 successive reads at the specified filter frequency. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga511738730422c0c8cc2b9de318005d1ba393d4e243552a538853af0bb03925b8f"></a>AGT_AGTIO_FILTER_NONE&#160;</td><td class="fielddoc"><p>No filter. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga511738730422c0c8cc2b9de318005d1ba01bf7e17c59c4a046e211a75783b0d68"></a>AGT_AGTIO_FILTER_PCLKB&#160;</td><td class="fielddoc"><p>Filter at PCLKB. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga511738730422c0c8cc2b9de318005d1baa35612a000c813f5766c5751642e09c6"></a>AGT_AGTIO_FILTER_PCLKB_DIV_8&#160;</td><td class="fielddoc"><p>Filter at PCLKB / 8. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga511738730422c0c8cc2b9de318005d1ba4de5cc4468e6e368a44974c82d5d6a93"></a>AGT_AGTIO_FILTER_PCLKB_DIV_32&#160;</td><td class="fielddoc"><p>Filter at PCLKB / 32. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga310d73c260c901d1b8e7585dcb8f7507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga310d73c260c901d1b8e7585dcb8f7507">&#9670;&nbsp;</a></span>agt_enable_pin_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_g_t.html#ga310d73c260c901d1b8e7585dcb8f7507">agt_enable_pin_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable pin for event counting mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga310d73c260c901d1b8e7585dcb8f7507a4fc875b5aecebbce8bc1013aebb7f2bd"></a>AGT_ENABLE_PIN_NOT_USED&#160;</td><td class="fielddoc"><p>AGTEE is not used. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga310d73c260c901d1b8e7585dcb8f7507a50c2707c125a9626bf48c7c81140e184"></a>AGT_ENABLE_PIN_ACTIVE_LOW&#160;</td><td class="fielddoc"><p>Events are only counted when AGTEE is low. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga310d73c260c901d1b8e7585dcb8f7507a2a3e88855635034ff05a84bafea94a26"></a>AGT_ENABLE_PIN_ACTIVE_HIGH&#160;</td><td class="fielddoc"><p>Events are only counted when AGTEE is high. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga1d568085c1ce9738b532fde46c47d908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d568085c1ce9738b532fde46c47d908">&#9670;&nbsp;</a></span>agt_trigger_edge_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_g_t.html#ga1d568085c1ce9738b532fde46c47d908">agt_trigger_edge_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Trigger edge for pulse period measurement mode and event counting mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga1d568085c1ce9738b532fde46c47d908a146dda2432ec6753d11b0a9da11cad06"></a>AGT_TRIGGER_EDGE_RISING&#160;</td><td class="fielddoc"><p>Measurement starts or events are counted on rising edge. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1d568085c1ce9738b532fde46c47d908a9fccbb321ba218243530c82a1d867e30"></a>AGT_TRIGGER_EDGE_FALLING&#160;</td><td class="fielddoc"><p>Measurement starts or events are counted on falling edge. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1d568085c1ce9738b532fde46c47d908ae990ca758f4d7b309ceda49d6f251241"></a>AGT_TRIGGER_EDGE_BOTH&#160;</td><td class="fielddoc"><p>Events are counted on both edges (n/a for pulse period mode) </p>
</td></tr>
</table>

</div>
</div>
<a id="gab3f3aa0cc9a2951751e76f493dd429eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3f3aa0cc9a2951751e76f493dd429eb">&#9670;&nbsp;</a></span>agt_output_pin_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_g_t.html#gab3f3aa0cc9a2951751e76f493dd429eb">agt_output_pin_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Output pins, used to select which duty cycle to update in <a class="el" href="group___a_g_t.html#ga25f4904a0e4ce56c413364b7c21b76a3">R_AGT_DutyCycleSet()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab3f3aa0cc9a2951751e76f493dd429eba72a6691905b605006601da6a30039ab0"></a>AGT_OUTPUT_PIN_AGTOA&#160;</td><td class="fielddoc"><p>GTIOCA. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab3f3aa0cc9a2951751e76f493dd429ebaf92849658e3a26042940fe9112ddd3a9"></a>AGT_OUTPUT_PIN_AGTOB&#160;</td><td class="fielddoc"><p>GTIOCB. </p>
</td></tr>
</table>

</div>
</div>
<a id="gabb88a55a2156cdd322947f71189da627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb88a55a2156cdd322947f71189da627">&#9670;&nbsp;</a></span>agt_pin_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_g_t.html#gabb88a55a2156cdd322947f71189da627">agt_pin_cfg_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Level of AGT pin </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggabb88a55a2156cdd322947f71189da627a34ef90e5d639605e1f468af8df43094b"></a>AGT_PIN_CFG_DISABLED&#160;</td><td class="fielddoc"><p>Not used as output pin. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabb88a55a2156cdd322947f71189da627a3fab671eb8f52a392eeb9bb91896f5f5"></a>AGT_PIN_CFG_START_LEVEL_LOW&#160;</td><td class="fielddoc"><p>Pin level low. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabb88a55a2156cdd322947f71189da627a49e8e6f466efe14a756d1f684b7c01bb"></a>AGT_PIN_CFG_START_LEVEL_HIGH&#160;</td><td class="fielddoc"><p>Pin level high. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gabe0a42cc31ae911c5ac6fe78eeb21c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe0a42cc31ae911c5ac6fe78eeb21c8a">&#9670;&nbsp;</a></span>R_AGT_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_AGT_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops counter, disables interrupts, disables output pins, and clears internal driver data. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#a9e8b8140010a28082aedd758390fac97">timer_api_t::close</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Timer closed. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance control structure is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1b8a21776f618aaa1b8471592b4b5464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b8a21776f618aaa1b8471592b4b5464">&#9670;&nbsp;</a></span>R_AGT_PeriodSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_AGT_PeriodSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>period_counts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates period. The new period is updated immediately and the counter is reset to the maximum value. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#ae9aad84a01ccd7ce0039ed491faeff19">timer_api_t::periodSet</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>If periodic output is used, the duty cycle buffer registers are updated after the period buffer register. If this function is called while the timer is running and an AGT underflow occurs during processing, the duty cycle will not be the desired 50% duty cycle until the counter underflow after processing completes.</dd>
<dd>
Stop the timer before calling this function if one-shot output is used.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Get the source clock frequency (in Hz). There are several ways to do this in FSP:</span></div><div class="line"><span class="comment">     *  - If LOCO or subclock is chosen in agt_extended_cfg_t::clock_source</span></div><div class="line"><span class="comment">     *      - The source clock frequency is BSP_LOCO_HZ &gt;&gt; timer_cfg_t::source_div</span></div><div class="line"><span class="comment">     *  - If PCLKB is chosen in agt_extended_cfg_t::clock_source and the PCLKB frequency has not changed since reset,</span></div><div class="line"><span class="comment">     *      - The source clock frequency is BSP_STARTUP_PCLKB_HZ &gt;&gt; timer_cfg_t::source_div</span></div><div class="line"><span class="comment">     *  - Use the R_AGT_InfoGet function (it accounts for the clock source and divider).</span></div><div class="line"><span class="comment">     *  - Calculate the current PCLKB frequency using R_FSP_SystemClockHzGet(FSP_PRIV_CLOCK_PCLKB) and right shift</span></div><div class="line"><span class="comment">     *    by timer_cfg_t::source_div.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * This example uses the last option (R_FSP_SystemClockHzGet).</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    uint32_t timer_freq_hz = <a class="code" href="group___b_s_p___m_c_u.html#gaac289335b731d0bdb5cb8e6d243898ef">R_FSP_SystemClockHzGet</a>(FSP_PRIV_CLOCK_PCLKB) &gt;&gt; g_timer0_cfg.source_div;</div><div class="line"></div><div class="line">    <span class="comment">/* Calculate the desired period based on the current clock. Note that this calculation could overflow if the</span></div><div class="line"><span class="comment">     * desired period is larger than UINT32_MAX / pclkb_freq_hz. A cast to uint64_t is used to prevent this. */</span></div><div class="line">    uint32_t period_counts =</div><div class="line">        (uint32_t) (((uint64_t) timer_freq_hz * AGT_EXAMPLE_DESIRED_PERIOD_MSEC) / AGT_EXAMPLE_MSEC_PER_SEC);</div><div class="line"></div><div class="line">    <span class="comment">/* Set the calculated period. This will return an error if parameter checking is enabled and the calculated</span></div><div class="line"><span class="comment">     * period is larger than UINT16_MAX. */</span></div><div class="line">    err = <a class="code" href="group___a_g_t.html#ga1b8a21776f618aaa1b8471592b4b5464">R_AGT_PeriodSet</a>(&amp;g_timer0_ctrl, period_counts);</div><div class="line">    handle_error(err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Period value updated. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer was NULL, or the period was not in the valid range of 1 to 0xFFFF. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance control structure is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga25f4904a0e4ce56c413364b7c21b76a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25f4904a0e4ce56c413364b7c21b76a3">&#9670;&nbsp;</a></span>R_AGT_DutyCycleSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_AGT_DutyCycleSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>duty_cycle_counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>pin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates duty cycle. If the timer is counting, the new duty cycle is reflected after the next counter underflow. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#a819ed0740ca426ace0d6b67e16c6ddfc">timer_api_t::dutyCycleSet</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Get the current period setting. */</span></div><div class="line">    <a class="code" href="group___t_i_m_e_r___a_p_i.html#structtimer__info__t">timer_info_t</a> info;</div><div class="line">    (void) <a class="code" href="group___a_g_t.html#ga91174b9feb94088512b85d2f020d3fe2">R_AGT_InfoGet</a>(&amp;g_timer0_ctrl, &amp;info);</div><div class="line">    uint32_t current_period_counts = info.<a class="code" href="group___t_i_m_e_r___a_p_i.html#a08b897cfbf2d0cefafe8d3abb1afc747">period_counts</a>;</div><div class="line"></div><div class="line">    <span class="comment">/* Calculate the desired duty cycle based on the current period. */</span></div><div class="line">    uint32_t duty_cycle_counts = (current_period_counts * AGT_EXAMPLE_DESIRED_DUTY_CYCLE_PERCENT) /</div><div class="line">                                 AGT_EXAMPLE_MAX_PERCENT;</div><div class="line"></div><div class="line">    <span class="comment">/* Set the calculated duty cycle. */</span></div><div class="line">    err = <a class="code" href="group___a_g_t.html#ga25f4904a0e4ce56c413364b7c21b76a3">R_AGT_DutyCycleSet</a>(&amp;g_timer0_ctrl, duty_cycle_counts, <a class="code" href="group___a_g_t.html#ggab3f3aa0cc9a2951751e76f493dd429eba72a6691905b605006601da6a30039ab0">AGT_OUTPUT_PIN_AGTOA</a>);</div><div class="line">    handle_error(err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Duty cycle updated. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer was NULL, or the pin was not AGT_AGTO_AGTOA or AGT_AGTO_AGTOB. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ARGUMENT</td><td>Duty cycle was not in the valid range of 0 to period (counts) - 1 </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance control structure is not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>AGT_CFG_OUTPUT_SUPPORT_ENABLE is 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1ae3d1d197e2a433939dc430dad05d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ae3d1d197e2a433939dc430dad05d99">&#9670;&nbsp;</a></span>R_AGT_Reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_AGT_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the counter value to the period minus one. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#ab1c62157861ef1ea8393bb3cafd72102">timer_api_t::reset</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Counter reset. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl is NULL </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance control structure is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6e5c0080a8a035351d920360d6e9fd4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e5c0080a8a035351d920360d6e9fd4d">&#9670;&nbsp;</a></span>R_AGT_Start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_AGT_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts timer. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#afcc7e85d01c3d7dc0c6e09954631f47f">timer_api_t::start</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Start the timer. */</span></div><div class="line">    (void) <a class="code" href="group___a_g_t.html#ga6e5c0080a8a035351d920360d6e9fd4d">R_AGT_Start</a>(&amp;g_timer0_ctrl);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Timer started. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl is null. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance control structure is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga548babc3a9f803374e70ba027935a086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga548babc3a9f803374e70ba027935a086">&#9670;&nbsp;</a></span>R_AGT_Enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_AGT_Enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables external event triggers that start, stop, clear, or capture the counter. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#a13cb48d1657a9eda3380c111ba33aa2a">timer_api_t::enable</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Enable captures. Captured values arrive in the interrupt. */</span></div><div class="line">    (void) <a class="code" href="group___a_g_t.html#ga548babc3a9f803374e70ba027935a086">R_AGT_Enable</a>(&amp;g_timer0_ctrl);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>External events successfully enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae27f425278e24c45345242a78a10d649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae27f425278e24c45345242a78a10d649">&#9670;&nbsp;</a></span>R_AGT_Disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_AGT_Disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables external event triggers that start, stop, clear, or capture the counter. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#a8b69fad02aee5d83b941ed02fca18aca">timer_api_t::disable</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Disable captures. */</span></div><div class="line">    (void) <a class="code" href="group___a_g_t.html#gae27f425278e24c45345242a78a10d649">R_AGT_Disable</a>(&amp;g_timer0_ctrl);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>External events successfully disabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga91174b9feb94088512b85d2f020d3fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91174b9feb94088512b85d2f020d3fe2">&#9670;&nbsp;</a></span>R_AGT_InfoGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_AGT_InfoGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#structtimer__info__t">timer_info_t</a> *const&#160;</td>
          <td class="paramname"><em>p_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets timer information and store it in provided pointer p_info. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#aeaea79f26305c493566e4b45ae9e294c">timer_api_t::infoGet</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">        <span class="comment">/* (Optional) Get the current period if not known. */</span></div><div class="line">        <a class="code" href="group___t_i_m_e_r___a_p_i.html#structtimer__info__t">timer_info_t</a> info;</div><div class="line">        (void) <a class="code" href="group___a_g_t.html#ga91174b9feb94088512b85d2f020d3fe2">R_AGT_InfoGet</a>(&amp;g_timer0_ctrl, &amp;info);</div><div class="line">        uint32_t period = info.<a class="code" href="group___t_i_m_e_r___a_p_i.html#a08b897cfbf2d0cefafe8d3abb1afc747">period_counts</a>;</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Period, count direction, and frequency stored in p_info. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance control structure is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga11a30a7a093f91c09a340f7b301945fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11a30a7a093f91c09a340f7b301945fd">&#9670;&nbsp;</a></span>R_AGT_StatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_AGT_StatusGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#structtimer__status__t">timer_status_t</a> *const&#160;</td>
          <td class="paramname"><em>p_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the current state and counter value stores them in p_status. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#a11321e8dde7c33a4e6835a1bf64f7689">timer_api_t::statusGet</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Read the current counter value. Counter value is in status.counter. */</span></div><div class="line">    <a class="code" href="group___t_i_m_e_r___a_p_i.html#structtimer__status__t">timer_status_t</a> status;</div><div class="line">    (void) <a class="code" href="group___a_g_t.html#ga11a30a7a093f91c09a340f7b301945fd">R_AGT_StatusGet</a>(&amp;g_timer0_ctrl, &amp;status);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Current status and counter value provided in p_status. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance control structure is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa2b20f0b2d6856813a3a76413e0083c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2b20f0b2d6856813a3a76413e0083c0">&#9670;&nbsp;</a></span>R_AGT_Stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_AGT_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops the timer. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#aed0139dbf5102e39719ddbc51f16a21e">timer_api_t::stop</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Stop the timer. */</span></div><div class="line">    (void) <a class="code" href="group___a_g_t.html#gaa2b20f0b2d6856813a3a76413e0083c0">R_AGT_Stop</a>(&amp;g_timer0_ctrl);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Timer stopped. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance control structure is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga499ee5459a9adb90cf73dd659ae29b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga499ee5459a9adb90cf73dd659ae29b46">&#9670;&nbsp;</a></span>R_AGT_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_AGT_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#structtimer__cfg__t">timer_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the AGT module instance. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#af49a90087a53c8019d642a3f7abaa8ad">timer_api_t::open</a>.</p>
<p>The AGT hardware does not support one-shot functionality natively. The one-shot feature is therefore implemented in the AGT HAL layer. For a timer configured as a one-shot timer, the timer is stopped upon the first timer expiration.</p>
<p>The AGT implementation of the general timer can accept an optional <a class="el" href="group___a_g_t.html#structagt__extended__cfg__t">agt_extended_cfg_t</a> extension parameter. For AGT, the extension specifies the clock to be used as timer source and the output pin configurations. If the extension parameter is not specified (NULL), the default clock PCLKB is used and the output pins are disabled.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___a_g_t.html#ga499ee5459a9adb90cf73dd659ae29b46">R_AGT_Open</a>(&amp;g_timer0_ctrl, &amp;g_timer0_cfg);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Initialization was successful and timer has started. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required input pointer is NULL or the period is not in the valid range of 1 to 0xFFFF. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>R_AGT_Open has already been called for this p_ctrl. </td></tr>
    <tr><td class="paramname">FSP_ERR_IRQ_BSP_DISABLED</td><td>A required interrupt has not been enabled in the vector table. </td></tr>
    <tr><td class="paramname">FSP_ERR_IP_CHANNEL_NOT_PRESENT</td><td>Requested channel number is not available on AGT. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad6d600521cfd1134e1fd5cd5fefe2819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6d600521cfd1134e1fd5cd5fefe2819">&#9670;&nbsp;</a></span>R_AGT_VersionGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_AGT_VersionGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#unionfsp__version__t">fsp_version_t</a> *const&#160;</td>
          <td class="paramname"><em>p_version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets driver version based on compile time macros. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#afd486e90a2c3214bdf156ab47560d236">timer_api_t::versionGet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Version in p_version. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>The parameter p_version is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v1.3.0 User's Manual Copyright  (2020) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
