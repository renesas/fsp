<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: Ethernet (r_rmac)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
    $(document).ready(function() {
        $("tr.tree_lvl_1").nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
		$("tr.tree_lvl_1").data("expanded","0");
		$("tr.tree_lvl_2").data("expanded","0");
		$("tr.tree_lvl_3").data("expanded","0");
		$("tr.tree_lvl_4").data("expanded","0");
		$("tr.tree_lvl_5").data("expanded","0");
        $("tr.tree_lvl_1").click(function() {
		    var lvl_1_is_open = $(this).data("expanded");
		    if (lvl_1_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2, tr.tree_lvl_1_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_2").click(function() {
		    var lvl_2_is_open = $(this).data("expanded");
		    if (lvl_2_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3, tr.tree_lvl_2_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_3").click(function() {
		    var lvl_3_is_open = $(this).data("expanded");
		    if (lvl_3_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_3_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_4").click(function() {
		    var lvl_4_is_open = $(this).data("expanded");
		    if (lvl_4_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5, tr.tree_lvl_4_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_5").click(function() {
		    var lvl_5_is_open = $(this).data("expanded");
		    if (lvl_5_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4_item,tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
     });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v6.3.1</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">

    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text">
      </span>
      <span class="right">
          &nbsp;
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___r_m_a_c.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body.
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len));
            }
          }
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element.
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Ethernet (r_rmac)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___n_e_t_w_o_r_k_i_n_g___m_o_d_u_l_e_s.html">Networking</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga052caff07274427357117507a538e8c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m_a_c.html#ga052caff07274427357117507a538e8c2">R_RMAC_Open</a> (<a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const p_ctrl, <a class="el" href="group___e_t_h_e_r___a_p_i.html#structether__cfg__t">ether_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="memdesc:ga052caff07274427357117507a538e8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">After RMAC, Switch and PHY-LSI are reset in software, an auto negotiation of PHY-LSI is begun. Afterwards, the link signal change interrupt is permitted. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#aa0c703be12efe73efdd0d47168239470">ether_api_t::open</a>.  <a href="#ga052caff07274427357117507a538e8c2">More...</a><br /></td></tr>
<tr class="separator:ga052caff07274427357117507a538e8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac014279a2fa944ef2326bb5a727ce9c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m_a_c.html#gac014279a2fa944ef2326bb5a727ce9c0">R_RMAC_Close</a> (<a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="memdesc:gac014279a2fa944ef2326bb5a727ce9c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables interrupts. Removes power and releases hardware lock. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#a84ae3c1816a60c8fc45ccc2084805088">ether_api_t::close</a>.  <a href="#gac014279a2fa944ef2326bb5a727ce9c0">More...</a><br /></td></tr>
<tr class="separator:gac014279a2fa944ef2326bb5a727ce9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fb1dfa67bcada0ce7fafed44a772519"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m_a_c.html#ga0fb1dfa67bcada0ce7fafed44a772519">R_RMAC_BufferRelease</a> (<a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="memdesc:ga0fb1dfa67bcada0ce7fafed44a772519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move to the next buffer in the receive buffer list. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#a4f988e111dadbfab48e9eccec8d462b5">ether_api_t::bufferRelease</a>.  <a href="#ga0fb1dfa67bcada0ce7fafed44a772519">More...</a><br /></td></tr>
<tr class="separator:ga0fb1dfa67bcada0ce7fafed44a772519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae264a546790ece09ebf725e0b7c06213"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m_a_c.html#gae264a546790ece09ebf725e0b7c06213">R_RMAC_RxBufferUpdate</a> (<a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const p_ctrl, void *const p_buffer)</td></tr>
<tr class="memdesc:gae264a546790ece09ebf725e0b7c06213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the buffer pointer of the current rx buffer descriptor. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#a6d088fd3b1a5326af7bedad146491d74">ether_api_t::rxBufferUpdate</a>.  <a href="#gae264a546790ece09ebf725e0b7c06213">More...</a><br /></td></tr>
<tr class="separator:gae264a546790ece09ebf725e0b7c06213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga876a68d8ec34d3736ff1c3e98927c888"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m_a_c.html#ga876a68d8ec34d3736ff1c3e98927c888">R_RMAC_LinkProcess</a> (<a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="memdesc:ga876a68d8ec34d3736ff1c3e98927c888"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Link up processing, the Link down processing, and the magic packet detection processing are executed. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#ae11e3e3521df4c3efe6e0dafecddee72">ether_api_t::linkProcess</a>.  <a href="#ga876a68d8ec34d3736ff1c3e98927c888">More...</a><br /></td></tr>
<tr class="separator:ga876a68d8ec34d3736ff1c3e98927c888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga277354f6053e6d66639dac11efbb2bcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m_a_c.html#ga277354f6053e6d66639dac11efbb2bcd">R_RMAC_WakeOnLANEnable</a> (<a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="memdesc:ga277354f6053e6d66639dac11efbb2bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The setting of RMAC is changed from normal sending and receiving mode to magic packet detection mode. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#acde8967c0512722ca73a1596daf654ea">ether_api_t::wakeOnLANEnable</a>.  <a href="#ga277354f6053e6d66639dac11efbb2bcd">More...</a><br /></td></tr>
<tr class="separator:ga277354f6053e6d66639dac11efbb2bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga121ae669c4f311ecd10fd189dfa1de12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m_a_c.html#ga121ae669c4f311ecd10fd189dfa1de12">R_RMAC_Read</a> (<a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const p_ctrl, void *const p_buffer, uint32_t *const length_bytes)</td></tr>
<tr class="memdesc:ga121ae669c4f311ecd10fd189dfa1de12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive Ethernet frame. Receives data to the location specified by the pointer to the receive buffer. In zero copy mode, the address of the receive buffer is returned. In non zero copy mode, the received data in the internal buffer is copied to the pointer passed by the argument. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#a58975a11436cc5980698b6e843eea3f3">ether_api_t::read</a>.  <a href="#ga121ae669c4f311ecd10fd189dfa1de12">More...</a><br /></td></tr>
<tr class="separator:ga121ae669c4f311ecd10fd189dfa1de12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab393ab423c240b4a4dba7472e1cf534"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m_a_c.html#gaab393ab423c240b4a4dba7472e1cf534">R_RMAC_Write</a> (<a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const p_ctrl, void *const p_buffer, uint32_t const frame_length)</td></tr>
<tr class="memdesc:gaab393ab423c240b4a4dba7472e1cf534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit Ethernet frame. Transmits data from the location specified by the pointer to the transmit buffer, with the data size equal to the specified frame length. In the non zero copy mode, transmits data after being copied to the internal buffer. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#aa61e5ba4dd1de3a50864c0b1970c3b51">ether_api_t::write</a>.  <a href="#gaab393ab423c240b4a4dba7472e1cf534">More...</a><br /></td></tr>
<tr class="separator:gaab393ab423c240b4a4dba7472e1cf534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga080a8964701568116bf95212b8a6d452"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m_a_c.html#ga080a8964701568116bf95212b8a6d452">R_RMAC_TxStatusGet</a> (<a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const p_ctrl, void *const p_buffer_address)</td></tr>
<tr class="separator:ga080a8964701568116bf95212b8a6d452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d04bd2fdf0676a7a2d992b5e8ff0b65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m_a_c.html#ga3d04bd2fdf0676a7a2d992b5e8ff0b65">R_RMAC_CallbackSet</a> (<a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const p_api_ctrl, void(*p_callback)(<a class="el" href="group___e_t_h_e_r___a_p_i.html#structether__callback__args__t">ether_callback_args_t</a> *), void *const p_context, <a class="el" href="group___e_t_h_e_r___a_p_i.html#structether__callback__args__t">ether_callback_args_t</a> *const p_callback_memory)</td></tr>
<tr class="separator:ga3d04bd2fdf0676a7a2d992b5e8ff0b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabae2f3adcc92fae91041af247affc43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m_a_c.html#gaabae2f3adcc92fae91041af247affc43">R_RMAC_SetWriteConfig</a> (<a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const p_ctrl, <a class="el" href="structrmac__write__cfg__t.html">rmac_write_cfg_t</a> *const p_write_cfg)</td></tr>
<tr class="memdesc:gaabae2f3adcc92fae91041af247affc43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set configuration for tx frame. This API must call before <a class="el" href="group___e_t_h_e_r___a_p_i.html#aa61e5ba4dd1de3a50864c0b1970c3b51">ether_api_t::write</a>.  <a href="#gaabae2f3adcc92fae91041af247affc43">More...</a><br /></td></tr>
<tr class="separator:gaabae2f3adcc92fae91041af247affc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade9b7430ef877c3ff44c9601339932e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m_a_c.html#gade9b7430ef877c3ff44c9601339932e9">R_RMAC_GetTxTimestamp</a> (<a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const p_ctrl, <a class="el" href="structrmac__timestamp__t.html">rmac_timestamp_t</a> *const p_timestamp)</td></tr>
<tr class="memdesc:gade9b7430ef877c3ff44c9601339932e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get timestamp of transmitted frame. This API must call after <a class="el" href="group___e_t_h_e_r___a_p_i.html#aa61e5ba4dd1de3a50864c0b1970c3b51">ether_api_t::write</a>.  <a href="#gade9b7430ef877c3ff44c9601339932e9">More...</a><br /></td></tr>
<tr class="separator:gade9b7430ef877c3ff44c9601339932e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga338bb68cc016993825595068ee274302"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m_a_c.html#ga338bb68cc016993825595068ee274302">R_RMAC_GetRxTimestamp</a> (<a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const p_ctrl, <a class="el" href="structrmac__timestamp__t.html">rmac_timestamp_t</a> *const p_timestamp)</td></tr>
<tr class="memdesc:ga338bb68cc016993825595068ee274302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get timestamp of received frame. This API must call before <a class="el" href="group___e_t_h_e_r___a_p_i.html#a58975a11436cc5980698b6e843eea3f3">ether_api_t::read</a>.  <a href="#ga338bb68cc016993825595068ee274302">More...</a><br /></td></tr>
<tr class="separator:ga338bb68cc016993825595068ee274302"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the Ethernet peripheral on RA MCUs. This module implements the <a class="el" href="group___e_t_h_e_r___a_p_i.html">Ethernet Interface</a>. </p>
<h1><a class="anchor" id="r-rmac-overview"></a>
Overview</h1>
<p>This module transmits and receives Ethernet (IEEE 802.3) frames. This module provides single MAC layer interface.</p>
<p>The following figure shows which IPs are used by the r_rmac module.</p>
<div class="image">
<img src="r_rmac_sw_and_hw_relation.png" alt="r_rmac_sw_and_hw_relation.png"/>
<div class="caption">
ESWM block diagram</div></div>
 <h2><a class="anchor" id="r-rmac-features"></a>
Features</h2>
<p>The RMAC module supports the following features:</p><ul>
<li>Transmit/Receive processing</li>
<li>Optional zero-copy buffering</li>
<li>Callback function with returned event code</li>
<li>Auto negotiation support</li>
<li>Flow control support</li>
<li>Multicast filtering support<a class="anchor" id="um_rmac_skipping_multicast_frame_when_multicast_filter_enabled"></a></li>
<li>Broadcast filtering support<a class="anchor" id="um_rmac_regurating_broadcast_packet_when_broadcast_filter_enable"></a></li>
<li>Promiscuous mode support<a class="anchor" id="um_rmac_receiving_all_frame_when_promiscuous_mode_enabled"></a></li>
<li>Get the frame transmission and reception times</li>
</ul>
<h1><a class="anchor" id="r-rmac-configuration"></a>
Configuration</h1>
<p><h2>Build Time Configurations for r_rmac</h2>
The following build time configurations are defined in fsp_cfg/r_rmac_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr class="tree_none">
<td>Read Buffer Size Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>If selected code for buffer size checking is included in the build. </td></tr>
</table>
 <h2>Configurations for Networking &gt; Ethernet MAC (r_rmac)</h2>
This module can be added to the Stacks tab via New Stack &gt; Networking &gt; Ethernet MAC (r_rmac). Non-secure callable guard functions can be generated for this module by right clicking the module in the RA Configuration tool and checking the "Non-secure Callable" box.<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> General  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Name</td><td>Name must be a valid C symbol</td><td>g_ether0 </td><td>Module name. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Channel</td><td>Must be an integer greater than or equal to 0.</td><td>0 </td><td>Write the ether channel number. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Zero-copy Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disable</li>
<li>
Enable</li>
</ul>
</td><td>Disable </td><td>Enable or disable zero-copy mode. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Flow control functionality</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disable</li>
<li>
Enable</li>
</ul>
</td><td>Disable </td><td>Enable or disable flow control. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">MAC address</td><td>Must be a valid MAC address</td><td>00:11:22:33:44:55 </td><td>MAC address of this channel. </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Filters  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Multicast Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disable</li>
<li>
Enable</li>
</ul>
</td><td>Enable </td><td>Enable or disable multicast frame reception. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Promiscuous Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disable</li>
<li>
Enable</li>
</ul>
</td><td>Disable </td><td>Enable this option to receive packets addressed to other NICs. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Broadcast filter</td><td>Must be a valid non-negative integer with maximum configurable value of 65535. </td><td>0 </td><td>Limit of the number of broadcast frames received continuously </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Buffers  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Padding size</td><td>Disable</td><td>Disable </td><td>The padding size that is automatically inserted into the received packets </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Padding offset</td><td>Must be less than 64 bytes.</td><td>0 </td><td>The offset into a receive buffer to insert padding bytes. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">TX queue length</td><td>Value must be an integer</td><td>3 </td><td>Number of buffers per TX queue. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">RX queue length</td><td>Value must be an integer</td><td>3 </td><td>Number of buffers per RX queue. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">TX queue num</td><td>Value must be an integer</td><td>2 </td><td>TX queue num </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">RX queue num</td><td>Value must be an integer</td><td>2 </td><td>RX queue num </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Number of TX buffer</td><td>Value must be an integer</td><td>12 </td><td>Number of transmit buffers </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Number of RX buffer</td><td>Value must be an integer</td><td>12 </td><td>Number of receive buffers </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Buffer size</td><td>Must be at least 1514 which is the maximum Ethernet frame size.</td><td>1514 </td><td>Size of Ethernet buffer </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Allocate RX buffer</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disable</li>
<li>
Enable</li>
</ul>
</td><td>Enable </td><td>Allocates the RX buffer when generating the configuration structure </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Number of node num</td><td>Value must be an integer</td><td>24 </td><td>Number of receive buffers </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Interrupts  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Magic packet interrupt priority</td><td>MCU Specific Options</td><td></td><td>Select the magic packet detection interrupt priority. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Callback</td><td>Name must be a valid C symbol</td><td>NULL </td><td>Callback provided when an ISR occurs </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Timestamp  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">TS queue length</td><td>Value must be an integer</td><td>8 </td><td>Timestamp queue length. </td></tr>
</table>
</p>
<p><a class="anchor" id="um_rmac_configuration_for_connection_mode"></a><a class="anchor" id="um_rmac_configuration_of_mac_address"></a> </p>
<h2><a class="anchor" id="r-rmac-interrupt-configuration"></a>
Interrupt Configuration</h2>
<p>The first <a class="el" href="group___r_m_a_c.html#ga052caff07274427357117507a538e8c2">R_RMAC_Open</a> function call sets GWDI interrupts. The user could provide callback function which would be invoked when GWDI interrupt handler has been completed. The callback arguments will contain information about a channel number, the event code and a pointer to the user defined context.</p>
<h2><a class="anchor" id="r-rmac-callback-configuration"></a>
Callback Configuration</h2>
<p>The user could provide callback function which would be invoked when either a magic packet or a link signal change is detected. When the callback function is called, a variable in which the channel number for which the detection occurred and a constant shown in Table 2.4 are stored is passed as an argument. If the value of this argument is to be used outside the callback function, its value should be copied into, for example, a global variable.</p>
<h2><a class="anchor" id="r-rmac-clock-configuration"></a>
Clock Configuration</h2>
<p>The ESWM peripheral uses ICLK, PCLKA, ESWCLK and ESWPHYCLK as clocks. These clocks must be set to frequencies within the ranges shown in the following table. </p><table class="doxtable">
<tr>
<th>PHY speed [Mbps] </th><th>ICLK [MHz] </th><th>PCLKA [MHz] </th><th>ESWCLK [MHz] </th><th>ESWPHYCLK [MHz]  </th></tr>
<tr>
<td>10/100 </td><td>50 to 250 </td><td>up to 125 </td><td>50 to 250 </td><td>Not required </td></tr>
<tr>
<td>1000 </td><td>150 to 250 </td><td>up to 125 </td><td>150 to 250 </td><td>500 </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>1. Clock restrictions are as follow: ICLK Ã— 1.5 =&gt; ESWCLK, ESWCLK &gt; PCLKA and ICLK &gt; PCLKA. </dd>
<dd>
2. When using a products in the HLQFP176 package, set ESWCLK to 125 MHz or less.</dd></dl>
<h2><a class="anchor" id="r-rmac-pin-configuration"></a>
Pin Configuration</h2>
<p>To use the RMAC module, input/output signals of the peripheral function have to be allocated to pins with the multi-function pin controller (MPC). Please perform the pin setting before calling the <a class="el" href="group___r_m_a_c.html#ga052caff07274427357117507a538e8c2">R_RMAC_Open</a> function.</p>
<h1><a class="anchor" id="r-rmac-usage_notes"></a>
Usage Notes</h1>
<h2>Ethernet Frame Format</h2>
<p>The RMAC module supports the Ethernet II/IEEE 802.3 frame format.</p>
<h3>Frame Format for Data Transmission and Reception</h3>
<div class="image">
<object type="image/svg+xml" data="frame_format_image.svg">frame_format_image.svg</object>
<div class="caption">
Frame Format Image</div></div>
<p> The preamble and SFD signal the start of an Ethernet frame. The FCS contains the CRC of the Ethernet frame and is calculated on the transmitting side. When data is received the CRC value of the frame is calculated in hardware, and the Ethernet frame is discarded if the values do not match. When the hardware determines that the data is normal, the valid range of receive data is: (transmission destination address) + (transmission source address) + (length/type) + (data).</p>
<h3>PAUSE Frame Format</h3>
<div class="image">
<object type="image/svg+xml" data="pause_frame_format_image.svg">pause_frame_format_image.svg</object>
<div class="caption">
Pause Frame Format Image</div></div>
<p> The transmission destination address is specified as 01:80:C2:00:00:01 (a multicast address reserved for PAUSE frames). At the start of the payload the length/type is specified as 0x8808 and the operation code as 0x0001. The pause duration in the payload is specified by the value of the automatic PAUSE (AP) bits in the automatic PAUSE frame setting register (APR), or the manual PAUSE time setting (MP) bits in the manual PAUSE frame setting register (MPR).</p>
<h3>Magic Packet Frame Format</h3>
<div class="image">
<object type="image/svg+xml" data="magic_packet_frame_format_image.svg">magic_packet_frame_format_image.svg</object>
<div class="caption">
Magic Packet Frame Format Image</div></div>
<p> In a Magic Packet, the value FF:FF:FF:FF:FF:FF followed by the transmission destination address repeated 16 times is inserted somewhere in the Ethernet frame data.</p>
<h1><a class="anchor" id="r-rmac-examples"></a>
Examples</h1>
<h2>ETHER Basic Example</h2>
<p>This is a basic example of minimal use of the ETHER in an application.</p>
<dl class="section note"><dt>Note</dt><dd>In this example zero-copy mode is disabled and there are no restrictions on buffer alignment.</dd></dl>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define RMAC_EXAMPLE_MAXIMUM_ETHERNET_FRAME_SIZE     (1514)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define RMAC_EXAMPLE_TRANSMIT_ETHERNET_FRAME_SIZE    (60)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define RMAC_EXAMPLE_SOURCE_MAC_ADDRESS              0x74, 0x90, 0x50, 0x00, 0x79, 0x01</span></div><div class="line"><span class="preprocessor">#define RMAC_EXAMPLE_DESTINATION_MAC_ADDRESS         0x74, 0x90, 0x50, 0x00, 0x79, 0x02</span></div><div class="line"><span class="preprocessor">#define RMAC_EXAMPLE_FRAME_TYPE                      0x00, 0x2E</span></div><div class="line"><span class="preprocessor">#define RMAC_EXAMPLE_PAYLOAD                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \</span></div><div class="line"><span class="preprocessor">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                  \</span></div><div class="line"><span class="preprocessor">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                  \</span></div><div class="line"><span class="preprocessor">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                  \</span></div><div class="line"><span class="preprocessor"></span></div><div class="line"></div><div class="line"><span class="comment">/* Receive data buffer */</span></div><div class="line"><span class="keyword">static</span> uint8_t gp_read_buffer[RMAC_EXAMPLE_MAXIMUM_ETHERNET_FRAME_SIZE] = {0};</div><div class="line"></div><div class="line"><span class="comment">/* Transmit data buffer */</span></div><div class="line"><span class="keyword">static</span> uint8_t gp_send_data[RMAC_EXAMPLE_TRANSMIT_ETHERNET_FRAME_SIZE] =</div><div class="line">{</div><div class="line">    RMAC_EXAMPLE_DESTINATION_MAC_ADDRESS, <span class="comment">/* Destination MAC address */</span></div><div class="line">    RMAC_EXAMPLE_SOURCE_MAC_ADDRESS,      <span class="comment">/* Source MAC address */</span></div><div class="line">    RMAC_EXAMPLE_FRAME_TYPE,              <span class="comment">/* Type field */</span></div><div class="line">    RMAC_EXAMPLE_PAYLOAD                  <span class="comment">/* Payload value (46byte) */</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> rmac_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err            = FSP_SUCCESS;</div><div class="line">    uint32_t  read_data_size = 0;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Open the rmac instance with initial configuration. */</span></div><div class="line">    err = <a class="code" href="group___r_m_a_c.html#ga052caff07274427357117507a538e8c2">R_RMAC_Open</a>(&amp;g_ether0_ctrl, &amp;g_ether0_cfg);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* When the Ethernet link status read from the PHY-LSI Basic Status register is link-up,</span></div><div class="line"><span class="comment">         * Initializes the module and make auto negotiation. */</span></div><div class="line">        err = <a class="code" href="group___r_m_a_c.html#ga876a68d8ec34d3736ff1c3e98927c888">R_RMAC_LinkProcess</a>(&amp;g_ether0_ctrl);</div><div class="line">    } <span class="keywordflow">while</span> (FSP_SUCCESS != err);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Transmission is non-blocking. */</span></div><div class="line">    <span class="comment">/* User data copy to internal buffer and is transferred by DMA in the background. */</span></div><div class="line">    err = <a class="code" href="group___r_m_a_c.html#gaab393ab423c240b4a4dba7472e1cf534">R_RMAC_Write</a>(&amp;g_ether0_ctrl, (<span class="keywordtype">void</span> *) gp_send_data, <span class="keyword">sizeof</span>(gp_send_data));</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Received data copy to user buffer from internal buffer. */</span></div><div class="line">    err = <a class="code" href="group___r_m_a_c.html#ga121ae669c4f311ecd10fd189dfa1de12">R_RMAC_Read</a>(&amp;g_ether0_ctrl, (<span class="keywordtype">void</span> *) gp_read_buffer, &amp;read_data_size);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Disable transmission and receive function and close the rmac instance. */</span></div><div class="line">    <a class="code" href="group___r_m_a_c.html#gac014279a2fa944ef2326bb5a727ce9c0">R_RMAC_Close</a>(&amp;g_ether0_ctrl);</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Timestamp Example</h2>
<p>This is a example of getting transmission and reception timestamps.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> rmac_timestamp_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err            = FSP_SUCCESS;</div><div class="line">    uint32_t  read_data_size = 0;</div><div class="line"></div><div class="line">    <a class="code" href="structrmac__timestamp__t.html">rmac_timestamp_t</a> rx_timestamp;</div><div class="line">    <a class="code" href="structrmac__timestamp__t.html">rmac_timestamp_t</a> tx_timestamp;</div><div class="line">    <a class="code" href="structrmac__write__cfg__t.html">rmac_write_cfg_t</a> write_cfg = {.<a class="code" href="structrmac__write__cfg__t.html#a66c8e2efbcabe6a2b1531ac492dbd79d">tx_timestamp_enable</a> = 1};</div><div class="line"></div><div class="line">    <span class="comment">/* Open the rmac instance with initial configuration. */</span></div><div class="line">    err = <a class="code" href="group___r_m_a_c.html#ga052caff07274427357117507a538e8c2">R_RMAC_Open</a>(&amp;g_ether0_ctrl, &amp;g_ether0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* When the Ethernet link status read from the PHY-LSI Basic Status register is link-up,</span></div><div class="line"><span class="comment">         * Initializes the module and make auto negotiation. */</span></div><div class="line">        err = <a class="code" href="group___r_m_a_c.html#ga876a68d8ec34d3736ff1c3e98927c888">R_RMAC_LinkProcess</a>(&amp;g_ether0_ctrl);</div><div class="line">    } <span class="keywordflow">while</span> (FSP_SUCCESS != err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Set write configuration. */</span></div><div class="line">    err = <a class="code" href="group___r_m_a_c.html#gaabae2f3adcc92fae91041af247affc43">R_RMAC_SetWriteConfig</a>(&amp;g_ether0_ctrl, &amp;write_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Transmission is non-blocking. */</span></div><div class="line">    <span class="comment">/* User data copy to internal buffer and is transferred by DMA in the background. */</span></div><div class="line">    err = <a class="code" href="group___r_m_a_c.html#gaab393ab423c240b4a4dba7472e1cf534">R_RMAC_Write</a>(&amp;g_ether0_ctrl, (<span class="keywordtype">void</span> *) gp_send_data, <span class="keyword">sizeof</span>(gp_send_data));</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Get TX timestamp value. */</span></div><div class="line">    err = <a class="code" href="group___r_m_a_c.html#gade9b7430ef877c3ff44c9601339932e9">R_RMAC_GetTxTimestamp</a>(&amp;g_ether0_ctrl, &amp;tx_timestamp);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Get RX timestamp value. */</span></div><div class="line">    err = <a class="code" href="group___r_m_a_c.html#ga338bb68cc016993825595068ee274302">R_RMAC_GetRxTimestamp</a>(&amp;g_ether0_ctrl, &amp;rx_timestamp);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Received data copy to user buffer from internal buffer. */</span></div><div class="line">    err = <a class="code" href="group___r_m_a_c.html#ga121ae669c4f311ecd10fd189dfa1de12">R_RMAC_Read</a>(&amp;g_ether0_ctrl, (<span class="keywordtype">void</span> *) gp_read_buffer, &amp;read_data_size);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Disable transmission and receive function and close the rmac instance. */</span></div><div class="line">    <a class="code" href="group___r_m_a_c.html#gac014279a2fa944ef2326bb5a727ce9c0">R_RMAC_Close</a>(&amp;g_ether0_ctrl);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h2 class="groupheader">Function Documentation</h2>
<a id="ga052caff07274427357117507a538e8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga052caff07274427357117507a538e8c2">&#9670;&nbsp;</a></span>R_RMAC_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_RMAC_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___e_t_h_e_r___a_p_i.html#structether__cfg__t">ether_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>After RMAC, Switch and PHY-LSI are reset in software, an auto negotiation of PHY-LSI is begun. Afterwards, the link signal change interrupt is permitted. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#aa0c703be12efe73efdd0d47168239470">ether_api_t::open</a>. </p>
<p>Initializes the ether module and applies configurations. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#aa0c703be12efe73efdd0d47168239470">ether_api_t::open</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Channel opened successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to ETHER control block or configuration structure is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Control block has already been opened or channel is being used by another instance. Call close() then open() to reconfigure. </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_ERROR_PHY_COMMUNICATION</td><td>Initialization of PHY-LSI failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_CHANNEL</td><td>Invalid channel number is given. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_POINTER</td><td>Pointer to extend config structure or MAC address is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ARGUMENT</td><td>Interrupt is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_PHY_ERROR_LINK</td><td>Initialization of PHY-LSI failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac014279a2fa944ef2326bb5a727ce9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac014279a2fa944ef2326bb5a727ce9c0">&#9670;&nbsp;</a></span>R_RMAC_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_RMAC_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables interrupts. Removes power and releases hardware lock. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#a84ae3c1816a60c8fc45ccc2084805088">ether_api_t::close</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Channel successfully closed. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to ETHER control block is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0fb1dfa67bcada0ce7fafed44a772519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fb1dfa67bcada0ce7fafed44a772519">&#9670;&nbsp;</a></span>R_RMAC_BufferRelease()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_RMAC_BufferRelease </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move to the next buffer in the receive buffer list. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#a4f988e111dadbfab48e9eccec8d462b5">ether_api_t::bufferRelease</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Processing completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to ETHER control block or internal buffers is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_ERROR_LINK</td><td>Auto-negotiation is not completed, and reception is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_BUFFER_EMPTY</td><td>There is no available internal RX buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae264a546790ece09ebf725e0b7c06213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae264a546790ece09ebf725e0b7c06213">&#9670;&nbsp;</a></span>R_RMAC_RxBufferUpdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_RMAC_RxBufferUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>p_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the buffer pointer of the current rx buffer descriptor. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#a6d088fd3b1a5326af7bedad146491d74">ether_api_t::rxBufferUpdate</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Processing completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A pointer argument is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_POINTER</td><td>The pointer of buffer is NULL or not aligned on a 32-bit boundary. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>Driver is configured to non zero copy mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_BUFFER_EMPTY</td><td>There is no available internal RX buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga876a68d8ec34d3736ff1c3e98927c888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga876a68d8ec34d3736ff1c3e98927c888">&#9670;&nbsp;</a></span>R_RMAC_LinkProcess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_RMAC_LinkProcess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Link up processing, the Link down processing, and the magic packet detection processing are executed. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#ae11e3e3521df4c3efe6e0dafecddee72">ether_api_t::linkProcess</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Link is up. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to ETHER control block is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_ERROR_LINK</td><td>Link is down. </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_ERROR_PHY_COMMUNICATION</td><td>When reopening the PHY interface initialization of the PHY-LSI failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>When reopening the PHY interface it was already opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_CHANNEL</td><td>When reopening the PHY interface an invalid channel was passed. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_POINTER</td><td>When reopening the PHY interface the MAC address pointer was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ARGUMENT</td><td>When reopening the PHY interface the interrupt was not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_PHY_ERROR_LINK</td><td>Initialization of the PHY-LSI failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga277354f6053e6d66639dac11efbb2bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga277354f6053e6d66639dac11efbb2bcd">&#9670;&nbsp;</a></span>R_RMAC_WakeOnLANEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_RMAC_WakeOnLANEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The setting of RMAC is changed from normal sending and receiving mode to magic packet detection mode. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#acde8967c0512722ca73a1596daf654ea">ether_api_t::wakeOnLANEnable</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Processing completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to ETHER control block is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_ERROR_LINK</td><td>Auto-negotiation is not completed, and reception is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_PHY_ERROR_LINK</td><td>Initialization of PHY-LSI failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga121ae669c4f311ecd10fd189dfa1de12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga121ae669c4f311ecd10fd189dfa1de12">&#9670;&nbsp;</a></span>R_RMAC_Read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_RMAC_Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>p_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *const&#160;</td>
          <td class="paramname"><em>length_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive Ethernet frame. Receives data to the location specified by the pointer to the receive buffer. In zero copy mode, the address of the receive buffer is returned. In non zero copy mode, the received data in the internal buffer is copied to the pointer passed by the argument. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#a58975a11436cc5980698b6e843eea3f3">ether_api_t::read</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Processing completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to ETHER control block is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_ERROR_NO_DATA</td><td>There is no data in receive buffer. </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_ERROR_LINK</td><td>Auto-negotiation is not completed, and reception is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_ERROR_FILTERING</td><td>Multicast Frame filter is enable, and Multicast Address Frame is received. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_POINTER</td><td>Value of the pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_BUFFER_EMPTY</td><td>There is no available internal RX buffer. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_SIZE</td><td>The buffer size is smaller than <a class="el" href="group___e_t_h_e_r___a_p_i.html#abe9247fcd1556396eb74c76c899f5256">ether_cfg_t::ether_buffer_size</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaab393ab423c240b4a4dba7472e1cf534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab393ab423c240b4a4dba7472e1cf534">&#9670;&nbsp;</a></span>R_RMAC_Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_RMAC_Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>p_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>frame_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit Ethernet frame. Transmits data from the location specified by the pointer to the transmit buffer, with the data size equal to the specified frame length. In the non zero copy mode, transmits data after being copied to the internal buffer. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#aa61e5ba4dd1de3a50864c0b1970c3b51">ether_api_t::write</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Processing completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to ETHER control block is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_ERROR_LINK</td><td>Auto-negotiation is not completed, and reception is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_ERROR_TRANSMIT_BUFFER_FULL</td><td>Transmit buffer is not empty. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_POINTER</td><td>Value of the pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ARGUMENT</td><td>Value of the send frame size is out of range. </td></tr>
    <tr><td class="paramname">FSP_ERR_BUFFER_EMPTY</td><td>There is no available internal TX buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga080a8964701568116bf95212b8a6d452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga080a8964701568116bf95212b8a6d452">&#9670;&nbsp;</a></span>R_RMAC_TxStatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_RMAC_TxStatusGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>p_buffer_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides status of Ethernet driver in the user provided pointer. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#ad52cabec533efaaef3258caade1e0640">ether_api_t::txStatusGet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Transmit buffer address is stored in provided p_buffer_address. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to ETHER control block is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_POINTER</td><td>p_status is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_FOUND</td><td>Transmit buffer address has been overwritten in transmit descriptor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3d04bd2fdf0676a7a2d992b5e8ff0b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d04bd2fdf0676a7a2d992b5e8ff0b65">&#9670;&nbsp;</a></span>R_RMAC_CallbackSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_RMAC_CallbackSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="group___e_t_h_e_r___a_p_i.html#structether__callback__args__t">ether_callback_args_t</a> *)&#160;</td>
          <td class="paramname"><em>p_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>p_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___e_t_h_e_r___a_p_i.html#structether__callback__args__t">ether_callback_args_t</a> *const&#160;</td>
          <td class="paramname"><em>p_callback_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the user callback with the option to provide memory for the callback argument structure. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#a2d85d35c6eb31690a2c050dffed7a0df">ether_api_t::callbackSet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Callback updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_NO_CALLBACK_MEMORY</td><td>p_callback is non-secure and p_callback_memory is either secure or NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaabae2f3adcc92fae91041af247affc43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabae2f3adcc92fae91041af247affc43">&#9670;&nbsp;</a></span>R_RMAC_SetWriteConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_RMAC_SetWriteConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmac__write__cfg__t.html">rmac_write_cfg_t</a> *const&#160;</td>
          <td class="paramname"><em>p_write_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set configuration for tx frame. This API must call before <a class="el" href="group___e_t_h_e_r___a_p_i.html#aa61e5ba4dd1de3a50864c0b1970c3b51">ether_api_t::write</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Processing completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A pointer argument is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gade9b7430ef877c3ff44c9601339932e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade9b7430ef877c3ff44c9601339932e9">&#9670;&nbsp;</a></span>R_RMAC_GetTxTimestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_RMAC_GetTxTimestamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmac__timestamp__t.html">rmac_timestamp_t</a> *const&#160;</td>
          <td class="paramname"><em>p_timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get timestamp of transmitted frame. This API must call after <a class="el" href="group___e_t_h_e_r___a_p_i.html#aa61e5ba4dd1de3a50864c0b1970c3b51">ether_api_t::write</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Processing completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A pointer argument is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga338bb68cc016993825595068ee274302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga338bb68cc016993825595068ee274302">&#9670;&nbsp;</a></span>R_RMAC_GetRxTimestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_RMAC_GetRxTimestamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrmac__timestamp__t.html">rmac_timestamp_t</a> *const&#160;</td>
          <td class="paramname"><em>p_timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get timestamp of received frame. This API must call before <a class="el" href="group___e_t_h_e_r___a_p_i.html#a58975a11436cc5980698b6e843eea3f3">ether_api_t::read</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Processing completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A pointer argument is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v6.3.1 User's Manual Copyright Â© (2026) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
