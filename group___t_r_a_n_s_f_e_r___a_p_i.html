<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: Transfer Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
    $(document).ready(function() {
        $("tr.tree_lvl_1").nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
		$("tr.tree_lvl_1").data("expanded","0");
		$("tr.tree_lvl_2").data("expanded","0");
		$("tr.tree_lvl_3").data("expanded","0");
		$("tr.tree_lvl_4").data("expanded","0");
		$("tr.tree_lvl_5").data("expanded","0");
        $("tr.tree_lvl_1").click(function() {
		    var lvl_1_is_open = $(this).data("expanded");
		    if (lvl_1_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2, tr.tree_lvl_1_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_2").click(function() {
		    var lvl_2_is_open = $(this).data("expanded");
		    if (lvl_2_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3, tr.tree_lvl_2_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_3").click(function() {
		    var lvl_3_is_open = $(this).data("expanded");
		    if (lvl_3_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_3_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_4").click(function() {
		    var lvl_4_is_open = $(this).data("expanded");
		    if (lvl_4_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5, tr.tree_lvl_4_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_5").click(function() {
		    var lvl_5_is_open = $(this).data("expanded");
		    if (lvl_5_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4_item,tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
     });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v6.2.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">

    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text">
      </span>
      <span class="right">
          &nbsp;
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___t_r_a_n_s_f_e_r___a_p_i.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body.
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len));
            }
          }
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element.
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">Transfer Interface<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___i_n_t_e_r_f_a_c_e_s.html">Interfaces</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___t_r_a_n_s_f_e_r___i_n_t_e_r_f_a_c_e_s.html">Transfer</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Interface for data transfer functions. </p>
<h1><a class="anchor" id="TRANSFER_API_SUMMARY"></a>
Summary</h1>
<p>The transfer interface supports background data transfer (no CPU intervention). </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structtransfer__callback__args__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__callback__args__t">transfer_callback_args_t</a></td></tr>
<tr class="separator:structtransfer__callback__args__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtransfer__properties__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__properties__t">transfer_properties_t</a></td></tr>
<tr class="separator:structtransfer__properties__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtransfer__info__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__info__t">transfer_info_t</a></td></tr>
<tr class="separator:structtransfer__info__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtransfer__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__cfg__t">transfer_cfg_t</a></td></tr>
<tr class="separator:structtransfer__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtransfer__api__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__api__t">transfer_api_t</a></td></tr>
<tr class="separator:structtransfer__api__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtransfer__instance__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__instance__t">transfer_instance_t</a></td></tr>
<tr class="separator:structtransfer__instance__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga665f80fc984ccf7585606be8eeccbb98"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a></td></tr>
<tr class="separator:ga665f80fc984ccf7585606be8eeccbb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gadfb7c2a6a73bfdf993e50505aa92992f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#gadfb7c2a6a73bfdf993e50505aa92992f">transfer_mode_t</a> </td></tr>
<tr class="separator:gadfb7c2a6a73bfdf993e50505aa92992f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c224e5afb174f3f6ea9eddbb9da8b12"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga6c224e5afb174f3f6ea9eddbb9da8b12">transfer_size_t</a> </td></tr>
<tr class="separator:ga6c224e5afb174f3f6ea9eddbb9da8b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadce62e6c2407d6ffd5a94636736f7c51"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#gadce62e6c2407d6ffd5a94636736f7c51">transfer_addr_mode_t</a> </td></tr>
<tr class="separator:gadce62e6c2407d6ffd5a94636736f7c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga769464d2068881ccb44573c96167812b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga769464d2068881ccb44573c96167812b">transfer_repeat_area_t</a> </td></tr>
<tr class="separator:ga769464d2068881ccb44573c96167812b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68f81dc8b9ca46fbe3a1e556c020436d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga68f81dc8b9ca46fbe3a1e556c020436d">transfer_chain_mode_t</a> </td></tr>
<tr class="separator:ga68f81dc8b9ca46fbe3a1e556c020436d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad71bdadb7f486bb5d3ca6ff508dc0b08"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#gad71bdadb7f486bb5d3ca6ff508dc0b08">transfer_irq_t</a> </td></tr>
<tr class="separator:gad71bdadb7f486bb5d3ca6ff508dc0b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11917a0ab2cb8b878937c97691b07fd9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga11917a0ab2cb8b878937c97691b07fd9">transfer_start_mode_t</a> </td></tr>
<tr class="separator:ga11917a0ab2cb8b878937c97691b07fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structtransfer__callback__args__t" id="structtransfer__callback__args__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structtransfer__callback__args__t">&#9670;&nbsp;</a></span>transfer_callback_args_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct transfer_callback_args_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Callback function parameter data. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a60ba3dde72b1fe2b88391aa0dd0249a4"></a>void *</td>
<td class="fieldname">
p_context</td>
<td class="fielddoc">
Placeholder for user data. Set in <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a84d48960cdfe867ef54fd4635a85ceeb">transfer_api_t::open</a> function in <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__cfg__t">transfer_cfg_t</a>. </td></tr>
</table>

</div>
</div>
<a name="structtransfer__properties__t" id="structtransfer__properties__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structtransfer__properties__t">&#9670;&nbsp;</a></span>transfer_properties_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct transfer_properties_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Driver specific information. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ab480a287279e160d73f60173605485ca"></a>uint32_t</td>
<td class="fieldname">
block_count_max</td>
<td class="fielddoc">
Maximum number of blocks. </td></tr>
<tr><td class="fieldtype">
<a id="aaa2d7970aa8501e9d3929c7bdf05d357"></a>uint32_t</td>
<td class="fieldname">
block_count_remaining</td>
<td class="fielddoc">
Number of blocks remaining. </td></tr>
<tr><td class="fieldtype">
<a id="ae8ae839a9fa2fea09d9390e11b2edd9c"></a>uint32_t</td>
<td class="fieldname">
transfer_length_max</td>
<td class="fielddoc">
Maximum number of transfers. </td></tr>
<tr><td class="fieldtype">
<a id="afd44a3b34e332d28d7573865c58b00df"></a>uint32_t</td>
<td class="fieldname">
transfer_length_remaining</td>
<td class="fielddoc">
Number of transfers remaining. </td></tr>
</table>

</div>
</div>
<a name="structtransfer__info__t" id="structtransfer__info__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structtransfer__info__t">&#9670;&nbsp;</a></span>transfer_info_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct transfer_info_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure specifies the properties of the transfer. </p><dl class="section warning"><dt>Warning</dt><dd>When using DTC, this structure corresponds to the descriptor block registers required by the DTC. The following components may be modified by the driver: p_src, p_dest, num_blocks, and length. </dd>
<dd>
When using DTC, do NOT reuse this structure to configure multiple transfers. Each transfer must have a unique <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__info__t">transfer_info_t</a>. </dd>
<dd>
When using DTC, this structure must not be allocated in a temporary location. Any instance of this structure must remain in scope until the transfer it is used for is closed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When using DTC, consider placing instances of this structure in a protected section of memory. </dd></dl>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a4311c96e15e19fe4c2044cc757448121"></a>union <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#uniontransfer__info__t_8____unnamed____">transfer_info_t</a></td>
<td class="fieldname">
__unnamed__</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="ad264d20a1b0afc0100c2e3b1d5a1a1c8"></a>void const  *volatile</td>
<td class="fieldname">
p_src</td>
<td class="fielddoc">
Source pointer. </td></tr>
<tr><td class="fieldtype">
<a id="a176dc2f3d1edfc321fa248a7e4c3b549"></a>void *volatile</td>
<td class="fieldname">
p_dest</td>
<td class="fielddoc">
Destination pointer. </td></tr>
<tr><td class="fieldtype">
<a id="a9781e58bb7cb2ee40de446936d523814"></a>volatile uint16_t</td>
<td class="fieldname">
num_blocks</td>
<td class="fielddoc">
<p>Number of blocks to transfer when using <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ggadfb7c2a6a73bfdf993e50505aa92992faa4f65de2d9454af406f60172ff858d55">TRANSFER_MODE_BLOCK</a> (both DTC an DMAC) or <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ggadfb7c2a6a73bfdf993e50505aa92992fa607c41bfd08797c08a5ee9bd4dfb9c8b">TRANSFER_MODE_REPEAT</a> (DMAC only) or <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ggadfb7c2a6a73bfdf993e50505aa92992fafb43c6e62b61f0dbb9a5bcd5575e79e2">TRANSFER_MODE_REPEAT_BLOCK</a> (DMAC only), unused in other modes. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa92c5d06d07e7d13c16f9704a431c7cb"></a>volatile uint16_t</td>
<td class="fieldname">
length</td>
<td class="fielddoc">
<p>Length of each transfer. Range limited for <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ggadfb7c2a6a73bfdf993e50505aa92992faa4f65de2d9454af406f60172ff858d55">TRANSFER_MODE_BLOCK</a>, <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ggadfb7c2a6a73bfdf993e50505aa92992fa607c41bfd08797c08a5ee9bd4dfb9c8b">TRANSFER_MODE_REPEAT</a>, and <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ggadfb7c2a6a73bfdf993e50505aa92992fafb43c6e62b61f0dbb9a5bcd5575e79e2">TRANSFER_MODE_REPEAT_BLOCK</a> see HAL driver for details. </p>
</td></tr>
</table>

</div>
</div>
<a name="structtransfer__cfg__t" id="structtransfer__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structtransfer__cfg__t">&#9670;&nbsp;</a></span>transfer_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct transfer_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Driver configuration set in <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a84d48960cdfe867ef54fd4635a85ceeb">transfer_api_t::open</a>. All elements except p_extend are required and must be initialized. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="af99b114594ac2d55aae0c9e11f703164"></a><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__info__t">transfer_info_t</a> *</td>
<td class="fieldname">
p_info</td>
<td class="fielddoc">
<p>Pointer to transfer configuration options. If using chain transfer (DTC only), this can be a pointer to an array of chained transfers that will be completed in order. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a7dcf4353ecf5e5df7024e1a3d5db7c09"></a>void const  *</td>
<td class="fieldname">
p_extend</td>
<td class="fielddoc">
Extension parameter for hardware specific settings. </td></tr>
</table>

</div>
</div>
<a name="structtransfer__api__t" id="structtransfer__api__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structtransfer__api__t">&#9670;&nbsp;</a></span>transfer_api_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct transfer_api_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Transfer functions implemented at the HAL layer will follow this API. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a84d48960cdfe867ef54fd4635a85ceeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a84d48960cdfe867ef54fd4635a85ceeb">open</a> )(<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl, <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__cfg__t">transfer_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:a84d48960cdfe867ef54fd4635a85ceeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e38b8ef4e4fa3e59efb257102e72b72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a1e38b8ef4e4fa3e59efb257102e72b72">reconfigure</a> )(<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl, <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__info__t">transfer_info_t</a> *p_info)</td></tr>
<tr class="separator:a1e38b8ef4e4fa3e59efb257102e72b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c096c8d0e78dfbf8b3809a4598b8619"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a9c096c8d0e78dfbf8b3809a4598b8619">reset</a> )(<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl, void const *p_src, void *p_dest, uint16_t const num_transfers)</td></tr>
<tr class="separator:a9c096c8d0e78dfbf8b3809a4598b8619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd4d96709c77a309492d13fd43fd048"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a7fd4d96709c77a309492d13fd43fd048">enable</a> )(<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:a7fd4d96709c77a309492d13fd43fd048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3188207ba386da0ec85946e134b4327a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a3188207ba386da0ec85946e134b4327a">disable</a> )(<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:a3188207ba386da0ec85946e134b4327a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394ddea028013153254bafa12115dce2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a394ddea028013153254bafa12115dce2">softwareStart</a> )(<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl, <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga11917a0ab2cb8b878937c97691b07fd9">transfer_start_mode_t</a> mode)</td></tr>
<tr class="separator:a394ddea028013153254bafa12115dce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77207de2ae81eab58858fd28ae88df06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a77207de2ae81eab58858fd28ae88df06">softwareStop</a> )(<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:a77207de2ae81eab58858fd28ae88df06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18824ffdf72b5e6a0c588289620fc84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ad18824ffdf72b5e6a0c588289620fc84">infoGet</a> )(<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl, <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__properties__t">transfer_properties_t</a> *const p_properties)</td></tr>
<tr class="separator:ad18824ffdf72b5e6a0c588289620fc84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5973e7a8e994f9146e0db84bee8bf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ade5973e7a8e994f9146e0db84bee8bf4">close</a> )(<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:ade5973e7a8e994f9146e0db84bee8bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af1d98295baf9bd92251f55c95f8868"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a3af1d98295baf9bd92251f55c95f8868">reload</a> )(<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl, void const *p_src, void *p_dest, uint32_t const num_transfers)</td></tr>
<tr class="separator:a3af1d98295baf9bd92251f55c95f8868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27b0544680f6ef53822b37753f404cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ae27b0544680f6ef53822b37753f404cb">callbackSet</a> )(<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl, void(*p_callback)(<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__callback__args__t">transfer_callback_args_t</a> *), void *const p_context, <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__callback__args__t">transfer_callback_args_t</a> *const p_callback_memory)</td></tr>
<tr class="separator:ae27b0544680f6ef53822b37753f404cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a id="a84d48960cdfe867ef54fd4635a85ceeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84d48960cdfe867ef54fd4635a85ceeb">&#9670;&nbsp;</a></span>open</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>(*  transfer_api_t::open) (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl, <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__cfg__t">transfer_cfg_t</a> const *const p_cfg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initial configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_ctrl</td><td>Pointer to control block. Must be declared by user. Elements set here. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_cfg</td><td>Pointer to configuration structure. All elements of this structure must be set by user. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e38b8ef4e4fa3e59efb257102e72b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e38b8ef4e4fa3e59efb257102e72b72">&#9670;&nbsp;</a></span>reconfigure</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>(*  transfer_api_t::reconfigure) (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl, <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__info__t">transfer_info_t</a> *p_info)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reconfigure the transfer. Enable the transfer if p_info is valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_ctrl</td><td>Pointer to control block. Must be declared by user. Elements set here. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_info</td><td>Pointer to a new transfer info structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c096c8d0e78dfbf8b3809a4598b8619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c096c8d0e78dfbf8b3809a4598b8619">&#9670;&nbsp;</a></span>reset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>(*  transfer_api_t::reset) (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl, void const *p_src, void *p_dest, uint16_t const num_transfers)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset source address pointer, destination address pointer, and/or length, keeping all other settings the same. Enable the transfer if p_src, p_dest, and length are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_ctrl</td><td>Control block set in <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a84d48960cdfe867ef54fd4635a85ceeb">transfer_api_t::open</a> call for this transfer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_src</td><td>Pointer to source. Set to NULL if source pointer should not change. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_dest</td><td>Pointer to destination. Set to NULL if destination pointer should not change. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_transfers</td><td>Transfer length in normal mode or number of blocks in block mode. In DMAC only, resets number of repeats (initially stored in <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a9781e58bb7cb2ee40de446936d523814">transfer_info_t::num_blocks</a>) in repeat mode. Not used in repeat mode for DTC. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fd4d96709c77a309492d13fd43fd048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd4d96709c77a309492d13fd43fd048">&#9670;&nbsp;</a></span>enable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>(*  transfer_api_t::enable) (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable transfer. Transfers occur after the activation source event (or when <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a394ddea028013153254bafa12115dce2">transfer_api_t::softwareStart</a> is called if no peripheral event is chosen as activation source).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_ctrl</td><td>Control block set in <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a84d48960cdfe867ef54fd4635a85ceeb">transfer_api_t::open</a> call for this transfer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3188207ba386da0ec85946e134b4327a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3188207ba386da0ec85946e134b4327a">&#9670;&nbsp;</a></span>disable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>(*  transfer_api_t::disable) (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable transfer. Transfers do not occur after the activation source event (or when <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a394ddea028013153254bafa12115dce2">transfer_api_t::softwareStart</a> is called if no peripheral event is chosen as the DMAC activation source). </p><dl class="section note"><dt>Note</dt><dd>If a transfer is in progress, it will be completed. Subsequent transfer requests do not cause a transfer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_ctrl</td><td>Control block set in <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a84d48960cdfe867ef54fd4635a85ceeb">transfer_api_t::open</a> call for this transfer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a394ddea028013153254bafa12115dce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394ddea028013153254bafa12115dce2">&#9670;&nbsp;</a></span>softwareStart</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>(*  transfer_api_t::softwareStart) (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl, <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga11917a0ab2cb8b878937c97691b07fd9">transfer_start_mode_t</a> mode)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start transfer in software. </p><dl class="section warning"><dt>Warning</dt><dd>Only works if no peripheral event is chosen as the DMAC activation source. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Not supported for DTC.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_ctrl</td><td>Control block set in <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a84d48960cdfe867ef54fd4635a85ceeb">transfer_api_t::open</a> call for this transfer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Select mode from <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga11917a0ab2cb8b878937c97691b07fd9">transfer_start_mode_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77207de2ae81eab58858fd28ae88df06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77207de2ae81eab58858fd28ae88df06">&#9670;&nbsp;</a></span>softwareStop</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>(*  transfer_api_t::softwareStop) (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop transfer in software. The transfer will stop after completion of the current transfer. </p><dl class="section note"><dt>Note</dt><dd>Not supported for DTC. </dd>
<dd>
Only applies for transfers started with TRANSFER_START_MODE_REPEAT. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Only works if no peripheral event is chosen as the DMAC activation source.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_ctrl</td><td>Control block set in <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a84d48960cdfe867ef54fd4635a85ceeb">transfer_api_t::open</a> call for this transfer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad18824ffdf72b5e6a0c588289620fc84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18824ffdf72b5e6a0c588289620fc84">&#9670;&nbsp;</a></span>infoGet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>(*  transfer_api_t::infoGet) (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl, <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__properties__t">transfer_properties_t</a> *const p_properties)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides information about this transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_ctrl</td><td>Control block set in <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a84d48960cdfe867ef54fd4635a85ceeb">transfer_api_t::open</a> call for this transfer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_properties</td><td>Driver specific information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade5973e7a8e994f9146e0db84bee8bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5973e7a8e994f9146e0db84bee8bf4">&#9670;&nbsp;</a></span>close</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>(*  transfer_api_t::close) (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases hardware lock. This allows a transfer to be reconfigured using <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a84d48960cdfe867ef54fd4635a85ceeb">transfer_api_t::open</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_ctrl</td><td>Control block set in <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a84d48960cdfe867ef54fd4635a85ceeb">transfer_api_t::open</a> call for this transfer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3af1d98295baf9bd92251f55c95f8868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af1d98295baf9bd92251f55c95f8868">&#9670;&nbsp;</a></span>reload</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>(*  transfer_api_t::reload) (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl, void const *p_src, void *p_dest, uint32_t const num_transfers)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>To update next transfer information without interruption during transfer. Allow further transfer continuation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_ctrl</td><td>Control block set in <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a84d48960cdfe867ef54fd4635a85ceeb">transfer_api_t::open</a> call for this transfer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_src</td><td>Pointer to source. Set to NULL if source pointer should not change. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_dest</td><td>Pointer to destination. Set to NULL if destination pointer should not change. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_transfers</td><td>Transfer length in normal mode or block mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae27b0544680f6ef53822b37753f404cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27b0544680f6ef53822b37753f404cb">&#9670;&nbsp;</a></span>callbackSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>(*  transfer_api_t::callbackSet) (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl, void(*p_callback)(<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__callback__args__t">transfer_callback_args_t</a> *), void *const p_context, <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__callback__args__t">transfer_callback_args_t</a> *const p_callback_memory)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specify callback function and optional context pointer and working memory pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_ctrl</td><td>Control block set in <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a84d48960cdfe867ef54fd4635a85ceeb">transfer_api_t::open</a> call for this transfer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_callback</td><td>Callback function to register </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_context</td><td>Pointer to send to callback function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_callback_memory</td><td>Pointer to volatile memory where callback structure can be allocated. Callback arguments allocated here are only valid during the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>

</div>
</div>
<a name="structtransfer__instance__t" id="structtransfer__instance__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structtransfer__instance__t">&#9670;&nbsp;</a></span>transfer_instance_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct transfer_instance_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure encompasses everything that is needed to use an instance of this interface. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a655547e7bbc2c8be77ac085f3417a389"></a><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *</td>
<td class="fieldname">
p_ctrl</td>
<td class="fielddoc">
Pointer to the control structure for this instance. </td></tr>
<tr><td class="fieldtype">
<a id="a8ffd253e9be22795d2736d6dc683d710"></a><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__cfg__t">transfer_cfg_t</a> const  *</td>
<td class="fieldname">
p_cfg</td>
<td class="fielddoc">
Pointer to the configuration structure for this instance. </td></tr>
<tr><td class="fieldtype">
<a id="a12d4ba0d43dd22fda6b1b238d2fa17b6"></a><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__api__t">transfer_api_t</a> const  *</td>
<td class="fieldname">
p_api</td>
<td class="fielddoc">
Pointer to the API structure for this instance. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga665f80fc984ccf7585606be8eeccbb98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga665f80fc984ccf7585606be8eeccbb98">&#9670;&nbsp;</a></span>transfer_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transfer control block. Allocate an instance specific control block to pass into the transfer API calls. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gadfb7c2a6a73bfdf993e50505aa92992f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfb7c2a6a73bfdf993e50505aa92992f">&#9670;&nbsp;</a></span>transfer_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#gadfb7c2a6a73bfdf993e50505aa92992f">transfer_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transfer mode describes what will happen when a transfer request occurs. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadfb7c2a6a73bfdf993e50505aa92992fada90d8a89f98ff82475383b14141b08d"></a>TRANSFER_MODE_NORMAL&#160;</td><td class="fielddoc"><p>In normal mode, each transfer request causes a transfer of <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga6c224e5afb174f3f6ea9eddbb9da8b12">transfer_size_t</a> from the source pointer to the destination pointer. The transfer length is decremented and the source and address pointers are updated according to <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#gadce62e6c2407d6ffd5a94636736f7c51">transfer_addr_mode_t</a>. After the transfer length reaches 0, transfer requests will not cause any further transfers. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadfb7c2a6a73bfdf993e50505aa92992fa607c41bfd08797c08a5ee9bd4dfb9c8b"></a>TRANSFER_MODE_REPEAT&#160;</td><td class="fielddoc"><p>Repeat mode is like normal mode, except that when the transfer length reaches 0, the pointer to the repeat area and the transfer length will be reset to their initial values. If DMAC is used, the transfer repeats only <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a9781e58bb7cb2ee40de446936d523814">transfer_info_t::num_blocks</a> times. After the transfer repeats <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a9781e58bb7cb2ee40de446936d523814">transfer_info_t::num_blocks</a> times, transfer requests will not cause any further transfers. If DTC is used, the transfer repeats continuously (no limit to the number of repeat transfers). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadfb7c2a6a73bfdf993e50505aa92992faa4f65de2d9454af406f60172ff858d55"></a>TRANSFER_MODE_BLOCK&#160;</td><td class="fielddoc"><p>In block mode, each transfer request causes <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#aa92c5d06d07e7d13c16f9704a431c7cb">transfer_info_t::length</a> transfers of <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga6c224e5afb174f3f6ea9eddbb9da8b12">transfer_size_t</a>. After each individual transfer, the source and destination pointers are updated according to <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#gadce62e6c2407d6ffd5a94636736f7c51">transfer_addr_mode_t</a>. After the block transfer is complete, <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a9781e58bb7cb2ee40de446936d523814">transfer_info_t::num_blocks</a> is decremented. After the <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a9781e58bb7cb2ee40de446936d523814">transfer_info_t::num_blocks</a> reaches 0, transfer requests will not cause any further transfers. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadfb7c2a6a73bfdf993e50505aa92992fafb43c6e62b61f0dbb9a5bcd5575e79e2"></a>TRANSFER_MODE_REPEAT_BLOCK&#160;</td><td class="fielddoc"><p>In addition to block mode features, repeat-block mode supports a ring buffer of blocks and offsets within a block (to split blocks into arrays of their first data, second data, etc.) </p>
</td></tr>
</table>

</div>
</div>
<a id="ga6c224e5afb174f3f6ea9eddbb9da8b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c224e5afb174f3f6ea9eddbb9da8b12">&#9670;&nbsp;</a></span>transfer_size_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga6c224e5afb174f3f6ea9eddbb9da8b12">transfer_size_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transfer size specifies the size of each individual transfer. Total transfer length = transfer_size_t * transfer_length_t </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6c224e5afb174f3f6ea9eddbb9da8b12accfeb24892ec24e42ccf14e4d4896c21"></a>TRANSFER_SIZE_1_BYTE&#160;</td><td class="fielddoc"><p>Each transfer transfers a 8-bit value. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6c224e5afb174f3f6ea9eddbb9da8b12a8b6b33a085b51ea2eeed1ef119de562f"></a>TRANSFER_SIZE_2_BYTE&#160;</td><td class="fielddoc"><p>Each transfer transfers a 16-bit value. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6c224e5afb174f3f6ea9eddbb9da8b12a18482bfa86e737cde78042be4db54412"></a>TRANSFER_SIZE_4_BYTE&#160;</td><td class="fielddoc"><p>Each transfer transfers a 32-bit value. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6c224e5afb174f3f6ea9eddbb9da8b12a5bb02177f10ea6a06f9fdf3d8f353d6f"></a>TRANSFER_SIZE_8_BYTE&#160;</td><td class="fielddoc"><p>Each transfer transfers a 64-bit value. </p>
</td></tr>
</table>

</div>
</div>
<a id="gadce62e6c2407d6ffd5a94636736f7c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadce62e6c2407d6ffd5a94636736f7c51">&#9670;&nbsp;</a></span>transfer_addr_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#gadce62e6c2407d6ffd5a94636736f7c51">transfer_addr_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Address mode specifies whether to modify (increment or decrement) pointer after each transfer. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadce62e6c2407d6ffd5a94636736f7c51abf18f9b3701e9e91f44055ee47d0ca47"></a>TRANSFER_ADDR_MODE_FIXED&#160;</td><td class="fielddoc"><p>Address pointer remains fixed after each transfer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadce62e6c2407d6ffd5a94636736f7c51ab8b3f8ce28fb6f7a57a1b87db0d612c2"></a>TRANSFER_ADDR_MODE_OFFSET&#160;</td><td class="fielddoc"><p>Offset is added to the address pointer after each transfer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadce62e6c2407d6ffd5a94636736f7c51a7665741e25c4cc78fd24745efbd2eaad"></a>TRANSFER_ADDR_MODE_INCREMENTED&#160;</td><td class="fielddoc"><p>Address pointer is incremented by associated <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga6c224e5afb174f3f6ea9eddbb9da8b12">transfer_size_t</a> after each transfer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadce62e6c2407d6ffd5a94636736f7c51a56a87e1587844119831414f3d5e6d761"></a>TRANSFER_ADDR_MODE_DECREMENTED&#160;</td><td class="fielddoc"><p>Address pointer is decremented by associated <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga6c224e5afb174f3f6ea9eddbb9da8b12">transfer_size_t</a> after each transfer. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga769464d2068881ccb44573c96167812b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga769464d2068881ccb44573c96167812b">&#9670;&nbsp;</a></span>transfer_repeat_area_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga769464d2068881ccb44573c96167812b">transfer_repeat_area_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Repeat area options (source or destination). In <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ggadfb7c2a6a73bfdf993e50505aa92992fa607c41bfd08797c08a5ee9bd4dfb9c8b">TRANSFER_MODE_REPEAT</a>, the selected pointer returns to its original value after <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#aa92c5d06d07e7d13c16f9704a431c7cb">transfer_info_t::length</a> transfers. In <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ggadfb7c2a6a73bfdf993e50505aa92992faa4f65de2d9454af406f60172ff858d55">TRANSFER_MODE_BLOCK</a> and <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ggadfb7c2a6a73bfdf993e50505aa92992fafb43c6e62b61f0dbb9a5bcd5575e79e2">TRANSFER_MODE_REPEAT_BLOCK</a>, the selected pointer returns to its original value after each transfer. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga769464d2068881ccb44573c96167812ba77aeeab30b003de23742e40a57f19239"></a>TRANSFER_REPEAT_AREA_DESTINATION&#160;</td><td class="fielddoc"><p>Destination area repeated in <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ggadfb7c2a6a73bfdf993e50505aa92992fa607c41bfd08797c08a5ee9bd4dfb9c8b">TRANSFER_MODE_REPEAT</a> or <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ggadfb7c2a6a73bfdf993e50505aa92992faa4f65de2d9454af406f60172ff858d55">TRANSFER_MODE_BLOCK</a> or <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ggadfb7c2a6a73bfdf993e50505aa92992fafb43c6e62b61f0dbb9a5bcd5575e79e2">TRANSFER_MODE_REPEAT_BLOCK</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga769464d2068881ccb44573c96167812ba2002ef7bbc49f7c9ebfac1618ba3c391"></a>TRANSFER_REPEAT_AREA_SOURCE&#160;</td><td class="fielddoc"><p>Source area repeated in <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ggadfb7c2a6a73bfdf993e50505aa92992fa607c41bfd08797c08a5ee9bd4dfb9c8b">TRANSFER_MODE_REPEAT</a> or <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ggadfb7c2a6a73bfdf993e50505aa92992faa4f65de2d9454af406f60172ff858d55">TRANSFER_MODE_BLOCK</a> or <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ggadfb7c2a6a73bfdf993e50505aa92992fafb43c6e62b61f0dbb9a5bcd5575e79e2">TRANSFER_MODE_REPEAT_BLOCK</a>. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga68f81dc8b9ca46fbe3a1e556c020436d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68f81dc8b9ca46fbe3a1e556c020436d">&#9670;&nbsp;</a></span>transfer_chain_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga68f81dc8b9ca46fbe3a1e556c020436d">transfer_chain_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Chain transfer mode options. </p><dl class="section note"><dt>Note</dt><dd>Only applies for DTC. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga68f81dc8b9ca46fbe3a1e556c020436dae974453c306b4959252905e362d75067"></a>TRANSFER_CHAIN_MODE_DISABLED&#160;</td><td class="fielddoc"><p>Chain mode not used. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga68f81dc8b9ca46fbe3a1e556c020436dadab837d29a543149d35ed2fd28d8e4e8"></a>TRANSFER_CHAIN_MODE_EACH&#160;</td><td class="fielddoc"><p>Switch to next transfer after a single transfer from this <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__info__t">transfer_info_t</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga68f81dc8b9ca46fbe3a1e556c020436dab853bdecc90c476b995644c273e0ee75"></a>TRANSFER_CHAIN_MODE_END&#160;</td><td class="fielddoc"><p>Complete the entire transfer defined in this <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__info__t">transfer_info_t</a> before chaining to next transfer. </p>
</td></tr>
</table>

</div>
</div>
<a id="gad71bdadb7f486bb5d3ca6ff508dc0b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad71bdadb7f486bb5d3ca6ff508dc0b08">&#9670;&nbsp;</a></span>transfer_irq_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#gad71bdadb7f486bb5d3ca6ff508dc0b08">transfer_irq_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interrupt options. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad71bdadb7f486bb5d3ca6ff508dc0b08ada378ad830e44cc0c25d4fe2413e11de"></a>TRANSFER_IRQ_END&#160;</td><td class="fielddoc"><p>Interrupt occurs only after last transfer. If this transfer is chained to a subsequent transfer, the interrupt will occur only after subsequent chained transfer(s) are complete. </p><dl class="section warning"><dt>Warning</dt><dd>DTC triggers the interrupt of the activation source. Choosing TRANSFER_IRQ_END with DTC will prevent activation source interrupts until the transfer is complete. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggad71bdadb7f486bb5d3ca6ff508dc0b08a0929782b61686db69e12b3cb18175b35"></a>TRANSFER_IRQ_EACH&#160;</td><td class="fielddoc"><p>Interrupt occurs after each transfer. </p><dl class="section note"><dt>Note</dt><dd>Not available in all HAL drivers. See HAL driver for details. </dd></dl>
</td></tr>
</table>

</div>
</div>
<a id="ga11917a0ab2cb8b878937c97691b07fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11917a0ab2cb8b878937c97691b07fd9">&#9670;&nbsp;</a></span>transfer_start_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga11917a0ab2cb8b878937c97691b07fd9">transfer_start_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select whether to start single or repeated transfer with software start. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga11917a0ab2cb8b878937c97691b07fd9aca210983d734307a694af55fbf11ed7e"></a>TRANSFER_START_MODE_SINGLE&#160;</td><td class="fielddoc"><p>Software start triggers single transfer. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga11917a0ab2cb8b878937c97691b07fd9aa9b89e5adf9e24c9203f9fdf6c6aa331"></a>TRANSFER_START_MODE_REPEAT&#160;</td><td class="fielddoc"><p>Software start transfer continues until transfer is complete. </p>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v6.2.0 User's Manual Copyright © (2025) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
