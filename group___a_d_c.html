<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: Analog to Digital Converter (r_adc)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v3.1.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">
 
    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text"> 
      </span>
      <span class="right">
          &nbsp; 
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___a_d_c.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() { 
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body. 
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works 
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len)); 
            }
          } 
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }    
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element. 
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;  
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">Analog to Digital Converter (r_adc)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gade895e0810cecb3be6a9e5217f5c78ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#gade895e0810cecb3be6a9e5217f5c78ac">R_ADC_Open</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#structadc__cfg__t">adc_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:gade895e0810cecb3be6a9e5217f5c78ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga994514574730e0701dc1a6ad41889f88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga994514574730e0701dc1a6ad41889f88">R_ADC_ScanCfg</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, void const *const p_channel_cfg)</td></tr>
<tr class="separator:ga994514574730e0701dc1a6ad41889f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cc44d84e1dd1cad8fdafe1e91a3b6d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga1cc44d84e1dd1cad8fdafe1e91a3b6d0">R_ADC_InfoGet</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#structadc__info__t">adc_info_t</a> *p_adc_info)</td></tr>
<tr class="separator:ga1cc44d84e1dd1cad8fdafe1e91a3b6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a7fb2265b5a03c7586253ff28b3faf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga4a7fb2265b5a03c7586253ff28b3faf2">R_ADC_ScanStart</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:ga4a7fb2265b5a03c7586253ff28b3faf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b5242c153c6320a564ed9ffd324f144"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga9b5242c153c6320a564ed9ffd324f144">R_ADC_ScanStop</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:ga9b5242c153c6320a564ed9ffd324f144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga676b1c7f1ccceda288cbb2ad79a14ff2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga676b1c7f1ccceda288cbb2ad79a14ff2">R_ADC_StatusGet</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#structadc__status__t">adc_status_t</a> *p_status)</td></tr>
<tr class="separator:ga676b1c7f1ccceda288cbb2ad79a14ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6bfc8395b53a96ee89f266fc940e2da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#gad6bfc8395b53a96ee89f266fc940e2da">R_ADC_Read</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const reg_id, uint16_t *const p_data)</td></tr>
<tr class="separator:gad6bfc8395b53a96ee89f266fc940e2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga905e1cd6ff8ca4aaf91ee63529dc0d0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga905e1cd6ff8ca4aaf91ee63529dc0d0d">R_ADC_Read32</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const reg_id, uint32_t *const p_data)</td></tr>
<tr class="separator:ga905e1cd6ff8ca4aaf91ee63529dc0d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0701bf45818dee071cb12e979017bce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#gaf0701bf45818dee071cb12e979017bce">R_ADC_SampleStateCountSet</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c.html#structadc__sample__state__t">adc_sample_state_t</a> *p_sample)</td></tr>
<tr class="separator:gaf0701bf45818dee071cb12e979017bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga499187b3067534e42a57239ead111797"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga499187b3067534e42a57239ead111797">R_ADC_Close</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:ga499187b3067534e42a57239ead111797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3bc65f19ba61612e0b7517dfd41ab61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#gaf3bc65f19ba61612e0b7517dfd41ab61">R_ADC_OffsetSet</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const reg_id, int32_t offset)</td></tr>
<tr class="separator:gaf3bc65f19ba61612e0b7517dfd41ab61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb2e4cd66d5bd276d05eb5fa104a2037"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#gafb2e4cd66d5bd276d05eb5fa104a2037">R_ADC_Calibrate</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const p_ctrl, void *const p_extend)</td></tr>
<tr class="separator:gafb2e4cd66d5bd276d05eb5fa104a2037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9110aa7c0d36661e561641f522eeb737"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga9110aa7c0d36661e561641f522eeb737">R_ADC_CallbackSet</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const p_api_ctrl, void(*p_callback)(<a class="el" href="group___a_d_c___a_p_i.html#structadc__callback__args__t">adc_callback_args_t</a> *), void const *const p_context, <a class="el" href="group___a_d_c___a_p_i.html#structadc__callback__args__t">adc_callback_args_t</a> *const p_callback_memory)</td></tr>
<tr class="separator:ga9110aa7c0d36661e561641f522eeb737"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the ADC12, ADC14, and ADC16 peripherals on RA MCUs. This module implements the <a class="el" href="group___a_d_c___a_p_i.html">ADC Interface</a>. </p>
<h1><a class="anchor" id="r-adc-overview"></a>
Overview</h1>
<h2><a class="anchor" id="r-adc-features"></a>
Features</h2>
<p>The ADC module supports the following features:</p>
<ul>
<li>12, 14, or 16 bit maximum resolution depending on the MCU</li>
<li>Configure scans to include:<ul>
<li>Multiple analog channels</li>
<li>Temperature sensor channel<a class="anchor" id="um_adc_support_the_on_chip_temperature_sensor"></a></li>
<li>Voltage sensor channel<a class="anchor" id="um_adc_support_the_on_chip_voltage_sensor"></a></li>
</ul>
</li>
<li>Configurable scan start trigger:<ul>
<li>Software scan triggers<a class="anchor" id="um_adc_starting_a_conversion"></a></li>
<li>Hardware scan triggers (timer expiration, for example)</li>
<li>External scan triggers from the ADTRGn port pins</li>
</ul>
</li>
<li>Configurable scan mode:<ul>
<li>Single scan mode, where each trigger starts a single scan</li>
<li>Continuous scan mode, where all channels are scanned continuously</li>
<li>Group scan mode, where channels are grouped into group A and group B. The groups can be assigned different start triggers, and group A can be given priority over group B. When group A has priority over group B, a group A trigger suspends an ongoing group B scan.</li>
</ul>
</li>
<li>Supports adding and averaging converted samples</li>
<li>Optional callback when scan completes<a class="anchor" id="um_adc_interrupt_callback_data"></a><a class="anchor" id="um_adc_support_for_group_mode_scan_completion_interrupts"></a></li>
<li>Supports reading converted data<a class="anchor" id="um_adc_reading_conversion_data"></a></li>
<li>Sample and hold support</li>
<li>Double-trigger support</li>
</ul>
<h1><a class="anchor" id="r-adc-configuration"></a>
Configuration</h1>
<p><a class="anchor" id="um_adc_configure_conversion_data_resolution"></a><a class="anchor" id="um_adc_configure_conversion_data_alignment"></a><a class="anchor" id="um_adc_automatically_clearing_conversion_results"></a><a class="anchor" id="um_adc_hardware_support_for_automatically_adding_converted_data"></a><a class="anchor" id="um_adc_hardware_support_for_automatically_averaging_sampled_data"></a><a class="anchor" id="um_adc_configure_single_scan_mode"></a><a class="anchor" id="um_adc_configure_software_trigger"></a><a class="anchor" id="um_adc_configure_the_hardware_trigger"></a><a class="anchor" id="um_adc_configure_continuous_mode"></a><a class="anchor" id="um_adc_configure_channels_for_group_mode"></a><a class="anchor" id="um_adc_configure_group_scan_mode"></a><a class="anchor" id="um_adc_configuring_sample_and_hold"></a><a class="anchor" id="um_adc_configuring_double_trigger"></a><a class="anchor" id="um_adc_reference_voltage_control"></a> <h2>Build Time Configurations for r_adc</h2>
The following build time configurations are defined in fsp_cfg/r_adc_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
</table>
 <h2>Configurations for Driver &gt; Analog &gt; ADC Driver on r_adc</h2>
This module can be added to the Stacks tab via New Stack &gt; Driver &gt; Analog &gt; ADC Driver on r_adc. Non-secure callable guard functions can be generated for this module by right clicking the module in the RA Configuration tool and checking the "Non-secure Callable" box.<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>General &gt; Name</td><td>Name must be a valid C symbol</td><td>g_adc0 </td><td>Module name </td></tr>
<tr>
<td>General &gt; Unit</td><td>Unit must be a non-negative integer</td><td>0 </td><td>Specifies the ADC Unit to be used. </td></tr>
<tr>
<td>General &gt; Resolution</td><td>MCU Specific Options</td><td></td><td>Specifies the conversion resolution for this unit. </td></tr>
<tr>
<td>General &gt; Alignment</td><td>MCU Specific Options</td><td></td><td>Specifies the conversion result alignment. </td></tr>
<tr>
<td>General &gt; Clear after read</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Off</li>
<li>
On</li>
</ul>
</td><td>On </td><td>Specifies if the result register will be automatically cleared after the conversion result is read. </td></tr>
<tr>
<td>General &gt; Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Single Scan</li>
<li>
Continuous Scan</li>
<li>
Group Scan</li>
</ul>
</td><td>Single Scan </td><td>Specifies the mode that this ADC unit is used in. </td></tr>
<tr>
<td>General &gt; Double-trigger</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
<li>
Enabled (extended mode)</li>
</ul>
</td><td>Disabled </td><td>When enabled, the scan-end interrupt for Group A is only thrown on every second scan. Extended double-trigger mode (single-scan only) triggers on both ELC events, allowing (for example) a scan on two different timer compare match values.<br />
<br />
In group mode Group B is unaffected.<br />
<br />
 </td></tr>
<tr>
<td>Input &gt; Sample and Hold &gt; Sample and Hold Channels (Available only on selected MCUs)</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Channel 0</li>
<li>
Channel 1</li>
<li>
Channel 2</li>
</ul>
</td><td></td><td>Specifies if this channel is included in the Sample and Hold Mask. </td></tr>
<tr>
<td>Input &gt; Sample and Hold &gt; Sample Hold States (Applies only to channels 0, 1, 2)</td><td>Must be a valid non-negative integer with configurable value 4 to 255</td><td>24 </td><td>Specifies the updated sample-and-hold count for the channel dedicated sample-and-hold circuit </td></tr>
<tr>
<td>Input &gt; Channel Scan Mask (channel availability varies by MCU)</td><td>Refer to the RA Configuration tool for available options.</td><td></td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input &gt; Group B Scan Mask (channel availability varies by MCU)</td><td>Refer to the RA Configuration tool for available options.</td><td></td><td>In group mode, this field specifies which channels belong to group B. </td></tr>
<tr>
<td>Input &gt; Add/Average Count</td><td>MCU Specific Options</td><td></td><td>Specifies if addition or averaging needs to be done for any of the channels in this unit. </td></tr>
<tr>
<td>Input &gt; Reference Voltage control</td><td>MCU Specific Options</td><td></td><td>Specify VREFH/VREFADC output voltage control. </td></tr>
<tr>
<td>Input &gt; Addition/Averaging Mask (channel availability varies by MCU and unit)</td><td>Refer to the RA Configuration tool for available options.</td><td></td><td>Select channels to include in the Addition/Averaging Mask </td></tr>
<tr>
<td>Interrupts &gt; Normal/Group A Trigger</td><td>MCU Specific Options</td><td></td><td>Specifies the trigger type to be used for this unit.  </td></tr>
<tr>
<td>Interrupts &gt; Group B Trigger</td><td>MCU Specific Options</td><td></td><td>Specifies the trigger for Group B scanning in group scanning mode. This event is also used to trigger Group A in extended double-trigger mode. </td></tr>
<tr>
<td>Interrupts &gt; Group Priority (Valid only in Group Scan Mode)</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Group A cannot interrupt Group B</li>
<li>
Group A can interrupt Group B; Group B scan restarts at next trigger</li>
<li>
Group A can interrupt Group B; Group B scan restarts immediately</li>
<li>
Group A can interrupt Group B; Group B scan restarts immediately and scans continuously</li>
</ul>
</td><td>Group A cannot interrupt Group B </td><td>Determines whether an ongoing group B scan can be interrupted by a group A trigger, whether it should abort on a group A trigger, or if it should pause to allow group A scan and restart immediately after group A scan is complete. </td></tr>
<tr>
<td>Interrupts &gt; Callback</td><td>Name must be a valid C symbol</td><td>NULL </td><td>A user callback function. If this callback function is provided, it is called from the interrupt service routine (ISR) each time the ADC scan completes. </td></tr>
<tr>
<td>Interrupts &gt; Scan End Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select scan end interrupt priority. </td></tr>
<tr>
<td>Interrupts &gt; Scan End Group B Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select group B scan end interrupt priority. </td></tr>
<tr>
<td>Extra &gt; ADC Ring Buffer</td><td>MCU Specific Options</td><td></td><td>ADC Ring Buffer to be used only with DMAC transfers, keep this property disabled for normal ADC operations. When enabled, ADC converted data is stored in ADBUF registers in place of ADDR registers. The read API will not read from this location for normal ADC operations. </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-adc-clock-configuration"></a>
Clock Configuration</h2>
<p>The ADC clock is PCLKC if the MCU has PCLKC, or PCLKD otherwise.</p>
<p>The clock for this module is derived from the following peripheral clock for each MCU group:<br />
</p><table class="doxtable">
<tr>
<th>MCU Group</th><th>Peripheral Clock </th></tr>
<tr>
<td>RA2A1</td><td>PCLKD</td></tr>
<tr>
<td>RA2E1</td><td>PCLKD</td></tr>
<tr>
<td>RA2L1</td><td>PCLKD</td></tr>
<tr>
<td>RA4M1</td><td>PCLKC</td></tr>
<tr>
<td>RA4M2</td><td>PCLKC</td></tr>
<tr>
<td>RA4M3</td><td>PCLKC</td></tr>
<tr>
<td>RA4W1</td><td>PCLKC</td></tr>
<tr>
<td>RA6M1</td><td>PCLKC</td></tr>
<tr>
<td>RA6M2</td><td>PCLKC</td></tr>
<tr>
<td>RA6M3</td><td>PCLKC</td></tr>
<tr>
<td>RA6M4</td><td>PCLKC</td></tr>
<tr>
<td>RA6M5</td><td>PCLKC</td></tr>
<tr>
<td>RA6T1</td><td>PCLKC</td></tr>
</table>
</p>
<p>The ADC clock must be at least 1 MHz when the ADC is used. Many MCUs also have PCLK ratio restrictions when the ADC is used. For details on PCLK ratio restrictions, reference the footnotes in the second table of the Clock Generation Circuit chapter of the MCU User's Manual (for example, Table 9.2 "Specifications
of the clock generation circuit for the internal clocks" in the RA6M3 manual R01UH0886EJ0100).</p>
<h2><a class="anchor" id="r-adc-pin-configuration"></a>
Pin Configuration</h2>
<p>The ANxxx pins are analog input channels that can be used with the ADC.</p>
<p><a class="anchor" id="um_adc_configure_the_external_trigger"></a>ADTRG0 and ADTRG1 can be used to start scans with an external trigger for unit 0 and 1 respectively. When external triggers are used, ADC scans begin on the falling edge of the ADTRG pin.</p>
<h1><a class="anchor" id="r-adc-usage_notes"></a>
Usage Notes</h1>
<h2>Sample Hold</h2>
<p>Enabling the sample and hold functionality reduces the maximum scan frequency because the sample and hold time is added to each scan. Refer to the hardware manual for details on the sample and hold time.</p>
<h2><a class="anchor" id="adc-hal-module-operational-overview"></a>
ADC Operational Modes</h2>
<p>The driver supports three operation modes: single-scan, continuous-scan, and group-scan modes. In each mode, analog channels are converted in ascending order of channel number, followed by scans of the temperature sensor and voltage sensor if they are included in the mask of channels to scan.</p>
<h3>Single-scan Mode</h3>
<p>In single scan mode, one or more specified channels are scanned once per trigger.</p>
<h3>Continuous-scan Mode</h3>
<p>In continuous scan mode, a single trigger is required to start the scan. Scans continue until <a class="el" href="group___a_d_c.html#ga9b5242c153c6320a564ed9ffd324f144">R_ADC_ScanStop()</a> is called.</p>
<h3>Group-scan Mode</h3>
<p>Group-scan mode allows the application to allocate channels to one of two groups (A and B). Conversion begins when the specified ELC start trigger for that group is received.</p>
<p>With the priority configuration parameter, you can optionally give group A priority over group B. If group A has priority over group B, a group B scan is interrupted when a group A scan trigger occurs. The following options exist for group B when group A has priority:</p>
<ul>
<li><a class="anchor" id="um_adc_configure_group_mode_priority_restart"></a>To restart the interrupted group B scan after the group A scan completes.</li>
<li><a class="anchor" id="um_adc_configure_group_mode_priority_wait"></a>To wait for another group B trigger and forget the interrupted scan.</li>
<li><a class="anchor" id="um_adc_configure_group_mode_priority_continuous"></a>To continuously scan group B and suspend scanning group B only when a group A trigger is received. <dl class="section note"><dt>Note</dt><dd>If this option is selected, group B scanning begins immediately after <a class="el" href="group___a_d_c.html#ga994514574730e0701dc1a6ad41889f88">R_ADC_ScanCfg()</a>. Group A scan triggers must be enabled by <a class="el" href="group___a_d_c.html#ga4a7fb2265b5a03c7586253ff28b3faf2">R_ADC_ScanStart()</a> and can be disabled by <a class="el" href="group___a_d_c.html#ga9b5242c153c6320a564ed9ffd324f144">R_ADC_ScanStop()</a>. Group B scans can only be disabled by reconfiguring the group A priority to a different mode.</dd></dl>
<br />
</li>
</ul>
<h3>Double-triggering</h3>
<p>When double-triggering is enabled a single channel is selected to be scanned twice before an interrupt is thrown. The first scan result when using double-triggering is always saved to the selected channel's data register. The second result is saved to the data duplexing register (<a class="el" href="group___a_d_c___a_p_i.html#ggaafc4060027875f8fe46242b0656d7814a2602b0a06ce1ce485d0812de6f6f4091">ADC_CHANNEL_DUPLEX</a>).</p>
<p>Double-triggering uses Group A; only one channel can be selected when enabled. No other scanning is possible on Group A while double-trigger mode is selected. In addition, any special ADC channels (such as temperature sensors or voltage references) are not valid double-trigger channels.</p>
<p>When extended double-triggering is enabled both ADC input events are routed to Group A. The interrupt is still thrown after every two scans regardless of the triggering event(s). While the first and second scan are saved to the selected ADC data register and the ADC duplexing register as before, scans associated with event A and B are additionally copied into duplexing register A and B, respectively (<a class="el" href="group___a_d_c___a_p_i.html#ggaafc4060027875f8fe46242b0656d7814aadc3763b403f4b9ab667602137a9de57">ADC_CHANNEL_DUPLEX_A</a> and <a class="el" href="group___a_d_c___a_p_i.html#ggaafc4060027875f8fe46242b0656d7814aa66d57680818caebf7be4d68f8c505be">ADC_CHANNEL_DUPLEX_B</a>).</p>
<h3>When Interrupts Are Not Enabled</h3>
<p>If interrupts are not enabled, the R_ADC_StatusGet API can be used to poll the ADC to determine when the scan has completed. The read API function is used to access the converted ADC result. This applies to both normal scans and calibration scans for MCUs that support calibration.</p>
<h2>Sample-State Count Setting</h2>
<p>The application program can modify the setting of the sample-state count for analog channels by calling the <a class="el" href="group___a_d_c.html#gaf0701bf45818dee071cb12e979017bce">R_ADC_SampleStateCountSet()</a> API function. The application program only needs to modify the sample-state count settings from their default values to increase the sampling time. This can be either because the impedance of the input signal is too high to secure sufficient sampling time under the default setting or if the ADCLK is too slow. To modify the sample-state count for a given channel, set the channel number and the number of states when calling the <a class="el" href="group___a_d_c.html#gaf0701bf45818dee071cb12e979017bce">R_ADC_SampleStateCountSet()</a> API function. Valid sample state counts are 7-255.</p>
<dl class="section note"><dt>Note</dt><dd>Although the hardware supports a minimum number of sample states of 5, some MCUs require 7 states, so the minimum is set to 7. At the lowest supported ADC conversion clock rate (1 MHz), these extra states will lead to, at worst case, a 2 microsecond increase in conversion time. At 60 MHz the extra states will add 33.4 ns to the conversion time.</dd></dl>
<p>If the sample state count needs to be changed for multiple channels, the application program must call the <a class="el" href="group___a_d_c.html#gaf0701bf45818dee071cb12e979017bce">R_ADC_SampleStateCountSet()</a> API function repeatedly, with appropriately modified arguments for each channel.</p>
<p>If the ADCLK frequency changes, the sample states may need to be updated.</p>
<h3>Sample States for Temperature Sensor and Internal Voltage Reference</h3>
<p>Sample states for the temperature sensor and the internal reference voltage are calculated during <a class="el" href="group___a_d_c.html#ga994514574730e0701dc1a6ad41889f88">R_ADC_ScanCfg()</a> based on the ADCLK frequency at the time. The sample states for the temperature sensor and internal voltage reference cannot be updated with <a class="el" href="group___a_d_c.html#gaf0701bf45818dee071cb12e979017bce">R_ADC_SampleStateCountSet()</a>. If the ADCLK frequency changes, call <a class="el" href="group___a_d_c.html#ga994514574730e0701dc1a6ad41889f88">R_ADC_ScanCfg()</a> before using the temperature sensor or internal reference voltage again to ensure the sampling time for the temperature sensor and internal voltage reference is optimal.</p>
<h3>Selecting Reference Voltage</h3>
<p>The ADC16 can select VREFH0 or VREFADC as the high-potential reference voltage on selected MCU's. When using VREFADC stabilization time of 1500us is required after call for <a class="el" href="group___a_d_c.html#gade895e0810cecb3be6a9e5217f5c78ac">R_ADC_Open()</a>.</p>
<h2>Using the Temperature Sensor with the ADC</h2>
<p>The ADC HAL module supports reading the data from the on-chip temperature sensor. The value returned from the sensor can be converted into degrees Celsius or Fahrenheit in the application program using the following formula, T = (Vs - V1)/slope + T1, where:</p>
<ul>
<li>T: Measured temperature (degrees C)</li>
<li>Vs: Voltage output by the temperature sensor at the time of temperature measurement (Volts)</li>
<li>T1: Temperature experimentally measured at one point (degrees C)</li>
<li>V1: Voltage output by the temperature sensor at the time of measurement of T1 (Volts)</li>
<li>T2: Temperature at the experimental measurement of another point (degrees C)</li>
<li>V2: Voltage output by the temperature sensor at the time of measurement of T2 (Volts)</li>
<li>Slope: Temperature gradient of the temperature sensor (V/degrees C); slope = (V2 - V1)/ (T2 - T1)</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The slope value can be obtained from the hardware manual for each device in the Electrical Characteristics Chapter - TSN Characteristics Table, Temperature slope entry.</dd></dl>
<h2>Reading CTSU TSCAP with ADC</h2>
<p>Some MCUs support reading CTSU TSCAP with ADC. CTSU TSCAP is connected to ADC0 channel 16. Use existing enums for channel 16 to set sample states for the sensor connected to CTSU TSCAP, enable scanning of CTSU TSCAP, and read results for CTSU TSCAP.</p>
<h2>Usage Notes for ADC16</h2>
<h3>Calibration</h3>
<p>Calibration is required to use the ADC16 peripheral. When using this driver on an MCU that has ADC16, call <a class="el" href="group___a_d_c.html#gafb2e4cd66d5bd276d05eb5fa104a2037">R_ADC_Calibrate()</a> after open, and prior to any other function.</p>
<h3>Range of ADC16 Results</h3>
<p>The range of the ADC16 is from 0 (lowest) to 0x7FFF (highest) when used in single-ended mode. This driver only supports single ended mode.</p>
<h1><a class="anchor" id="r-adc-examples"></a>
Examples</h1>
<h2>Basic Example</h2>
<p>This is a basic example of minimal use of the ADC in an application.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">/* A channel configuration is generated by the RA Configuration editor based on the options selected.  If additional</span></div><div class="line"><span class="comment"> * configurations are desired additional adc_channel_cfg_t elements can be defined and passed to R_ADC_ScanCfg. */</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="group___a_d_c.html#structadc__channel__cfg__t">adc_channel_cfg_t</a> g_adc0_channel_cfg =</div><div class="line">{</div><div class="line">    .<a class="code" href="group___a_d_c.html#a706f698d4cd3a57b1e04503c143003dc">scan_mask</a>          = <a class="code" href="group___a_d_c.html#ggada437c4b88ed24eb8b9c94c0b45d76eaac501dac2fb65d1f922a6177d149b56bd">ADC_MASK_CHANNEL_0</a> | <a class="code" href="group___a_d_c.html#ggada437c4b88ed24eb8b9c94c0b45d76eaaee05b1448c74da666ef0ed4bf1bbfb8e">ADC_MASK_CHANNEL_1</a>,</div><div class="line">    .scan_mask_group_b  = 0,</div><div class="line">    .priority_group_a   = (<a class="code" href="group___a_d_c.html#ga79014196d08d86b161b77892bf26b100">adc_group_a_t</a>) 0,</div><div class="line">    .add_mask           = 0,</div><div class="line">    .sample_hold_mask   = 0,</div><div class="line">    .sample_hold_states = 0,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> adc_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___a_d_c.html#gade895e0810cecb3be6a9e5217f5c78ac">R_ADC_Open</a>(&amp;g_adc0_ctrl, &amp;g_adc0_cfg);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Enable channels. */</span></div><div class="line">    err = <a class="code" href="group___a_d_c.html#ga994514574730e0701dc1a6ad41889f88">R_ADC_ScanCfg</a>(&amp;g_adc0_ctrl, &amp;g_adc0_channel_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* In software trigger mode, start a scan by calling R_ADC_ScanStart(). In other modes, enable external</span></div><div class="line"><span class="comment">     * triggers by calling R_ADC_ScanStart(). */</span></div><div class="line">    (void) <a class="code" href="group___a_d_c.html#ga4a7fb2265b5a03c7586253ff28b3faf2">R_ADC_ScanStart</a>(&amp;g_adc0_ctrl);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Wait for conversion to complete. */</span></div><div class="line">    <a class="code" href="group___a_d_c___a_p_i.html#structadc__status__t">adc_status_t</a> status;</div><div class="line">    status.<a class="code" href="group___a_d_c___a_p_i.html#a276869569116678c7838ef506fceb77b">state</a> = <a class="code" href="group___a_d_c___a_p_i.html#gga2783ab2e29809bf0a50bc66c6fa8d3c6abe1c11b191e48669cc5129aca45800d7">ADC_STATE_SCAN_IN_PROGRESS</a>;</div><div class="line">    <span class="keywordflow">while</span> (<a class="code" href="group___a_d_c___a_p_i.html#gga2783ab2e29809bf0a50bc66c6fa8d3c6abe1c11b191e48669cc5129aca45800d7">ADC_STATE_SCAN_IN_PROGRESS</a> == status.<a class="code" href="group___a_d_c___a_p_i.html#a276869569116678c7838ef506fceb77b">state</a>)</div><div class="line">    {</div><div class="line">        (void) <a class="code" href="group___a_d_c.html#ga676b1c7f1ccceda288cbb2ad79a14ff2">R_ADC_StatusGet</a>(&amp;g_adc0_ctrl, &amp;status);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Read converted data. */</span></div><div class="line">    uint16_t channel1_conversion_result;</div><div class="line">    err = <a class="code" href="group___a_d_c.html#gad6bfc8395b53a96ee89f266fc940e2da">R_ADC_Read</a>(&amp;g_adc0_ctrl, <a class="code" href="group___a_d_c___a_p_i.html#ggaafc4060027875f8fe46242b0656d7814a203b48944d019f4fda969a6fc2a9e492">ADC_CHANNEL_1</a>, &amp;channel1_conversion_result);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Temperature Sensor Example</h2>
<p>This example shows how to calculate the MCU temperature using the ADC and the temperature sensor.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define ADC_EXAMPLE_CALIBRATION_DATA_RA6M1               (0x7D5)</span></div><div class="line"><span class="preprocessor">#define ADC_EXAMPLE_VCC_MICROVOLT                        (3300000)</span></div><div class="line"><span class="preprocessor">#define ADC_EXAMPLE_TEMPERATURE_RESOLUTION               (12U)</span></div><div class="line"><span class="preprocessor">#define ADC_EXAMPLE_REFERENCE_CALIBRATION_TEMPERATURE    (127)</span></div><div class="line"><span class="keywordtype">void</span> adc_temperature_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* The following example calculates the temperature on an RA6M1 device using the data provided in the section</span></div><div class="line"><span class="comment">     * 44.3.1 &quot;Preparation for Using the Temperature Sensor&quot; of the RA6M1 manual R01UH0884EJ0100. */</span></div><div class="line"></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___a_d_c.html#gade895e0810cecb3be6a9e5217f5c78ac">R_ADC_Open</a>(&amp;g_adc0_ctrl, &amp;g_adc0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable temperature sensor. */</span></div><div class="line">    err = <a class="code" href="group___a_d_c.html#ga994514574730e0701dc1a6ad41889f88">R_ADC_ScanCfg</a>(&amp;g_adc0_ctrl, &amp;g_adc0_channel_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* In software trigger mode, start a scan by calling R_ADC_ScanStart(). In other modes, enable external</span></div><div class="line"><span class="comment">     * triggers by calling R_ADC_ScanStart(). */</span></div><div class="line">    (void) <a class="code" href="group___a_d_c.html#ga4a7fb2265b5a03c7586253ff28b3faf2">R_ADC_ScanStart</a>(&amp;g_adc0_ctrl);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for conversion to complete. */</span></div><div class="line">    <a class="code" href="group___a_d_c___a_p_i.html#structadc__status__t">adc_status_t</a> status;</div><div class="line">    status.<a class="code" href="group___a_d_c___a_p_i.html#a276869569116678c7838ef506fceb77b">state</a> = <a class="code" href="group___a_d_c___a_p_i.html#gga2783ab2e29809bf0a50bc66c6fa8d3c6abe1c11b191e48669cc5129aca45800d7">ADC_STATE_SCAN_IN_PROGRESS</a>;</div><div class="line">    <span class="keywordflow">while</span> (<a class="code" href="group___a_d_c___a_p_i.html#gga2783ab2e29809bf0a50bc66c6fa8d3c6abe1c11b191e48669cc5129aca45800d7">ADC_STATE_SCAN_IN_PROGRESS</a> == status.<a class="code" href="group___a_d_c___a_p_i.html#a276869569116678c7838ef506fceb77b">state</a>)</div><div class="line">    {</div><div class="line">        (void) <a class="code" href="group___a_d_c.html#ga676b1c7f1ccceda288cbb2ad79a14ff2">R_ADC_StatusGet</a>(&amp;g_adc0_ctrl, &amp;status);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Read converted data. */</span></div><div class="line">    uint16_t temperature_conversion_result;</div><div class="line">    err = <a class="code" href="group___a_d_c.html#gad6bfc8395b53a96ee89f266fc940e2da">R_ADC_Read</a>(&amp;g_adc0_ctrl, <a class="code" href="group___a_d_c___a_p_i.html#ggaafc4060027875f8fe46242b0656d7814aff4cf0b5a9bfd1fc634f6b097e34fe73">ADC_CHANNEL_TEMPERATURE</a>, &amp;temperature_conversion_result);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* If the MCU does not provide calibration data, use the value in the hardware manual or determine it</span></div><div class="line"><span class="comment">     * experimentally. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Get Calibration data from the MCU if available. */</span></div><div class="line">    int32_t    reference_calibration_data;</div><div class="line">    <a class="code" href="group___a_d_c___a_p_i.html#structadc__info__t">adc_info_t</a> adc_info;</div><div class="line">    (void) <a class="code" href="group___a_d_c.html#ga1cc44d84e1dd1cad8fdafe1e91a3b6d0">R_ADC_InfoGet</a>(&amp;g_adc0_ctrl, &amp;adc_info);</div><div class="line">    reference_calibration_data = (int32_t) adc_info.<a class="code" href="group___a_d_c___a_p_i.html#a5869042d58165926402aa499eefb68f2">calibration_data</a>;</div><div class="line"></div><div class="line">    <span class="comment">/* NOTE: The slope of the temperature sensor varies from sensor to sensor. Renesas recommends calculating</span></div><div class="line"><span class="comment">     * the slope of the temperature sensor experimentally.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * This example uses the typical slope provided in Table 52.38  &quot;TSN characteristics&quot; in the RA6M1 manual</span></div><div class="line"><span class="comment">     * R01UM0011EU0050. */</span></div><div class="line">    int32_t slope_uv_per_c = BSP_FEATURE_ADC_TSN_SLOPE;</div><div class="line"></div><div class="line">    <span class="comment">/* Formula for calculating temperature copied from section 44.3.1 &quot;Preparation for Using the Temperature Sensor&quot;</span></div><div class="line"><span class="comment">     * of the RA6M1 manual R01UH0884EJ0100:</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * In this MCU, the TSCDR register stores the temperature value (CAL127) of the temperature sensor measured</span></div><div class="line"><span class="comment">     * under the condition Ta = Tj = 127 C and AVCC0 = 3.3 V. By using this value as the sample measurement result</span></div><div class="line"><span class="comment">     * at the first point, preparation before using the temperature sensor can be omitted.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * If V1 is calculated from CAL127,</span></div><div class="line"><span class="comment">     * V1 = 3.3 * CAL127 / 4096 [V]</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * Using this, the measured temperature can be calculated according to the following formula.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * T = (Vs - V1) / Slope + 127 [C]</span></div><div class="line"><span class="comment">     * T: Measured temperature (C)</span></div><div class="line"><span class="comment">     * Vs: Voltage output by the temperature sensor when the temperature is measured (V)</span></div><div class="line"><span class="comment">     * V1: Voltage output by the temperature sensor when Ta = Tj = 127 C and AVCC0 = 3.3 V (V)</span></div><div class="line"><span class="comment">     * Slope: Temperature slope given in Table 52.38 / 1000 (V/C)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    int32_t v1_uv = (ADC_EXAMPLE_VCC_MICROVOLT &gt;&gt; ADC_EXAMPLE_TEMPERATURE_RESOLUTION) *</div><div class="line">                    reference_calibration_data;</div><div class="line">    int32_t vs_uv = (ADC_EXAMPLE_VCC_MICROVOLT &gt;&gt; ADC_EXAMPLE_TEMPERATURE_RESOLUTION) *</div><div class="line">                    temperature_conversion_result;</div><div class="line">    int32_t temperature_c = (vs_uv - v1_uv) / slope_uv_per_c + ADC_EXAMPLE_REFERENCE_CALIBRATION_TEMPERATURE;</div><div class="line"></div><div class="line">    <span class="comment">/* Expect room temperature, break if temperature is outside the range of 20 C to 25 C. */</span></div><div class="line">    <span class="keywordflow">if</span> ((temperature_c &lt; 20) || (temperature_c &gt; 25))</div><div class="line">    {</div><div class="line">        __BKPT(0);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Double-Trigger Example</h2>
<p>This example demonstrates reading data from a double-trigger scan. A flag is used to wait for a callback event. Two scans must occur before the callback is called. These results are read via <a class="el" href="group___a_d_c.html#gad6bfc8395b53a96ee89f266fc940e2da">R_ADC_Read</a> using the selected channel enum value as well as <a class="el" href="group___a_d_c___a_p_i.html#ggaafc4060027875f8fe46242b0656d7814a2602b0a06ce1ce485d0812de6f6f4091">ADC_CHANNEL_DUPLEX</a>.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keyword">volatile</span> <span class="keywordtype">bool</span> scan_complete_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> adc_callback (<a class="code" href="group___a_d_c___a_p_i.html#structadc__callback__args__t">adc_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gaf0afcbc9a110ac9366a811d96ee06029">FSP_PARAMETER_NOT_USED</a>(p_args);</div><div class="line"></div><div class="line">    scan_complete_flag = <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> adc_double_trigger_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the module. */</span></div><div class="line">    err = <a class="code" href="group___a_d_c.html#gade895e0810cecb3be6a9e5217f5c78ac">R_ADC_Open</a>(&amp;g_adc0_ctrl, &amp;g_adc0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable double-trigger channel. */</span></div><div class="line">    err = <a class="code" href="group___a_d_c.html#ga994514574730e0701dc1a6ad41889f88">R_ADC_ScanCfg</a>(&amp;g_adc0_ctrl, &amp;g_adc0_channel_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable scan triggering from ELC events. */</span></div><div class="line">    (void) <a class="code" href="group___a_d_c.html#ga4a7fb2265b5a03c7586253ff28b3faf2">R_ADC_ScanStart</a>(&amp;g_adc0_ctrl);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for conversion to complete. Two scans must be triggered before a callback occurs. */</span></div><div class="line">    scan_complete_flag = <span class="keyword">false</span>;</div><div class="line">    <span class="keywordflow">while</span> (!scan_complete_flag)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait for callback to set flag. */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Read converted data from both scans. */</span></div><div class="line">    uint16_t channel1_conversion_result_0;</div><div class="line">    uint16_t channel1_conversion_result_1;</div><div class="line">    err = <a class="code" href="group___a_d_c.html#gad6bfc8395b53a96ee89f266fc940e2da">R_ADC_Read</a>(&amp;g_adc0_ctrl, <a class="code" href="group___a_d_c___a_p_i.html#ggaafc4060027875f8fe46242b0656d7814a203b48944d019f4fda969a6fc2a9e492">ADC_CHANNEL_1</a>, &amp;channel1_conversion_result_0);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">    err = <a class="code" href="group___a_d_c.html#gad6bfc8395b53a96ee89f266fc940e2da">R_ADC_Read</a>(&amp;g_adc0_ctrl, <a class="code" href="group___a_d_c___a_p_i.html#ggaafc4060027875f8fe46242b0656d7814a2602b0a06ce1ce485d0812de6f6f4091">ADC_CHANNEL_DUPLEX</a>, &amp;channel1_conversion_result_1);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>ADC-DMAC Repeat-Block Transfer Example</h2>
<p>This example demonstrates writing multiple data from DAC peripheral to ADC channels and storing the data in memory through DMAC using Repeat-Block Transfer mode. It creates single block to multiple ring buffer type of transfer topology. Ping-Pong mechanism is used to read the data from memory in between the transfers. This example is valid only for MCUs that have ADBUF.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor"> #define ADC_DMAC_EXAMPLE_DATA_LOW                  (0U)</span></div><div class="line"><span class="preprocessor"> #define ADC_DMAC_EXAMPLE_DATA_HIGH                 (0x000FU)</span></div><div class="line"><span class="preprocessor"> #define ADC_DMAC_EXAMPLE_DELAY_1000_MS             (1000U)</span></div><div class="line"></div><div class="line"><span class="preprocessor"> #define ADC_DMAC_EXAMPLE_NUM_PING_PONG_BUFFERS     (2)</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> uint16_t g_adc_dmac_example_buffer[ADC_DMAC_EXAMPLE_NUM_PING_PONG_BUFFERS][</div><div class="line">    ADC_DMAC_EXAMPLE_ADC_CHANNELS_PER_BLOCK][ADC_DMAC_EXAMPLE_SAMPLES_PER_CHANNEL]; <span class="comment">// Destination buffer for DMAC transfers</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> uint16_t g_adc_dmac_example_ping_pong_index = 0U;</div><div class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keywordtype">void</span>   * gp_read_data;</div><div class="line"></div><div class="line"><span class="comment">/* DMAC callback */</span></div><div class="line"><span class="keywordtype">void</span> adc_dmac_callback (<a class="code" href="group___d_m_a_c.html#structdmac__callback__args__t">dmac_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    (void) p_args;</div><div class="line"></div><div class="line">    <span class="comment">/* Store the pointer to the last buffer that was written</span></div><div class="line"><span class="comment">     * An array of data for the first enabled channel is at &amp;g_adc_dmac_example_buffer[g_adc_dmac_example_ping_pong_index][0][0],</span></div><div class="line"><span class="comment">     * an array of data for the next channel is at &amp;g_adc_dmac_example_buffer[g_adc_dmac_example_ping_pong_index][1][0], etc.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    gp_read_data = &amp;g_adc_dmac_example_buffer[g_adc_dmac_example_ping_pong_index][0][0];</div><div class="line"></div><div class="line">    <span class="comment">/* Select the other ping-pong buffer which is free for writing */</span></div><div class="line">    g_adc_dmac_example_ping_pong_index = !g_adc_dmac_example_ping_pong_index;</div><div class="line"></div><div class="line">    <span class="comment">/* Reset the destination pointer and DMAC peripheral */</span></div><div class="line">    <a class="code" href="group___d_m_a_c.html#gaac8f15eacf61325ad50ca0778cfc7ffd">R_DMAC_Reset</a>(&amp;g_transfer0_ctrl,</div><div class="line">                 NULL,</div><div class="line">                 (<span class="keywordtype">void</span> *) &amp;g_adc_dmac_example_buffer[g_adc_dmac_example_ping_pong_index][0][0],</div><div class="line">                 ADC_DMAC_EXAMPLE_SAMPLES_PER_CHANNEL);</div><div class="line"></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gaf0afcbc9a110ac9366a811d96ee06029">FSP_PARAMETER_NOT_USED</a>(gp_read_data);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> adc_dmac_repeat_block_transfer_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Open ADC Module and configure the channels */</span></div><div class="line">    <span class="comment">/* Enable the ADBUF property from configurations */</span></div><div class="line">    err = <a class="code" href="group___a_d_c.html#gade895e0810cecb3be6a9e5217f5c78ac">R_ADC_Open</a>(&amp;g_adc0_ctrl, &amp;g_adc0_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">    err = <a class="code" href="group___a_d_c.html#ga994514574730e0701dc1a6ad41889f88">R_ADC_ScanCfg</a>(&amp;g_adc0_ctrl, &amp;g_adc0_channel_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Open DMAC channel for repeat-block transfer with following configurations</span></div><div class="line"><span class="comment">     * (1) Destination address as &amp;g_adc_dmac_example_buffer[g_adc_dmac_example_ping_pong_index][0][0]</span></div><div class="line"><span class="comment">     * (2) Enable end of transfer interrupt</span></div><div class="line"><span class="comment">     * (3) Configure source address mode as incremented and destination address mode as offset addition,</span></div><div class="line"><span class="comment">     *     fixed to address of ADBUF register by configurator with ADC-DMAC module</span></div><div class="line"><span class="comment">     * (4) Configure source buffer size as total size of source buffer - Refer RA6M4 Hardware Manual R01UH0890EJ0110,</span></div><div class="line"><span class="comment">     *     section 16.2.15 for source buffer size limitations</span></div><div class="line"><span class="comment">     * (5) Configure transfer mode as Repeat-Block mode</span></div><div class="line"><span class="comment">     * (6) Refer RA6M4 Hardware Manual R01UH0890EJ0110,</span></div><div class="line"><span class="comment">     *     section 16.2.16 for total number of blocks which decides destination buffer size</span></div><div class="line"><span class="comment">     * (7) Number of blocks is determined by the samples per channel property for ADC-DMAC module</span></div><div class="line"><span class="comment">     * (8) Size of block is determined using the enabled ADC channels in the configurator when using ADC-DMAC-module</span></div><div class="line"><span class="comment">     * (9) Configure DMAC activation source as A/D scan end interrupt</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    err = <a class="code" href="group___d_m_a_c.html#ga448a013ad5b91097e45833313d5df354">R_DMAC_Open</a>(&amp;g_transfer0_ctrl, &amp;g_transfer0_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">    err = <a class="code" href="group___d_m_a_c.html#gaf72221183919d50cbd8ee1ca528aa20b">R_DMAC_Enable</a>(&amp;g_transfer0_ctrl);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    uint16_t     count = ADC_DMAC_EXAMPLE_DATA_LOW;</div><div class="line">    <a class="code" href="group___a_d_c___a_p_i.html#structadc__status__t">adc_status_t</a> adc_status;</div><div class="line"></div><div class="line">    <span class="comment">/* Trigger the ADC scan for &quot;count&quot; times, this can be replaced by triggering the ADC using a timer */</span></div><div class="line">    <span class="keywordflow">while</span> (count &lt;= (uint16_t) ADC_DMAC_EXAMPLE_DATA_HIGH)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Scan the data with ADC channels*/</span></div><div class="line">        err = <a class="code" href="group___a_d_c.html#ga4a7fb2265b5a03c7586253ff28b3faf2">R_ADC_ScanStart</a>(&amp;g_adc0_ctrl);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">        <span class="comment">/* Wait for conversion to complete */</span></div><div class="line">        uint16_t timeout = UINT16_MAX;</div><div class="line">        adc_status.<a class="code" href="group___a_d_c___a_p_i.html#a276869569116678c7838ef506fceb77b">state</a> = <a class="code" href="group___a_d_c___a_p_i.html#gga2783ab2e29809bf0a50bc66c6fa8d3c6abe1c11b191e48669cc5129aca45800d7">ADC_STATE_SCAN_IN_PROGRESS</a>;</div><div class="line">        <span class="keywordflow">while</span> ((<a class="code" href="group___a_d_c___a_p_i.html#gga2783ab2e29809bf0a50bc66c6fa8d3c6abe1c11b191e48669cc5129aca45800d7">ADC_STATE_SCAN_IN_PROGRESS</a> == adc_status.<a class="code" href="group___a_d_c___a_p_i.html#a276869569116678c7838ef506fceb77b">state</a>) &amp;&amp; (timeout &gt; 0U))</div><div class="line">        {</div><div class="line">            timeout--;</div><div class="line">            <a class="code" href="group___a_d_c.html#ga676b1c7f1ccceda288cbb2ad79a14ff2">R_ADC_StatusGet</a>(&amp;g_adc0_ctrl, &amp;adc_status);</div><div class="line">        }</div><div class="line"></div><div class="line">        <a class="code" href="group___b_s_p___m_c_u.html#gaf3219448adfd1531cf69f68697ab184b">R_BSP_SoftwareDelay</a>(ADC_DMAC_EXAMPLE_DELAY_1000_MS, <a class="code" href="group___b_s_p___m_c_u.html#ggafd98e2a6f080d6a52a3ef72e3d731b2baa0312618f2508347a9a815b5887c12ae">BSP_DELAY_UNITS_MICROSECONDS</a>);</div><div class="line"></div><div class="line">        count++;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structadc__sample__state__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#structadc__sample__state__t">adc_sample_state_t</a></td></tr>
<tr class="separator:structadc__sample__state__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structadc__extended__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#structadc__extended__cfg__t">adc_extended_cfg_t</a></td></tr>
<tr class="separator:structadc__extended__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structadc__channel__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#structadc__channel__cfg__t">adc_channel_cfg_t</a></td></tr>
<tr class="separator:structadc__channel__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structadc__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#structadc__instance__ctrl__t">adc_instance_ctrl_t</a></td></tr>
<tr class="separator:structadc__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gada437c4b88ed24eb8b9c94c0b45d76ea"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#gada437c4b88ed24eb8b9c94c0b45d76ea">adc_mask_t</a> </td></tr>
<tr class="separator:gada437c4b88ed24eb8b9c94c0b45d76ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9ce774d7384e84ac724f5a1c6ca0d21"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#gae9ce774d7384e84ac724f5a1c6ca0d21">adc_add_t</a> </td></tr>
<tr class="separator:gae9ce774d7384e84ac724f5a1c6ca0d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ddc074052e3b84fcc2defed431fe022"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga9ddc074052e3b84fcc2defed431fe022">adc_clear_t</a> </td></tr>
<tr class="separator:ga9ddc074052e3b84fcc2defed431fe022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03d10a44658a1383520ca2d9c3928eb9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga03d10a44658a1383520ca2d9c3928eb9">adc_vref_control_t</a> </td></tr>
<tr class="separator:ga03d10a44658a1383520ca2d9c3928eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2817e17c728f9a2b041b54fd92244c3b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga2817e17c728f9a2b041b54fd92244c3b">adc_sample_state_reg_t</a> </td></tr>
<tr class="separator:ga2817e17c728f9a2b041b54fd92244c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79014196d08d86b161b77892bf26b100"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga79014196d08d86b161b77892bf26b100">adc_group_a_t</a> </td></tr>
<tr class="separator:ga79014196d08d86b161b77892bf26b100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga802c536966b5905a58039e347c5dbbc5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga802c536966b5905a58039e347c5dbbc5">adc_double_trigger_t</a> </td></tr>
<tr class="separator:ga802c536966b5905a58039e347c5dbbc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structadc__sample__state__t" id="structadc__sample__state__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structadc__sample__state__t">&#9670;&nbsp;</a></span>adc_sample_state_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct adc_sample_state_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>ADC sample state configuration </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a369eb3d0d52d0b68bcd36f3b0dbdeaef"></a><a class="el" href="group___a_d_c.html#ga2817e17c728f9a2b041b54fd92244c3b">adc_sample_state_reg_t</a></td>
<td class="fieldname">
reg_id</td>
<td class="fielddoc">
Sample state register ID. </td></tr>
<tr><td class="fieldtype">
<a id="aedbb76489ecc68110ccf3ede6f02fce9"></a>uint8_t</td>
<td class="fieldname">
num_states</td>
<td class="fielddoc">
Number of sampling states for conversion. Ch16-20/21 use the same value. </td></tr>
</table>

</div>
</div>
<a name="structadc__extended__cfg__t" id="structadc__extended__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structadc__extended__cfg__t">&#9670;&nbsp;</a></span>adc_extended_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct adc_extended_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Extended configuration structure for ADC. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a44fb36e649b135f9803548a488f6684d"></a><a class="el" href="group___a_d_c.html#gae9ce774d7384e84ac724f5a1c6ca0d21">adc_add_t</a></td>
<td class="fieldname">
add_average_count</td>
<td class="fielddoc">
Add or average samples. </td></tr>
<tr><td class="fieldtype">
<a id="a3ea48b1c97df4f5169bdfe5af3911396"></a><a class="el" href="group___a_d_c.html#ga9ddc074052e3b84fcc2defed431fe022">adc_clear_t</a></td>
<td class="fieldname">
clearing</td>
<td class="fielddoc">
Clear after read. </td></tr>
<tr><td class="fieldtype">
<a id="ae8c077fe7cbf5c28f605ed84f68dca9b"></a><a class="el" href="group___a_d_c___a_p_i.html#ga1ac380ffe2ebef256338616747d330e3">adc_trigger_t</a></td>
<td class="fieldname">
trigger_group_b</td>
<td class="fielddoc">
Group B trigger source; valid only for group mode. </td></tr>
<tr><td class="fieldtype">
<a id="ad2be3785d3a8153d8ec71123583450b9"></a><a class="el" href="group___a_d_c.html#ga802c536966b5905a58039e347c5dbbc5">adc_double_trigger_t</a></td>
<td class="fieldname">
double_trigger_mode</td>
<td class="fielddoc">
Double-trigger mode setting. </td></tr>
<tr><td class="fieldtype">
<a id="a4bc9f429e6477b2f8f526f670325030c"></a><a class="el" href="group___a_d_c.html#ga03d10a44658a1383520ca2d9c3928eb9">adc_vref_control_t</a></td>
<td class="fieldname">
adc_vref_control</td>
<td class="fielddoc">
VREFADC output voltage control. </td></tr>
<tr><td class="fieldtype">
<a id="a4f9198f9cd87c8abaaec94946fda33bc"></a>uint8_t</td>
<td class="fieldname">
enable_adbuf</td>
<td class="fielddoc">
Enable ADC Ring Buffer, Valid only to use along with DMAC transfer. </td></tr>
</table>

</div>
</div>
<a name="structadc__channel__cfg__t" id="structadc__channel__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structadc__channel__cfg__t">&#9670;&nbsp;</a></span>adc_channel_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct adc_channel_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>ADC channel(s) configuration </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a706f698d4cd3a57b1e04503c143003dc"></a>uint32_t</td>
<td class="fieldname">
scan_mask</td>
<td class="fielddoc">
Channels/bits: bit 0 is ch0; bit 15 is ch15. </td></tr>
<tr><td class="fieldtype">
<a id="aa1cf641bc6b225b233baa1c11ee7d4b5"></a>uint32_t</td>
<td class="fieldname">
scan_mask_group_b</td>
<td class="fielddoc">
Valid for group modes. </td></tr>
<tr><td class="fieldtype">
<a id="a81489e3b2a0f142e6e902065e82dfe81"></a>uint32_t</td>
<td class="fieldname">
add_mask</td>
<td class="fielddoc">
Valid if add enabled in Open(). </td></tr>
<tr><td class="fieldtype">
<a id="aef59542e008313144646bd057d840c8a"></a><a class="el" href="group___a_d_c.html#ga79014196d08d86b161b77892bf26b100">adc_group_a_t</a></td>
<td class="fieldname">
priority_group_a</td>
<td class="fielddoc">
Valid for group modes. </td></tr>
<tr><td class="fieldtype">
<a id="a2963c15f5fd0b6c358926e22f67eb740"></a>uint8_t</td>
<td class="fieldname">
sample_hold_mask</td>
<td class="fielddoc">
Channels/bits 0-2. </td></tr>
<tr><td class="fieldtype">
<a id="a91b488601bfb54ef0cf793c2ea44a001"></a>uint8_t</td>
<td class="fieldname">
sample_hold_states</td>
<td class="fielddoc">
Number of states to be used for sample and hold. Affects channels 0-2. </td></tr>
</table>

</div>
</div>
<a name="structadc__instance__ctrl__t" id="structadc__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structadc__instance__ctrl__t">&#9670;&nbsp;</a></span>adc_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct adc_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>ADC instance control block. DO NOT INITIALIZE. Initialized in <a class="el" href="group___a_d_c___a_p_i.html#afa184c06541e3fd9f90fc12ed775f468">adc_api_t::open()</a>. </p>
</div>
</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gada437c4b88ed24eb8b9c94c0b45d76ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada437c4b88ed24eb8b9c94c0b45d76ea">&#9670;&nbsp;</a></span>adc_mask_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c.html#gada437c4b88ed24eb8b9c94c0b45d76ea">adc_mask_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For ADC Scan configuration <a class="el" href="group___a_d_c.html#a706f698d4cd3a57b1e04503c143003dc" title="Channels/bits: bit 0 is ch0; bit 15 is ch15. ">adc_channel_cfg_t::scan_mask</a>, <a class="el" href="group___a_d_c.html#aa1cf641bc6b225b233baa1c11ee7d4b5" title="Valid for group modes. ">adc_channel_cfg_t::scan_mask_group_b</a>, <a class="el" href="group___a_d_c.html#a81489e3b2a0f142e6e902065e82dfe81" title="Valid if add enabled in Open(). ">adc_channel_cfg_t::add_mask</a> and <a class="el" href="group___a_d_c.html#a2963c15f5fd0b6c358926e22f67eb740" title="Channels/bits 0-2. ">adc_channel_cfg_t::sample_hold_mask</a>. Use bitwise OR to combine these masks for desired channels and sensors. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaa1a520b21e25b15e8771e66ec30e821c0"></a>ADC_MASK_OFF&#160;</td><td class="fielddoc"><p>No channels selected. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaac501dac2fb65d1f922a6177d149b56bd"></a>ADC_MASK_CHANNEL_0&#160;</td><td class="fielddoc"><p>Channel 0 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaaee05b1448c74da666ef0ed4bf1bbfb8e"></a>ADC_MASK_CHANNEL_1&#160;</td><td class="fielddoc"><p>Channel 1 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaaf6ed6dc12b9f00816248fab86defd438"></a>ADC_MASK_CHANNEL_2&#160;</td><td class="fielddoc"><p>Channel 2 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaac6b4aff675dec9cadaae4199ed4ff1ce"></a>ADC_MASK_CHANNEL_3&#160;</td><td class="fielddoc"><p>Channel 3 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaa31384e0aedc6d3bb72bb337bc3a26926"></a>ADC_MASK_CHANNEL_4&#160;</td><td class="fielddoc"><p>Channel 4 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaa37244da83766b5339012612cb94c24a1"></a>ADC_MASK_CHANNEL_5&#160;</td><td class="fielddoc"><p>Channel 5 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaa2d0d20c8b71625964503f427e34c087f"></a>ADC_MASK_CHANNEL_6&#160;</td><td class="fielddoc"><p>Channel 6 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaac4230924f979ea41f84bb7b1b5923aa8"></a>ADC_MASK_CHANNEL_7&#160;</td><td class="fielddoc"><p>Channel 7 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaabc48f28b2cd64aa57646414fccfcf20d"></a>ADC_MASK_CHANNEL_8&#160;</td><td class="fielddoc"><p>Channel 8 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaa4abb79c0220229121fc0191df18b1489"></a>ADC_MASK_CHANNEL_9&#160;</td><td class="fielddoc"><p>Channel 9 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaabe5718054829cb20152408348c39e6ad"></a>ADC_MASK_CHANNEL_10&#160;</td><td class="fielddoc"><p>Channel 10 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaa1aae5dbbbb242e4fb8152e05944964ff"></a>ADC_MASK_CHANNEL_11&#160;</td><td class="fielddoc"><p>Channel 11 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaa7d739e17b3579f4f792f646ae1dca32c"></a>ADC_MASK_CHANNEL_12&#160;</td><td class="fielddoc"><p>Channel 12 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaae00f3e1d56e90441de81d6ca35dd7602"></a>ADC_MASK_CHANNEL_13&#160;</td><td class="fielddoc"><p>Channel 13 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaac544630494da89f6d7a2f1cca190dc1c"></a>ADC_MASK_CHANNEL_14&#160;</td><td class="fielddoc"><p>Channel 14 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaaf087bfd9d507a86f7a5f6211b9f0b8db"></a>ADC_MASK_CHANNEL_15&#160;</td><td class="fielddoc"><p>Channel 15 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaa5ffe6ec6a65a3e36ee258ad0d102903b"></a>ADC_MASK_CHANNEL_16&#160;</td><td class="fielddoc"><p>Channel 16 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaa627d06a991048bd40cc4b17c305382a9"></a>ADC_MASK_CHANNEL_17&#160;</td><td class="fielddoc"><p>Channel 17 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaadf0335341e66b1f2eac954ab40eafa1d"></a>ADC_MASK_CHANNEL_18&#160;</td><td class="fielddoc"><p>Channel 18 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaa249875874079ec43d88741470afa2662"></a>ADC_MASK_CHANNEL_19&#160;</td><td class="fielddoc"><p>Channel 19 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaa91b21804c76b556f5d3eea57efdd0c1a"></a>ADC_MASK_CHANNEL_20&#160;</td><td class="fielddoc"><p>Channel 20 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaaceb77bd8e3a4529991aebb35df3261b7"></a>ADC_MASK_CHANNEL_21&#160;</td><td class="fielddoc"><p>Channel 21 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaa6381178e13fefbc75f329032673969f2"></a>ADC_MASK_CHANNEL_22&#160;</td><td class="fielddoc"><p>Channel 22 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaaf85b257b17c361f3851a26ac414556f5"></a>ADC_MASK_CHANNEL_23&#160;</td><td class="fielddoc"><p>Channel 23 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaabd438f0a01aeed961d71e3d949b41f79"></a>ADC_MASK_CHANNEL_24&#160;</td><td class="fielddoc"><p>Channel 24 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaa5d1b9967b76bd206dd9834adedb7511d"></a>ADC_MASK_CHANNEL_25&#160;</td><td class="fielddoc"><p>Channel 25 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaaebec3e24f9142260a7c06b7c70e49a74"></a>ADC_MASK_CHANNEL_26&#160;</td><td class="fielddoc"><p>Channel 26 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaa1114ae29dc12afc9748bdbfe1586f60a"></a>ADC_MASK_CHANNEL_27&#160;</td><td class="fielddoc"><p>Channel 27 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaac1ac20cd379e67bf23b34d826a49dc1a"></a>ADC_MASK_TEMPERATURE&#160;</td><td class="fielddoc"><p>Temperature sensor channel mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaa7cb05f1111dcc356ccac809b1a337691"></a>ADC_MASK_VOLT&#160;</td><td class="fielddoc"><p>Voltage reference channel mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaa083aadf81dbe5a4a3e3869e7ad7c34cb"></a>ADC_MASK_SENSORS&#160;</td><td class="fielddoc"><p>All sensor channel mask. </p>
</td></tr>
</table>

</div>
</div>
<a id="gae9ce774d7384e84ac724f5a1c6ca0d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9ce774d7384e84ac724f5a1c6ca0d21">&#9670;&nbsp;</a></span>adc_add_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c.html#gae9ce774d7384e84ac724f5a1c6ca0d21">adc_add_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADC data sample addition and averaging options </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae9ce774d7384e84ac724f5a1c6ca0d21a090916b0598df17cfc4cbc6da7a24361"></a>ADC_ADD_OFF&#160;</td><td class="fielddoc"><p>Addition turned off for channels/sensors. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae9ce774d7384e84ac724f5a1c6ca0d21aae57197b45505b18cb188b1a44bb0411"></a>ADC_ADD_TWO&#160;</td><td class="fielddoc"><p>Add two samples. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae9ce774d7384e84ac724f5a1c6ca0d21adec8cd78254fbd95b677c5b842b6209e"></a>ADC_ADD_THREE&#160;</td><td class="fielddoc"><p>Add three samples. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae9ce774d7384e84ac724f5a1c6ca0d21a0c4068dac9f508406946326b31cc45cd"></a>ADC_ADD_FOUR&#160;</td><td class="fielddoc"><p>Add four samples. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae9ce774d7384e84ac724f5a1c6ca0d21a09798f7c00aef944195aa7039081f171"></a>ADC_ADD_SIXTEEN&#160;</td><td class="fielddoc"><p>Add sixteen samples. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae9ce774d7384e84ac724f5a1c6ca0d21a6c9935940088b096683ce038643c93c8"></a>ADC_ADD_AVERAGE_TWO&#160;</td><td class="fielddoc"><p>Average two samples. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae9ce774d7384e84ac724f5a1c6ca0d21aa5551fce055385439e74076ea349ca38"></a>ADC_ADD_AVERAGE_FOUR&#160;</td><td class="fielddoc"><p>Average four samples. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae9ce774d7384e84ac724f5a1c6ca0d21ad2c5445357f4973b69afbab249fc9e83"></a>ADC_ADD_AVERAGE_EIGHT&#160;</td><td class="fielddoc"><p>Average eight samples. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae9ce774d7384e84ac724f5a1c6ca0d21a9026625853db106940c2418a1d65226e"></a>ADC_ADD_AVERAGE_SIXTEEN&#160;</td><td class="fielddoc"><p>Add sixteen samples. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga9ddc074052e3b84fcc2defed431fe022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ddc074052e3b84fcc2defed431fe022">&#9670;&nbsp;</a></span>adc_clear_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c.html#ga9ddc074052e3b84fcc2defed431fe022">adc_clear_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADC clear after read definitions </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9ddc074052e3b84fcc2defed431fe022a40a15e57eb830cd349dc65bbb1804983"></a>ADC_CLEAR_AFTER_READ_OFF&#160;</td><td class="fielddoc"><p>Clear after read off. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9ddc074052e3b84fcc2defed431fe022a0ba72fa05c9e7855c869e82c39ce8634"></a>ADC_CLEAR_AFTER_READ_ON&#160;</td><td class="fielddoc"><p>Clear after read on. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga03d10a44658a1383520ca2d9c3928eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03d10a44658a1383520ca2d9c3928eb9">&#9670;&nbsp;</a></span>adc_vref_control_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c.html#ga03d10a44658a1383520ca2d9c3928eb9">adc_vref_control_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga03d10a44658a1383520ca2d9c3928eb9a8072df0bda056626d8fdb837e2b7e9c2"></a>ADC_VREF_CONTROL_VREFH&#160;</td><td class="fielddoc"><p>VREFAMPCNT reset value. VREFADC Output voltage is Hi-Z. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga03d10a44658a1383520ca2d9c3928eb9ae0702807252eb6041e26b09a99478496"></a>ADC_VREF_CONTROL_1_5V_OUTPUT&#160;</td><td class="fielddoc"><p>BGR turn ON. VREFADC Output voltage is 1.5 V. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga03d10a44658a1383520ca2d9c3928eb9a3b29fd8f4b57ca18e86b0e7675daf094"></a>ADC_VREF_CONTROL_2_0V_OUTPUT&#160;</td><td class="fielddoc"><p>BGR turn ON. VREFADC Output voltage is 2.0 V. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga03d10a44658a1383520ca2d9c3928eb9a091bf95c38c3df5304ffb528c3394570"></a>ADC_VREF_CONTROL_2_5V_OUTPUT&#160;</td><td class="fielddoc"><p>BGR turn ON. VREFADC Output voltage is 2.5 V. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga03d10a44658a1383520ca2d9c3928eb9aec854c22228db1dfa5f0a1bd972250a4"></a>ADC_VREF_CONTROL_AVCC0_AVSS0&#160;</td><td class="fielddoc"><p>High potential is AVCC0, low potential is AVSS0. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga03d10a44658a1383520ca2d9c3928eb9a0da7299e3aa591f4cb97b065974579ad"></a>ADC_VREF_CONTROL_VREFH0_AVSS0&#160;</td><td class="fielddoc"><p>High potential is VREFH0, low potential is AVSS0. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga03d10a44658a1383520ca2d9c3928eb9a8588e997cacbd688d849fac4495be134"></a>ADC_VREF_CONTROL_IVREF_AVSS0&#160;</td><td class="fielddoc"><p>High potential is internal reference voltage, low potential is AVSS0. When the high potential is set to the internal reference voltage, wait 5 us after <a class="el" href="group___a_d_c.html#gade895e0810cecb3be6a9e5217f5c78ac">R_ADC_Open()</a> to start an ADC measurement. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga03d10a44658a1383520ca2d9c3928eb9a1ccaa796a89acb8a0b8cb7290011b2cf"></a>ADC_VREF_CONTROL_AVCC0_VREFL0&#160;</td><td class="fielddoc"><p>High potential is AVCC0, low potential is VREFL0. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga03d10a44658a1383520ca2d9c3928eb9a6989ac5f611d6ee3b2ee8619e2d802dc"></a>ADC_VREF_CONTROL_VREFH0_VREFL0&#160;</td><td class="fielddoc"><p>High potential is VREFH0, low potential is VREFL0. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga03d10a44658a1383520ca2d9c3928eb9a7902695c4fccb9e61488cbe490cda59b"></a>ADC_VREF_CONTROL_IVREF_VREFL0&#160;</td><td class="fielddoc"><p>High potential is internal reference voltage, low potential is VREFL0. When the high potential is set to the internal reference voltage, wait 5 us after <a class="el" href="group___a_d_c.html#gade895e0810cecb3be6a9e5217f5c78ac">R_ADC_Open()</a> to start an ADC measurement. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga2817e17c728f9a2b041b54fd92244c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2817e17c728f9a2b041b54fd92244c3b">&#9670;&nbsp;</a></span>adc_sample_state_reg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c.html#ga2817e17c728f9a2b041b54fd92244c3b">adc_sample_state_reg_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADC sample state registers </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3ba604a99834f18e561f607273935ba24ef"></a>ADC_SAMPLE_STATE_CHANNEL_0&#160;</td><td class="fielddoc"><p>Sample state register channel 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3bafd39019ec86088e9d0759f867d86cba5"></a>ADC_SAMPLE_STATE_CHANNEL_1&#160;</td><td class="fielddoc"><p>Sample state register channel 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3ba8b105e38f5647e5b7c93ea006085c536"></a>ADC_SAMPLE_STATE_CHANNEL_2&#160;</td><td class="fielddoc"><p>Sample state register channel 2. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3bae1c044bc95b5471599d2a7271c726fb7"></a>ADC_SAMPLE_STATE_CHANNEL_3&#160;</td><td class="fielddoc"><p>Sample state register channel 3. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3ba7a36e2a75d6660e060dfdae679e7e52f"></a>ADC_SAMPLE_STATE_CHANNEL_4&#160;</td><td class="fielddoc"><p>Sample state register channel 4. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3baf73e7cec5f82b03d9c18fde149496d55"></a>ADC_SAMPLE_STATE_CHANNEL_5&#160;</td><td class="fielddoc"><p>Sample state register channel 5. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3ba085cb57e804911e5f00ddf5b089a52a4"></a>ADC_SAMPLE_STATE_CHANNEL_6&#160;</td><td class="fielddoc"><p>Sample state register channel 6. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3baeac06f74c92938efe5781be93d8ebd4a"></a>ADC_SAMPLE_STATE_CHANNEL_7&#160;</td><td class="fielddoc"><p>Sample state register channel 7. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3ba91daae7d41cb1e2ae21a4526058a7627"></a>ADC_SAMPLE_STATE_CHANNEL_8&#160;</td><td class="fielddoc"><p>Sample state register channel 8. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3ba512873b0a3351c25c118dca97c06bb54"></a>ADC_SAMPLE_STATE_CHANNEL_9&#160;</td><td class="fielddoc"><p>Sample state register channel 9. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3bad9180bdea39bc4756cafe59e23fb8255"></a>ADC_SAMPLE_STATE_CHANNEL_10&#160;</td><td class="fielddoc"><p>Sample state register channel 10. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3ba66c461385327fd649e27a173c16d23e9"></a>ADC_SAMPLE_STATE_CHANNEL_11&#160;</td><td class="fielddoc"><p>Sample state register channel 11. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3baac60e177a232289fefd27667d63709cb"></a>ADC_SAMPLE_STATE_CHANNEL_12&#160;</td><td class="fielddoc"><p>Sample state register channel 12. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3ba2cbeb74ff07c6a77c1b598247cc7e535"></a>ADC_SAMPLE_STATE_CHANNEL_13&#160;</td><td class="fielddoc"><p>Sample state register channel 13. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3badd8b22743455d23b4bbd6df024bdb226"></a>ADC_SAMPLE_STATE_CHANNEL_14&#160;</td><td class="fielddoc"><p>Sample state register channel 14. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3baf4b29f4c28457a25bbdecf62cf038df3"></a>ADC_SAMPLE_STATE_CHANNEL_15&#160;</td><td class="fielddoc"><p>Sample state register channel 15. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3ba9cde1e159dda5cb81609d861a69ecea5"></a>ADC_SAMPLE_STATE_CHANNEL_16_TO_31&#160;</td><td class="fielddoc"><p>Sample state register channel 16 to 31. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga79014196d08d86b161b77892bf26b100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79014196d08d86b161b77892bf26b100">&#9670;&nbsp;</a></span>adc_group_a_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c.html#ga79014196d08d86b161b77892bf26b100">adc_group_a_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADC action for group A interrupts group B scan. This enumeration is used to specify the priority between Group A and B in group mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga79014196d08d86b161b77892bf26b100a356a40c69cc74ea30a461d7dd3e4d55e"></a>ADC_GROUP_A_PRIORITY_OFF&#160;</td><td class="fielddoc"><p>Group A ignored and does not interrupt ongoing group B scan. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga79014196d08d86b161b77892bf26b100aad6bf6c403c26b6891f27a40d65359c9"></a>ADC_GROUP_A_GROUP_B_WAIT_FOR_TRIGGER&#160;</td><td class="fielddoc"><p>Group A interrupts Group B(single scan) which restarts at next Group B trigger. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga79014196d08d86b161b77892bf26b100a008539c98b123b9a7db52e3bf8ebc631"></a>ADC_GROUP_A_GROUP_B_RESTART_SCAN&#160;</td><td class="fielddoc"><p>Group A interrupts Group B(single scan) which restarts immediately after Group A scan is complete. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga79014196d08d86b161b77892bf26b100a555241a868ee8b93557c4358c21caea0"></a>ADC_GROUP_A_GROUP_B_CONTINUOUS_SCAN&#160;</td><td class="fielddoc"><p>Group A interrupts Group B(continuous scan) which continues scanning without a new Group B trigger. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga802c536966b5905a58039e347c5dbbc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga802c536966b5905a58039e347c5dbbc5">&#9670;&nbsp;</a></span>adc_double_trigger_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c.html#ga802c536966b5905a58039e347c5dbbc5">adc_double_trigger_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADC double-trigger mode definitions </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga802c536966b5905a58039e347c5dbbc5a5bba4c6110fce02531f6f7822604ed08"></a>ADC_DOUBLE_TRIGGER_DISABLED&#160;</td><td class="fielddoc"><p>Double-triggering disabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga802c536966b5905a58039e347c5dbbc5a0c5f35117003eac5370c768e56f160a1"></a>ADC_DOUBLE_TRIGGER_ENABLED&#160;</td><td class="fielddoc"><p>Double-triggering enabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga802c536966b5905a58039e347c5dbbc5a67e6c1666364c908d8ceb504b4ccf15f"></a>ADC_DOUBLE_TRIGGER_ENABLED_EXTENDED&#160;</td><td class="fielddoc"><p>Double-triggering enabled on both ADC ELC events. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gade895e0810cecb3be6a9e5217f5c78ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade895e0810cecb3be6a9e5217f5c78ac">&#9670;&nbsp;</a></span>R_ADC_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#structadc__cfg__t">adc_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the operational mode, trigger sources, interrupt priority, and configurations for the peripheral as a whole. If interrupt is enabled, the function registers a callback function pointer for notifying the user whenever a scan has completed.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Module is ready for use. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>The instance control structure has already been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_IRQ_BSP_DISABLED</td><td>A callback is provided, but the interrupt is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_IP_CHANNEL_NOT_PRESENT</td><td>The requested unit does not exist on this MCU. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_HW_CONDITION</td><td>The ADC clock must be at least 1 MHz </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga994514574730e0701dc1a6ad41889f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga994514574730e0701dc1a6ad41889f88">&#9670;&nbsp;</a></span>R_ADC_ScanCfg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_ScanCfg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>p_channel_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the ADC scan parameters. Channel specific settings are set in this function. Pass a pointer to <a class="el" href="group___a_d_c.html#structadc__channel__cfg__t">adc_channel_cfg_t</a> to p_channel_cfg.</p>
<dl class="section note"><dt>Note</dt><dd>This starts group B scans if <a class="el" href="group___a_d_c.html#aef59542e008313144646bd057d840c8a" title="Valid for group modes. ">adc_channel_cfg_t::priority_group_a</a> is set to ADC_GROUP_A_GROUP_B_CONTINUOUS_SCAN.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Channel specific settings applied. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1cc44d84e1dd1cad8fdafe1e91a3b6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cc44d84e1dd1cad8fdafe1e91a3b6d0">&#9670;&nbsp;</a></span>R_ADC_InfoGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_InfoGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#structadc__info__t">adc_info_t</a> *&#160;</td>
          <td class="paramname"><em>p_adc_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the address of the lowest number configured channel and the total number of bytes to be read in order to read the results of the configured channels and return the ELC Event name. If no channels are configured, then a length of 0 is returned.</p>
<p>Also provides the temperature sensor slope and the calibration data for the sensor if available on this MCU. Otherwise, invalid calibration data of 0xFFFFFFFF will be returned.</p>
<dl class="section note"><dt>Note</dt><dd>In group mode, information is returned for group A only. Calculating information for group B is not currently supported.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Information stored in p_adc_info. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4a7fb2265b5a03c7586253ff28b3faf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a7fb2265b5a03c7586253ff28b3faf2">&#9670;&nbsp;</a></span>R_ADC_ScanStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_ScanStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts a software scan or enables the hardware trigger for a scan depending on how the triggers were configured in the R_ADC_Open call. If the unit was configured for ELC or external hardware triggering, then this function allows the trigger signal to get to the ADC unit. The function is not able to control the generation of the trigger itself. If the unit was configured for software triggering, then this function starts the software triggered scan.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Call R_ADC_ScanCfg after R_ADC_Open before starting a scan.</dd>
<dd>
On MCUs that support calibration, call R_ADC_Calibrate and wait for calibration to complete before starting a scan.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Scan started (software trigger) or hardware triggers enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>Another scan is still in progress (software trigger). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9b5242c153c6320a564ed9ffd324f144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b5242c153c6320a564ed9ffd324f144">&#9670;&nbsp;</a></span>R_ADC_ScanStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_ScanStop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops the software scan or disables the unit from being triggered by the hardware trigger (ELC or external) based on what type of trigger the unit was configured for in the R_ADC_Open function. Stopping a hardware triggered scan via this function does not abort an ongoing scan, but prevents the next scan from occurring. Stopping a software triggered scan aborts an ongoing scan.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Scan stopped (software trigger) or hardware triggers disabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga676b1c7f1ccceda288cbb2ad79a14ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga676b1c7f1ccceda288cbb2ad79a14ff2">&#9670;&nbsp;</a></span>R_ADC_StatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_StatusGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#structadc__status__t">adc_status_t</a> *&#160;</td>
          <td class="paramname"><em>p_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides the status of any scan process that was started, including scans started by ELC or external triggers and calibration scans on MCUs that support calibration.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Module status stored in the provided pointer p_status </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad6bfc8395b53a96ee89f266fc940e2da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6bfc8395b53a96ee89f266fc940e2da">&#9670;&nbsp;</a></span>R_ADC_Read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const&#160;</td>
          <td class="paramname"><em>reg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *const&#160;</td>
          <td class="paramname"><em>p_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads conversion results from a single channel or sensor.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Data read into provided p_data. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga905e1cd6ff8ca4aaf91ee63529dc0d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga905e1cd6ff8ca4aaf91ee63529dc0d0d">&#9670;&nbsp;</a></span>R_ADC_Read32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_Read32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const&#160;</td>
          <td class="paramname"><em>reg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *const&#160;</td>
          <td class="paramname"><em>p_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads conversion results from a single channel or sensor register into a 32-bit result.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Data read into provided p_data. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf0701bf45818dee071cb12e979017bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0701bf45818dee071cb12e979017bce">&#9670;&nbsp;</a></span>R_ADC_SampleStateCountSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_SampleStateCountSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c.html#structadc__sample__state__t">adc_sample_state_t</a> *&#160;</td>
          <td class="paramname"><em>p_sample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the sample state count for individual channels. This only needs to be set for special use cases. Normally, use the default values out of reset.</p>
<dl class="section note"><dt>Note</dt><dd>The sample states for the temperature and voltage sensor are set in R_ADC_ScanCfg.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Sample state count updated. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga499187b3067534e42a57239ead111797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga499187b3067534e42a57239ead111797">&#9670;&nbsp;</a></span>R_ADC_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function ends any scan in progress, disables interrupts, and removes power to the A/D peripheral.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Module closed. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf3bc65f19ba61612e0b7517dfd41ab61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3bc65f19ba61612e0b7517dfd41ab61">&#9670;&nbsp;</a></span>R_ADC_OffsetSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_OffsetSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const&#160;</td>
          <td class="paramname"><em>reg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group___a_d_c___a_p_i.html#a305b2c2466cd88fdddf6134db542dc7e">adc_api_t::offsetSet</a> is not supported on the ADC.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Function not supported in this implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafb2e4cd66d5bd276d05eb5fa104a2037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb2e4cd66d5bd276d05eb5fa104a2037">&#9670;&nbsp;</a></span>R_ADC_Calibrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_Calibrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>p_extend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initiates calibration of the ADC on MCUs that require calibration. This function must be called before starting a scan on MCUs that require calibration.</p>
<p>Calibration is complete when the callback is called with ADC_EVENT_CALIBRATION_COMPLETE or when R_ADC_StatusGet returns ADC_STATUS_IDLE. Reference Figure 32.35 "Software flow and operation example of calibration operation." in the RA2A1 manual R01UH0888EJ0100.</p>
<p>ADC calibration time: 12 PCLKB + 774,930 ADCLK. (Reference Table 32.16 "Required calibration time (shown
as the number of ADCLK and PCLKB cycles)" in the RA2A1 manual R01UH0888EJ0100. The lowest supported ADCLK is 1MHz.</p>
<p>Calibration will take a minimum of 24 milliseconds at 32 MHz PCLKB and ADCLK. This wait could take up to 780 milliseconds for a 1 MHz PCLKD (ADCLK).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_ctrl</td><td>Pointer to the instance control structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_extend</td><td>Unused argument. Pass NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Calibration successfully initiated. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_HW_CONDITION</td><td>A scan is in progress or hardware triggers are enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Calibration not supported on this MCU. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9110aa7c0d36661e561641f522eeb737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9110aa7c0d36661e561641f522eeb737">&#9670;&nbsp;</a></span>R_ADC_CallbackSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_CallbackSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="group___a_d_c___a_p_i.html#structadc__callback__args__t">adc_callback_args_t</a> *)&#160;</td>
          <td class="paramname"><em>p_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>p_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#structadc__callback__args__t">adc_callback_args_t</a> *const&#160;</td>
          <td class="paramname"><em>p_callback_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the user callback and has option of providing memory for callback structure. Implements <a class="el" href="group___a_d_c___a_p_i.html#a8d081aba32f84d62e7d48389b1d10b3e">adc_api_t::callbackSet</a></p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Callback updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_NO_CALLBACK_MEMORY</td><td>p_callback is non-secure and p_callback_memory is either secure or NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v3.1.0 User's Manual Copyright  (2021) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
