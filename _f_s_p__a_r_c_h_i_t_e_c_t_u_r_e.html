<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: FSP Architecture</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
    $(document).ready(function() {
        $("tr.tree_lvl_1").nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
		$("tr.tree_lvl_1").data("expanded","0");
		$("tr.tree_lvl_2").data("expanded","0");
		$("tr.tree_lvl_3").data("expanded","0");
		$("tr.tree_lvl_4").data("expanded","0");
		$("tr.tree_lvl_5").data("expanded","0");
        $("tr.tree_lvl_1").click(function() {
		    var lvl_1_is_open = $(this).data("expanded");
		    if (lvl_1_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2, tr.tree_lvl_1_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_2").click(function() {
		    var lvl_2_is_open = $(this).data("expanded");
		    if (lvl_2_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3, tr.tree_lvl_2_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_3").click(function() {
		    var lvl_3_is_open = $(this).data("expanded");
		    if (lvl_3_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_3_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_4").click(function() {
		    var lvl_4_is_open = $(this).data("expanded");
		    if (lvl_4_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5, tr.tree_lvl_4_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_5").click(function() {
		    var lvl_5_is_open = $(this).data("expanded");
		    if (lvl_5_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4_item,tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
     });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v6.2.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">

    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text">
      </span>
      <span class="right">
          &nbsp;
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_f_s_p__a_r_c_h_i_t_e_c_t_u_r_e.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body.
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len));
            }
          }
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element.
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">FSP Architecture </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#renesas-ra-software-package-fsp-architecture">FSP Architecture Overview</a><ul><li class="level2"><a href="#c99-use">C99 Use</a></li>
<li class="level2"><a href="#doxygen">Doxygen</a></li>
<li class="level2"><a href="#weak-symbols">Weak Symbols</a></li>
<li class="level2"><a href="#memory-allocation">Memory Allocation</a></li>
<li class="level2"><a href="#fsp-terms">FSP Terms</a></li>
</ul>
</li>
<li class="level1"><a href="#fsp-modules">FSP Modules</a><ul><li class="level2"><a href="#module-sources">Module Sources</a></li>
<li class="level2"><a href="#module-distribution">Module Distribution</a></li>
<li class="level2"><a href="#module-versioning">Module Versioning</a></li>
</ul>
</li>
<li class="level1"><a href="#fsp-stacks">FSP Stacks</a></li>
<li class="level1"><a href="#fsp-interfaces">FSP Interfaces</a><ul><li class="level2"><a href="#fsp-interface-enumerations">FSP Interface Enumerations</a></li>
<li class="level2"><a href="#fsp-interface-callback-functions">FSP Interface Callback Functions</a></li>
<li class="level2"><a href="#fsp-internface-data-structures">FSP Interface Data Structures</a><ul><li class="level3"><a href="#fsp-interface-configuration-structure">FSP Interface Configuration Structure</a></li>
<li class="level3"><a href="#fsp-interface-api-structure">FSP Interface API Structure</a></li>
<li class="level3"><a href="#fsp-instance-structure">FSP Interface Instance Structure</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#fsp-instances">FSP Instances</a><ul><li class="level2"><a href="#control-structure">FSP Instance Control Structure</a></li>
<li class="level2"><a href="#fsp-interface-extensions">FSP Interface Extensions</a><ul><li class="level3"><a href="#fsp-extended-configuration-structure">FSP Extended Configuration Structure</a></li>
</ul>
</li>
<li class="level2"><a href="#fsp-instance-api">FSP Instance API</a></li>
</ul>
</li>
<li class="level1"><a href="#fsp-api-standards">FSP API Standards</a><ul><li class="level2"><a href="#fsp-function-names">FSP Function Names</a></li>
<li class="level2"><a href="#use-of-const-in-api-parameters">Use of const in API parameters</a></li>
<li class="level2"><a href="#fsp-version-information">FSP Version Information</a></li>
</ul>
</li>
<li class="level1"><a href="#fsp-build-time-configurations">FSP Build Time Configurations</a></li>
<li class="level1"><a href="#fsp-file-structure">FSP File Structure</a></li>
<li class="level1"><a href="#fsp-trustzone-support">FSP TrustZone Support</a><ul><li class="level2"><a href="#fsp-trustzone-projects">FSP TrustZone Projects</a></li>
<li class="level2"><a href="#fsp-trustzone-nsc-guard-functions">Non-Secure Callable Guard Functions</a></li>
<li class="level2"><a href="#fsp-trustzone-callback-to-non-secure">Callbacks in Non-Secure from Non-Secure Callable Modules</a></li>
<li class="level2"><a href="#fsp-trustzone-project-migration">Migrating TrustZone Project to newer FSP Version</a></li>
<li class="level2"><a href="#additional-trustzone-information">Additional TrustZone Information</a></li>
</ul>
</li>
<li class="level1"><a href="#fsp-architecture-in-practice">FSP Architecture in Practice</a><ul><li class="level2"><a href="#fsp-connecting-layers">FSP Connecting Layers</a></li>
<li class="level2"><a href="#using-fsp-modules-in-an-application">Using FSP Modules in an Application</a><ul><li class="level3"><a href="#create-a-module-instance">Create a Module Instance in the RA Configuration Editor</a></li>
<li class="level3"><a href="#use-the-instance-api">Use the Instance API in the Application</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="renesas-ra-software-package-fsp-architecture"></a>
FSP Architecture Overview</h1>
<p>This guide describes the Renesas Flexible Software Package (FSP) architecture and how to use the FSP Application Programming Interface (API).</p>
<h2><a class="anchor" id="c99-use"></a>
C99 Use</h2>
<p>FSP uses the ISO/IEC 9899:1999 (C99) C programming language standard. Specific features introduced in C99 that are used include standard integer types (stdint.h), booleans (stdbool.h), designated initializers, and the ability to intermingle declarations and code.</p>
<h2><a class="anchor" id="doxygen"></a>
Doxygen</h2>
<p>Doxygen is the default documentation tool used by FSP. You can find Doxygen comments throughout the FSP source.</p>
<h2><a class="anchor" id="weak-symbols"></a>
Weak Symbols</h2>
<p>Weak symbols are used occasionally in FSP. They are used to ensure that a project builds even when the user has not defined an optional function.</p>
<h2><a class="anchor" id="memory-allocation"></a>
Memory Allocation</h2>
<p>Dynamic memory allocation through use of the malloc() and free() functions are not used in FSP modules; all memory required by FSP modules is allocated in the application and passed to the module in a pointer. Exceptions are considered only for ports of 3rd party code that require dynamic memory.</p>
<h2><a class="anchor" id="fsp-terms"></a>
FSP Terms</h2>
<table class="doxtable">
<tr>
<th>Term </th><th>Description </th><th>Reference  </th></tr>
<tr>
<td>BSP </td><td>Short for Board Support Package. In FSP, the BSP provides just enough foundation to allow other FSP modules to work together without issue. </td><td><a class="el" href="group___b_s_p___m_c_u.html">MCU Board Support Package</a> </td></tr>
<tr>
<td>Module </td><td>Modules can be peripheral drivers, purely software, or anything in between. Each module consists of a folder with source code, documentation, and anything else that the customer needs to use the code effectively. Modules are independent units, but they may depend on other modules. Applications can be built by combining multiple modules to provide the user with the features they need. </td><td><a class="el" href="_f_s_p__a_r_c_h_i_t_e_c_t_u_r_e.html#fsp-modules">FSP Modules</a> </td></tr>
<tr>
<td>Driver </td><td>A driver is a specific kind of module that directly modifies registers on the MCU. </td><td>- </td></tr>
<tr>
<td>Interface </td><td>An interface contains API definitions that can be shared by modules with similar features. Interfaces are definitions only and do not add to code size. </td><td><a class="el" href="_f_s_p__a_r_c_h_i_t_e_c_t_u_r_e.html#fsp-interfaces">FSP Interfaces</a> </td></tr>
<tr>
<td>Stacks </td><td>The FSP architecture is designed such that modules work together to form a stack. A stack consists of a top level module and all its dependencies. </td><td><a class="el" href="_f_s_p__a_r_c_h_i_t_e_c_t_u_r_e.html#fsp-stacks">FSP Stacks</a> </td></tr>
<tr>
<td>Module Instance </td><td>Single and independent instantiation of a module. An application may require two GPT timers. Each of these timers is a module instance of the r_gpt module. </td><td>- </td></tr>
<tr>
<td>Application </td><td>Code that is owned and maintained by the user. Application code may be based on sample application code provided by Renesas, but it is the responsibility of the user to maintain as necessary. </td><td>- </td></tr>
<tr>
<td>Callback Function </td><td>This term refers to a function that is called when an event occurs. As an example, suppose the user would like to be notified every second based on the RTC. As part of the RTC configuration, a callback function can be supplied that will be jumped to during each RTC interrupt. When a single callback services multiple events, the arguments contain the triggering event. Callback functions for interrupts should be kept short and handled carefully because when they are called the MCU is still inside of an interrupt, delaying any pending interrupts. </td><td>- </td></tr>
</table>
<h1><a class="anchor" id="fsp-modules"></a>
FSP Modules</h1>
<p>Modules are the core building block of FSP. Modules can do many different things, but all modules share the basic concept of providing functionality upwards and requiring functionality from below.</p>
<div class="image">
<object type="image/svg+xml" data="figure-fsp-module.svg">figure-fsp-module.svg</object>
<div class="caption">
Modules</div></div>
<p> The amount of functionality provided by a module is determined based on functional use cases. Common functionality required by multiple modules is often placed into a self-contained submodule so it can be reused. Code size, speed and complexity are also considered when defining a module.</p>
<p>The simplest FSP application consists of one module with the Board Support Package (BSP) and the user application on top.</p>
<div class="image">
<object type="image/svg+xml" data="figure-fsp-application-single-module.svg">figure-fsp-application-single-module.svg</object>
<div class="caption">
Module with application</div></div>
<p> The Board Support Package (BSP) is the foundation for FSP modules, providing functionality to determine the MCU used as well as configuring clocks, interrupts and pins. For the sake of clarity, the BSP will be omitted from further diagrams.</p>
<h2><a class="anchor" id="module-sources"></a>
Module Sources</h2>
<p>Some modules distributed alongside FSP originate from outside sources. A full list of sources for FSP modules, including versions and hyperlinks, can be found in the Third Party Software section of the release notes for each release.</p>
<h2><a class="anchor" id="module-distribution"></a>
Module Distribution</h2>
<p>All modules distributed with FSP are packaged as CMSIS components in CMSIS packs. Each module consists of source files and a tooling support file used to integrate the module with e&sup2; studio or RASC. The tooling support file defines the configurations used to generate code in the ra_gen and ra_cfg folders.</p>
<h2><a class="anchor" id="module-versioning"></a>
Module Versioning</h2>
<p>Module versions can be seen on the Components tab of the FSP Configuration editor. The FSP Configuration editor automatically selects compatible components.</p>
<p>All third party modules have a semantic version are versioned with their original semantic version plus added metadata <code>fsp.&lt;fsp_semantic_version&gt;</code>. The metadata is added to reflect the tooling support file added for the FSP configuration tool.</p>
<p>Third party modules versioned with <code>+renesas.&lt;counter&gt;</code> in the metadata have been forked and updated for FSP. If <code>+renesas.&lt;counter&gt;</code> is not in the metadata, the third party code is unchanged from its original source.</p>
<p>If changes are made to third party module source code to support FSP, the changes are pushed to a public Renesas GitHub fork of the original source. Links to Renesas forks are provided in the Third Party Software section of the release notes for each release.</p>
<p>Modules that originate from outside sources that do not have a semantic version are versioned with the FSP version.</p>
<p>All modules that are part of FSP or integrated with FSP are tested as a package. Mixing versions is not encouraged and may lead to support issues.</p>
<h1><a class="anchor" id="fsp-stacks"></a>
FSP Stacks</h1>
<p>When modules are layered atop one another, an FSP stack is formed. The stacking process is performed by matching what one module provides with what another module requires. For example, the SPI module (<a class="el" href="group___s_p_i.html">SPI (r_spi)</a>) requires a module that provides the transfer interface (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html">Transfer Interface</a>) to send or receive data without a CPU interrupt. The transfer interface requirement can be fulfilled by the DTC driver module (<a class="el" href="group___d_t_c.html">Transfer (r_dtc)</a>).</p>
<p>Through this methodology the same code can be shared by several modules simultaneously. The example below illustrates how the same DTC module can be used with SPI (<a class="el" href="group___s_p_i.html">SPI (r_spi)</a>), UART (<a class="el" href="group___s_c_i___u_a_r_t.html">UART (r_sci_uart)</a>) and SDHI (<a class="el" href="group___s_d_h_i.html">SD/MMC (r_sdhi)</a>).</p>
<div class="image">
<object type="image/svg+xml" data="figure-fsp-multiple-drivers-use-dtc.svg">figure-fsp-multiple-drivers-use-dtc.svg</object>
<div class="caption">
Stacks -- Shared DTC Module</div></div>
<p> The ability to stack modules ensures the flexibility of the architecture as a whole. If multiple modules include the same functionality issues arise when application features must work across different user designs. To ensure that modules are reusable, any dependent modules must be capable of being swapped out for other modules that provide the same features. The FSP architecture provides this flexibility to swap modules in and out through the use of FSP interfaces.</p>
<h1><a class="anchor" id="fsp-interfaces"></a>
FSP Interfaces</h1>
<p>At the architecture level, interfaces are the way that modules provide common features. This commonality allows modules that adhere to the same interface to be used interchangeably. Interfaces can be thought of as a contract between two modules - the modules agree to work together using the information that was established in the contract.</p>
<p>On RA hardware there is occasionally an overlap of features between different peripherals. For example, I2C communications can be achieved through use of the IIC peripheral or the SCI peripheral. However, there is a difference in the level of features provided by both peripherals; in I2C mode the SCI peripheral will only support a subset of the capabilities of the fully-featured IIC.</p>
<p>Interfaces aim to provide support for the common features that most users would expect. This means that some of the advanced features of a peripheral (such as IIC) might not be available in the interface. In most cases these features are still available through interface extensions.</p>
<p>In FSP design, interfaces are defined in header files. All interface header files are located in the folder <code>ra/fsp/inc/api</code> and end with <code>*_api.h</code>. Interface extensions are defined in header files in the folder <code>ra/fsp/inc/instances</code>. The following sections detail what makes up an interface.</p>
<h2><a class="anchor" id="fsp-interface-enumerations"></a>
FSP Interface Enumerations</h2>
<p>Whenever possible, interfaces use typed enumerations for function parameters and structure members.</p>
 <div class="fragment"><div class="line">typedef enum e_i2c_master_addr_mode</div><div class="line">{</div><div class="line">    I2C_MASTER_ADDR_MODE_7BIT  = 1,    ///&lt; Use 7-bit addressing mode</div><div class="line">    I2C_MASTER_ADDR_MODE_10BIT = 2,    ///&lt; Use 10-bit addressing mode</div><div class="line">} i2c_master_addr_mode_t;</div></div><!-- fragment --></p>
<p>Enumerations remove uncertainty when deciding what values are available for a parameter. FSP enumeration options follow a strict naming convention where the name of the type is prefixed on the available options. Combining the naming convention with the autocomplete feature available in e&sup2; studio (Ctrl + Space) provides the benefits of rapid coding while maintaining high readability.</p>
<h2><a class="anchor" id="fsp-interface-callback-functions"></a>
FSP Interface Callback Functions</h2>
<p>Callback functions allow modules to asynchronously alert the user application when an event has occurred, such as when a byte has been received over a UART channel or an IRQ pin is toggled. FSP driver modules define and handle the interrupt service routines for RA MCU peripherals to ensure any required hardware procedures are implemented. The interrupt service routines in FSP modules then call the user-defined callbacks to allow the application to respond.</p>
<p>Callback functions must be defined in the user application. They always return <code>void</code> and take a structure for their one parameter. The structure is defined in the interface for the module and is named <code>&lt;interface&gt;_callback_args_t</code>. The contents of the structure may vary depending on the interface, but two members are common: <code>event</code> and <code>p_context</code>.</p>
<p>The <code>event</code> member is an enumeration defined in the interface used by the application to determine why the callback was called. Using the UART example, the callback could be triggered for many different reasons, including when a byte is received, all bytes have been transmitted, or a framing error has occurred. The <code>event</code> member allows the application to determine which of these three events has occurred and handle it appropriately.</p>
<p>The <code>p_context</code> member is used for providing user-specified data to the callback function. In many cases a callback function is shared between multiple channels or module instances; when the callback occurs, the code handling the callback needs context information so that it can determine which module instance the callback is for. For example, if the callback wanted to make an FSP API call in the callback, then at a minimum the callback will need a reference to the relevant control structure. To make this easy, the user can provide a pointer to the control structure as the <code>p_context</code>. When the callback occurs, the control structure is passed in the <code>p_context</code> element of the callback structure.</p>
<p>Callback functions are called from within an interrupt service routine. For this reason callback functions should be kept as short as possible so they do not affect the real time performance of the user's system. An example skeleton function for the flash interface callback is shown below.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> flash_callback (<a class="code" href="group___f_l_a_s_h___a_p_i.html#structflash__callback__args__t">flash_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="comment">/* See what event caused this callback. */</span></div><div class="line">    <span class="keywordflow">switch</span> (p_args-&gt;<a class="code" href="group___f_l_a_s_h___a_p_i.html#a85ce087229ae1cb0076dfb4e38238d7e">event</a>)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___f_l_a_s_h___a_p_i.html#gga44753f7d426ae0121c94a307a95314a5a47cf4f3983c35ca46fcfabeb1903e068">FLASH_EVENT_ERASE_COMPLETE</a>:</div><div class="line">        {</div><div class="line">            <span class="comment">/* Handle event. */</span></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___f_l_a_s_h___a_p_i.html#gga44753f7d426ae0121c94a307a95314a5a2a000e207e1a0db0f1a7c550599bb804">FLASH_EVENT_WRITE_COMPLETE</a>:</div><div class="line">        {</div><div class="line">            <span class="comment">/* Handle event. */</span></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___f_l_a_s_h___a_p_i.html#gga44753f7d426ae0121c94a307a95314a5a3fc21976299f9593314d6eaca4afa8fd">FLASH_EVENT_BLANK</a>:</div><div class="line">        {</div><div class="line">            <span class="comment">/* Handle event. */</span></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___f_l_a_s_h___a_p_i.html#gga44753f7d426ae0121c94a307a95314a5aafcc41f114f9f07e85cce8b0c4e7ad74">FLASH_EVENT_NOT_BLANK</a>:</div><div class="line">        {</div><div class="line">            <span class="comment">/* Handle event. */</span></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___f_l_a_s_h___a_p_i.html#gga44753f7d426ae0121c94a307a95314a5ab2ea36429331209ea82c1a22d98cb5e6">FLASH_EVENT_ERR_DF_ACCESS</a>:</div><div class="line">        {</div><div class="line">            <span class="comment">/* Handle error. */</span></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___f_l_a_s_h___a_p_i.html#gga44753f7d426ae0121c94a307a95314a5a6167eb1835398201b00b5c939f6bb97b">FLASH_EVENT_ERR_CF_ACCESS</a>:</div><div class="line">        {</div><div class="line">            <span class="comment">/* Handle error. */</span></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___f_l_a_s_h___a_p_i.html#gga44753f7d426ae0121c94a307a95314a5a2df4cbfb326d2c2817f28344373a990f">FLASH_EVENT_ERR_CMD_LOCKED</a>:</div><div class="line">        {</div><div class="line">            <span class="comment">/* Handle error. */</span></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___f_l_a_s_h___a_p_i.html#gga44753f7d426ae0121c94a307a95314a5a72edb6a3157ef6a937e6cb6af5c1998b">FLASH_EVENT_ERR_FAILURE</a>:</div><div class="line">        {</div><div class="line">            <span class="comment">/* Handle error. */</span></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___f_l_a_s_h___a_p_i.html#gga44753f7d426ae0121c94a307a95314a5a416c2c08801d97af315facc443baa2ed">FLASH_EVENT_ERR_ONE_BIT</a>:</div><div class="line">        {</div><div class="line">            <span class="comment">/* Handle error. */</span></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___f_l_a_s_h___a_p_i.html#gga44753f7d426ae0121c94a307a95314a5acce5b1272d35c9309b5b7e1e3c2b3f3d">FLASH_EVENT_ERR_TWO_BIT</a>:</div><div class="line">        {</div><div class="line">            <span class="comment">/* Handle error. */</span></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___f_l_a_s_h___a_p_i.html#gga44753f7d426ae0121c94a307a95314a5a8c771e5aaca1a943a932d34223325e35">FLASH_EVENT_ERR_ECC</a>:</div><div class="line">        {</div><div class="line">            <span class="comment">/* Handle error. */</span></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p> When a module is not directly used in the user application (that is, it is not the top layer of the stack), its callback function will be handled by the module above. For example, if a module requires a UART interface module the upper layer module will control and use the UART's callback function. In this case the user would not need to create a callback function for the UART module in their application code.</p>
<h2><a class="anchor" id="fsp-internface-data-structures"></a>
FSP Interface Data Structures</h2>
<p>At a minimum, all FSP interfaces include three data structures: a configuration structure, an API structure, and an instance structure.</p>
<h3><a class="anchor" id="fsp-interface-configuration-structure"></a>
FSP Interface Configuration Structure</h3>
<p>The configuration structure is used for the initial configuration of a module during the <code>&lt;MODULE&gt;_Open()</code> call. The structure consists of members such as channel number, bitrate, and operating mode.</p>
<p>The configuration structure is used purely as an input into the module. It may be stored and referenced by the module, so the configuration structure and anything it references must persist as long as the module is open.</p>
<p>The configuration structure is allocated for each module instance in files generated by the RA Configuration editor.</p>
<p>When FSP stacks are used, it is also important to understand that configuration structures only have members that apply to the current interface. If multiple layers in the same stack define the same configuration parameters then it becomes difficult to know where to modify the option. For example, the baud rate for a UART is only defined in the UART module instance. Any modules that use the UART interface rely on the baud rate being provided in the UART module instance and do not offer it in their own configuration structures.</p>
<h3><a class="anchor" id="fsp-interface-api-structure"></a>
FSP Interface API Structure</h3>
<p>All interfaces include an API structure which contains function pointers for all the supported interface functions. An example structure for the DAC is shown below.</p>
 <div class="fragment"><div class="line">typedef struct st_dac_api</div><div class="line">{</div><div class="line">    /** Initial configuration.</div><div class="line">     *</div><div class="line">     * @param[in]   p_ctrl     Pointer to control block. Must be declared by user. Elements set here.</div><div class="line">     * @param[in]   p_cfg      Pointer to configuration structure. All elements of this structure must be set by user.</div><div class="line">     */</div><div class="line">    fsp_err_t (* open)(dac_ctrl_t * const p_ctrl, dac_cfg_t const * const p_cfg);</div><div class="line"></div><div class="line">    /** Close the D/A Converter.</div><div class="line">     *</div><div class="line">     * @param[in]   p_ctrl     Control block set in @ref dac_api_t::open call for this timer.</div><div class="line">     */</div><div class="line">    fsp_err_t (* close)(dac_ctrl_t * const p_ctrl);</div><div class="line"></div><div class="line">    /** Write sample value to the D/A Converter.</div><div class="line">     *</div><div class="line">     * @param[in]   p_ctrl     Control block set in @ref dac_api_t::open call for this timer.</div><div class="line">     * @param[in]   value      Sample value to be written to the D/A Converter.</div><div class="line">     */</div><div class="line">    fsp_err_t (* write)(dac_ctrl_t * const p_ctrl, uint16_t value);</div><div class="line"></div><div class="line">    /** Start the D/A Converter if it has not been started yet.</div><div class="line">     *</div><div class="line">     * @param[in]   p_ctrl     Control block set in @ref dac_api_t::open call for this timer.</div><div class="line">     */</div><div class="line">    fsp_err_t (* start)(dac_ctrl_t * const p_ctrl);</div><div class="line"></div><div class="line">    /** Stop the D/A Converter if the converter is running.</div><div class="line">     *</div><div class="line">     * @param[in]   p_ctrl     Control block set in @ref dac_api_t::open call for this timer.</div><div class="line">     */</div><div class="line">    fsp_err_t (* stop)(dac_ctrl_t * const p_ctrl);</div><div class="line">} dac_api_t;</div></div><!-- fragment --></p>
<p>The API structure is what allows for modules to easily be swapped in and out for other modules that are instances of the same interface. Let's look at an example application using the DAC interface above.</p>
<p>RA MCUs have an internal DAC peripheral. If the DAC API structure in the DAC interface is not used the application can make calls directly into the module. In the example below the application is making calls to the <a class="el" href="group___d_a_c.html#gad33261cb041a53bdd0e8978b2efcc435">R_DAC_Write()</a> function which is provided in the r_dac module.</p>
<div class="image">
<object type="image/svg+xml" data="figure-fsp-dac-write.svg">figure-fsp-dac-write.svg</object>
<div class="caption">
DAC Write example</div></div>
<p> Now let's assume that the user needs more DAC channels than are available on the MCU and decides to add an external DAC module named dac_external using I2C for communications. The application must now distinguish between the two modules, adding complexity and further dependencies to the application.</p>
<div class="image">
<object type="image/svg+xml" data="figure-fsp-external-dac.svg">figure-fsp-external-dac.svg</object>
<div class="caption">
DAC Write with two write modules</div></div>
<p> The use of interfaces and the API structure allows for the use of an abstracted DAC. This means that no extra logic is needed if the user's dac_external module implements the FSP DAC interface, so the application no longer depends upon hard-coded module function names. Instead the application now depends on the DAC interface API which can be implemented by any number of modules.</p>
<div class="image">
<object type="image/svg+xml" data="figure-fsp-dac-interface.svg">figure-fsp-dac-interface.svg</object>
<div class="caption">
DAC Interface</div></div>
 <h3><a class="anchor" id="fsp-instance-structure"></a>
FSP Interface Instance Structure</h3>
<p>Every FSP interface also has an instance structure. The instance structure encapsulates everything required to use the module:</p>
<ul>
<li>A pointer to the instance API structure (<a class="el" href="_f_s_p__a_r_c_h_i_t_e_c_t_u_r_e.html#fsp-instance-api">FSP Instance API</a>)</li>
<li>A pointer to the configuration structure</li>
<li>A pointer to the control structure</li>
</ul>
<p>The instance structure is not required at the application layer. It is used to connect modules to their dependencies (other than the BSP).</p>
<p>Instance structures have a standardized name of <code>&lt;interface&gt;_instance_t</code>. An example from the <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html">Transfer Interface</a> is shown below.</p>
 <div class="fragment"><div class="line">typedef struct st_transfer_instance</div><div class="line">{</div><div class="line">    transfer_ctrl_t      * p_ctrl;     ///&lt; Pointer to the control structure for this instance</div><div class="line">    transfer_cfg_t const * p_cfg;      ///&lt; Pointer to the configuration structure for this instance</div><div class="line">    transfer_api_t const * p_api;      ///&lt; Pointer to the API structure for this instance</div><div class="line">} transfer_instance_t;</div></div><!-- fragment --></p>
<p>Note that when an instance structure variable is declared, the API is the only thing that is instance specific, not <em>module instance</em> specific. This is because all module instances of the same module share the same underlying module source code. If SPI is being used on SCI channels 0 and 2 then both module instances use the same API while the configuration and control structures are typically different.</p>
<h1><a class="anchor" id="fsp-instances"></a>
FSP Instances</h1>
<p>While interfaces dictate the features that are provided, instances actually implement those features. Each instance is tied to a specific interface. Instances use the enumerations, data structures, and API prototypes from the interface. This allows an application that uses an interface to swap out the instance when needed.</p>
<p>On RA MCUs some peripherals are used to implement multiple interfaces. In the example below the IIC and SPI peripherals map to only one interface each while the SCI peripheral implements three interfaces.</p>
<div class="image">
<object type="image/svg+xml" data="figure-fsp-interface-implementation-example.svg">figure-fsp-interface-implementation-example.svg</object>
<div class="caption">
Instances</div></div>
<p> In FSP design, instances consist of the interface extension and API defined in the instance header file located in the folder <code>ra/fsp/inc/instances</code> and the module source <code>ra/fsp/src/&lt;module&gt;</code>.</p>
<h2><a class="anchor" id="control-structure"></a>
FSP Instance Control Structure</h2>
<p>The control structure is used as a unique identifier for the module instance and contains memory required by the module. Elements in the control structure are owned by the module and <em>must not be modified</em> by the application. The user allocates storage for a control structure, often as a global variable, then sends a pointer to it into the <code>&lt;MODULE&gt;_Open()</code> call for a module. At this point, the module initializes the structure as needed. The user must then send in a pointer to the control structure for all subsequent module calls.</p>
<h2><a class="anchor" id="fsp-interface-extensions"></a>
FSP Interface Extensions</h2>
<p>In some cases, instances require more information than is provided in the interface. This situation can occur in the following cases:</p>
<ul>
<li>An instance offers extra features that are not common to most instances of the interface. An example of this is the start source selection of the GPT (<a class="el" href="group___g_p_t.html">Timer, General PWM (r_gpt)</a>). The GPT can be configured to start based on hardware events such as a falling edge on a trigger pin. This feature is not common to all timers, so it is included in the GPT instance.</li>
<li>An interface must be very generic out of necessity. As an interface becomes more generic, the number of possible instances increases. An example of an interface that must be generic is a block media interface that abstracts functions required by a file system. Possible instances include SD card, SPI Flash, SDRAM, USB, and many more.</li>
</ul>
<p>The <code>p_extend</code> member provides this extension function.</p>
<p>Use of interface extensions is not always necessary. Some instances do not offer an extension since all functionality is provided in the interface. In these cases the <code>p_extend</code> member can be set to NULL. The documentation for each instance indicates whether an interface extension is available and whether it is mandatory or optional.</p>
<h3><a class="anchor" id="fsp-extended-configuration-structure"></a>
FSP Extended Configuration Structure</h3>
<p>When extended configuration is required it can be supplied through the <code>p_extend</code> parameter of the interface configuration structure.</p>
<p>The extended configuration structure is part of the instance, but it is also still considered to be part of the configuration structure. All usage notes about the configuration structure described in <a class="el" href="_f_s_p__a_r_c_h_i_t_e_c_t_u_r_e.html#fsp-interface-configuration-structure">FSP Interface Configuration Structure</a> apply to the extended configuration structure as well.</p>
<p>The extended configuration structure and all typed structures and enumerations required to define it make up the interface extension.</p>
<h2><a class="anchor" id="fsp-instance-api"></a>
FSP Instance API</h2>
<p>Each instance includes a constant global variable tying the interface API functions to the functions provided by the module. The name of this structure is standardized as <code>g_&lt;interface&gt;_on_&lt;instance&gt;</code>. Examples include g_spi_on_spi, g_transfer_on_dtc, and g_adc_on_adc. This structure is available to be used through an extern in the instance header file (r_spi.h, r_dtc.h, and r_adc.h respectively).</p>
<h1><a class="anchor" id="fsp-api-standards"></a>
FSP API Standards</h1>
<h2><a class="anchor" id="fsp-function-names"></a>
FSP Function Names</h2>
<p>FSP functions start with the uppercase module name (<code>&lt;MODULE&gt;</code>). All modules have <code>&lt;MODULE&gt;_Open()</code> and <code>&lt;MODULE&gt;_Close()</code> functions. The <code>&lt;MODULE&gt;_Open()</code> function must be called before any of the other functions.</p>
<p>Other functions that will commonly be found are <code>&lt;MODULE&gt;_Read()</code>, <code>&lt;MODULE&gt;_Write()</code>, <code>&lt;MODULE&gt;_InfoGet()</code>, and <code>&lt;MODULE&gt;_StatusGet()</code>. The <code>&lt;MODULE&gt;_StatusGet()</code> function provides a status that could change asynchronously, while <code>&lt;MODULE&gt;_InfoGet()</code> provides information that cannot change after open or can only be updated by API calls. Example function names include:</p>
<ul>
<li><a class="el" href="group___s_p_i.html#ga9427801ef2c771a88fad0ab4524d7d42">R_SPI_Read()</a>, <a class="el" href="group___s_p_i.html#ga97b928cbe1a9df78d4ab5ff69732dbcd">R_SPI_Write()</a>, <a class="el" href="group___s_p_i.html#ga459fb4dfcfc9ee278599ae431237f549">R_SPI_WriteRead()</a></li>
<li><a class="el" href="group___s_d_h_i.html#ga6bebd1e0295bac31b76888d4fca94f90">R_SDHI_StatusGet()</a></li>
<li><a class="el" href="group___r_t_c.html#ga5c39b02432cedcb7a29ae8bdc8fcefb8">R_RTC_CalendarAlarmSet()</a>, <a class="el" href="group___r_t_c.html#gacbb2641ed2236f071c001df6b025e0f2">R_RTC_CalendarAlarmGet()</a></li>
<li><a class="el" href="group___f_l_a_s_h___h_p.html#ga27c1c44f16fac40b8258696a88929f80">R_FLASH_HP_AccessWindowSet()</a>, <a class="el" href="group___f_l_a_s_h___h_p.html#ga0d274fe4ee10e0aba086d6dd2baad8a9">R_FLASH_HP_AccessWindowClear()</a></li>
</ul>
<h2><a class="anchor" id="use-of-const-in-api-parameters"></a>
Use of const in API parameters</h2>
<p>The <code>const</code> qualifier is used with API parameters whenever possible. An example case is shown below.</p>
 <div class="fragment"><div class="line">fsp_err_t R_FLASH_HP_Open(flash_ctrl_t * const p_api_ctrl, flash_cfg_t const * const p_cfg);</div></div><!-- fragment --></p>
<p>In this example, <code><a class="el" href="group___f_l_a_s_h___a_p_i.html#structflash__cfg__t">flash_cfg_t</a></code> is a structure of configuration parameters for the r_flash_hp module. The parameter <code>p_cfg</code> is a pointer to this structure. The first <code>const</code> qualifier on <code>p_cfg</code> ensures the <code><a class="el" href="group___f_l_a_s_h___a_p_i.html#structflash__cfg__t">flash_cfg_t</a></code> structure cannot be modified by <a class="el" href="group___f_l_a_s_h___h_p.html#ga3c593b353cc97d311fb599142b05dc65">R_FLASH_HP_Open()</a>. This allows the structure to be allocated as a const variable and stored in ROM instead of RAM.</p>
<p>The <code>const</code> qualifier after the pointer star for both <code>p_ctrl</code> and <code>p_cfg</code> ensures the FSP function does not modify the input pointer addresses. While not fool-proof by any means this does provide some extra checking inside the FSP code to ensure that arguments that should not be altered are treated as such.</p>
<h2><a class="anchor" id="fsp-version-information"></a>
FSP Version Information</h2>
<p>The BSP provides a function <code><a class="el" href="group___b_s_p___m_c_u.html#gaf3ee66233fc75acfcc21a97d7a767aa1">R_FSP_VersionGet()</a></code> which fills in a structure of type <code><a class="el" href="group___r_e_n_e_s_a_s___c_o_m_m_o_n.html#unionfsp__pack__version__t">fsp_pack_version_t</a></code>. This can be used to determine the FSP version at runtime.</p>
<p>There are also <code>FSP_VERSION_*</code> macros in fsp_version.h that can be used to determine the FSP version at build time.</p>
<h1><a class="anchor" id="fsp-build-time-configurations"></a>
FSP Build Time Configurations</h1>
<p>All modules have a build-time configuration header file. Most configuration options are supplied at run time, though options that are rarely used or apply to all instances of a module may be moved to build time. The advantage of using a build-time configuration option is to potentially reduce code size reduction by removing an unused feature.</p>
<p>All modules have a build time option to enable or disable parameter checking for the module. FSP modules check function arguments for validity when possible, though this feature is disabled by default to reduce code size. Enabling it can help catch parameter errors during development and debugging. By default, each module's parameter checking configuration inherits the BSP parameter checking setting (set on the BSP tab of the RA Configuration editor). Leaving each module's parameter checking configuration set to Default (BSP) allows parameter checking to be enabled or disabled globally in all FSP code through the parameter checking setting on the BSP tab.</p>
<p>If an error condition can reasonably be avoided it is only checked in a section of code that can be disabled by disabling parameter checking. Most FSP APIs can only return FSP_SUCCESS if parameter checking is disabled. An example of an error that cannot be reasonably avoided is the "bus busy" error that occurs when another master is using an I2C bus. This type of error can be returned even if parameter checking is disabled.</p>
<h1><a class="anchor" id="fsp-file-structure"></a>
FSP File Structure</h1>
<p>The high-level file structure of an FSP project is shown below.</p>
<div class="fragment"><div class="line">ra_gen</div><div class="line"></div><div class="line">ra</div><div class="line"></div><div class="line">+---fsp</div><div class="line"></div><div class="line">    +---inc</div><div class="line"></div><div class="line">    |   +---api</div><div class="line"></div><div class="line">    |   \---instances</div><div class="line"></div><div class="line">    \---src</div><div class="line"></div><div class="line">        +---bsp</div><div class="line"></div><div class="line">        \---r_module</div><div class="line"></div><div class="line">ra_cfg</div><div class="line"></div><div class="line">+---fsp_cfg</div><div class="line"></div><div class="line">    +---bsp</div><div class="line"></div><div class="line">    +---driver</div></div><!-- fragment --><p>Directly underneath the base <code>ra</code> folder the folders are split into the source and include folders. Include folders are kept separate from the source for easy browsing and easy setup of include paths.</p>
<p>The <code>ra_gen</code> folder contains code generated by the RA Configuration editor. This includes global variables for the control structure and configuration structure for each module.</p>
<p>The <code>ra_cfg</code> folder is where configuration header files are stored for each module. See <a class="el" href="_f_s_p__a_r_c_h_i_t_e_c_t_u_r_e.html#fsp-build-time-configurations">FSP Build Time Configurations</a> for information on what is provided in these header files.</p>
<h1><a class="anchor" id="fsp-trustzone-support"></a>
FSP TrustZone Support</h1>
<p>TrustZone support for FSP is primarily handled in the RA Configuration Tool.</p>
<h2><a class="anchor" id="fsp-trustzone-projects"></a>
FSP TrustZone Projects</h2>
<p>During development of a TrustZone project, users create an RA TrustZone Secure Project first, followed by an RA TrustZone Non-secure Project that is linked to the RA TrustZone Secure Project. Allocation of secure memory is handled automatically within the tooling. The non-secure project starts at the required alignment boundary beyond the memory taken by the secure project.</p>
<h2><a class="anchor" id="fsp-trustzone-nsc-guard-functions"></a>
Non-Secure Callable Guard Functions</h2>
<p>The tooling generates guard functions for any module marked as Non-secure Callable. These guard functions are owned by the application once generated, so they can be modified as necessary by the secure application developer.</p>
<p>The default non-secure callable guard functions limit the configuration and control structure to the structures generated in the secure project. They also check any input pointers to ensure the caller does not overwrite secure memory.</p>
<h2><a class="anchor" id="fsp-trustzone-callback-to-non-secure"></a>
Callbacks in Non-Secure from Non-Secure Callable Modules</h2>
<p>If the non-secure project needs a callback function from a non-secure callable module, the callback can be registered after the module is opened using the callback_set() guard function.</p>
<h2><a class="anchor" id="fsp-trustzone-project-migration"></a>
Migrating TrustZone Project to newer FSP Version</h2>
<p>The TrustZone projects can be migrated to newer FSP version as mentioned in the following resource.</p>
<ul>
<li><a href="https://www.renesas.com/us/en/document/apn/migrating-projects-new-fsp-version">Migrating Projects to New FSP Version</a> (Application Note)</li>
</ul>
<p>Additional steps are required if newer FSP version introduces new guard function. In such case, simply migrating the project would result in the build failure for non secure project. Following extra steps are required:</p>
<ul>
<li>If xxx_guard.c file in src folder of secure project was not modified earlier<ol type="1">
<li>Delete the xxx_guard.c file in secure project before generating the Project Files.</li>
<li>Generate Project contents and build the secure project.</li>
<li>Follow the steps in Application Note to migrate the Non-Secure project.</li>
</ol>
</li>
<li>If xxx_guard.c file in src folder of secure project was modified earlier<ol type="1">
<li>Take the backup of existing xxx_guard.c file and delete it from src folder of secure project before generating the Project Files.</li>
<li>Generate Project contents. It creates a new guard.c file. Compare the contents of the older file and newly generated guard.c file.</li>
<li>Copy the modified code from the older file (i.e Security checks added by user) and add it to newly generated file.</li>
<li>Follow the steps in Application Note to migrate the Non-Secure project.</li>
</ol>
</li>
</ul>
<h2><a class="anchor" id="additional-trustzone-information"></a>
Additional TrustZone Information</h2>
<p>The following resources provide technical background, application notes and example projects that demonstrate key TrustZone concepts and implementation procedures.</p>
<ul>
<li><a href="https://www.renesas.com/us/en/document/whp/benefits-using-arm-trustzone-your-design">The Benefits of Using Arm® TrustZone® in Your Design</a> (Brochure)</li>
<li><a href="https://www.renesas.com/us/en/document/apn/ra-arm-trustzone-tooling-primer">RA Arm® TrustZone® Tooling Primer</a> (Application Note)</li>
<li><a href="https://www.renesas.com/us/en/document/scd/renesas-ra-family-security-design-arm-trustzone-ip-protection">Renesas RA Family Security Design with Arm® TrustZone® - IP Protection</a> (Application Note)</li>
<li><a href="https://www.renesas.com/us/en/document/apn/renesas-ra-securing-data-rest-using-arm-trustzone">Renesas RA Family Securing Data at Rest Using the Arm® TrustZone®</a> (Application Note)</li>
</ul>
<h1><a class="anchor" id="fsp-architecture-in-practice"></a>
FSP Architecture in Practice</h1>
<h2><a class="anchor" id="fsp-connecting-layers"></a>
FSP Connecting Layers</h2>
<p>FSP modules are meant to be both reusable and stackable. It is important to remember that modules are not dependent upon other modules, but upon other interfaces. The user is then free to fulfill the interface using the instance that best fits their needs.</p>
<div class="image">
<object type="image/svg+xml" data="figure-fsp-interface-dependency-connection.svg">figure-fsp-interface-dependency-connection.svg</object>
<div class="caption">
Connecting layers</div></div>
<p> In the image above interface Y is a dependency of interface X and has its own dependency on interface Z. Interface X only has a dependency on interface Y. Interface X has no knowledge of interface Z. This is a requirement for ensuring that layers can easily be swapped out.</p>
<h2><a class="anchor" id="using-fsp-modules-in-an-application"></a>
Using FSP Modules in an Application</h2>
<p>The typical use of an FSP module involves generating required module data then using the API in the application.</p>
<h3><a class="anchor" id="create-a-module-instance"></a>
Create a Module Instance in the RA Configuration Editor</h3>
<p>The RA Configuration editor (available both in the Renesas e&sup2; studio IDE as well as through the standalone RA Smart Configurator) provides a graphical user interface for setting the parameters of the interface and instance configuration structures. It also automatically includes those structures (once they are configured in the GUI) in application-specific header files that can be included in application code.</p>
<p>The RA Configuration editor allocates storage for the control structures, all required configuration structures, and the instance structure in generated files in the <code>ra_gen</code> folder. Use the <b>Properties</b> window to set the values for the members of the configuration structures as needed. Refer to the Configuration section of the module usage notes for documentation about the configuration options.</p>
<p>If the interface has a callback function option then the application must declare and define the function. The return value is always of type <code>void</code> and the parameter to the function is a typed structure of name <code>&lt;interface&gt;_callback_args_t</code>. Once the function has been defined, assign its name to the <code>p_callback</code> member of the configuration structure. Callback function names can be assigned through the <b>Properties</b> window for the selected module.</p>
<h3><a class="anchor" id="use-the-instance-api"></a>
Use the Instance API in the Application</h3>
<p>Call the module's <code>&lt;MODULE&gt;_Open()</code> function. Pass pointers to the generated control structure and configuration structure. The names of these structures are based on the 'Name' field provided in the configuration editor. The control structure is <code>&lt;Name&gt;_ctrl</code> and the configuration structure is <code>&lt;Name&gt;_cfg</code>. An example <code>&lt;MODULE&gt;_Open()</code> call for an r_rtc module instance named <code>g_clock</code> is:</p>
<div class="fragment"><div class="line"></div><div class="line">    <a class="code" href="group___r_t_c.html#gae6b2cd0b0827d0fdef1dd148ddc354bb">R_RTC_Open</a>(&amp;g_clock_ctrl, &amp;g_clock_cfg);</div><div class="line"></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Each layer in the FSP Stack is responsible for calling the API functions of its dependencies. This means that users are only responsible for calling the API functions at the layer at which they are interfacing. Using the example above of a SPI module with a DTC dependency, the application uses only SPI APIs. The application starts by calling <a class="el" href="group___s_p_i.html#ga4c30ef8817407bd4b394ee9cc8b90a0b">R_SPI_Open()</a>. Internally, the SPI module opens the DTC. It locates <a class="el" href="group___d_t_c.html#gad2bd9d74b22d0f3e109130385ac8904e">R_DTC_Open()</a> by accessing the dependent transfer interface function pointers from the pointers DTC instances (<a class="el" href="group___s_p_i___a_p_i.html#a312e4358f12551a3f7aaa5f0a09c0501" title="To use SPI DTC/DMAC write transfer, link a transfer instance here. Set to NULL if unused...">spi_cfg_t::p_transfer_tx</a> and <a class="el" href="group___s_p_i___a_p_i.html#ab38fb6af687bdf7e0ea9143499849bc6" title="To use SPI DTC/DMAC read transfer, link a transfer instance here. Set to NULL if unused. ">spi_cfg_t::p_transfer_rx</a>) to open the DTC.</dd></dl>
<p>Refer to the module usage notes for example code to help get started with any particular module. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v6.2.0 User's Manual Copyright © (2025) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
