<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: FileX I/O (rm_filex_levelx_nor)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
    $(document).ready(function() {
        $("tr.tree_lvl_1").nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
		$("tr.tree_lvl_1").data("expanded","0");
		$("tr.tree_lvl_2").data("expanded","0");
		$("tr.tree_lvl_3").data("expanded","0");
		$("tr.tree_lvl_4").data("expanded","0");
		$("tr.tree_lvl_5").data("expanded","0");
        $("tr.tree_lvl_1").click(function() {
		    var lvl_1_is_open = $(this).data("expanded");
		    if (lvl_1_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2, tr.tree_lvl_1_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_2").click(function() {
		    var lvl_2_is_open = $(this).data("expanded");
		    if (lvl_2_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3, tr.tree_lvl_2_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_3").click(function() {
		    var lvl_3_is_open = $(this).data("expanded");
		    if (lvl_3_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_3_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_4").click(function() {
		    var lvl_4_is_open = $(this).data("expanded");
		    if (lvl_4_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5, tr.tree_lvl_4_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_5").click(function() {
		    var lvl_5_is_open = $(this).data("expanded");
		    if (lvl_5_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4_item,tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
     });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v6.2.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">

    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text">
      </span>
      <span class="right">
          &nbsp;
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___r_m___f_i_l_e_x___l_e_v_e_l_x___n_o_r.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body.
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len));
            }
          }
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element.
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">FileX I/O (rm_filex_levelx_nor)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___s_t_o_r_a_g_e___m_o_d_u_l_e_s.html">Storage</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4f300fdb7b384b42d19f71322f4386d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___f_i_l_e_x___l_e_v_e_l_x___n_o_r.html#ga4f300fdb7b384b42d19f71322f4386d5">RM_FILEX_LEVELX_NOR_DeviceDriver</a> (FX_MEDIA *p_fx_media)</td></tr>
<tr class="memdesc:ga4f300fdb7b384b42d19f71322f4386d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access LevelX NOR device functions open, close, read, write and control.  <a href="#ga4f300fdb7b384b42d19f71322f4386d5">More...</a><br /></td></tr>
<tr class="separator:ga4f300fdb7b384b42d19f71322f4386d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Middleware for the Azure RTOS FileX File System control using LevelX NOR on RA MCUs. </p>
<h1><a class="anchor" id="rm-filex-levelx-nor-overview"></a>
Overview</h1>
<p>This module provides the hardware port layer for FileX file system. After initializing this module, refer to the FileX API reference to use the file system: <a href="https://docs.microsoft.com/en-us/azure/rtos/filex/">https://docs.microsoft.com/en-us/azure/rtos/filex/</a></p>
<h2><a class="anchor" id="rm-filex-levelx-nor-features"></a>
Features</h2>
<p>The FileX LevelX NOR module supports the following features:</p><ul>
<li>ThreadX is typically required for FileX. To use FileX without ThreadX FX_STANDALONE_ENABLE must be defined.</li>
<li>Unless FX_SINGLE_THREAD or FX_STANDALONE_ENABLE are defined, all FileX operations are thread safe.<a class="anchor" id="um_rm_filex_thread_safe"></a> </li>
</ul>
<h1><a class="anchor" id="rm-filex-levelx-nor-configurations"></a>
Configuration</h1>
<p><h2>Build Time Configurations for rm_filex_levelx_nor</h2>
The following build time configurations are defined in fsp_cfg/middleware/rm_filex_levelx_nor_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>Selects if code for parameter checking is to be included in the build. </td></tr>
</table>
 <h2>Configurations for Storage &gt; FileX I/O (rm_filex_levelx_nor)</h2>
<table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Name</td><td>Name must be a valid C symbol</td><td>g_rm_filex_levelx_nor0 </td><td>Module name. </td></tr>
<tr class="tree_none">
<td>Callback</td><td>Name must be a valid C symbol</td><td>g_rm_filex_levelx_nor_0_callback </td><td>A user callback function can be provided. If this callback function is provided, it will be called during operations by the lower level block media as a way for the user to provide their desired waiting functionality. </td></tr>
<tr class="tree_none">
<td>LevelX NOR Name (String)</td><td>Manual Entry</td><td>g_rm_filex_levelx_nor_0 </td><td>String name to be input into LevelX API. </td></tr>
</table>
 <h2>Build Time Configurations for fx</h2>
The following build time configurations are defined in fsp_cfg/azure/fx/fx_user.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Common  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Max Long Name Len</td><td>Value must be an integer greater than or equal to 13 and less than or equal to 256, or empty</td><td></td><td>Specifies the maximum file name size for FileX. If left blank the default value is 256. Legal values range between 13 and 256. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Max Last Name Len</td><td>Value must be an integer greater than or equal to 13 and less than or equal to 256, or empty</td><td></td><td>This value defines the maximum file name length, which includes full path name. If left blank the default value is 256. Legal values range between 13 and 256. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Max Sector Cache</td><td>Value must be an integer greater than 0 and power of 2 or empty</td><td></td><td>Specifies the maximum number of logical sectors that can be cached by FileX. The actual number of sectors that can be cached is lesser of this constant and how many sectors can fit in the amount of memory supplied at fx_media_open. The default value if left blank is 256. All values must be a power of 2. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Fat Map Size</td><td>Value must be an integer greater than 0 or empty</td><td></td><td>Specifies the number of sectors that can be represented in the FAT update map. The default value if left blank is 256. Larger values help reduce unneeded updates of secondary FAT sectors. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Max Fat Cache</td><td>Value must be an integer greater than 0 and power of 2 or empty</td><td></td><td>Specifies the number of entries in the internal FAT cache. The default value if left blank is 16. All values must be a power of 2. </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Threading  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Update Rate (Seconds)</td><td>Value must be an integer greater than 0 or empty</td><td></td><td>Specifies rate at which system time in FileX is adjusted. Default value if left blank is 10, specifying that the FileX system time is updated every 10 seconds. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">No Timer</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled (default)</li>
</ul>
</td><td>Disabled (default) </td><td>Eliminates the ThreadX timer setup to update the FileX system time and date. Doing so causes default time and date to be placed on all file operations. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Single Thread</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled (default)</li>
</ul>
</td><td>Disabled (default) </td><td>Eliminates ThreadX protection logic from the FileX source. It should be used if FileX is being used only from one thread. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Standalone</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled (default)</li>
</ul>
</td><td>Disabled (default) </td><td>Enables FileX to be used in standalone mode (without Azure RTOS). </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Extra Features  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Don't Update Open Files</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled (default)</li>
</ul>
</td><td>Disabled (default) </td><td>When enabled, FileX does not update already opened files. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Media Search Cache</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (default)</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled (default) </td><td>When disabled, the file search cache optimization is disabled. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Direct Data Read Cache Fill</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (default)</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled (default) </td><td>When disabled, the direct read sector update of cache is disabled. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Media Statistics</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (default)</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled (default) </td><td>When disabled, gathering of media statistics is disabled. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Single Open Legacy</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled (default)</li>
</ul>
</td><td>Disabled (default) </td><td>When enabled, legacy single open logic for the same file is enabled. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Rename Path Inherit</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled (default)</li>
</ul>
</td><td>Disabled (default) </td><td>When enabled, renaming inherits path information. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">No Local Path</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled (default)</li>
</ul>
</td><td>Disabled (default) </td><td>When enabled, removes local path logic from FileX, resulting in smaller code size. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">64-bit LBA</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled (default)</li>
</ul>
</td><td>Disabled (default) </td><td>When enabled, 64-bits sector addresses are used in I/O driver. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Cache</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (default)</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled (default) </td><td>Enables or disables the cache, default is enabled. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">File Close</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (default)</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled (default) </td><td>Enables or disables file close, default is enabled. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Fast Close</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (default)</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled (default) </td><td>Enables or disables fast open, default is enabled. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Force Memory Operation</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (default)</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled (default) </td><td>Enables or disables force memory operation, default is enabled. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Build Options</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (default)</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled (default) </td><td>Enables or disables build options, default is enabled. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">One Line Function</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (default)</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled (default) </td><td>Enables or disables one line function, default is enabled. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">FAT Entry Refresh</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (default)</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled (default) </td><td>Enables or disables FAT entry refresh, default is enabled. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Consecutive Detect</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (default)</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled (default) </td><td>Enables or disables consecutive detect, default is enabled. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Enable exFAT</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled (default)</li>
</ul>
</td><td>Disabled (default) </td><td>Enables exFAT support in FileX. </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Fault Tolerant  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Fault Tolerant Service</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled (default)</li>
</ul>
</td><td>Disabled (default) </td><td>When enabled, enables the FileX Fault Tolerant Module. Enabling Fault Tolerant automatically defines the symbol FX_FAULT_TOLERANT and FX_FAULT_TOLERANT_DATA. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Fault Tolerant Data</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled (default)</li>
</ul>
</td><td>Disabled (default) </td><td>When enabled, FileX immediately passes all file data write requests to the media's driver. This potentially decreases performance, but helps limit lost file data. Note that enabling this feature does not automatically enable FileX Fault Tolerant Module, which should be enabled separately. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Fault Tolerant</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled (default)</li>
</ul>
</td><td>Disabled (default) </td><td>When enabled, FileX immediately passes write requests of all system sectors (boot, FAT, and directory sectors) to the media's driver. This potentially decreases performance, but helps limit corruption to lost clusters. Note that enabling this feature does not automatically enable FileX Fault Tolerant Module, which should be enabled separately. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Fault Tolerant Boot Index</td><td>Value must be an integer greater than or equal to 116 and less than or equal to 119</td><td></td><td>Defines byte offset in the boot sector where the cluster for the fault tolerant log is. By default if left blank this value is 116. This field takes 4 bytes. Bytes 116 through 119 are chosen because they are marked as reserved by FAT 12/16/32/exFAT specification. </td></tr>
<tr class="tree_none">
<td>Error Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (default)</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled (default) </td><td></td></tr>
</table>
 <h2>Configurations for Storage &gt; Azure RTOS FileX on LevelX NOR</h2>
This module can be added to the Stacks tab via New Stack &gt; Storage &gt; Azure RTOS FileX on LevelX NOR.<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Name</td><td>Name must be a valid C symbol</td><td>g_fx_media0 </td><td>Symbol used for media_ptr parameter in FileX APIs </td></tr>
<tr class="tree_none">
<td>Volume Name</td><td>Name must be a maximum of 11 characters</td><td>Volume 1 </td><td>Volume name string, which is a maximum of 11 characters. </td></tr>
<tr class="tree_none">
<td>Number of FATs</td><td>Number of FATs must be an integer greater than 0</td><td>1 </td><td>Number of FATs in the media. The minimal value is 1 for the primary FAT. Values greater than 1 result in additional FAT copies being maintained at run-time. </td></tr>
<tr class="tree_none">
<td>Directory Entries</td><td>Number of Directory Entries must be an integer greater than 0</td><td>256 </td><td>Number of directory entries in the root directory. </td></tr>
<tr class="tree_none">
<td>Hidden Sectors</td><td>Number of Hidden Sectors must be an integer</td><td>0 </td><td>Number of sectors hidden before this media’s boot sector. If using media formatted with multiple partitions this number should correspond to the starting block number for the desired partition. </td></tr>
<tr class="tree_none">
<td>Total Sectors</td><td>Total Sectors must be an integer greater than 0</td><td>57337 </td><td>Total number of sectors in the media. When using a Renesas provided block media implementation, total sectors can be fetched by the infoGet from the block media API. Any removable media must be inserted and initialized first to retrieve this info. </td></tr>
<tr class="tree_none">
<td>Sectors per Cluster</td><td>Sectors per Cluster must be an integer greater than 0</td><td>1 </td><td>Number of sectors in each cluster. The cluster is the minimum allocation unit in a FAT file system. </td></tr>
<tr class="tree_none">
<td>Volume Serial Number (exFAT only)</td><td>Volume Serial Number must be an integer greater than 0</td><td>12345 </td><td>Serial number to be used for this volume. exFAT only. </td></tr>
<tr class="tree_none">
<td>Boundary Unit (exFAT only)</td><td>Boundary unit must be an integer greater than 0</td><td>128 </td><td>Physical data area alignment size, in number of sectors. exFAT only. </td></tr>
<tr class="tree_none">
<td>Working media memory size</td><td>Memory size must be an integer greater than or equal to the size of one sector</td><td>512 </td><td>Memory allocated for file system. Memory size must be an integer greater than or equal to the size of one sector. </td></tr>
</table>
</p>
<h1><a class="anchor" id="rm-filex-levelx-nor-usage-notes"></a>
Usage Notes</h1>
<h2>Pending during Write/Erase</h2>
<p>If the underlying LevelX NOR driver performs a blocking operation that requires waiting to complete (such as a long write/erase on NOR SPI), a callback can be provided to provide a way to wait with an OS-specific thread wait. This callback will also pass up block erase events.</p>
<h2>Partitioned Media</h2>
<p>Partitioned media is not supported directly by the FileX LevelX NOR port.<a class="anchor" id="um_rm_filex_multiple_partitions"></a> </p>
<h1><a class="anchor" id="rm-filex-levelx-nor-examples"></a>
Examples</h1>
<h2>Basic Example</h2>
<p>This is a basic example of FileX Block Media in an application.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define RM_FILEX_LEVELX_NOR_EXAMPLE_FILE_NAME                &quot;TEST_FILE.txt&quot;</span></div><div class="line"><span class="preprocessor">#define RM_FILEX_LEVELX_NOR_EXAMPLE_BUFFER_SIZE_BYTES        (10240)</span></div><div class="line"><span class="preprocessor">#define RM_FILEX_LEVELX_NOR_EXAMPLE_PARTITION_NUMBER         (0)</span></div><div class="line"><span class="preprocessor">#define RM_FILEX_LEVELX_NOR_EXAMPLE_BLOCK_SIZE               (512)</span></div><div class="line"><span class="preprocessor">#define RM_FILEX_LEVELX_NOR_EXAMPLE_NUM_DIRECTORY_ENTRIES    (128)</span></div><div class="line"><span class="preprocessor">#define RM_FILEX_LEVELX_NOR_EXAMPLE_NUM_FATS                 (1)</span></div><div class="line"><span class="preprocessor">#define RM_FILEX_LEVELX_NOR_EXAMPLE_HIDDEN_SECTORS           (0)</span></div><div class="line"><span class="preprocessor">#define RM_FILEX_LEVELX_NOR_EXAMPLE_TOTAL_SECTORS            (512)</span></div><div class="line"><span class="preprocessor">#define RM_FILEX_LEVELX_NOR_EXAMPLE_SECTOR_SIZE              (512)</span></div><div class="line"><span class="preprocessor">#define RM_FILEX_LEVELX_NOR_EXAMPLE_SECTORS_PER_CLUSTER      (1)</span></div><div class="line"><span class="preprocessor">#define RM_FILEX_LEVELX_NOR_EXAMPLE_NUM_HEADS                (1)</span></div><div class="line"><span class="preprocessor">#define RM_FILEX_LEVELX_NOR_EXAMPLE_SECTORS_PER_TRACK        (1)</span></div><div class="line"></div><div class="line"><span class="keyword">extern</span> <a class="code" href="group___r_m___f_i_l_e_x___l_e_v_e_l_x___n_o_r.html#structrm__filex__levelx__nor__instance__t">rm_filex_levelx_nor_instance_t</a>      g_filex_levelx_nor0;</div><div class="line"><span class="keyword">extern</span> <a class="code" href="group___r_m___f_i_l_e_x___l_e_v_e_l_x___n_o_r.html#structrm__filex__levelx__nor__instance__ctrl__t">rm_filex_levelx_nor_instance_ctrl_t</a> g_filex_levelx_nor0_ctrl;</div><div class="line"><span class="keyword">extern</span> <a class="code" href="group___r_m___f_i_l_e_x___l_e_v_e_l_x___n_o_r.html#structrm__filex__levelx__nor__cfg__t">rm_filex_levelx_nor_cfg_t</a>           g_filex_levelx_nor0_cfg;</div><div class="line"></div><div class="line"><span class="keyword">extern</span> FX_MEDIA g_fx_media0;</div><div class="line"><span class="keyword">extern</span> uint8_t  g_fx_media0_memory[RM_FILEX_LEVELX_NOR_EXAMPLE_BLOCK_SIZE];</div><div class="line"><span class="keyword">extern</span> uint8_t  g_file_data[RM_FILEX_LEVELX_NOR_EXAMPLE_BUFFER_SIZE_BYTES];</div><div class="line"><span class="keyword">extern</span> uint8_t  g_read_buffer[RM_FILEX_LEVELX_NOR_EXAMPLE_BUFFER_SIZE_BYTES];</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> rm_filex_levelx_nor_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Initialize FileX */</span></div><div class="line">    fx_system_initialize();</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize LevelX */</span></div><div class="line">    lx_nor_flash_initialize();</div><div class="line"></div><div class="line">    <span class="comment">/* Open the media. This assumes the flash is already formatted. */</span></div><div class="line">    UINT fx_err = fx_media_open(&amp;g_fx_media0,</div><div class="line">                                <span class="stringliteral">&quot;filex_example_media&quot;</span>,</div><div class="line">                                <a class="code" href="group___r_m___f_i_l_e_x___l_e_v_e_l_x___n_o_r.html#ga4f300fdb7b384b42d19f71322f4386d5">RM_FILEX_LEVELX_NOR_DeviceDriver</a>,</div><div class="line">                                &amp;g_filex_levelx_nor0,</div><div class="line">                                g_fx_media0_memory,</div><div class="line">                                <span class="keyword">sizeof</span>(g_fx_media0_memory));</div><div class="line">    handle_fx_error(fx_err);</div><div class="line"></div><div class="line">    <span class="comment">/* Create a file */</span></div><div class="line">    fx_err = fx_file_create(&amp;g_fx_media0, RM_FILEX_LEVELX_NOR_EXAMPLE_FILE_NAME);</div><div class="line">    handle_fx_error(fx_err);</div><div class="line"></div><div class="line">    <span class="comment">/* Open source file for writing. */</span></div><div class="line">    FX_FILE sourceFile;</div><div class="line">    fx_err = fx_file_open(&amp;g_fx_media0, &amp;sourceFile, RM_FILEX_LEVELX_NOR_EXAMPLE_FILE_NAME, FX_OPEN_FOR_WRITE);</div><div class="line">    handle_fx_error(fx_err);</div><div class="line"></div><div class="line">    <span class="comment">/* Write file data. */</span></div><div class="line">    fx_err = fx_file_write(&amp;sourceFile, g_file_data, <span class="keyword">sizeof</span>(g_file_data));</div><div class="line">    handle_fx_error(fx_err);</div><div class="line"></div><div class="line">    <span class="comment">/* Close the file. */</span></div><div class="line">    fx_err = fx_file_close(&amp;sourceFile);</div><div class="line">    handle_fx_error(fx_err);</div><div class="line"></div><div class="line">    <span class="comment">/* Open the source file in read mode. */</span></div><div class="line">    fx_err = fx_file_open(&amp;g_fx_media0, &amp;sourceFile, RM_FILEX_LEVELX_NOR_EXAMPLE_FILE_NAME, FX_OPEN_FOR_READ);</div><div class="line">    handle_fx_error(fx_err);</div><div class="line"></div><div class="line">    <span class="comment">/* Read file data. */</span></div><div class="line">    ULONG actual_size_read;</div><div class="line">    fx_err = fx_file_read(&amp;sourceFile, g_read_buffer, <span class="keyword">sizeof</span>(g_file_data), &amp;actual_size_read);</div><div class="line">    handle_fx_error(fx_err);</div><div class="line">    assert(<span class="keyword">sizeof</span>(g_file_data) == actual_size_read);</div><div class="line"></div><div class="line">    <span class="comment">/* Close the file. */</span></div><div class="line">    fx_err = fx_file_close(&amp;sourceFile);</div><div class="line">    handle_fx_error(fx_err);</div><div class="line"></div><div class="line">    <span class="comment">/* Verify the file data read matches the file written. */</span></div><div class="line">    assert(0U == memcmp(g_file_data, g_read_buffer, <span class="keyword">sizeof</span>(g_file_data)));</div><div class="line"></div><div class="line">    <span class="comment">/* Close the Media */</span></div><div class="line">    fx_err = fx_media_close(&amp;g_fx_media0);</div><div class="line">    handle_fx_error(fx_err);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Format Example</h2>
<p>This shows how to partition and format a disk if it is not already partitioned and formatted.</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <a class="code" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#structrm__levelx__nor__spi__cfg__t">rm_levelx_nor_spi_cfg_t</a> g_levelx_nor_spi0_cfg;</div><div class="line"><span class="preprocessor">#define RM_FILEX_LEVELX_NOR_EXAMPLE_SPI_SECTOR_SIZE    (4096)</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> rm_filex_levelx_nor_format_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__instance__t">spi_flash_instance_t</a> * p_spi_flash_instance = (<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__instance__t">spi_flash_instance_t</a> *) g_levelx_nor_spi0_cfg.<a class="code" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#a7dcadbcfcfa10de3673c1c008e35bfc5">p_lower_lvl</a>;</div><div class="line">    <a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__status__t">spi_flash_status_t</a>     status;</div><div class="line"></div><div class="line">    <span class="comment">/* Erase flash prior to usage */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = p_spi_flash_instance-&gt;<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#aa393a0e23c69a916e8c30e9dc4e5513b">p_api</a>-&gt;<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a75a4468493abb92f6bf484ed93718f6f">open</a>(p_spi_flash_instance-&gt;<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ab7cca7ee8e821effe8d7e8902e6a7514">p_ctrl</a>, p_spi_flash_instance-&gt;<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a74f26946c33e77fda5b6e2d26b2c9fee">p_cfg</a>);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (uint32_t i = g_levelx_nor_spi0_cfg.<a class="code" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#a6d6dc54ab7b793bc4c241956cf743a2d">address_offset</a>;</div><div class="line">         i &lt; g_levelx_nor_spi0_cfg.<a class="code" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#a28e980602115f51ad7b912d79d42015a">size</a>;</div><div class="line">         i += RM_FILEX_LEVELX_NOR_EXAMPLE_SPI_SECTOR_SIZE)</div><div class="line">    {</div><div class="line">        err = p_spi_flash_instance-&gt;<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#aa393a0e23c69a916e8c30e9dc4e5513b">p_api</a>-&gt;<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a4fb48ee9af80243cf7f8f966b4c6c56e">erase</a>(p_spi_flash_instance-&gt;<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ab7cca7ee8e821effe8d7e8902e6a7514">p_ctrl</a>,</div><div class="line">                                                 (uint8_t *) g_levelx_nor_spi0_cfg.<a class="code" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#a44e353ea1aa9280fe4ce369367a37b24">base_address</a> + i,</div><div class="line">                                                 RM_FILEX_LEVELX_NOR_EXAMPLE_SPI_SECTOR_SIZE);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">        status.write_in_progress = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">while</span> (status.write_in_progress)</div><div class="line">        {</div><div class="line">            err = p_spi_flash_instance-&gt;<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#aa393a0e23c69a916e8c30e9dc4e5513b">p_api</a>-&gt;<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a36600006109effd5c9d47283a7760ce6">statusGet</a>(p_spi_flash_instance-&gt;<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ab7cca7ee8e821effe8d7e8902e6a7514">p_ctrl</a>, &amp;status);</div><div class="line">            assert(FSP_SUCCESS == err);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    err = p_spi_flash_instance-&gt;<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#aa393a0e23c69a916e8c30e9dc4e5513b">p_api</a>-&gt;<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a28bdae798428b85222739a0b9fd43a15">close</a>(p_spi_flash_instance-&gt;<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ab7cca7ee8e821effe8d7e8902e6a7514">p_ctrl</a>);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Format the media */</span></div><div class="line">    UINT fx_err = fx_media_format(&amp;g_fx_media0,                                      <span class="comment">// Pointer to FileX media control block.</span></div><div class="line">                                  <a class="code" href="group___r_m___f_i_l_e_x___l_e_v_e_l_x___n_o_r.html#ga4f300fdb7b384b42d19f71322f4386d5">RM_FILEX_LEVELX_NOR_DeviceDriver</a>,                  <span class="comment">// Driver entry</span></div><div class="line">                                  &amp;g_filex_levelx_nor0,                              <span class="comment">// Pointer to Block Media Driver</span></div><div class="line">                                  g_fx_media0_memory,                                <span class="comment">// Media buffer pointer</span></div><div class="line">                                  <span class="keyword">sizeof</span>(g_fx_media0_memory),                        <span class="comment">// Media buffer size</span></div><div class="line">                                  <span class="stringliteral">&quot;EXAMPLE_VOLUME&quot;</span>,                                  <span class="comment">// Volume Name</span></div><div class="line">                                  RM_FILEX_LEVELX_NOR_EXAMPLE_NUM_FATS,              <span class="comment">// Number of FATs</span></div><div class="line">                                  RM_FILEX_LEVELX_NOR_EXAMPLE_NUM_DIRECTORY_ENTRIES, <span class="comment">// Directory Entries</span></div><div class="line">                                  RM_FILEX_LEVELX_NOR_EXAMPLE_HIDDEN_SECTORS,        <span class="comment">// Hidden sectors</span></div><div class="line">                                  RM_FILEX_LEVELX_NOR_EXAMPLE_TOTAL_SECTORS,         <span class="comment">// Total sectors</span></div><div class="line">                                  RM_FILEX_LEVELX_NOR_EXAMPLE_SECTOR_SIZE,           <span class="comment">// Sector size</span></div><div class="line">                                  RM_FILEX_LEVELX_NOR_EXAMPLE_SECTORS_PER_CLUSTER,   <span class="comment">// Sectors per cluster</span></div><div class="line">                                  RM_FILEX_LEVELX_NOR_EXAMPLE_NUM_HEADS,             <span class="comment">// Heads</span></div><div class="line">                                  RM_FILEX_LEVELX_NOR_EXAMPLE_SECTORS_PER_TRACK);    <span class="comment">// Sectors per track</span></div><div class="line">    handle_fx_error(fx_err);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Callback Wait Example</h2>
<p>This shows how to use the I/O driver callback with ThreadX in order to wait for operations to complete.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">/* Callback called by FileX block media I/O driver needs to wait on operation. */</span></div><div class="line"><span class="keywordtype">void</span> rm_filex_levelx_nor_test_callback_wait (<a class="code" href="group___r_m___f_i_l_e_x___l_e_v_e_l_x___n_o_r.html#structrm__filex__levelx__nor__callback__args__t">rm_filex_levelx_nor_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (p_args-&gt;<a class="code" href="group___r_m___f_i_l_e_x___l_e_v_e_l_x___n_o_r.html#a1d9f57cba943e15af2e622d03c75745d">event</a> &amp; <a class="code" href="group___r_m___f_i_l_e_x___l_e_v_e_l_x___n_o_r.html#gga50a68cde1290af62786375f06729908ba6bcb085314fab96ebee0c099d84d500c">RM_FILEX_LEVELX_NOR_EVENT_BUSY</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Put the thread to sleep while waiting for operation to complete. */</span></div><div class="line">        tx_thread_sleep(1);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> rm_filex_levelx_nor_callback_wait_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Format the media */</span></div><div class="line">    UINT fx_err = fx_media_format(&amp;g_fx_media0,                                      <span class="comment">// Pointer to FileX media control block.</span></div><div class="line">                                  <a class="code" href="group___r_m___f_i_l_e_x___l_e_v_e_l_x___n_o_r.html#ga4f300fdb7b384b42d19f71322f4386d5">RM_FILEX_LEVELX_NOR_DeviceDriver</a>,                  <span class="comment">// Driver entry</span></div><div class="line">                                  &amp;g_filex_levelx_nor0,                              <span class="comment">// Pointer to Block Media Driver</span></div><div class="line">                                  g_fx_media0_memory,                                <span class="comment">// Media buffer pointer</span></div><div class="line">                                  <span class="keyword">sizeof</span>(g_fx_media0_memory),                        <span class="comment">// Media buffer size</span></div><div class="line">                                  <span class="stringliteral">&quot;EXAMPLE_VOLUME&quot;</span>,                                  <span class="comment">// Volume Name</span></div><div class="line">                                  RM_FILEX_LEVELX_NOR_EXAMPLE_NUM_FATS,              <span class="comment">// Number of FATs</span></div><div class="line">                                  RM_FILEX_LEVELX_NOR_EXAMPLE_NUM_DIRECTORY_ENTRIES, <span class="comment">// Directory Entries</span></div><div class="line">                                  RM_FILEX_LEVELX_NOR_EXAMPLE_HIDDEN_SECTORS,        <span class="comment">// Hidden sectors</span></div><div class="line">                                  RM_FILEX_LEVELX_NOR_EXAMPLE_TOTAL_SECTORS,         <span class="comment">// Total sectors</span></div><div class="line">                                  RM_FILEX_LEVELX_NOR_EXAMPLE_SECTOR_SIZE,           <span class="comment">// Sector size</span></div><div class="line">                                  RM_FILEX_LEVELX_NOR_EXAMPLE_SECTORS_PER_CLUSTER,   <span class="comment">// Sectors per cluster</span></div><div class="line">                                  RM_FILEX_LEVELX_NOR_EXAMPLE_NUM_HEADS,             <span class="comment">// Heads</span></div><div class="line">                                  RM_FILEX_LEVELX_NOR_EXAMPLE_SECTORS_PER_TRACK);    <span class="comment">// Sectors per track</span></div><div class="line">    handle_fx_error(fx_err);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structrm__filex__levelx__nor__callback__args__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___f_i_l_e_x___l_e_v_e_l_x___n_o_r.html#structrm__filex__levelx__nor__callback__args__t">rm_filex_levelx_nor_callback_args_t</a></td></tr>
<tr class="separator:structrm__filex__levelx__nor__callback__args__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structrm__filex__levelx__nor__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___f_i_l_e_x___l_e_v_e_l_x___n_o_r.html#structrm__filex__levelx__nor__cfg__t">rm_filex_levelx_nor_cfg_t</a></td></tr>
<tr class="separator:structrm__filex__levelx__nor__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structrm__filex__levelx__nor__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___f_i_l_e_x___l_e_v_e_l_x___n_o_r.html#structrm__filex__levelx__nor__instance__ctrl__t">rm_filex_levelx_nor_instance_ctrl_t</a></td></tr>
<tr class="separator:structrm__filex__levelx__nor__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structrm__filex__levelx__nor__instance__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___f_i_l_e_x___l_e_v_e_l_x___n_o_r.html#structrm__filex__levelx__nor__instance__t">rm_filex_levelx_nor_instance_t</a></td></tr>
<tr class="separator:structrm__filex__levelx__nor__instance__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga7f319bfc2492a2136964194204e7a8cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___f_i_l_e_x___l_e_v_e_l_x___n_o_r.html#ga7f319bfc2492a2136964194204e7a8cf">VOID</a></td></tr>
<tr class="separator:ga7f319bfc2492a2136964194204e7a8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga50a68cde1290af62786375f06729908b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___f_i_l_e_x___l_e_v_e_l_x___n_o_r.html#ga50a68cde1290af62786375f06729908b">rm_filex_levelx_nor_event_t</a> </td></tr>
<tr class="separator:ga50a68cde1290af62786375f06729908b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structrm__filex__levelx__nor__callback__args__t" id="structrm__filex__levelx__nor__callback__args__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structrm__filex__levelx__nor__callback__args__t">&#9670;&nbsp;</a></span>rm_filex_levelx_nor_callback_args_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rm_filex_levelx_nor_callback_args_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Callback function parameter data </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a1d9f57cba943e15af2e622d03c75745d"></a><a class="el" href="group___r_m___f_i_l_e_x___l_e_v_e_l_x___n_o_r.html#ga50a68cde1290af62786375f06729908b">rm_filex_levelx_nor_event_t</a></td>
<td class="fieldname">
event</td>
<td class="fielddoc">
The event can be used to identify what caused the callback. </td></tr>
<tr><td class="fieldtype">
<a id="a58c55fb35232f666761783e8d560d5a1"></a>void *</td>
<td class="fieldname">
p_context</td>
<td class="fielddoc">
Placeholder for user data. </td></tr>
</table>

</div>
</div>
<a name="structrm__filex__levelx__nor__cfg__t" id="structrm__filex__levelx__nor__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structrm__filex__levelx__nor__cfg__t">&#9670;&nbsp;</a></span>rm_filex_levelx_nor_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rm_filex_levelx_nor_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>FileX LevelX configuration </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:ab8be40e15ffbcb346d2cfed0d04a177a"><td class="memItemLeft" align="right" valign="top"><a id="ab8be40e15ffbcb346d2cfed0d04a177a"></a>
UINT(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___f_i_l_e_x___l_e_v_e_l_x___n_o_r.html#ab8be40e15ffbcb346d2cfed0d04a177a">nor_driver_initialize</a> )(LX_NOR_FLASH *)</td></tr>
<tr class="memdesc:ab8be40e15ffbcb346d2cfed0d04a177a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the initialization function. <br /></td></tr>
<tr class="separator:ab8be40e15ffbcb346d2cfed0d04a177a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f5c6780d5eef1f420ffa938a929378"><td class="memItemLeft" align="right" valign="top"><a id="a46f5c6780d5eef1f420ffa938a929378"></a>
LX_NOR_FLASH *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___f_i_l_e_x___l_e_v_e_l_x___n_o_r.html#a46f5c6780d5eef1f420ffa938a929378">p_nor_flash</a></td></tr>
<tr class="memdesc:a46f5c6780d5eef1f420ffa938a929378"><td class="mdescLeft">&#160;</td><td class="mdescRight">NOR Flash instance. <br /></td></tr>
<tr class="separator:a46f5c6780d5eef1f420ffa938a929378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d81a188484b39c4f44a82c48bf783e"><td class="memItemLeft" align="right" valign="top"><a id="a48d81a188484b39c4f44a82c48bf783e"></a>
CHAR *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___f_i_l_e_x___l_e_v_e_l_x___n_o_r.html#a48d81a188484b39c4f44a82c48bf783e">p_nor_flash_name</a></td></tr>
<tr class="memdesc:a48d81a188484b39c4f44a82c48bf783e"><td class="mdescLeft">&#160;</td><td class="mdescRight">NOR Flash instance name. <br /></td></tr>
<tr class="separator:a48d81a188484b39c4f44a82c48bf783e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e421173c938cc5a0ede6531ba9adb9d"><td class="memItemLeft" align="right" valign="top"><a id="a8e421173c938cc5a0ede6531ba9adb9d"></a>
<a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___f_i_l_e_x___l_e_v_e_l_x___n_o_r.html#a8e421173c938cc5a0ede6531ba9adb9d">close</a> )()</td></tr>
<tr class="memdesc:a8e421173c938cc5a0ede6531ba9adb9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to underlying driver close. <br /></td></tr>
<tr class="separator:a8e421173c938cc5a0ede6531ba9adb9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee5bf1864efd40150ef80eaeb9d15ba"><td class="memItemLeft" align="right" valign="top"><a id="a1ee5bf1864efd40150ef80eaeb9d15ba"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___f_i_l_e_x___l_e_v_e_l_x___n_o_r.html#a1ee5bf1864efd40150ef80eaeb9d15ba">p_callback</a> )(<a class="el" href="group___r_m___f_i_l_e_x___l_e_v_e_l_x___n_o_r.html#structrm__filex__levelx__nor__callback__args__t">rm_filex_levelx_nor_callback_args_t</a> *p_args)</td></tr>
<tr class="memdesc:a1ee5bf1864efd40150ef80eaeb9d15ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to callback function. <br /></td></tr>
<tr class="separator:a1ee5bf1864efd40150ef80eaeb9d15ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d31970533b4a518ad44c86965a9823"><td class="memItemLeft" align="right" valign="top"><a id="a39d31970533b4a518ad44c86965a9823"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___f_i_l_e_x___l_e_v_e_l_x___n_o_r.html#a39d31970533b4a518ad44c86965a9823">p_context</a></td></tr>
<tr class="memdesc:a39d31970533b4a518ad44c86965a9823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placeholder for user data. <br /></td></tr>
<tr class="separator:a39d31970533b4a518ad44c86965a9823"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<a name="structrm__filex__levelx__nor__instance__ctrl__t" id="structrm__filex__levelx__nor__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structrm__filex__levelx__nor__instance__ctrl__t">&#9670;&nbsp;</a></span>rm_filex_levelx_nor_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rm_filex_levelx_nor_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>FileX block media private control block. DO NOT MODIFY. Initialization occurs when RM_FILEX_LEVELX_NOR_Open is called. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a723568373b70287cca565e0c979812e9"></a><a class="el" href="group___r_m___f_i_l_e_x___l_e_v_e_l_x___n_o_r.html#structrm__filex__levelx__nor__cfg__t">rm_filex_levelx_nor_cfg_t</a> const  *</td>
<td class="fieldname">
p_cfg</td>
<td class="fielddoc">
Pointer to instance configuration. </td></tr>
</table>

</div>
</div>
<a name="structrm__filex__levelx__nor__instance__t" id="structrm__filex__levelx__nor__instance__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structrm__filex__levelx__nor__instance__t">&#9670;&nbsp;</a></span>rm_filex_levelx_nor_instance_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rm_filex_levelx_nor_instance_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure encompasses everything that is needed to use an instance of this interface. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a36a50894c5775e920c524451b6bd3d87"></a><a class="el" href="group___r_m___f_i_l_e_x___l_e_v_e_l_x___n_o_r.html#structrm__filex__levelx__nor__instance__ctrl__t">rm_filex_levelx_nor_instance_ctrl_t</a> *</td>
<td class="fieldname">
p_ctrl</td>
<td class="fielddoc">
Pointer to the control structure for this instance. </td></tr>
<tr><td class="fieldtype">
<a id="a69460462985646d0c6edc31e5fcbae64"></a><a class="el" href="group___r_m___f_i_l_e_x___l_e_v_e_l_x___n_o_r.html#structrm__filex__levelx__nor__cfg__t">rm_filex_levelx_nor_cfg_t</a> const  *</td>
<td class="fieldname">
p_cfg</td>
<td class="fielddoc">
Pointer to the configuration structure for this instance. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga7f319bfc2492a2136964194204e7a8cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f319bfc2492a2136964194204e7a8cf">&#9670;&nbsp;</a></span>VOID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VOID</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Common macro for FSP header files. There is also a corresponding FSP_FOOTER macro at the end of this file. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga50a68cde1290af62786375f06729908b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50a68cde1290af62786375f06729908b">&#9670;&nbsp;</a></span>rm_filex_levelx_nor_event_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___r_m___f_i_l_e_x___l_e_v_e_l_x___n_o_r.html#ga50a68cde1290af62786375f06729908b">rm_filex_levelx_nor_event_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Options for the callback events. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga50a68cde1290af62786375f06729908ba6bcb085314fab96ebee0c099d84d500c"></a>RM_FILEX_LEVELX_NOR_EVENT_BUSY&#160;</td><td class="fielddoc"><p>Pending operation, user can define their own wait functionality. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga4f300fdb7b384b42d19f71322f4386d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f300fdb7b384b42d19f71322f4386d5">&#9670;&nbsp;</a></span>RM_FILEX_LEVELX_NOR_DeviceDriver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RM_FILEX_LEVELX_NOR_DeviceDriver </td>
          <td>(</td>
          <td class="paramtype">FX_MEDIA *&#160;</td>
          <td class="paramname"><em>p_fx_media</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access LevelX NOR device functions open, close, read, write and control. </p>
<p>The RM_FILEX_LEVELX_NOR_DeviceDriver function is called from the FileX file system driver and issues requests to a LevelX NOR device through the LevelX API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_fx_media</td><td>FileX media control block. All information about each open media device are maintained in the FX_MEDIA data type. The I/O driver communicates the success or failure of the request through the fx_media_driver_status member of FX_MEDIA (p_fx_media-&gt;fx_media_driver_status). Possible values are documented in the FileX User Guide.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing, but updates FileX media control block. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v6.2.0 User's Manual Copyright © (2025) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
