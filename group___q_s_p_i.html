<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: QSPI (r_qspi)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
    $(document).ready(function() {
        $("tr.tree_lvl_1").nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
		$("tr.tree_lvl_1").data("expanded","0");
		$("tr.tree_lvl_2").data("expanded","0");
		$("tr.tree_lvl_3").data("expanded","0");
		$("tr.tree_lvl_4").data("expanded","0");
		$("tr.tree_lvl_5").data("expanded","0");
        $("tr.tree_lvl_1").click(function() {
		    var lvl_1_is_open = $(this).data("expanded");
		    if (lvl_1_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2, tr.tree_lvl_1_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_2").click(function() {
		    var lvl_2_is_open = $(this).data("expanded");
		    if (lvl_2_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3, tr.tree_lvl_2_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_3").click(function() {
		    var lvl_3_is_open = $(this).data("expanded");
		    if (lvl_3_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_3_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_4").click(function() {
		    var lvl_4_is_open = $(this).data("expanded");
		    if (lvl_4_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5, tr.tree_lvl_4_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_5").click(function() {
		    var lvl_5_is_open = $(this).data("expanded");
		    if (lvl_5_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4_item,tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
     });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v6.2.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">

    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text">
      </span>
      <span class="right">
          &nbsp;
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___q_s_p_i.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body.
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len));
            }
          }
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element.
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">QSPI (r_qspi)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___s_t_o_r_a_g_e___m_o_d_u_l_e_s.html">Storage</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9126728f755c2b34939013218ab81b44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga9126728f755c2b34939013218ab81b44">R_QSPI_Open</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_ctrl, <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__cfg__t">spi_flash_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:ga9126728f755c2b34939013218ab81b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80ea8f11ac3c0f354d89a3e06fbf6a4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga80ea8f11ac3c0f354d89a3e06fbf6a4c">R_QSPI_DirectWrite</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_ctrl, uint8_t const *const p_src, uint32_t const bytes, bool const read_after_write)</td></tr>
<tr class="separator:ga80ea8f11ac3c0f354d89a3e06fbf6a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacddc3f64e5e87d4df22dd0da7a444308"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gacddc3f64e5e87d4df22dd0da7a444308">R_QSPI_DirectRead</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_ctrl, uint8_t *const p_dest, uint32_t const bytes)</td></tr>
<tr class="separator:gacddc3f64e5e87d4df22dd0da7a444308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3439f15e60af9cf55e15e8016b67875"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gaf3439f15e60af9cf55e15e8016b67875">R_QSPI_DirectTransfer</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_ctrl, <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__direct__transfer__t">spi_flash_direct_transfer_t</a> *const p_transfer, <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga80ecf65e658f5b36bfe0bf2d88dd3ca5">spi_flash_direct_transfer_dir_t</a> direction)</td></tr>
<tr class="separator:gaf3439f15e60af9cf55e15e8016b67875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13cbc9d58890d7094712edcf64bc1bf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga13cbc9d58890d7094712edcf64bc1bf1">R_QSPI_XipEnter</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:ga13cbc9d58890d7094712edcf64bc1bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c894a8a9ef0bb28ba8db701e5a71b3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga9c894a8a9ef0bb28ba8db701e5a71b3a">R_QSPI_XipExit</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:ga9c894a8a9ef0bb28ba8db701e5a71b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d449604f886f5f59952d9e789d5dc65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga9d449604f886f5f59952d9e789d5dc65">R_QSPI_Write</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_ctrl, uint8_t const *const p_src, uint8_t *const p_dest, uint32_t byte_count)</td></tr>
<tr class="separator:ga9d449604f886f5f59952d9e789d5dc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0409e8bb9585e9bd0be17ba9840f8fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gaa0409e8bb9585e9bd0be17ba9840f8fb">R_QSPI_Erase</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_ctrl, uint8_t *const p_device_address, uint32_t byte_count)</td></tr>
<tr class="separator:gaa0409e8bb9585e9bd0be17ba9840f8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03da39d9d9f82ea0dfd0f7cc4f253189"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga03da39d9d9f82ea0dfd0f7cc4f253189">R_QSPI_StatusGet</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_ctrl, <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__status__t">spi_flash_status_t</a> *const p_status)</td></tr>
<tr class="separator:ga03da39d9d9f82ea0dfd0f7cc4f253189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3762ca61aea95737c5a018d0aa9bd6f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga3762ca61aea95737c5a018d0aa9bd6f1">R_QSPI_BankSet</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_ctrl, uint32_t bank)</td></tr>
<tr class="separator:ga3762ca61aea95737c5a018d0aa9bd6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d09918d3ab7458bbd15908f17bae951"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga7d09918d3ab7458bbd15908f17bae951">R_QSPI_SpiProtocolSet</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_ctrl, <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga17c347a498a8a9d38ffc36c0de49a535">spi_flash_protocol_t</a> spi_protocol)</td></tr>
<tr class="separator:ga7d09918d3ab7458bbd15908f17bae951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f163c6c0a41fae3a196d3bf2eeb0907"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga3f163c6c0a41fae3a196d3bf2eeb0907">R_QSPI_AutoCalibrate</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:ga3f163c6c0a41fae3a196d3bf2eeb0907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96b3e76ff7daef41184898e3af0aa1a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga96b3e76ff7daef41184898e3af0aa1a4">R_QSPI_Close</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:ga96b3e76ff7daef41184898e3af0aa1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the QSPI peripheral on RA MCUs. This module implements the <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html">SPI Flash Interface</a>. </p>
<h1><a class="anchor" id="r-qspi-overview"></a>
Overview</h1>
<h2><a class="anchor" id="r-qspi-features"></a>
Features</h2>
<p>The QSPI driver has the following key features:</p><ul>
<li>Memory mapped read access to the QSPI flash</li>
<li>Programming the QSPI flash device<a class="anchor" id="um_qspi_page_program"></a></li>
<li>Erasing the QSPI flash device<a class="anchor" id="um_qspi_erase"></a></li>
<li>Sending device specific commands and reading back responses<a class="anchor" id="um_qspi_custom_write"></a><a class="anchor" id="um_qspi_custom_read"></a></li>
<li>Entering and exiting QPI mode</li>
<li>Entering and exiting XIP mode<a class="anchor" id="um_qspi_xip_mode"></a></li>
<li>3 or 4 byte addressing<a class="anchor" id="um_qspi_4byte_address"></a> </li>
</ul>
<h1><a class="anchor" id="r-qspi-configuration"></a>
Configuration</h1>
<p><h2>Build Time Configurations for r_qspi</h2>
The following build time configurations are defined in driver/r_qspi_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr class="tree_none">
<td>Support Multiple Line Program in Extended SPI Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>If selected code for programming on multiple lines in extended SPI mode is included in the build. </td></tr>
</table>
 <h2>Configurations for Storage &gt; QSPI (r_qspi)</h2>
This module can be added to the Stacks tab via New Stack &gt; Storage &gt; QSPI (r_qspi).<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> General  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Name</td><td>Name must be a valid C symbol</td><td>g_qspi0 </td><td>Module name. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">SPI Protocol</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Extended SPI</li>
<li>
QPI</li>
</ul>
</td><td>Extended SPI </td><td>Select the initial SPI protocol. SPI protocol can be changed in R_QSPI_Direct(). </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Address Bytes</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
3</li>
<li>
4</li>
<li>
4 with 4-byte read code</li>
</ul>
</td><td>3 </td><td>Select the number of address bytes. Selecting '4 with 4-byte read code' converts the default read code determined in Read Mode to the 4-byte version. If 4-byte mode is selected without using 4-byte commands, the application must issue the EN4B command using R_QSPI_Direct(). </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Read Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Standard Read</li>
<li>
Fast Read</li>
<li>
Fast Read Dual Output</li>
<li>
Fast Read Dual I/O</li>
<li>
Fast Read Quad Output</li>
<li>
Fast Read Quad I/O</li>
</ul>
</td><td>Fast Read Quad I/O </td><td>Select the read mode for memory mapped access. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Dummy Clocks for Fast Read</td><td>Refer to the RA Configuration tool for available options.</td><td>Default </td><td>Select the number of dummy clocks for fast read operations. Default is 6 clocks for Fast Read Quad I/O, 4 clocks for Fast Read Dual I/O, and 8 clocks for other fast read instructions including Fast Read Quad Output, Fast Read Dual Output, and Fast Read </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Page Size Bytes</td><td>Must be an integer greater than 0</td><td>256 </td><td>The maximum number of bytes allowed for a single write. </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Command Definitions  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Page Program Command</td><td>Must be an 8-bit QSPI Page Program Command under Command Definitions</td><td>0x02 </td><td>The command to program a page. If 'Support Multiple Line Program in Extended SPI Mode' is Enabled, this command must use the same number of data lines as the selected read mode. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Page Program Address Lines</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1</li>
<li>
2</li>
<li>
4</li>
</ul>
</td><td>1 </td><td>Select the number of lines to use for the address bytes during write operations. This can be determined by referencing the datasheet for the external QSPI. It should either be 1 or match the number of data lines used for memory mapped fast read operations. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Write Enable Command</td><td>Must be an 8-bit QSPI Write Enable Command under Command Definitions</td><td>0x06 </td><td>The command to enable write. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Status Command</td><td>Must be an 8-bit QSPI Status Command under Command Definitions</td><td>0x05 </td><td>The command to query the status of a write or erase command. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Write Status Bit</td><td>Must be an integer between 0 and 7</td><td>0 </td><td>Which bit contains the write in progress status returned from the Write Status Command. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Sector Erase Command</td><td>Must be an 8-bit QSPI Sector Erase Command under Command Definitions</td><td>0x20 </td><td>The command to erase a sector. Set Sector Erase Size to 0 if unused. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Sector Erase Size</td><td>Must be an integer greater than or equal to 0</td><td>4096 </td><td>The sector erase size. Set Sector Erase Size to 0 if Sector Erase is not supported. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Block Erase Command</td><td>Must be an 8-bit QSPI Block Erase Command under Command Definitions</td><td>0xD8 </td><td>The command to erase a block. Set Block Erase Size to 0 if unused. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Block Erase Size</td><td>Must be an integer greater than or equal to 0</td><td>65536 </td><td>The block erase size. Set Block Erase Size to 0 if Block Erase is not supported. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Block Erase 32KB Command</td><td>Must be an 8-bit QSPI Block Erase 32KB Command under Command Definitions</td><td>0x52 </td><td>The command to erase a 32KB block. Set Block Erase Size to 0 if unused. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Block Erase 32KB Size</td><td>Must be an integer greater than or equal to 0</td><td>32768 </td><td>The block erase 32KB size. Set Block Erase 32KB Size to 0 if Block Erase 32KB is not supported. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Chip Erase Command</td><td>Must be an 8-bit QSPI Chip Erase Command under Command Definitions</td><td>0xC7 </td><td>The command to erase the entire chip. Set Chip Erase Command to 0 if unused. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">XIP Enter M7-M0</td><td>Must be an 8-bit QSPI XIP Enter M7-M0 command under Command Definitions</td><td>0x20 </td><td>How to set M7-M0 to enter XIP mode. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">XIP Exit M7-M0</td><td>Must be an 8-bit QSPI XIP Exit M7-M0 command under Command Definitions</td><td>0xFF </td><td>How to set M7-M0 exit XIP mode. </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Bus Timing  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">QSPKCLK Divisor</td><td>MCU Specific Options</td><td></td><td>Select the divisor to apply to PCLK to get QSPCLK. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Minimum QSSL Deselect Cycles</td><td>Refer to the RA Configuration tool for available options.</td><td>4 QSPCLK </td><td>Define the minimum number of QSPCLK cycles for QSSL to remain high between operations. </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-qspi-clock-configuration"></a>
Clock Configuration</h2>
<p>The QSPI clock is derived from PCLKA.</p>
<h2><a class="anchor" id="r-qspi-pin-configuration"></a>
Pin Configuration</h2>
<p>The following pins are available to connect to an external QSPI device:</p><ul>
<li>QSPCLK: QSPI clock output</li>
<li>QSSL: QSPI slave select</li>
<li>QIO0: Data 0 I/O</li>
<li>QIO1: Data 1 I/O</li>
<li>QIO2: Data 2 I/O</li>
<li>QIO3: Data 3 I/O</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>It is recommended to configure the pins with IOPORT_CFG_DRIVE_HIGH.</dd></dl>
<h1><a class="anchor" id="r-qspi-usage_notes"></a>
Usage Notes</h1>
<h2>QSPI Memory Mapped Access</h2>
<p>After <a class="el" href="group___q_s_p_i.html#ga9126728f755c2b34939013218ab81b44">R_QSPI_Open()</a> completes successfully, the QSPI flash device contents are mapped to address 0x60000000 and can be read like on-chip flash.</p>
<h2><a class="anchor" id="r-qspi-limitations"></a>
Limitations</h2>
<p>Developers should be aware of the following limitations when using the QSPI driver:</p>
<ul>
<li>Only P305-P310 are currently supported by the J-Link driver to flash the QSPI.</li>
<li>The default J-Link downloader requires the device to be in extended SPI mode (not QPI mode).</li>
</ul>
<h1><a class="anchor" id="r-qspi-examples"></a>
Examples</h1>
<h2>Basic Example</h2>
<p><a class="anchor" id="um_qspi_sections"></a> This is a basic example of minimal use of the QSPI in an application.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define QSPI_EXAMPLE_DATA_LENGTH    (1024)</span></div><div class="line"></div><div class="line">uint8_t g_dest[QSPI_EXAMPLE_DATA_LENGTH];</div><div class="line"></div><div class="line"><span class="comment">/* Place data in the .qspi_flash section to flash it during programming. */</span></div><div class="line"><span class="keyword">const</span> uint8_t g_src[QSPI_EXAMPLE_DATA_LENGTH] BSP_PLACE_IN_SECTION(<span class="stringliteral">&quot;.qspi_flash&quot;</span>) = <span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</div><div class="line"></div><div class="line"><span class="comment">/* Place code in the .qspi_flash_code section to flash it during programming. */</span></div><div class="line"><span class="keywordtype">void</span> r_qspi_example_function(<span class="keywordtype">void</span>) BSP_PLACE_IN_SECTION(<span class="stringliteral">&quot;.qspi_flash_code&quot;</span>) __attribute__((noinline));</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> r_qspi_example_function (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Add code here. */</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> r_qspi_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line"></div><div class="line">    <span class="comment">/* Open the QSPI instance. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___q_s_p_i.html#ga9126728f755c2b34939013218ab81b44">R_QSPI_Open</a>(&amp;g_qspi0_ctrl, &amp;g_qspi0_cfg);</div><div class="line"></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Send device specific initialization commands. */</span></div><div class="line">    r_qspi_example_init();</div><div class="line"></div><div class="line">    <span class="comment">/* After R_QSPI_Open() and any required device specific intiialization, data can be read directly from the QSPI flash. */</span></div><div class="line">    memcpy(&amp;g_dest[0], &amp;g_src[0], QSPI_EXAMPLE_DATA_LENGTH);</div><div class="line"></div><div class="line">    <span class="comment">/* After R_QSPI_Open() and any required device specific intiialization, functions in the QSPI flash can be called. */</span></div><div class="line">    r_qspi_example_function();</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Initialization Command Structure Example</h2>
<p>This is an example of the types of commands that can be used to initialize the QSPI.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define QSPI_COMMAND_WRITE_ENABLE             (0x06U)</span></div><div class="line"><span class="preprocessor">#define QSPI_COMMAND_WRITE_STATUS_REGISTER    (0x01U)</span></div><div class="line"><span class="preprocessor">#define QSPI_COMMAND_ENTER_QPI_MODE           (0x38U)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define QSPI_EXAMPLE_STATUS_REGISTER_1        (0x40)</span></div><div class="line"><span class="preprocessor">#define QSPI_EXAMPLE_STATUS_REGISTER_2        (0x00)</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> r_qspi_example_init (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Write status registers */</span></div><div class="line">    <span class="comment">/* Write one byte to enable writing to the status register, then deassert QSSL. */</span></div><div class="line">    uint8_t   data[4];</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err;</div><div class="line">    data[0] = QSPI_COMMAND_WRITE_ENABLE;</div><div class="line">    err     = <a class="code" href="group___q_s_p_i.html#ga80ea8f11ac3c0f354d89a3e06fbf6a4c">R_QSPI_DirectWrite</a>(&amp;g_qspi0_ctrl, &amp;data[0], 1, <span class="keyword">false</span>);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Write 3 bytes, including the write status register command followed by values for both status registers. In the</span></div><div class="line"><span class="comment">     * status registers, set QE to 1 and other bits to their default setting. After all data is written, deassert the</span></div><div class="line"><span class="comment">     * QSSL line. */</span></div><div class="line">    data[0] = QSPI_COMMAND_WRITE_STATUS_REGISTER;</div><div class="line">    data[1] = QSPI_EXAMPLE_STATUS_REGISTER_1;</div><div class="line">    data[2] = QSPI_EXAMPLE_STATUS_REGISTER_2;</div><div class="line">    err     = <a class="code" href="group___q_s_p_i.html#ga80ea8f11ac3c0f354d89a3e06fbf6a4c">R_QSPI_DirectWrite</a>(&amp;g_qspi0_ctrl, &amp;data[0], 3, <span class="keyword">false</span>);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for status register to update. */</span></div><div class="line">    <a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__status__t">spi_flash_status_t</a> status;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        (void) <a class="code" href="group___q_s_p_i.html#ga03da39d9d9f82ea0dfd0f7cc4f253189">R_QSPI_StatusGet</a>(&amp;g_qspi0_ctrl, &amp;status);</div><div class="line">    } <span class="keywordflow">while</span> (<span class="keyword">true</span> == status.<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ae20d4bed523ca4e802f5da6fdec4ca43">write_in_progress</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Write one byte to enter QSPI mode, then deassert QSSL. After entering QPI mode on the device, change the SPI</span></div><div class="line"><span class="comment">     * protocol to QPI mode on the MCU peripheral. */</span></div><div class="line">    data[0] = QSPI_COMMAND_ENTER_QPI_MODE;</div><div class="line">    err     = <a class="code" href="group___q_s_p_i.html#ga80ea8f11ac3c0f354d89a3e06fbf6a4c">R_QSPI_DirectWrite</a>(&amp;g_qspi0_ctrl, &amp;data[0], 1, <span class="keyword">false</span>);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    (void) <a class="code" href="group___q_s_p_i.html#ga7d09918d3ab7458bbd15908f17bae951">R_QSPI_SpiProtocolSet</a>(&amp;g_qspi0_ctrl, <a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#gga17c347a498a8a9d38ffc36c0de49a535abf7718fe53c0e4daa1dcad6f4d6d215e">SPI_FLASH_PROTOCOL_QPI</a>);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Reading Status Register Example (R_QSPI_DirectWrite, R_QSPI_DirectRead)</h2>
<p>This is an example of using R_QSPI_DirectWrite followed by R_QSPI_DirectRead to send the read status register command and read back the status register from the device.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define QSPI_COMMAND_READ_STATUS_REGISTER    (0x05U)</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> r_qspi_direct_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Read a status register. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Write one byte to read the status register. Do not deassert QSSL. */</span></div><div class="line">    uint8_t   data;</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err;</div><div class="line">    data = QSPI_COMMAND_READ_STATUS_REGISTER;</div><div class="line">    err  = <a class="code" href="group___q_s_p_i.html#ga80ea8f11ac3c0f354d89a3e06fbf6a4c">R_QSPI_DirectWrite</a>(&amp;g_qspi0_ctrl, &amp;data, 1, <span class="keyword">true</span>);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Read one byte. After all data is read, deassert the QSSL line. */</span></div><div class="line">    err = <a class="code" href="group___q_s_p_i.html#gacddc3f64e5e87d4df22dd0da7a444308">R_QSPI_DirectRead</a>(&amp;g_qspi0_ctrl, &amp;data, 1);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Status register contents are available in variable &#39;data&#39;. */</span></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Querying Device Size Example (R_QSPI_DirectWrite, R_QSPI_DirectRead)</h2>
<p>This is an example of using R_QSPI_DirectWrite followed by R_QSPI_DirectRead to query the device size.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define QSPI_EXAMPLE_COMMAND_READ_ID      (0x9F)</span></div><div class="line"><span class="preprocessor">#define QSPI_EXAMPLE_COMMAND_READ_SFDP    (0x5A)</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> r_qspi_size_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Many QSPI devices support more than one way to query the device size. Consult the datasheet for your</span></div><div class="line"><span class="comment">     * QSPI device to determine which of these methods are supported (if any). */</span></div><div class="line">    uint32_t  device_size_bytes;</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef QSPI_EXAMPLE_COMMAND_READ_ID</span></div><div class="line"></div><div class="line">    <span class="comment">/* This example shows how to get the device size by reading the manufacturer ID. */</span></div><div class="line">    uint8_t data[4];</div><div class="line">    data[0] = QSPI_EXAMPLE_COMMAND_READ_ID;</div><div class="line">    err     = <a class="code" href="group___q_s_p_i.html#ga80ea8f11ac3c0f354d89a3e06fbf6a4c">R_QSPI_DirectWrite</a>(&amp;g_qspi0_ctrl, &amp;data[0], 1, <span class="keyword">true</span>);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Read 3 bytes. The third byte often represents the size of the QSPI, where the size of the QSPI = 2 ^ N. */</span></div><div class="line">    err = <a class="code" href="group___q_s_p_i.html#gacddc3f64e5e87d4df22dd0da7a444308">R_QSPI_DirectRead</a>(&amp;g_qspi0_ctrl, &amp;data[0], 3);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">    device_size_bytes = 1U &lt;&lt; data[2];</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gaf0afcbc9a110ac9366a811d96ee06029">FSP_PARAMETER_NOT_USED</a>(device_size_bytes);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef QSPI_EXAMPLE_COMMAND_READ_SFDP</span></div><div class="line"></div><div class="line">    <span class="comment">/* Read the JEDEC SFDP header to locate the JEDEC flash parameters table. Reference JESD216 &quot;Serial Flash</span></div><div class="line"><span class="comment">     * Discoverable Parameters (SFDP)&quot;. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Send the standard 0x5A command followed by 3 address bytes (SFDP header is at address 0). */</span></div><div class="line">    uint8_t buffer[16];</div><div class="line">    memset(&amp;buffer[0], 0, <span class="keyword">sizeof</span>(buffer));</div><div class="line">    buffer[0] = QSPI_EXAMPLE_COMMAND_READ_SFDP;</div><div class="line">    err       = <a class="code" href="group___q_s_p_i.html#ga80ea8f11ac3c0f354d89a3e06fbf6a4c">R_QSPI_DirectWrite</a>(&amp;g_qspi0_ctrl, &amp;buffer[0], 4, <span class="keyword">true</span>);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Read out 16 bytes (1 dummy byte followed by 15 data bytes). */</span></div><div class="line">    err = <a class="code" href="group___q_s_p_i.html#gacddc3f64e5e87d4df22dd0da7a444308">R_QSPI_DirectRead</a>(&amp;g_qspi0_ctrl, &amp;buffer[0], 16);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Read the JEDEC flash parameters to locate the memory size. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Send the standard 0x5A command followed by 3 address bytes (located in big endian order at offset 0xC-0xE).</span></div><div class="line"><span class="comment">     * These bytes are accessed at 0xD-0xF because the first byte read is a dummy byte. */</span></div><div class="line">    buffer[0] = QSPI_EXAMPLE_COMMAND_READ_SFDP;</div><div class="line">    buffer[1] = buffer[0xF];</div><div class="line">    buffer[2] = buffer[0xE];</div><div class="line">    buffer[3] = buffer[0xD];</div><div class="line">    err       = <a class="code" href="group___q_s_p_i.html#ga80ea8f11ac3c0f354d89a3e06fbf6a4c">R_QSPI_DirectWrite</a>(&amp;g_qspi0_ctrl, &amp;buffer[0], 4, <span class="keyword">true</span>);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Read out 9 bytes (1 dummy byte followed by 8 data bytes). */</span></div><div class="line">    err = <a class="code" href="group___q_s_p_i.html#gacddc3f64e5e87d4df22dd0da7a444308">R_QSPI_DirectRead</a>(&amp;g_qspi0_ctrl, &amp;buffer[0], 9);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Read the memory density (located in big endian order at offset 0x4-0x7). These bytes are accessed at 0x5-0x8</span></div><div class="line"><span class="comment">     * because the first byte read is a dummy byte. */</span></div><div class="line">    uint32_t memory_density = (uint32_t) ((buffer[8] &lt;&lt; 24) | (buffer[7] &lt;&lt; 16) | (buffer[6] &lt;&lt; 8) | buffer[5]);</div><div class="line">    <span class="keywordflow">if</span> ((1U &lt;&lt; 31) &amp; memory_density)</div><div class="line">    {</div><div class="line">        <span class="comment">/* For densities 4 gigabits and above, bit-31 is set to 1b.  The field 30:0 defines ‘N’ where the density is</span></div><div class="line"><span class="comment">         * computed as 2^N bits (N must be &gt;= 32). This code subtracts 3 from N to divide by 8 to get the size in</span></div><div class="line"><span class="comment">         * bytes instead of bits. */</span></div><div class="line">        device_size_bytes = 1U &lt;&lt; ((memory_density &amp; ~(1U &lt;&lt; 31)) - 3U);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* For densities 2 gigabits or less, bit-31 is set to 0b.  The field 30:0 defines the size in bits. This</span></div><div class="line"><span class="comment">         * code divides the memory density by 8 to get the size in bytes instead of bits. */</span></div><div class="line">        device_size_bytes = (memory_density / 8) + 1;</div><div class="line">    }</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gaf0afcbc9a110ac9366a811d96ee06029">FSP_PARAMETER_NOT_USED</a>(device_size_bytes);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structqspi__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#structqspi__instance__ctrl__t">qspi_instance_ctrl_t</a></td></tr>
<tr class="separator:structqspi__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga401b048dfc526a4ab5e3b9c709ab2396"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga401b048dfc526a4ab5e3b9c709ab2396">qspi_qssl_min_high_level_t</a> </td></tr>
<tr class="separator:ga401b048dfc526a4ab5e3b9c709ab2396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53abedddf8fc81df853fc93071edf117"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga53abedddf8fc81df853fc93071edf117">qspi_qspclk_div_t</a> </td></tr>
<tr class="separator:ga53abedddf8fc81df853fc93071edf117"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structqspi__instance__ctrl__t" id="structqspi__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structqspi__instance__ctrl__t">&#9670;&nbsp;</a></span>qspi_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct qspi_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Instance control block. DO NOT INITIALIZE. Initialization occurs when <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a75a4468493abb92f6bf484ed93718f6f">spi_flash_api_t::open</a> is called </p>
</div>
</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga401b048dfc526a4ab5e3b9c709ab2396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga401b048dfc526a4ab5e3b9c709ab2396">&#9670;&nbsp;</a></span>qspi_qssl_min_high_level_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___q_s_p_i.html#ga401b048dfc526a4ab5e3b9c709ab2396">qspi_qssl_min_high_level_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga401b048dfc526a4ab5e3b9c709ab2396a0ed80d61a917c62e10cf3caf9c368b88"></a>QSPI_QSSL_MIN_HIGH_LEVEL_1_QSPCLK&#160;</td><td class="fielddoc"><p>QSSL deselected for at least 1 QSPCLK. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga401b048dfc526a4ab5e3b9c709ab2396afa797fdb96d57ea2de2f3d9c123b80e8"></a>QSPI_QSSL_MIN_HIGH_LEVEL_2_QSPCLK&#160;</td><td class="fielddoc"><p>QSSL deselected for at least 2 QSPCLK. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga401b048dfc526a4ab5e3b9c709ab2396a11f72d4b43c48d822551643622864add"></a>QSPI_QSSL_MIN_HIGH_LEVEL_3_QSPCLK&#160;</td><td class="fielddoc"><p>QSSL deselected for at least 3 QSPCLK. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga401b048dfc526a4ab5e3b9c709ab2396a7503a7803b9e39c2a90e03578233bf27"></a>QSPI_QSSL_MIN_HIGH_LEVEL_4_QSPCLK&#160;</td><td class="fielddoc"><p>QSSL deselected for at least 4 QSPCLK. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga401b048dfc526a4ab5e3b9c709ab2396a62a9b61f5c44422f2aaf32228edb2a6a"></a>QSPI_QSSL_MIN_HIGH_LEVEL_5_QSPCLK&#160;</td><td class="fielddoc"><p>QSSL deselected for at least 5 QSPCLK. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga401b048dfc526a4ab5e3b9c709ab2396aec0eae876ccffff4451390052527e7c2"></a>QSPI_QSSL_MIN_HIGH_LEVEL_6_QSPCLK&#160;</td><td class="fielddoc"><p>QSSL deselected for at least 6 QSPCLK. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga401b048dfc526a4ab5e3b9c709ab2396a987b930aecd1b045ab04d52895328575"></a>QSPI_QSSL_MIN_HIGH_LEVEL_7_QSPCLK&#160;</td><td class="fielddoc"><p>QSSL deselected for at least 7 QSPCLK. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga401b048dfc526a4ab5e3b9c709ab2396a64ab441f04aa0b85b2c49397b0de8f95"></a>QSPI_QSSL_MIN_HIGH_LEVEL_8_QSPCLK&#160;</td><td class="fielddoc"><p>QSSL deselected for at least 8 QSPCLK. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga401b048dfc526a4ab5e3b9c709ab2396a3b715ac1e7d4d32770ac948a87d4f37e"></a>QSPI_QSSL_MIN_HIGH_LEVEL_9_QSPCLK&#160;</td><td class="fielddoc"><p>QSSL deselected for at least 9 QSPCLK. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga401b048dfc526a4ab5e3b9c709ab2396a539bd3d6b6464c6f1fb4f79b3bce4d68"></a>QSPI_QSSL_MIN_HIGH_LEVEL_10_QSPCLK&#160;</td><td class="fielddoc"><p>QSSL deselected for at least 10 QSPCLK. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga401b048dfc526a4ab5e3b9c709ab2396a20ebd4b3cb0e19366109ce6f454c4afe"></a>QSPI_QSSL_MIN_HIGH_LEVEL_11_QSPCLK&#160;</td><td class="fielddoc"><p>QSSL deselected for at least 11 QSPCLK. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga401b048dfc526a4ab5e3b9c709ab2396a54928bbc46752913880e1810ff457c25"></a>QSPI_QSSL_MIN_HIGH_LEVEL_12_QSPCLK&#160;</td><td class="fielddoc"><p>QSSL deselected for at least 12 QSPCLK. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga401b048dfc526a4ab5e3b9c709ab2396a65914689f915c0206c3b4772b95aaa37"></a>QSPI_QSSL_MIN_HIGH_LEVEL_13_QSPCLK&#160;</td><td class="fielddoc"><p>QSSL deselected for at least 13 QSPCLK. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga401b048dfc526a4ab5e3b9c709ab2396ac4445025c386c08fd497fe21ebb90df4"></a>QSPI_QSSL_MIN_HIGH_LEVEL_14_QSPCLK&#160;</td><td class="fielddoc"><p>QSSL deselected for at least 14 QSPCLK. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga401b048dfc526a4ab5e3b9c709ab2396ab2950e303d7554a318d1e41b4c36cf82"></a>QSPI_QSSL_MIN_HIGH_LEVEL_15_QSPCLK&#160;</td><td class="fielddoc"><p>QSSL deselected for at least 15 QSPCLK. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga401b048dfc526a4ab5e3b9c709ab2396a4e6b29733e4c92bf9964940de6be9c1d"></a>QSPI_QSSL_MIN_HIGH_LEVEL_16_QSPCLK&#160;</td><td class="fielddoc"><p>QSSL deselected for at least 16 QSPCLK. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga53abedddf8fc81df853fc93071edf117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53abedddf8fc81df853fc93071edf117">&#9670;&nbsp;</a></span>qspi_qspclk_div_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___q_s_p_i.html#ga53abedddf8fc81df853fc93071edf117">qspi_qspclk_div_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117a1d3c5ec19556e9016261faee30b644c8"></a>QSPI_QSPCLK_DIV_2&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 2. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117a1f37af175439382245574cc1fc08214e"></a>QSPI_QSPCLK_DIV_3&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 3. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117a67d96f53260509e94c20f4c4c1e63c4b"></a>QSPI_QSPCLK_DIV_4&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 4. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117ab9cb77d7475f4e29404dd872fa00d05a"></a>QSPI_QSPCLK_DIV_5&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 5. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117a6741629a58f8fe1e5ba43f221c024b73"></a>QSPI_QSPCLK_DIV_6&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 6. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117a481f3d839975167fdbf5a736c8412264"></a>QSPI_QSPCLK_DIV_7&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 7. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117a22c17e2505bab8e9a4e96be6ebfc220c"></a>QSPI_QSPCLK_DIV_8&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 8. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117a9caad89f5ce647763e32408f141d2037"></a>QSPI_QSPCLK_DIV_9&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 9. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117a17fdaf615e46b1eeaa773136692a928c"></a>QSPI_QSPCLK_DIV_10&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 10. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117a3ec99b87729c8df2e7fd453433b6b4ca"></a>QSPI_QSPCLK_DIV_11&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 11. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117a3e8eac54156dbc6b886b03b459a63116"></a>QSPI_QSPCLK_DIV_12&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 12. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117a1001795b6ac4e1929feddfc6a18808a0"></a>QSPI_QSPCLK_DIV_13&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 13. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117a7278f8f8e6bd405c7f672d068cab88f6"></a>QSPI_QSPCLK_DIV_14&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 14. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117a80e260d3acba0df24f91489ccea4c68a"></a>QSPI_QSPCLK_DIV_15&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 15. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117a9923fe9b9bb7d3ca577765233aa6f0d6"></a>QSPI_QSPCLK_DIV_16&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 16. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117a53ea3e230c59917bf61689877c6ec4ef"></a>QSPI_QSPCLK_DIV_17&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 17. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117a8df72b69e34326c9c76be0246acf3dfa"></a>QSPI_QSPCLK_DIV_18&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 18. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117ae39be3f29b0d0c3157cd27525e63adf1"></a>QSPI_QSPCLK_DIV_20&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 20. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117a06bf89781df92a3eab51df780129270b"></a>QSPI_QSPCLK_DIV_22&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 22. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117a60b08a829e45c8e8cf2845fd901e76d2"></a>QSPI_QSPCLK_DIV_24&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 24. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117a4141ee787a1b7e2d1bdb22b29b75a4ea"></a>QSPI_QSPCLK_DIV_26&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 26. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117a585a248556cd3116584199938c78c7e4"></a>QSPI_QSPCLK_DIV_28&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 28. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117a93aa89495e16eb77d06cb51e6e8f9742"></a>QSPI_QSPCLK_DIV_30&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 30. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117ac7fee67fc3bc7c94b792f83d7d67120e"></a>QSPI_QSPCLK_DIV_32&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 32. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117a72d1e2b2523b861519e531cc0ac61395"></a>QSPI_QSPCLK_DIV_34&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 34. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117a4829fca1a95b30ca570786d47ac68187"></a>QSPI_QSPCLK_DIV_36&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 36. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117a7874bc9f258e011a23f990fc41fbe4c2"></a>QSPI_QSPCLK_DIV_38&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 38. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117aa461ef018d617a2637fd4d84dbcd740c"></a>QSPI_QSPCLK_DIV_40&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 40. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117a7fdd370f37ce55e6e97dc63a0c873160"></a>QSPI_QSPCLK_DIV_42&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 42. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117aafe9fa6e2b911cafd804e2ec5e3d735a"></a>QSPI_QSPCLK_DIV_44&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 44. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117ae2c61e59f215317c9ec913114da15687"></a>QSPI_QSPCLK_DIV_46&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 46. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga53abedddf8fc81df853fc93071edf117a9becf972d9269ef9599c11d08cbca19c"></a>QSPI_QSPCLK_DIV_48&#160;</td><td class="fielddoc"><p>QSPCLK = PCLK / 48. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9126728f755c2b34939013218ab81b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9126728f755c2b34939013218ab81b44">&#9670;&nbsp;</a></span>R_QSPI_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_QSPI_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__cfg__t">spi_flash_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open the QSPI driver module. After the driver is open, the QSPI can be accessed like internal flash memory starting at address 0x60000000.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a75a4468493abb92f6bf484ed93718f6f">spi_flash_api_t::open</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Configuration was successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>The parameter p_instance_ctrl or p_cfg is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Driver has already been opened with the same p_instance_ctrl. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga80ea8f11ac3c0f354d89a3e06fbf6a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80ea8f11ac3c0f354d89a3e06fbf6a4c">&#9670;&nbsp;</a></span>R_QSPI_DirectWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_QSPI_DirectWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *const&#160;</td>
          <td class="paramname"><em>p_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>read_after_write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes raw data directly to the QSPI.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#aebfa0317034f04f53b6b788da0debe80">spi_flash_api_t::directWrite</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The flash was programmed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>This function can't be called when XIP mode is enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_DEVICE_BUSY</td><td>The device is busy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacddc3f64e5e87d4df22dd0da7a444308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacddc3f64e5e87d4df22dd0da7a444308">&#9670;&nbsp;</a></span>R_QSPI_DirectRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_QSPI_DirectRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>p_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads raw data directly from the QSPI. This API can only be called after R_QSPI_DirectWrite with read_after_write set to true.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a4b3bfefb3b1ff0580fe1cce97b81c56f">spi_flash_api_t::directRead</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The flash was programmed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>This function must be called after R_QSPI_DirectWrite with read_after_write set to true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf3439f15e60af9cf55e15e8016b67875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3439f15e60af9cf55e15e8016b67875">&#9670;&nbsp;</a></span>R_QSPI_DirectTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_QSPI_DirectTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__direct__transfer__t">spi_flash_direct_transfer_t</a> *const&#160;</td>
          <td class="paramname"><em>p_transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga80ecf65e658f5b36bfe0bf2d88dd3ca5">spi_flash_direct_transfer_dir_t</a>&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read/Write raw data directly with the OctaFlash/OctaRAM device. Unsupported by QSPI.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a875857cdb3d6ebf0971115737b9e2989">spi_flash_api_t::directTransfer</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>API not supported by QSPI. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga13cbc9d58890d7094712edcf64bc1bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13cbc9d58890d7094712edcf64bc1bf1">&#9670;&nbsp;</a></span>R_QSPI_XipEnter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_QSPI_XipEnter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enters XIP (execute in place) mode.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a48a9a0db1f5bcb24acc9cc1cea14f0ab">spi_flash_api_t::xipEnter</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The flash was programmed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9c894a8a9ef0bb28ba8db701e5a71b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c894a8a9ef0bb28ba8db701e5a71b3a">&#9670;&nbsp;</a></span>R_QSPI_XipExit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_QSPI_XipExit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exits XIP (execute in place) mode.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a00317079cf31b5311592d0845caa4d8a">spi_flash_api_t::xipExit</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The flash was programmed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9d449604f886f5f59952d9e789d5dc65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d449604f886f5f59952d9e789d5dc65">&#9670;&nbsp;</a></span>R_QSPI_Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_QSPI_Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *const&#160;</td>
          <td class="paramname"><em>p_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>p_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>byte_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Program a page of data to the flash.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a35480fe077054fff8bd41c67dbce88fb">spi_flash_api_t::write</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The flash was programmed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_instance_ctrl, p_dest or p_src is NULL, or byte_count crosses a page boundary. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>This function can't be called when XIP mode is enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_DEVICE_BUSY</td><td>The device is busy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa0409e8bb9585e9bd0be17ba9840f8fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0409e8bb9585e9bd0be17ba9840f8fb">&#9670;&nbsp;</a></span>R_QSPI_Erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_QSPI_Erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>p_device_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>byte_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Erase a block or sector of flash. The byte_count must exactly match one of the erase sizes defined in <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__cfg__t">spi_flash_cfg_t</a>. For chip erase, byte_count must be SPI_FLASH_ERASE_SIZE_CHIP_ERASE.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a4fb48ee9af80243cf7f8f966b4c6c56e">spi_flash_api_t::erase</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The command to erase the flash was executed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_instance_ctrl or p_device_address is NULL, or byte_count doesn't match an erase size defined in <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__cfg__t">spi_flash_cfg_t</a>, or device is in XIP mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>This function can't be called when XIP mode is enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_DEVICE_BUSY</td><td>The device is busy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga03da39d9d9f82ea0dfd0f7cc4f253189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03da39d9d9f82ea0dfd0f7cc4f253189">&#9670;&nbsp;</a></span>R_QSPI_StatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_QSPI_StatusGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__status__t">spi_flash_status_t</a> *const&#160;</td>
          <td class="paramname"><em>p_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the write or erase status of the flash.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a36600006109effd5c9d47283a7760ce6">spi_flash_api_t::statusGet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The write status is in p_status. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_instance_ctrl or p_status is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>This function can't be called when XIP mode is enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3762ca61aea95737c5a018d0aa9bd6f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3762ca61aea95737c5a018d0aa9bd6f1">&#9670;&nbsp;</a></span>R_QSPI_BankSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_QSPI_BankSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Selects the bank to access. A bank is a 64MB sliding access window into the QSPI device flash memory space. To access chip address 0x4000000, select bank 1, then read from internal flash address 0x60000000. To access chip address 0x8001000, select bank 2, then read from internal flash address 0x60001000.</p>
<p>This function is not required for memory devices less than or equal to 512 Mb (64MB).</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ae581e587fb514ab784257d07a77d6b32">spi_flash_api_t::bankSet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Bank successfully selected. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7d09918d3ab7458bbd15908f17bae951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d09918d3ab7458bbd15908f17bae951">&#9670;&nbsp;</a></span>R_QSPI_SpiProtocolSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_QSPI_SpiProtocolSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga17c347a498a8a9d38ffc36c0de49a535">spi_flash_protocol_t</a>&#160;</td>
          <td class="paramname"><em>spi_protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the SPI protocol.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a423e63cd15ce3984410c2f5cdf717e35">spi_flash_api_t::spiProtocolSet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>SPI protocol updated on MCU peripheral. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ARGUMENT</td><td>Invalid SPI protocol requested. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3f163c6c0a41fae3a196d3bf2eeb0907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f163c6c0a41fae3a196d3bf2eeb0907">&#9670;&nbsp;</a></span>R_QSPI_AutoCalibrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_QSPI_AutoCalibrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Auto-calibrate the OctaRAM device using the preamble pattern. Unsupported by QSPI. Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ac78c55ffe2b7d99681612ce796a384c5">spi_flash_api_t::autoCalibrate</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>API not supported by QSPI </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga96b3e76ff7daef41184898e3af0aa1a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96b3e76ff7daef41184898e3af0aa1a4">&#9670;&nbsp;</a></span>R_QSPI_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_QSPI_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close the QSPI driver module.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a28bdae798428b85222739a0b9fd43a15">spi_flash_api_t::close</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Configuration was successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_instance_ctrl is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v6.2.0 User's Manual Copyright © (2025) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
