<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: FreeRTOS Port (rm_freertos_port)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v1.1.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___r_m___f_r_e_e_r_t_o_s___p_o_r_t.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">FreeRTOS Port (rm_freertos_port)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<p>FreeRTOS port for RA MCUs. </p>
<h1><a class="anchor" id="r-freertos-port-overview"></a>
Overview</h1>
<dl class="section note"><dt>Note</dt><dd><b>The FreeRTOS Port does not provide any interfaces to the user. Consult the FreeRTOS documentation at <a href="https://www.freertos.org/Documentation">https://www.freertos.org/Documentation</a> for further information.</b></dd></dl>
<h2><a class="anchor" id="r-freertos-port-features"></a>
Features</h2>
<p>The RA FreeRTOS port supports the following features:</p><ul>
<li>Standard FreeRTOS configurations<a class="anchor" id="um_freertos_tick_configuration"></a></li>
<li>Hardware stack monitor<a class="anchor" id="um_freertos_stack_monitor"></a> </li>
</ul>
<h1><a class="anchor" id="r-freertos-port-configuration"></a>
Configuration</h1>
<p><h2>Build Time Configurations for all</h2>
The following build time configurations are defined in aws/FreeRTOSConfig.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>General &gt; Custom FreeRTOSConfig.h</td><td>Manual Entry</td><td></td><td>Add a path to your custom FreeRTOSConfig.h file. It can be used to override some or all of the configurations defined here, and to define additional configurations. </td></tr>
<tr>
<td>General &gt; Use Preemption</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>Set to Enabled to use the preemptive RTOS scheduler, or Disabled to use the cooperative RTOS scheduler. </td></tr>
<tr>
<td>General &gt; Use Port Optimised Task Selection</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Some FreeRTOS ports have two methods of selecting the next task to execute - a generic method, and a method that is specific to that port.<br />
<br />
The Generic method:<br />
Is used when Use Port Optimized Task Selection is set to 0, or when a port specific method is not implemented.<br />
Can be used with all FreeRTOS ports.<br />
Is completely written in C, making it less efficient than a port specific method.<br />
Does not impose a limit on the maximum number of available priorities.<br />
<br />
A port specific method:<br />
Is not available for all ports.<br />
Is used when Use Port Optimized Task Selection is Enabled.<br />
Relies on one or more architecture specific assembly instructions (typically a Count Leading Zeros [CLZ] or equivalent instruction) so can only be used with the architecture for which it was specifically written.<br />
Is more efficient than the generic method.<br />
Typically imposes a limit of 32 on the maximum number of available priorities. </td></tr>
<tr>
<td>General &gt; Use Tickless Idle</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Set Use Tickless Idle to Enabled to use the low power tickless mode, or Disabled to keep the tick interrupt running at all times. Low power tickless implementations are not provided for all FreeRTOS ports. </td></tr>
<tr>
<td>General &gt; Cpu Clock Hz</td><td>Manual Entry</td><td>SystemCoreClock </td><td>Enter the frequency in Hz at which the internal clock that drives the peripheral used to generate the tick interrupt will be executing - this is normally the same clock that drives the internal CPU clock. This value is required in order to correctly configure timer peripherals. </td></tr>
<tr>
<td>General &gt; Tick Rate Hz</td><td>Must be an integer and greater than 0</td><td>1000 </td><td>The frequency of the RTOS tick interrupt.<br />
The tick interrupt is used to measure time. Therefore a higher tick frequency means time can be measured to a higher resolution. However, a high tick frequency also means that the RTOS kernel will use more CPU time so be less efficient. The RTOS demo applications all use a tick rate of 1000Hz. This is used to test the RTOS kernel and is higher than would normally be required.<br />
<br />
More than one task can share the same priority. The RTOS scheduler will share processor time between tasks of the same priority by switching between the tasks during each RTOS tick. A high tick rate frequency will therefore also have the effect of reducing the 'time slice' given to each task. </td></tr>
<tr>
<td>General &gt; Max Priorities</td><td>Must be an integer and greater than 0</td><td>5 </td><td>The number of priorities available to the application tasks. Any number of tasks can share the same priority.<br />
Each available priority consumes RAM within the RTOS kernel so this value should not be set any higher than actually required by your application. </td></tr>
<tr>
<td>General &gt; Minimal Stack Size</td><td>Must be an integer and greater than 0</td><td>128 </td><td>The size of the stack used by the idle task. Generally this should not be reduced from the value set in the FreeRTOSConfig.h file provided with the demo application for the port you are using.<br />
Like the stack size parameter to the xTaskCreate() and xTaskCreateStatic() functions, the stack size is specified in words, not bytes. If each item placed on the stack is 32-bits, then a stack size of 100 means 400 bytes (each 32-bit stack item consuming 4 bytes). </td></tr>
<tr>
<td>General &gt; Max Task Name Len</td><td>Must be an integer and greater than 0</td><td>16 </td><td>The maximum permissible length of the descriptive name given to a task when the task is created. The length is specified in the number of characters including the NULL termination byte. </td></tr>
<tr>
<td>General &gt; Use 16-bit Ticks</td><td>Disabled</td><td>Disabled </td><td>Time is measured in 'ticks' - which is the number of times the tick interrupt has executed since the RTOS kernel was started. The tick count is held in a variable of type TickType_t.<br />
Defining configUSE_16_BIT_TICKS as 1 causes TickType_t to be defined (typedef'ed) as an unsigned 16bit type. Defining configUSE_16_BIT_TICKS as 0 causes TickType_t to be defined (typedef'ed) as an unsigned 32bit type.<br />
<br />
Using a 16-bit type will greatly improve performance on 8- and 16-bit architectures, but limits the maximum specifiable time period to 65535 'ticks'. Therefore, assuming a tick frequency of 250Hz, the maximum time a task can delay or block when a 16bit counter is used is 262 seconds, compared to 17179869 seconds when using a 32-bit counter. </td></tr>
<tr>
<td>General &gt; Idle Should Yield</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>This parameter controls the behaviour of tasks at the idle priority. It only has an effect if:<br />
The preemptive scheduler is being used.<br />
The application creates tasks that run at the idle priority.<br />
If Use Time Slicing is Enabled then tasks that share the same priority will time slice. If none of the tasks get preempted then it might be assumed that each task at a given priority will be allocated an equal amount of processing time - and if the priority is above the idle priority then this is indeed the case.<br />
When tasks share the idle priority the behaviour can be slightly different. If Idle Should Yield is Enabled then the idle task will yield immediately if any other task at the idle priority is ready to run. This ensures the minimum amount of time is spent in the idle task when application tasks are available for scheduling. This behaviour can however have undesirable effects (depending on the needs of your application) as depicted below:<br />
<br />
<br />
The diagram above shows the execution pattern of four tasks that are all running at the idle priority. Tasks A, B and C are application tasks. Task I is the idle task. A context switch occurs with regular period at times T0, T1, ..., T6. When the idle task yields task A starts to execute - but the idle task has already consumed some of the current time slice. This results in task I and task A effectively sharing the same time slice. The application tasks B and C therefore get more processing time than the application task A.<br />
<br />
This situation can be avoided by:<br />
<br />
If appropriate, using an idle hook in place of separate tasks at the idle priority.<br />
Creating all application tasks at a priority greater than the idle priority.<br />
Setting Idle Should Yield to Disabled.<br />
Setting Idle Should Yield to Disabled prevents the idle task from yielding processing time until the end of its time slice. This ensure all tasks at the idle priority are allocated an equal amount of processing time (if none of the tasks get pre-empted) - but at the cost of a greater proportion of the total processing time being allocated to the idle task. </td></tr>
<tr>
<td>General &gt; Use Task Notifications</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>Setting Use Task Notifications to Enabled will include direct to task notification functionality and its associated API in the build.<br />
Setting Use Task Notifications to Disabled will exclude direct to task notification functionality and its associated API from the build.<br />
<br />
Each task consumes 8 additional bytes of RAM when direct to task notifications are included in the build. </td></tr>
<tr>
<td>General &gt; Use Mutexes</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Set to Enabled to include mutex functionality in the build, or Disabled to omit mutex functionality from the build. Readers should familiarise themselves with the differences between mutexes and binary semaphores in relation to the FreeRTOS functionality. </td></tr>
<tr>
<td>General &gt; Use Recursive Mutexes</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Set to Enabled to include recursive mutex functionality in the build, or Disabled to omit recursive mutex functionality from the build. </td></tr>
<tr>
<td>General &gt; Use Counting Semaphores</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>Set to Enabled to include counting semaphore functionality in the build, or Disabled to omit counting semaphore functionality from the build. </td></tr>
<tr>
<td>General &gt; Queue Registry Size</td><td>Must be an integer and greater than 0</td><td>10 </td><td>The queue registry has two purposes, both of which are associated with RTOS kernel aware debugging:<br />
It allows a textual name to be associated with a queue for easy queue identification within a debugging GUI.<br />
It contains the information required by a debugger to locate each registered queue and semaphore.<br />
The queue registry has no purpose unless you are using a RTOS kernel aware debugger. Registry Size defines the maximum number of queues and semaphores that can be registered. Only those queues and semaphores that you want to view using a RTOS kernel aware debugger need be registered. See the API reference documentation for vQueueAddToRegistry() and vQueueUnregisterQueue() for more information. </td></tr>
<tr>
<td>General &gt; Use Queue Sets</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Set to Enabled to include queue set functionality (the ability to block, or pend, on multiple queues and semaphores), or Disabled to omit queue set functionality. </td></tr>
<tr>
<td>General &gt; Use Time Slicing</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>If Use Time Slicing is Enabled, FreeRTOS uses prioritised preemptive scheduling with time slicing. That means the RTOS scheduler will always run the highest priority task that is in the Ready state, and will switch between tasks of equal priority on every RTOS tick interrupt. If Use Time Slicing is Disabled then the RTOS scheduler will still run the highest priority task that is in the Ready state, but will not switch between tasks of equal priority just because a tick interrupt has occurred. </td></tr>
<tr>
<td>General &gt; Use Newlib Reentrant</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>If Use Newlib Reentrant is Enabled then a newlib reent structure will be allocated for each created task.<br />
Note Newlib support has been included by popular demand, but is not used by the FreeRTOS maintainers themselves. FreeRTOS is not responsible for resulting newlib operation. User must be familiar with newlib and must provide system-wide implementations of the necessary stubs. Be warned that (at the time of writing) the current newlib design implements a system-wide malloc() that must be provided with locks. </td></tr>
<tr>
<td>General &gt; Enable Backward Compatibility</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>The FreeRTOS.h header file includes a set of #define macros that map the names of data types used in versions of FreeRTOS prior to version 8.0.0 to the names used in FreeRTOS version 8.0.0. The macros allow application code to update the version of FreeRTOS they are built against from a pre 8.0.0 version to a post 8.0.0 version without modification. Setting Enable Backward Compatibility to Disabled in FreeRTOSConfig.h excludes the macros from the build, and in so doing allowing validation that no pre version 8.0.0 names are being used. </td></tr>
<tr>
<td>General &gt; Num Thread Local Storage Pointers</td><td>Must be an integer and greater than 0</td><td>5 </td><td>Sets the number of indexes in each task's thread local storage array. </td></tr>
<tr>
<td>General &gt; Stack Depth Type</td><td>Manual Entry</td><td>uint32_t </td><td>Sets the type used to specify the stack depth in calls to xTaskCreate(), and various other places stack sizes are used (for example, when returning the stack high water mark).<br />
Older versions of FreeRTOS specified stack sizes using variables of type UBaseType_t, but that was found to be too restrictive on 8-bit microcontrollers. Stack Depth Type removes that restriction by enabling application developers to specify the type to use. </td></tr>
<tr>
<td>General &gt; Message Buffer Length Type</td><td>Manual Entry</td><td>size_t </td><td>FreeRTOS Message buffers use variables of type Message Buffer Length Type to store the length of each message. If Message Buffer Length Type is not defined then it will default to size_t. If the messages stored in a message buffer will never be larger than 255 bytes then defining Message Buffer Length Type to uint8_t will save 3 bytes per message on a 32-bit microcontroller. Likewise if the messages stored in a message buffer will never be larger than 65535 bytes then defining Message Buffer Length Type to uint16_t will save 2 bytes per message on a 32-bit microcontroller. </td></tr>
<tr>
<td>General &gt; Library Max Syscall Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>The highest interrupt priority that can be used by any interrupt service routine that makes calls to interrupt safe FreeRTOS API functions. DO NOT CALL INTERRUPT SAFE FREERTOS API FUNCTIONS FROM ANY INTERRUPT THAT HAS A HIGHER PRIORITY THAN THIS! (higher priorities are lower numeric values)<br />
<br />
Below is explanation for macros that are set based on this value from FreeRTOS website.<br />
<br />
In the RA port, configKERNEL_INTERRUPT_PRIORITY is not used and the kernel runs at the lowest priority.<br />
<br />
Note in the following discussion that only API functions that end in "FromISR" can be called from within an interrupt service routine.<br />
<br />
configMAX_SYSCALL_INTERRUPT_PRIORITY sets the highest interrupt priority from which interrupt safe FreeRTOS API functions can be called.<br />
<br />
A full interrupt nesting model is achieved by setting configMAX_SYSCALL_INTERRUPT_PRIORITY above (that is, at a higher priority level) than configKERNEL_INTERRUPT_PRIORITY. This means the FreeRTOS kernel does not completely disable interrupts, even inside critical sections. Further, this is achieved without the disadvantages of a segmented kernel architecture.<br />
<br />
Interrupts that do not call API functions can execute at priorities above configMAX_SYSCALL_INTERRUPT_PRIORITY and therefore never be delayed by the RTOS kernel execution.<br />
<br />
A special note for ARM Cortex-M users: Please read the page dedicated to interrupt priority settings on ARM Cortex-M devices. As a minimum, remember that ARM Cortex-M cores use numerically low priority numbers to represent HIGH priority interrupts, which can seem counter-intuitive and is easy to forget! If you wish to assign an interrupt a low priority do NOT assign it a priority of 0 (or other low numeric value) as this can result in the interrupt actually having the highest priority in the system - and therefore potentially make your system crash if this priority is above configMAX_SYSCALL_INTERRUPT_PRIORITY.<br />
<br />
The lowest priority on a ARM Cortex-M core is in fact 255 - however different ARM Cortex-M vendors implement a different number of priority bits and supply library functions that expect priorities to be specified in different ways. For example, on the RA6M3 the lowest priority you can specify is 15 - and the highest priority you can specify is 0. </td></tr>
<tr>
<td>General &gt; Assert</td><td>Manual Entry</td><td>assert ( x ) </td><td>The semantics of the configASSERT() macro are the same as the standard C assert() macro. An assertion is triggered if the parameter passed into configASSERT() is zero.<br />
configASSERT() is called throughout the FreeRTOS source files to check how the application is using FreeRTOS. It is highly recommended to develop FreeRTOS applications with configASSERT() defined.<br />
<br />
The example definition (shown at the top of the file and replicated below) calls vAssertCalled(), passing in the file name and line number of the triggering configASSERT() call (__FILE__ and __LINE__ are standard macros provided by most compilers). This is just for demonstration as vAssertCalled() is not a FreeRTOS function, configASSERT() can be defined to take whatever action the application writer deems appropriate.<br />
<br />
It is normal to define configASSERT() in such a way that it will prevent the application from executing any further. This if for two reasons; stopping the application at the point of the assertion allows the cause of the assertion to be debugged, and executing past a triggered assertion will probably result in a crash anyway.<br />
<br />
Note defining configASSERT() will increase both the application code size and execution time. When the application is stable the additional overhead can be removed by simply commenting out the configASSERT() definition in FreeRTOSConfig.h.<br />
<br />
/* Define configASSERT() to call vAssertCalled() if the assertion fails. The assertion<br />
has failed if the value of the parameter passed into configASSERT() equals zero. */<br />
#define configASSERT( ( x ) ) if( ( x ) == 0 ) vAssertCalled( __FILE__, __LINE__ )<br />
If running FreeRTOS under the control of a debugger, then configASSERT() can be defined to just disable interrupts and sit in a loop, as demonstrated below. That will have the effect of stopping the code on the line that failed the assert test - pausing the debugger will then immediately take you to the offending line so you can see why it failed.<br />
<br />
/* Define configASSERT() to disable interrupts and sit in a loop. */<br />
#define configASSERT( ( x ) ) if( ( x ) == 0 ) { taskDISABLE_INTERRUPTS(); for( ;; ); } </td></tr>
<tr>
<td>General &gt; Include Application Defined Privileged Functions</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Include Application Defined Privileged Functions is only used by FreeRTOS MPU.<br />
If Include Application Defined Privileged Functions is Enabled then the application writer must provide a header file called "application_defined_privileged_functions.h", in which functions the application writer needs to execute in privileged mode can be implemented. Note that, despite having a .h extension, the header file should contain the implementation of the C functions, not just the functions' prototypes.<br />
<br />
Functions implemented in "application_defined_privileged_functions.h" must save and restore the processor's privilege state using the prvRaisePrivilege() function and portRESET_PRIVILEGE() macro respectively. For example, if a library provided print function accesses RAM that is outside of the control of the application writer, and therefore cannot be allocated to a memory protected user mode task, then the print function can be encapsulated in a privileged function using the following code:<br />
<br />
void MPU_debug_printf( const char *pcMessage )<br />
{<br />
/* State the privilege level of the processor when the function was called. */<br />
BaseType_t xRunningPrivileged = prvRaisePrivilege();<br />
<br />
 /* Call the library function, which now has access to all RAM. */<br />
 debug_printf( pcMessage );<br />
<br />
 /* Reset the processor privilege level to its original value. */<br />
 portRESET_PRIVILEGE( xRunningPrivileged );<br />
}<br />
This technique should only be use during development, and not deployment, as it circumvents the memory protection. </td></tr>
<tr>
<td>Hooks &gt; Use Idle Hook</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>Set to Enabled if you wish to use an idle hook, or Disabled to omit an idle hook. </td></tr>
<tr>
<td>Hooks &gt; Use Malloc Failed Hook</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>The kernel uses a call to pvPortMalloc() to allocate memory from the heap each time a task, queue or semaphore is created. The official FreeRTOS download includes four sample memory allocation schemes for this purpose. The schemes are implemented in the heap_1.c, heap_2.c, heap_3.c, heap_4.c and heap_5.c source files respectively. Use Malloc Failed Hook is only relevant when one of these three sample schemes is being used.<br />
The malloc() failed hook function is a hook (or callback) function that, if defined and configured, will be called if pvPortMalloc() ever returns NULL. NULL will be returned only if there is insufficient FreeRTOS heap memory remaining for the requested allocation to succeed.<br />
<br />
If Use Malloc Failed Hook is Enabled then the application must define a malloc() failed hook function. If Use Malloc Failed Hook is set to Dosab;ed then the malloc() failed hook function will not be called, even if one is defined. Malloc() failed hook functions must have the name and prototype shown below.<br />
<br />
void vApplicationMallocFailedHook( void ); </td></tr>
<tr>
<td>Hooks &gt; Use Daemon Task Startup Hook</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>If Use Timers and Use Daemon Task Startup Hook are both Enabled then the application must define a hook function that has the exact name and prototype as shown below. The hook function will be called exactly once when the RTOS daemon task (also known as the timer service task) executes for the first time. Any application initialisation code that needs the RTOS to be running can be placed in the hook function.<br />
void void vApplicationDaemonTaskStartupHook( void ); </td></tr>
<tr>
<td>Hooks &gt; Use Tick Hook</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Set to Enabled if you wish to use an tick hook, or Disabled to omit an tick hook. </td></tr>
<tr>
<td>Hooks &gt; Check For Stack Overflow</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>The stack overflow detection page describes the use of this parameter. This is not recommended for RA MCUs with hardware stack monitor support. RA MCU designs should enable the RA hardware stack monitor instead. </td></tr>
<tr>
<td>Stats &gt; Use Trace Facility</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Set to Enabled if you wish to include additional structure members and functions to assist with execution visualisation and tracing. </td></tr>
<tr>
<td>Stats &gt; Use Stats Formatting Functions</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Set Use Trace Facility and Use Stats Formatting Functions to Enabled to include the vTaskList() and vTaskGetRunTimeStats() functions in the build. Setting either to Disabled will omit vTaskList() and vTaskGetRunTimeStates() from the build. </td></tr>
<tr>
<td>Stats &gt; Generate Run Time Stats</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>The Run Time Stats page describes the use of this parameter. </td></tr>
<tr>
<td>Memory Allocation &gt; Support Static Allocation</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>If Support Static Allocation is Enabled then RTOS objects can be created using RAM provided by the application writer.<br />
If Support Static Allocation is Disabled then RTOS objects can only be created using RAM allocated from the FreeRTOS heap.<br />
<br />
If Support Static Allocation is left undefined it will default to 0.<br />
<br />
If Support Static Allocation is Enabled then the application writer must also provide two callback functions: vApplicationGetIdleTaskMemory() to provide the memory for use by the RTOS Idle task, and (if Use Timers is Enabled) vApplicationGetTimerTaskMemory() to provide memory for use by the RTOS Daemon/Timer Service task. Examples are provided below.<br />
<br />
<br />
/* Support Static Allocation is Enabled, so the application must provide an<br />
implementation of vApplicationGetIdleTaskMemory() to provide the memory that is<br />
used by the Idle task. */<br />
void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer,&lt;br&gt;                                    StackType_t **ppxIdleTaskStackBuffer,&lt;br&gt;                                    uint32_t *pulIdleTaskStackSize )<br />
{<br />
/* If the buffers to be provided to the Idle task are declared inside this<br />
function then they must be declared static - otherwise they will be allocated on<br />
the stack and so not exists after this function exits. */<br />
static StaticTask_t xIdleTaskTCB;<br />
static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];<br />
<br />
 /* Pass out a pointer to the StaticTask_t structure in which the Idle task's<br />
 state will be stored. */<br />
 *ppxIdleTaskTCBBuffer = <br />
<br />
 /* Pass out the array that will be used as the Idle task's stack. */<br />
 *ppxIdleTaskStackBuffer = uxIdleTaskStack;<br />
<br />
 /* Pass out the size of the array pointed to by *ppxIdleTaskStackBuffer.<br />
 Note that, as the array is necessarily of type StackType_t,<br />
 configMINIMAL_STACK_SIZE is specified in words, not bytes. */<br />
 *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;<br />
}<br />
/*-----------------------------------------------------------*/<br />
<br />
/* Support Static Allocation and Use Timers are both Enabled, so the<br />
application must provide an implementation of vApplicationGetTimerTaskMemory()<br />
to provide the memory that is used by the Timer service task. */<br />
void vApplicationGetTimerTaskMemory( StaticTask_t **ppxTimerTaskTCBBuffer,&lt;br&gt;                                     StackType_t **ppxTimerTaskStackBuffer,&lt;br&gt;                                     uint32_t *pulTimerTaskStackSize )<br />
{<br />
/* If the buffers to be provided to the Timer task are declared inside this<br />
function then they must be declared static - otherwise they will be allocated on<br />
the stack and so not exists after this function exits. */<br />
static StaticTask_t xTimerTaskTCB;<br />
static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];<br />
<br />
 /* Pass out a pointer to the StaticTask_t structure in which the Timer<br />
 task's state will be stored. */<br />
 *ppxTimerTaskTCBBuffer = <br />
<br />
 /* Pass out the array that will be used as the Timer task's stack. */<br />
 *ppxTimerTaskStackBuffer = uxTimerTaskStack;<br />
<br />
 /* Pass out the size of the array pointed to by *ppxTimerTaskStackBuffer.<br />
 Note that, as the array is necessarily of type StackType_t,<br />
 configTIMER_TASK_STACK_DEPTH is specified in words, not bytes. */<br />
 *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;<br />
}<br />
<br />
Examples of the callback functions that must be provided by the application to<br />
supply the RAM used by the Idle and Timer Service tasks if Support Static Allocation<br />
is Enabled.<br />
<br />
See the Static Vs Dynamic Memory Allocation page for more information. </td></tr>
<tr>
<td>Memory Allocation &gt; Support Dynamic Allocation</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>If Support Dynamic Allocation is Enabled then RTOS objects can be created using RAM that is automatically allocated from the FreeRTOS heap.<br />
If Support Dynamic Allocation is set to 0 then RTOS objects can only be created using RAM provided by the application writer.<br />
<br />
See the Static Vs Dynamic Memory Allocation page for more information. </td></tr>
<tr>
<td>Memory Allocation &gt; Total Heap Size</td><td>Must be an integer and greater than 0</td><td>1024 </td><td>The total amount of RAM available in the FreeRTOS heap.<br />
This value will only be used if Support Dynamic Allocation is Enabled and the application makes use of one of the sample memory allocation schemes provided in the FreeRTOS source code download. See the memory configuration section for further details. </td></tr>
<tr>
<td>Memory Allocation &gt; Application Allocated Heap</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>By default the FreeRTOS heap is declared by FreeRTOS and placed in memory by the linker. Setting Application Allocated Heap to Enabled allows the heap to instead be declared by the application writer, which allows the application writer to place the heap wherever they like in memory.<br />
If heap_1.c, heap_2.c or heap_4.c is used, and Application Allocated Heap is Enabled, then the application writer must provide a uint8_t array with the exact name and dimension as shown below. The array will be used as the FreeRTOS heap. How the array is placed at a specific memory location is dependent on the compiler being used - refer to your compiler's documentation.<br />
<br />
uint8_t ucHeap[ configTOTAL_HEAP_SIZE ]; </td></tr>
<tr>
<td>Timers &gt; Use Timers</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>Set to Enabled to include software timer functionality, or Disabled to omit software timer functionality. See the FreeRTOS software timers page for a full description. </td></tr>
<tr>
<td>Timers &gt; Timer Task Priority</td><td>Must be an integer and greater than 0</td><td>3 </td><td>Sets the priority of the software timer service/daemon task. See the FreeRTOS software timers page for a full description. </td></tr>
<tr>
<td>Timers &gt; Timer Queue Length</td><td>Must be an integer and greater than 0</td><td>10 </td><td>Sets the length of the software timer command queue. See the FreeRTOS software timers page for a full description. </td></tr>
<tr>
<td>Timers &gt; Timer Task Stack Depth</td><td>Must be an integer and greater than 0</td><td>128 </td><td>Sets the stack depth allocated to the software timer service/daemon task. See the FreeRTOS software timers page for a full description. </td></tr>
<tr>
<td>Optional Functions &gt; vTaskPrioritySet() Function</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>Include vTaskPrioritySet() function in build </td></tr>
<tr>
<td>Optional Functions &gt; uxTaskPriorityGet() Function</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>Include uxTaskPriorityGet() function in build </td></tr>
<tr>
<td>Optional Functions &gt; vTaskDelete() Function</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>Include vTaskDelete() function in build </td></tr>
<tr>
<td>Optional Functions &gt; vTaskSuspend() Function</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>Include vTaskSuspend() function in build </td></tr>
<tr>
<td>Optional Functions &gt; xResumeFromISR() Function</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>Include xResumeFromISR() function in build </td></tr>
<tr>
<td>Optional Functions &gt; vTaskDelayUntil() Function</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>Include vTaskDelayUntil() function in build </td></tr>
<tr>
<td>Optional Functions &gt; vTaskDelay() Function</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>Include vTaskDelay() function in build </td></tr>
<tr>
<td>Optional Functions &gt; xTaskGetSchedulerState() Function</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>Include xTaskGetSchedulerState() function in build </td></tr>
<tr>
<td>Optional Functions &gt; xTaskGetCurrentTaskHandle() Function</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>Include xTaskGetCurrentTaskHandle() function in build </td></tr>
<tr>
<td>Optional Functions &gt; uxTaskGetStackHighWaterMark() Function</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Include uxTaskGetStackHighWaterMark() function in build </td></tr>
<tr>
<td>Optional Functions &gt; xTaskGetIdleTaskHandle() Function</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Include xTaskGetIdleTaskHandle() function in build </td></tr>
<tr>
<td>Optional Functions &gt; eTaskGetState() Function</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Include eTaskGetState() function in build </td></tr>
<tr>
<td>Optional Functions &gt; xEventGroupSetBitFromISR() Function</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>Include xEventGroupSetBitFromISR() function in build </td></tr>
<tr>
<td>Optional Functions &gt; xTimerPendFunctionCall() Function</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Include xTimerPendFunctionCall() function in build </td></tr>
<tr>
<td>Optional Functions &gt; xTaskAbortDelay() Function</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Include xTaskAbortDelay() function in build </td></tr>
<tr>
<td>Optional Functions &gt; xTaskGetHandle() Function</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Include xTaskGetHandle() function in build </td></tr>
<tr>
<td>Optional Functions &gt; xTaskResumeFromISR() Function</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>Include xTaskResumeFromISR() function in build </td></tr>
<tr>
<td>RA &gt; Hardware Stack Monitor</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Include RA stack monitor </td></tr>
<tr>
<td>Logging &gt; Print String Function</td><td>Manual Entry</td><td>printf(x) </td><td></td></tr>
<tr>
<td>Logging &gt; Logging Max Message Length</td><td>Manual Entry</td><td>192 </td><td></td></tr>
<tr>
<td>Logging &gt; Logging Include Time and Task Name</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td></td></tr>
</table>
</p>
<h2><a class="anchor" id="r-freertos-port-clock-configuration"></a>
Clock Configuration</h2>
<p>The FreeRTOS port uses the SysTick timer as the system clock. The timer rate is configured in the FreeRTOS component under General &gt; Tick Rate Hz.</p>
<h2><a class="anchor" id="r-freertos-port-pin-configuration"></a>
Pin Configuration</h2>
<p>This module does not use I/O pins.</p>
<h1><a class="anchor" id="r-freertos-port-usage-notes"></a>
Usage Notes</h1>
<h2><a class="anchor" id="r-freertos-port-hardware-stack-monitor"></a>
Hardware Stack Monitor</h2>
<p>The hardware stack monitor generates an NMI if the PSP goes out of the memory area for the stack allocated for the current task. A callback can be registered using <a class="el" href="group___b_s_p___m_c_u.html#gaed27ea47f0c85a1af9bb515600d5e2ba">R_BSP_GroupIrqWrite()</a> to be called whenever a stack overflow or underflow of the PSP for a particular thread is detected.</p>
<h3><a class="anchor" id="r-freertos-port-hardware-stack-monitor-underflow"></a>
Stack Monitor Underflow Detection</h3>
<p>By default the hardware stack monitor only checks for overflow of the process stack. To check for underflow define configRECORD_STACK_HIGH_ADDRESS as 1 on the command line.</p>
<h2><a class="anchor" id="r-freertos-port-low-power-modes"></a>
Low Power Modes</h2>
<p><a class="anchor" id="um_freertos_low_power"></a>When FreeRTOS is configured to use tickless idle, the idle task executes WFI() when no task is ready to run. If the MCU is configured to enter software standby mode or deep software standby mode when the idle task executes WFI(), the RA FreeRTOS port changes the low power mode to sleep mode so the idle task can wake from SysTick. The low power mode settings are restored when the MCU wakes from sleep mode.</p>
<h1><a class="anchor" id="r-freertos-port-examples"></a>
Examples</h1>
<h2>Stack Monitor Example</h2>
<p>This is an example of using the stack monitor in an application.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> stack_monitor_callback(<a class="code" href="group___b_s_p___m_c_u.html#ga72e70676360e6a4d753a8d235e6b93a2">bsp_grp_irq_t</a> irq);</div><div class="line"><span class="keywordtype">void</span> rm_freertos_port_stack_monitor_example(<span class="keywordtype">void</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> stack_monitor_callback (<a class="code" href="group___b_s_p___m_c_u.html#ga72e70676360e6a4d753a8d235e6b93a2">bsp_grp_irq_t</a> irq)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gaf0afcbc9a110ac9366a811d96ee06029">FSP_PARAMETER_NOT_USED</a>(irq);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (1U == R_MPU_SPMON-&gt;SP[0].CTL_b.ERROR)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Handle main stack monitor error here. */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (1U == R_MPU_SPMON-&gt;SP[1].CTL_b.ERROR)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Handle process stack monitor error here. */</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> rm_freertos_port_stack_monitor_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Register a callback to be called when the stack goes outside the allocated stack area. */</span></div><div class="line">    <a class="code" href="group___b_s_p___m_c_u.html#gaed27ea47f0c85a1af9bb515600d5e2ba">R_BSP_GroupIrqWrite</a>(<a class="code" href="group___b_s_p___m_c_u.html#gga72e70676360e6a4d753a8d235e6b93a2a3ddc13da630734d6b18004ffe3696d1d">BSP_GRP_IRQ_MPU_STACK</a>, stack_monitor_callback);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v1.1.0 User's Manual Copyright Â© (2020) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
