<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: OSPI Flash (r_ospi_b)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
    $(document).ready(function() {
        $("tr.tree_lvl_1").nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
		$("tr.tree_lvl_1").data("expanded","0");
		$("tr.tree_lvl_2").data("expanded","0");
		$("tr.tree_lvl_3").data("expanded","0");
		$("tr.tree_lvl_4").data("expanded","0");
		$("tr.tree_lvl_5").data("expanded","0");
        $("tr.tree_lvl_1").click(function() {
		    var lvl_1_is_open = $(this).data("expanded");
		    if (lvl_1_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2, tr.tree_lvl_1_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_2").click(function() {
		    var lvl_2_is_open = $(this).data("expanded");
		    if (lvl_2_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3, tr.tree_lvl_2_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_3").click(function() {
		    var lvl_3_is_open = $(this).data("expanded");
		    if (lvl_3_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_3_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_4").click(function() {
		    var lvl_4_is_open = $(this).data("expanded");
		    if (lvl_4_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5, tr.tree_lvl_4_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_5").click(function() {
		    var lvl_5_is_open = $(this).data("expanded");
		    if (lvl_5_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4_item,tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
     });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v6.1.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">

    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text">
      </span>
      <span class="right">
          &nbsp;
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___o_s_p_i___b.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body.
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len));
            }
          }
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element.
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">OSPI Flash (r_ospi_b)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___s_t_o_r_a_g_e___m_o_d_u_l_e_s.html">Storage</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9134500bd9ee50551e218a81868f5b1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#ga9134500bd9ee50551e218a81868f5b1a">R_OSPI_B_Open</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *const p_ctrl, <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__cfg__t">spi_flash_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:ga9134500bd9ee50551e218a81868f5b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae419ec1af4afc888da2d59403ca8225a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#gae419ec1af4afc888da2d59403ca8225a">R_OSPI_B_DirectWrite</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_ctrl, uint8_t const *const p_src, uint32_t const bytes, bool const read_after_write)</td></tr>
<tr class="separator:gae419ec1af4afc888da2d59403ca8225a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0f52f7bbbbf2f94305f6334ad06b2d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#gad0f52f7bbbbf2f94305f6334ad06b2d8">R_OSPI_B_DirectRead</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_ctrl, uint8_t *const p_dest, uint32_t const bytes)</td></tr>
<tr class="separator:gad0f52f7bbbbf2f94305f6334ad06b2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b42dbc86db7f4c82ed640620743c609"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#ga7b42dbc86db7f4c82ed640620743c609">R_OSPI_B_DirectTransfer</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_ctrl, <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__direct__transfer__t">spi_flash_direct_transfer_t</a> *const p_transfer, <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga80ecf65e658f5b36bfe0bf2d88dd3ca5">spi_flash_direct_transfer_dir_t</a> direction)</td></tr>
<tr class="separator:ga7b42dbc86db7f4c82ed640620743c609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15282e9d7ef4d8c5471be859da55dd4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#ga15282e9d7ef4d8c5471be859da55dd4a">R_OSPI_B_XipEnter</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:ga15282e9d7ef4d8c5471be859da55dd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96bc15adf392eccfa44eed3fb91fa7ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#ga96bc15adf392eccfa44eed3fb91fa7ef">R_OSPI_B_XipExit</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:ga96bc15adf392eccfa44eed3fb91fa7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeb33594cd4d4f031f090857a7b3832b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#gabeb33594cd4d4f031f090857a7b3832b">R_OSPI_B_Write</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_ctrl, uint8_t const *const p_src, uint8_t *const p_dest, uint32_t byte_count)</td></tr>
<tr class="separator:gabeb33594cd4d4f031f090857a7b3832b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga043d8c26f4d9c08a145bec1a3df4a2a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#ga043d8c26f4d9c08a145bec1a3df4a2a2">R_OSPI_B_Erase</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_ctrl, uint8_t *const p_device_address, uint32_t byte_count)</td></tr>
<tr class="separator:ga043d8c26f4d9c08a145bec1a3df4a2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5936464390d82c29e2d03f6c04880e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#gae5936464390d82c29e2d03f6c04880e2">R_OSPI_B_StatusGet</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_ctrl, <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__status__t">spi_flash_status_t</a> *const p_status)</td></tr>
<tr class="separator:gae5936464390d82c29e2d03f6c04880e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga353dc5f34b95e0fac9f4f3074e52df70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#ga353dc5f34b95e0fac9f4f3074e52df70">R_OSPI_B_BankSet</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_ctrl, uint32_t bank)</td></tr>
<tr class="separator:ga353dc5f34b95e0fac9f4f3074e52df70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39b3c250a591ffd092cd6ded8c45249c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#ga39b3c250a591ffd092cd6ded8c45249c">R_OSPI_B_SpiProtocolSet</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_ctrl, <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga17c347a498a8a9d38ffc36c0de49a535">spi_flash_protocol_t</a> spi_protocol)</td></tr>
<tr class="separator:ga39b3c250a591ffd092cd6ded8c45249c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4070e46f2fadda4ec4cb8b8f023c1a00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#ga4070e46f2fadda4ec4cb8b8f023c1a00">R_OSPI_B_Close</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:ga4070e46f2fadda4ec4cb8b8f023c1a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3441de6c487a640fae584248007a3a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#gac3441de6c487a640fae584248007a3a6">R_OSPI_B_AutoCalibrate</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:gac3441de6c487a640fae584248007a3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8ca05a2a44468130ef9e97aee6e9f66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#gaf8ca05a2a44468130ef9e97aee6e9f66">R_OSPI_B_RowLoad</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *const p_ctrl, uint32_t row_index)</td></tr>
<tr class="separator:gaf8ca05a2a44468130ef9e97aee6e9f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd7b272b5cd5d961d742d681bdc651bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#gafd7b272b5cd5d961d742d681bdc651bc">R_OSPI_B_RowStore</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *const p_ctrl, uint32_t row_index)</td></tr>
<tr class="separator:gafd7b272b5cd5d961d742d681bdc651bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga215959cccab9f53a2516920ed0182dfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#ga215959cccab9f53a2516920ed0182dfc">R_OSPI_B_DOTF_Configure</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *const p_ctrl, <a class="el" href="group___o_s_p_i___b.html#structospi__b__dotf__cfg__t">ospi_b_dotf_cfg_t</a> *const p_dotf_cfg)</td></tr>
<tr class="separator:ga215959cccab9f53a2516920ed0182dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the OSPI_B peripheral on RA MCUs. This module implements the <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html">SPI Flash Interface</a>. </p>
<h1><a class="anchor" id="r-ospi-b-overview"></a>
Overview</h1>
<p>The OSPI_B peripheral supports xSPI (or OSPI) compatible external memory devices, and it interfaces with these devices to perform data I/O Operations. The OSPI_B peripheral does not support addressable devices, so all connected memory devices must be connected to an individual chip-select pin. Please note that this document will reference the xSPI protocol to which OSPI is a subset. The OSPI_B peripheral is compatible with a variety of xSPI protocol operating modes.</p>
<h2><a class="anchor" id="r-ospi-b-features"></a>
Features</h2>
<p>The OSPI_B driver has the following key features to support the <b>xSPI</b> device:</p><ul>
<li>Perform data I/O Operation<a class="anchor" id="um_ospi_spi"></a><a class="anchor" id="um_ospi_opi"></a></li>
<li>Direct memory-mapped access to the xSPI device memory up to 256 MB.</li>
<li>Can be configured with xSPI devices on either of the 2 channels</li>
<li>Programming the xSPI device using combination write (up to 64 bytes)<a class="anchor" id="um_ospi_page_program"></a></li>
<li>Erasing the xSPI device<a class="anchor" id="um_ospi_erase"></a></li>
<li>Sending device specific commands and reading back responses of up to 8 bytes<a class="anchor" id="um_ospi_direct_transfer"></a></li>
<li>1- and 2-byte addressing intended for row-column memories</li>
<li>3 byte addressing<a class="anchor" id="um_ospi_3byte_address"></a></li>
<li>4 byte addressing<a class="anchor" id="um_ospi_4byte_address"></a></li>
<li>Auto-calibration<a class="anchor" id="um_ospi_autocalibration"></a></li>
<li>Decryption-on-the-fly</li>
<li>Support for standard SPI frames, xSPI Protocol 1.0, xSPI Protocol 2.0, and xSPI Protocol 2.0 Extended frames.</li>
</ul>
<p>Additional build-time features:</p><ul>
<li>Optional (build-time) DMAC support for data transmission when used with OSPI_B.<a class="anchor" id="um_ospi_optional_dmac_support_for_data_transmission"></a></li>
<li>Optional (build-time) XiP support for entering/exiting XiP mode of the target device.<a class="anchor" id="um_ospi_xip_mode"></a></li>
<li>Optional (build-time) Data-strobe (DS) auto-calibration support for target devices using the DS signal.</li>
<li>Optional (build-time) Decryption on the fly (DOTF)<a class="anchor" id="um_ospi_dotf"></a></li>
<li>Optional (build-time) Support for memory which use row-column addressing.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>For OSPI_B, use of DMAC for data transmission is strongly recommended. Without the use of DMAC, due to the high-speed hardware design of the OSPI peripheral, data transmission can be sensitive to timing variance, which could cause software-based memory-mapped operations to fail unexpectedly.</dd></dl>
<h1><a class="anchor" id="r-ospi-b-configuration"></a>
Configuration</h1>
<h2>OSPI_B Flash:</h2>
<p><h2>Build Time Configurations for r_ospi_b</h2>
The following build time configurations are defined in fsp_cfg/r_ospi_b_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Memory-mapping Support  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Prefetch Function</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enable</li>
<li>
Disable</li>
</ul>
</td><td>Enable </td><td>Enable prefetch function on memory-mapped reads. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Combination Function</td><td>Refer to the RA Configuration tool for available options.</td><td>64 Bytes </td><td>Enable combination function on memory-mapped writes. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">XiP Support</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enable</li>
<li>
Disable</li>
</ul>
</td><td>Disable </td><td>Enable the use of XiP enter and exit codes. </td></tr>
<tr class="tree_none">
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr class="tree_none">
<td>DMAC Support</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enable</li>
<li>
Disable</li>
</ul>
</td><td>Disable </td><td>Enable DMAC support for the OSPI module. </td></tr>
<tr class="tree_none">
<td>Autocalibration Support</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enable</li>
<li>
Disable</li>
</ul>
</td><td>Disable </td><td>Enable DS autocalibration for dual-data-rate modes. </td></tr>
<tr class="tree_none">
<td>DOTF Support</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enable (Protected Mode)</li>
<li>
Enable (Compatibility Mode)</li>
<li>
Disable</li>
</ul>
</td><td>Disable </td><td>Enable DOTF support for the OSPI module. </td></tr>
<tr class="tree_none">
<td>Row Addressing Support</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enable</li>
<li>
Disable</li>
</ul>
</td><td>Disable </td><td>Enable support for xSPI devices which utilize row-column addressing of the memory array. </td></tr>
</table>
 <h2>Configurations for Storage &gt; OSPI (r_ospi_b)</h2>
This module can be added to the Stacks tab via New Stack &gt; Storage &gt; OSPI (r_ospi_b).<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> General  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Name</td><td>Name must be a valid C symbol</td><td>g_ospi0 </td><td>Module name. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Unit</td><td>MCU Specific Options</td><td></td><td>Specify the OSPI peripheral to use. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Chip Select</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
CS0</li>
<li>
CS1</li>
</ul>
</td><td>CS1 </td><td>Specify the OSPI chip select line to use. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Write Status Bit</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
b0</li>
<li>
b1</li>
<li>
b2</li>
<li>
b3</li>
<li>
b4</li>
<li>
b5</li>
<li>
b6</li>
<li>
b7</li>
</ul>
</td><td>b0 </td><td>Which bit contains the write in progress status returned from the Write Status Command. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Write Enable Bit</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
b0</li>
<li>
b1</li>
<li>
b2</li>
<li>
b3</li>
<li>
b4</li>
<li>
b5</li>
<li>
b6</li>
<li>
b7</li>
</ul>
</td><td>b1 </td><td>Which bit contains the write enable status returned from the Write Enable Command. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">DS Auto-calibration Pattern Address</td><td>Must be a valid pointer address</td><td>0 </td><td>Address to the auto-calibration pattern in the target flash memory's address space. </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Command Sets  </td></tr>
<tr class="tree_lvl_2">
<td class="tree_lvl_2" colspan="4"><span class="chevron-collapsed"></span> Command Sets &gt; Custom Table  </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Table Pointer</td><td>Must be a vaild C symbol</td><td></td><td>Specify the custom command set table (<a class="el" href="group___o_s_p_i___b.html#structospi__b__xspi__command__set__t">ospi_b_xspi_command_set_t</a>[]) to use. If provided, all other command set settings are ignored. </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Table Length</td><td>Length must be an integer greater than or equal to zero.</td><td>0 </td><td>Length of the custom command set table. </td></tr>
<tr class="tree_lvl_2">
<td class="tree_lvl_2" colspan="4"><span class="chevron-collapsed"></span> Command Sets &gt; Erase Sizes  </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Sector Erase</td><td>Erase size must be an integer greater-than or equal-to zero and less than 4,294,967,296 (0xFFFF_FFFF).</td><td>4096 </td><td>Size of the memory region erased by Sector Erase </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Block Erase</td><td>Erase size must be an integer greater-than or equal-to zero and less than 4,294,967,296 (0xFFFF_FFFF).</td><td>262144 </td><td>Size of the memory region erased by Block Erase </td></tr>
<tr class="tree_lvl_2">
<td class="tree_lvl_2" colspan="4"><span class="chevron-collapsed"></span> Command Sets &gt; Initial Mode  </td></tr>
<tr class="tree_lvl_3">
<td class="tree_lvl_3" colspan="4"><span class="chevron-collapsed"></span> Command Sets &gt; Initial Mode &gt; Read  </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Command Code</td><td>Command codes must be positive and fit in the selected command byte length.</td><td>0x13 </td><td>Read command code. Set to 0x00 to disable. </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Dummy Cycles</td><td>Dummy cycle counts must be an integer between 0 and 31.</td><td>0 </td><td>Dummy cycles to use between the address and data phase for Read commands. Set to 0 to disable dummy cycles. </td></tr>
<tr class="tree_lvl_3">
<td class="tree_lvl_3" colspan="4"><span class="chevron-collapsed"></span> Command Sets &gt; Initial Mode &gt; Program  </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Command Code</td><td>Command codes must be positive and fit in the selected command byte length.</td><td>0x12 </td><td>Program command code. Set to 0x00 to disable. </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Dummy Cycles</td><td>Dummy cycle counts must be an integer between 0 and 31.</td><td>0 </td><td>Dummy cycles to use between the address and data phase for Program commands. Set to 0 to disable dummy cycles. </td></tr>
<tr class="tree_lvl_3">
<td class="tree_lvl_3" colspan="4"><span class="chevron-collapsed"></span> Command Sets &gt; Initial Mode &gt; Row Load  </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Command Code</td><td>Command codes must be positive and fit in the selected command byte length.</td><td>0x00 </td><td>Row Load command code. Set to 0x00 to disable. </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Dummy Cycles</td><td>Dummy cycle counts must be an integer between 0 and 31.</td><td>0 </td><td>Dummy cycles to use between the address and data phase for Row Load commands. Set to 0 to disable dummy cycles. </td></tr>
<tr class="tree_lvl_3">
<td class="tree_lvl_3" colspan="4"><span class="chevron-collapsed"></span> Command Sets &gt; Initial Mode &gt; Row Store  </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Command Code</td><td>Command codes must be positive and fit in the selected command byte length.</td><td>0x00 </td><td>Row Store command code. Set to 0x00 to disable. </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Dummy Cycles</td><td>Dummy cycle counts must be an integer between 0 and 31.</td><td>0 </td><td>Dummy cycles to use between the address and data phase for Row Store commands. Set to 0 to disable dummy cycles. </td></tr>
<tr class="tree_lvl_3">
<td class="tree_lvl_3" colspan="4"><span class="chevron-collapsed"></span> Command Sets &gt; Initial Mode &gt; Write Enable  </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Command Code</td><td>Command codes must be positive and fit in the selected command byte length.</td><td>0x06 </td><td>Write Enable command code. Set to 0x00 to disable. </td></tr>
<tr class="tree_lvl_3">
<td class="tree_lvl_3" colspan="4"><span class="chevron-collapsed"></span> Command Sets &gt; Initial Mode &gt; Status Read  </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Command Code</td><td>Command codes must be positive and fit in the selected command byte length.</td><td>0x05 </td><td>Status Read command code. Set to 0x00 to disable. </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Dummy Cycles</td><td>Dummy cycle counts must be an integer between 0 and 31.</td><td>0 </td><td>Dummy cycles to use between the address and data phase for Status Read commands. Set to 0 to disable dummy cycles. </td></tr>
<tr class="tree_lvl_3">
<td class="tree_lvl_3" colspan="4"><span class="chevron-collapsed"></span> Command Sets &gt; Initial Mode &gt; Sector Erase  </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Command Code</td><td>Command codes must be positive and fit in the selected command byte length.</td><td>0x21 </td><td>Sector Erase command code. Set to 0x00 to disable. </td></tr>
<tr class="tree_lvl_3">
<td class="tree_lvl_3" colspan="4"><span class="chevron-collapsed"></span> Command Sets &gt; Initial Mode &gt; Block Erase  </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Command Code</td><td>Command codes must be positive and fit in the selected command byte length.</td><td>0xDC </td><td>Block Erase command code. Set to 0x00 to disable. </td></tr>
<tr class="tree_lvl_3">
<td class="tree_lvl_3" colspan="4"><span class="chevron-collapsed"></span> Command Sets &gt; Initial Mode &gt; Chip Erase  </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Command Code</td><td>Command codes must be positive and fit in the selected command byte length.</td><td>0x60 </td><td>Chip Erase command code. Set to 0x00 to disable. </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Protocol Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
SPI (1S-1S-1S)</li>
<li>
DSPI (1S-2S-2S)</li>
<li>
DSPI (2S-2S-2S)</li>
<li>
QSPI (1S-4S-4S)</li>
<li>
QSPI (4S-4S-4S)</li>
<li>
QSPI (4S-4D-4D)</li>
<li>
Dual data rate OPI (8D-8D-8D)</li>
</ul>
</td><td>SPI (1S-1S-1S) </td><td>Signal protocol mode to use for this command set. </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Frame Format</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Standard</li>
<li>
xSPI Profile 1.0</li>
<li>
xSPI Profile 2.0</li>
<li>
xSPI Profile 2.0 Extended</li>
</ul>
</td><td>Standard </td><td>Frame format to use with this command set. </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Latency Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Fixed</li>
<li>
Variable (DQS)</li>
</ul>
</td><td>Fixed </td><td>Latency mode to use with this command set. </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Address Length</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1 byte</li>
<li>
2 bytes</li>
<li>
3 bytes</li>
<li>
4 bytes</li>
</ul>
</td><td>3 bytes </td><td>Number of bytes used to address data in a memory page or row. </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Address MSB Mask</td><td>Address mask must be between 0x00 and 0xFF.</td><td>0xF0 </td><td>Mask of bits to zero for the most-significant byte of the address stage during memory-mapped operations </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Command Code Length</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1 byte</li>
<li>
2 bytes</li>
</ul>
</td><td>1 byte </td><td></td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Status Register Address Length</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
No address</li>
<li>
1 byte</li>
<li>
2 bytes</li>
<li>
3 bytes</li>
<li>
4 bytes</li>
</ul>
</td><td>No address </td><td>Number of bytes used for addressing the status register. </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Status Register Address</td><td>Status register address must be between 0x00 and 0xFFFF_FFFF, inclusive.</td><td>0x00 </td><td>Address of the status register that reports Write-in-Progress and Write-Enable flags. </td></tr>
<tr class="tree_lvl_2">
<td class="tree_lvl_2" colspan="4"><span class="chevron-collapsed"></span> Command Sets &gt; High-speed Mode  </td></tr>
<tr class="tree_lvl_3">
<td class="tree_lvl_3" colspan="4"><span class="chevron-collapsed"></span> Command Sets &gt; High-speed Mode &gt; Read  </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Command Code</td><td>Command codes must be positive and fit in the selected command byte length.</td><td>0xEEEE </td><td>Read command code. Set to 0x00 to disable. </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Dummy Cycles</td><td>Dummy cycle counts must be an integer between 0 and 31.</td><td>20 </td><td>Dummy cycles to use between the address and data phase for Read commands. Set to 0 to disable dummy cycles. </td></tr>
<tr class="tree_lvl_3">
<td class="tree_lvl_3" colspan="4"><span class="chevron-collapsed"></span> Command Sets &gt; High-speed Mode &gt; Program  </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Command Code</td><td>Command codes must be positive and fit in the selected command byte length.</td><td>0x1212 </td><td>Program command code. Set to 0x00 to disable. </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Dummy Cycles</td><td>Dummy cycle counts must be an integer between 0 and 31.</td><td>0 </td><td>Dummy cycles to use between the address and data phase for Program commands. Set to 0 to disable dummy cycles. </td></tr>
<tr class="tree_lvl_3">
<td class="tree_lvl_3" colspan="4"><span class="chevron-collapsed"></span> Command Sets &gt; High-speed Mode &gt; Row Load  </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Command Code</td><td>Command codes must be positive and fit in the selected command byte length.</td><td>0x00 </td><td>Row Load command code. Set to 0x00 to disable. </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Dummy Cycles</td><td>Dummy cycle counts must be an integer between 0 and 31.</td><td>0 </td><td>Dummy cycles to use between the address and data phase for Row Load commands. Set to 0 to disable dummy cycles. </td></tr>
<tr class="tree_lvl_3">
<td class="tree_lvl_3" colspan="4"><span class="chevron-collapsed"></span> Command Sets &gt; High-speed Mode &gt; Row Store  </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Command Code</td><td>Command codes must be positive and fit in the selected command byte length.</td><td>0x00 </td><td>Row Store command code. Set to 0x00 to disable. </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Dummy Cycles</td><td>Dummy cycle counts must be an integer between 0 and 31.</td><td>0 </td><td>Dummy cycles to use between the address and data phase for Row Store commands. Set to 0 to disable dummy cycles. </td></tr>
<tr class="tree_lvl_3">
<td class="tree_lvl_3" colspan="4"><span class="chevron-collapsed"></span> Command Sets &gt; High-speed Mode &gt; Write Enable  </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Command Code</td><td>Command codes must be positive and fit in the selected command byte length.</td><td>0x0606 </td><td>Write Enable command code. Set to 0x00 to disable. </td></tr>
<tr class="tree_lvl_3">
<td class="tree_lvl_3" colspan="4"><span class="chevron-collapsed"></span> Command Sets &gt; High-speed Mode &gt; Status Read  </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Command Code</td><td>Command codes must be positive and fit in the selected command byte length.</td><td>0x0505 </td><td>Status Read command code. Set to 0x00 to disable. </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Dummy Cycles</td><td>Dummy cycle counts must be an integer between 0 and 31.</td><td>3 </td><td>Dummy cycles to use between the address and data phase for Status Read commands. Set to 0 to disable dummy cycles. </td></tr>
<tr class="tree_lvl_3">
<td class="tree_lvl_3" colspan="4"><span class="chevron-collapsed"></span> Command Sets &gt; High-speed Mode &gt; Sector Erase  </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Command Code</td><td>Command codes must be positive and fit in the selected command byte length.</td><td>0x2121 </td><td>Sector Erase command code. Set to 0x00 to disable. </td></tr>
<tr class="tree_lvl_3">
<td class="tree_lvl_3" colspan="4"><span class="chevron-collapsed"></span> Command Sets &gt; High-speed Mode &gt; Block Erase  </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Command Code</td><td>Command codes must be positive and fit in the selected command byte length.</td><td>0xDCDC </td><td>Block Erase command code. Set to 0x00 to disable. </td></tr>
<tr class="tree_lvl_3">
<td class="tree_lvl_3" colspan="4"><span class="chevron-collapsed"></span> Command Sets &gt; High-speed Mode &gt; Chip Erase  </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Command Code</td><td>Command codes must be positive and fit in the selected command byte length.</td><td>0x6060 </td><td>Chip Erase command code. Set to 0x00 to disable. </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Protocol Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
SPI (1S-1S-1S)</li>
<li>
DSPI (1S-2S-2S)</li>
<li>
DSPI (2S-2S-2S)</li>
<li>
QSPI (1S-4S-4S)</li>
<li>
QSPI (4S-4S-4S)</li>
<li>
QSPI (4S-4D-4D)</li>
<li>
Dual data rate OPI (8D-8D-8D)</li>
</ul>
</td><td>Dual data rate OPI (8D-8D-8D) </td><td>Signal protocol mode to use for this command set. </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Frame Format</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Standard</li>
<li>
xSPI Profile 1.0</li>
<li>
xSPI Profile 2.0</li>
<li>
xSPI Profile 2.0 Extended</li>
</ul>
</td><td>xSPI Profile 1.0 </td><td>Frame format to use with this command set. </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Latency Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Fixed</li>
<li>
Variable (DQS)</li>
</ul>
</td><td>Fixed </td><td>Latency mode to use with this command set. </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Address Length</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1 byte</li>
<li>
2 bytes</li>
<li>
3 bytes</li>
<li>
4 bytes</li>
</ul>
</td><td>4 bytes </td><td>Number of bytes used to address data in a memory page or row. </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Address MSB Mask</td><td>Address mask must be between 0x00 and 0xFF.</td><td>0xF0 </td><td>Mask of bits to zero for the most-significant byte of the address stage during memory-mapped operations </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Command Code Length</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1 byte</li>
<li>
2 bytes</li>
</ul>
</td><td>2 bytes </td><td></td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Status Register Address Length</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
No address</li>
<li>
1 byte</li>
<li>
2 bytes</li>
<li>
3 bytes</li>
<li>
4 bytes</li>
</ul>
</td><td>4 bytes </td><td>Number of bytes used for addressing the status register. </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Status Register Address</td><td>Status register address must be between 0x00 and 0xFFFF_FFFF, inclusive.</td><td>0x00 </td><td>Address of the status register that reports Write-in-Progress and Write-Enable flags. </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Timing Settings  </td></tr>
<tr class="tree_lvl_2">
<td class="tree_lvl_2" colspan="4"><span class="chevron-collapsed"></span> Timing Settings &gt; Chip Select  </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Command Interval</td><td>Refer to the RA Configuration tool for available options.</td><td>2 cycles </td><td>Minimum clock cycles between two consecutive xSPI frames (CS idle time). </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Pull-up Timing</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
No Extension</li>
<li>
1 Cycle</li>
</ul>
</td><td>No Extension </td><td>Signal pull-up timing (CS asserting extension) setting in OCTACLK units </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Pull-down Timing</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
No Extension</li>
<li>
1 Cycle</li>
</ul>
</td><td>No Extension </td><td>Signal pull-down timing (CS negating extension) setting in OCTACLK units </td></tr>
<tr class="tree_lvl_2">
<td class="tree_lvl_2" colspan="4"><span class="chevron-collapsed"></span> Timing Settings &gt; SDR  </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Drive Timing</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Drive 1/2 cycle before CK</li>
<li>
Drive at CK</li>
</ul>
</td><td>Drive 1/2 cycle before CK </td><td>Data signal timing relative to the rising-edge of the CK signal. </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">CK Sampling Edge</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Falling edge</li>
<li>
Rising edge</li>
</ul>
</td><td>Falling edge </td><td>Selects the clock edge to sample the data signal. </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Sampling Delay</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
None</li>
<li>
1 cycle</li>
<li>
2 cycles</li>
<li>
3 cycles</li>
<li>
4 cycles</li>
<li>
5 cycles</li>
<li>
6 cycles</li>
<li>
7 cycles</li>
</ul>
</td><td>None </td><td>Number of cycles to delay before sampling the data signal. </td></tr>
<tr class="tree_lvl_2">
<td class="tree_lvl_2" colspan="4"><span class="chevron-collapsed"></span> Timing Settings &gt; DDR  </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Sampling Window Extension</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
None</li>
<li>
1 cycle</li>
<li>
2 cycles</li>
<li>
3 cycles</li>
<li>
4 cycles</li>
<li>
5 cycles</li>
<li>
6 cycles</li>
<li>
7 cycles</li>
</ul>
</td><td>None </td><td>Number of cycles to extending the data sampling window in DDR mode. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">DS Latching Delay</td><td>Refer to the RA Configuration tool for available options.</td><td>Auto-calibrate </td><td>Number of delay cells for the data strobe signal. This value must be set to zero if auto-calibration is used. </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> XiP Mode  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">XiP Enter Code</td><td>Must be an integer between 0 and 255</td><td>0 </td><td>XiP enter code. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">XiP Exit Code</td><td>Must be an integer between 0 and 255</td><td>0 </td><td>XiP exit code. </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> DOTF  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Name</td><td>Name must be a valid C symbol</td><td>g_ospi_dotf </td><td>DOTF Configuration name. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">AES Key</td><td>Name must be a valid C symbol</td><td>g_ospi_dotf_key </td><td>Name of Key variable. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">AES IV</td><td>Name must be a valid C symbol</td><td>g_ospi_dotf_iv </td><td>Name of IV variable </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">AES Key Length</td><td>MCU Specific Options</td><td></td><td>Select AES key length </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Key Format</td><td>MCU Specific Options</td><td></td><td>Select key format </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Decryption start address</td><td>Value must be an integer between 0x80000000 and 0x9FFFF000</td><td>0x90000000 </td><td>OSPI decryption start address </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Decryption end address</td><td>Value must be an integer between 0x80000FFF and 0x9FFFFFFF</td><td>0x90001FFF </td><td>OSPI decryption end address </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Row Addressing  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Row Address Length</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
No address</li>
<li>
1 byte</li>
<li>
2 bytes</li>
<li>
3 bytes</li>
<li>
4 bytes</li>
</ul>
</td><td>No address </td><td>Number of bytes used for addressing the row index. </td></tr>
</table>
</p>
<dl class="section note"><dt>Note</dt><dd>The user is expected to modify the command definitions based on the xSPI chip and SPI communication mode. The default mode is SPI mode and default erase commands are set for DOPI mode based on Infineon S28HS256.</dd></dl>
<h2><a class="anchor" id="r-ospi-b-clock-configuration"></a>
Clock Configuration</h2>
<p>The signals to the xSPI target device are derived from OCTACLK. OCTACLK must be set to twice the desired OMSCLK signal frequency. This allows data to be latched on either clock edge for Dual-Data-Rate modes (4S-4D-4D or 8D-8D-8D).</p>
<p>Please refer to the Hardware User Manual for the clocks which control the OSPI_B registers. These along with OCTACLK can be set on the <b>Clocks</b> tab of the RA Configuration editor.</p>
<h2><a class="anchor" id="r-ospi-b-pin-configuration"></a>
Pin Configuration</h2>
<p>The following pins are available to connect to an external OSPI device:</p><ul>
<li>OMSCLK: OSPI clock output (OCTACLK / 2)</li>
<li>OMDQS: OSPI data strobe signal</li>
<li>OMCS0: OSPI device 0 select</li>
<li>OMCS1: OSPI device 1 select</li>
<li>OMSIO0: Data 0 I/O</li>
<li>OMSIO1: Data 1 I/O</li>
<li>OMSIO2: Data 2 I/O</li>
<li>OMSIO3: Data 3 I/O</li>
<li>OMSIO4: Data 4 I/O</li>
<li>OMSIO5: Data 5 I/O</li>
<li>OMSIO6: Data 6 I/O</li>
<li>OMSIO7: Data 7 I/O</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Data pins must be configured with IOPORT_CFG_DRIVE_HS_HIGH. </dd>
<dd>
Chip Select pins should be configured with at least IOPORT_CFG_DRIVE_MEDIUM.</dd></dl>
<h1><a class="anchor" id="r-ospi-b-usage_notes"></a>
Usage Notes</h1>
<h2><a class="anchor" id="r-ospi-b-usage_notes-for-octaflash-interfacing"></a>
Usage Notes for xSPI support</h2>
<p>After <a class="el" href="group___o_s_p_i___b.html#ga9134500bd9ee50551e218a81868f5b1a">R_OSPI_B_Open()</a> completes successfully, the xSPI device contents are mapped to the appropriate external memory regions for each OSPI_B unit. For example, on the RA8M1, R_OSPI_B0 maps the CS0 device to address 0x80000000 and the CS1 device to address 0x90000000. After opening, the addresses can be accessed like on-chip flash.</p>
<p>Bank CS0 and CS1 support up to 256&#160;MB of address space each depending on the platform.</p>
<h3><a class="anchor" id="r-ospi-b-auto-calibration-octaflash"></a>
Auto-calibration</h3>
<p>If support is enabled, auto-calibration procedures are triggered automatically when the 'Data latching delay' field in the configurator properties is set to 0. The user application is responsible for setting the appropriate preamble pattern before calling <a class="el" href="group___o_s_p_i___b.html#ga9134500bd9ee50551e218a81868f5b1a">R_OSPI_B_Open()</a> when using a data strobe (DS) mode or changing the SPI protocol to a DS mode using the <a class="el" href="group___o_s_p_i___b.html#ga39b3c250a591ffd092cd6ded8c45249c">R_OSPI_B_SpiProtocolSet()</a> API. The appropriate preamble pattern can be written to the desired address using the <a class="el" href="group___o_s_p_i___b.html#gabeb33594cd4d4f031f090857a7b3832b">R_OSPI_B_Write()</a> API while in simple SPI mode (recommended), or a non-DS mode. Ensure that the same address is passed through the configurator. If the xSPI device is already in a DS mode, the preamble pattern must be programmed using the debugger before calling <a class="el" href="group___o_s_p_i___b.html#ga9134500bd9ee50551e218a81868f5b1a">R_OSPI_B_Open()</a>.</p>
<p>The preamble pattern is expected to be <code>{ 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x08, 0x00, 0x00, 0xF7, 0xFF, 0x00, 0x08, 0xF7, 0x00, 0xF7 }</code>.</p>
<h3><a class="anchor" id="r-ospi-b-chip-select-latencies-octaflash"></a>
Chip Select Latencies</h3>
<p>Chip select latencies can be set through the configurator. The default settings support SPI at minimum latency. In case the driver is opened in SPI mode and will be switched to DOPI mode later using <a class="el" href="group___o_s_p_i___b.html#ga39b3c250a591ffd092cd6ded8c45249c">R_OSPI_B_SpiProtocolSet()</a>, please select latencies required for DOPI before calling <a class="el" href="group___o_s_p_i___b.html#ga9134500bd9ee50551e218a81868f5b1a">R_OSPI_B_Open()</a>.</p>
<h3><a class="anchor" id="r-ospi-b-xip-support"></a>
XiP Support</h3>
<p>OSPI_B supports eXecute in Place (XiP) modes of operation. This can be used for read-only memory-mapped accesses to reduce overall read latency by skipping the command sequence in the xSPI transaction. Separate XiP enter and exit codes may be specified for either attached target device. Upon calling <a class="el" href="group___o_s_p_i___b.html#ga15282e9d7ef4d8c5471be859da55dd4a">R_OSPI_B_XipEnter()</a>, the associated memory region for the target device is switched to read-only mode and the enter code sent to the device. Calling <a class="el" href="group___o_s_p_i___b.html#ga96bc15adf392eccfa44eed3fb91fa7ef">R_OSPI_B_XipExit()</a> will transmit the exit code and transition the memory region back to read-write access.</p>
<p>Only one flash device should be used after entering XiP mode. Once entered, XiP codes will be transmitted to all attached devices.</p>
<h3><a class="anchor" id="r-ospi-b-octaflash-commands-octaflash"></a>
xSPI Commands</h3>
<p>Command sets and erase commands may be specified individually for each supported protocol mode. By default, the configurator only supports an alternative command set for "High-Speed Mode" (DOPI 8D-8D-8D) mode. The command sets cannot be changed during run-time, but the appropriate command set will be selected when changing protocol modes. If a command set is not found, an <code>FSP_ERR_INVALID_MODE</code> error code will be returned.</p>
<p>If custom DOPI erase commands are not specified, ensure the erase commands are the appropriate 2-byte DOPI commands. The lower byte will be used for 1-byte command protocols.</p>
<h3><a class="anchor" id="r-ospi-dotf-configuration"></a>
DOTF Support</h3>
<p>Decryption-On-The-Fly is configurable for OSPI Flash and is disabled from the build by default.</p>
<p>Using the DOTF feature requires first creating the encrypted blob on the PC and then configuring the DOTF module with the appropriate parameters to allow decryption of the blob once it is programmed into OSPI. Use the Security Key Management Tool (<a href="https://www.renesas.com/us/en/software-tool/security-key-management-tool">https://www.renesas.com/us/en/software-tool/security-key-management-tool</a>) to create the encrypted blob.</p>
<p>Example: To encrypt a 4096 byte area in a input srec file from <code>0x90000000</code> to <code>0x90000FFF</code> using a 128 AES encryption key <code>FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</code> and IV <code>00000000000000000000000000000000</code> use SKMT with the following arguments:</p>
<div class="fragment"><div class="line">skmt.exe /encdotf /keytype &quot;AES-128&quot; /enckey &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot; /nonce &quot;00000000000000000000000000000000&quot; /startaddr &quot;90000000&quot; /endaddr &quot;90000FFF&quot; /prg &quot;input.srec&quot; /incplain /output &quot;encrypted_output.srec&quot;</div></div><!-- fragment --><p>The values for key, iv and decryption area start and end addresses that were used to create the blob using SKMT must be set in the DOTF configuration in FSP.</p>
<p>Make sure that the Key and IV passed into DOTF configuration are 4 byte aligned. This can be done using a compiler alignment attribute as shown below:</p>
<div class="fragment"><div class="line">uint8_t aes_key[] __attribute__((aligned(4))) =</div><div class="line">{</div><div class="line">    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,</div><div class="line">    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f</div><div class="line">};</div></div><!-- fragment --><h4>Supported Key Formats</h4>
<ul>
<li>When the Compatibility Mode stack is added for the crypto engine, the user can provide either a wrapped or plaintext AES key to the DOTF module.</li>
<li>When the Protected Mode stack is used, only wrapped keys are supported.</li>
</ul>
<p>When configuring the DOTF options, make sure that the key format is specified.</p>
<dl class="section note"><dt>Note</dt><dd><b>For a detailed description of the Crypto Engine operating modes, refer to Application Note R11AN0498.</b></dd></dl>
<h2><a class="anchor" id="r-ospi-b-limitations"></a>
Limitations</h2>
<p>Developers should be aware of the following limitations when using the OSPI_B driver:</p>
<h3><a class="anchor" id="r-ospi-b-limitations-octaflash"></a>
OSPI_B</h3>
<ul>
<li>The R_OSPI_B driver expects memory devices to have uniform sector sizes. If a design requires using a memory with non-uniform sectors, the end-user application must appropriately manage sectors.</li>
<li>Prefetch and combination support for memory-mapped access is applied globally to all slave devices per OSPI_B unit.</li>
<li>Combination writes are limited to a maximum of 64 bytes. The user should verify the write has completed before attempting to write more bytes.</li>
<li>Writing to the memory-mapped regions with the CPU is restricted to 64-bit accesses with 8-byte destination alignments. This restriction is not applicable to other bus masters (e.g. DTC or DMAC).</li>
<li>When using Arm LLVM ensure any read-only (<code>const</code>) data used with <code><a class="el" href="group___o_s_p_i___b.html#gabeb33594cd4d4f031f090857a7b3832b">R_OSPI_B_Write()</a></code> is word (4-byte) aligned if the DMAC is not being used. If parameter checking is enabled, the source pointer alignment will be verified for calls to <code><a class="el" href="group___o_s_p_i___b.html#gabeb33594cd4d4f031f090857a7b3832b">R_OSPI_B_Write()</a></code>.</li>
<li>Take care to restrict concurrent accesses of the OSPI memory area. Collisions on the bus can occur if other bus masters attempt to write to the OSPI memory area while another master is reading the OSPI memory area.</li>
<li>When using 8D-8D-8D mode, care should be taken to access on even-aligned addresses. Problems may occur if odd address alignment is used. This restriction applies to all bus masters using OSPI_B.</li>
<li>DOTF: AES-192 is not supported when the Protected Mode stack is used.</li>
<li>When using the IAR compiler, OSPI data must be <code>const</code> qualified to be downloaded by the debugger.</li>
<li>Memories which use row-column addressing must be managed by the end-user application to ensure the appropriate memory row is loaded and stored.</li>
</ul>
<h1><a class="anchor" id="r-ospi-b-examples"></a>
Examples</h1>
<h2>OSPI Flash:</h2>
<p>The following definitions are used across various example snippets below.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define OSPI_B_COMMAND_WRITE_ENABLE_SPI_MODE     (0x06U)</span></div><div class="line"><span class="preprocessor">#define OSPI_B_COMMAND_WRITE_DISABLE_SPI_MODE    (0x04U)</span></div><div class="line"><span class="preprocessor">#define OSPI_B_COMMAND_READ_STATUS_SPI_MODE      (0x05U)</span></div><div class="line"><span class="preprocessor">#define OSPI_B_COMMAND_READ_REGISTER_SPI_MODE    (0x65U)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define OSPI_B_COMMAND_READ_QSPI_MODE            (0x0BU)</span></div><div class="line"><span class="preprocessor">#define OSPI_B_COMMAND_PROGRAM_QSPI_MODE         (0x12U)</span></div><div class="line"><span class="preprocessor">#define OSPI_B_COMMAND_WRITE_ENABLE_QSPI_MODE    (0x06U)</span></div><div class="line"><span class="preprocessor">#define OSPI_B_COMMAND_STATUS_QSPI_MODE          (0x05U)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define OSPI_B_COMMAND_BLOCK_ERASE_DOPI_MODE     (0x21DEU)</span></div><div class="line"><span class="preprocessor">#define OSPI_B_COMMAND_SECTOR_ERASE_DOPI_MODE    (0xDC23U)</span></div><div class="line"><span class="preprocessor">#define OSPI_B_COMMAND_CHIP_ERASE_DOPI_MODE      (0x609FU)</span></div><div class="line"><span class="preprocessor">#define OSPI_B_COMMAND_READ_DOPI_MODE            (0xEE11U)</span></div><div class="line"><span class="preprocessor">#define OSPI_B_COMMAND_PROGRAM_DOPI_MODE         (0x12EDU)</span></div><div class="line"><span class="preprocessor">#define OSPI_B_COMMAND_WRITE_ENABLE_DOPI_MODE    (0x06F9U)</span></div><div class="line"><span class="preprocessor">#define OSPI_B_COMMAND_STATUS_DOPI_MODE          (0x05FAU)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define OSPI_B_WEN_BIT_MASK                      (0x02U)</span></div><div class="line"><span class="preprocessor">#define OSPI_B_WIP_BIT_MASK                      (0x01U)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define OSPI_B_BLOCK_ERASE_SIZE                  (4096U)</span></div><div class="line"><span class="preprocessor">#define OSPI_B_SECTOR_ERASE_SIZE                 (262144U)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define OSPI_B_EXAMPLE_DESTINATION_ADDRESS       ((void *) 0x90000000U) </span><span class="comment">/* Device on CS1 */</span><span class="preprocessor"></span></div><div class="line"></div></div><!-- fragment --> <div class="fragment"><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> ospi_b_change_mode (<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga17c347a498a8a9d38ffc36c0de49a535">spi_flash_protocol_t</a> new_protocol)</div><div class="line">{</div><div class="line">    <span class="comment">/* Step 1. Identify current device configuration and reconfigure as needed... */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Step 2. Update clocks... */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Step 3. Transition driver to the new protocol. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___o_s_p_i___b.html#ga39b3c250a591ffd092cd6ded8c45249c">R_OSPI_B_SpiProtocolSet</a>(&amp;g_ospi0_ctrl, new_protocol);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Step 4. Verify mode change... */</span></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h3>Basic Example</h3>
<p><a class="anchor" id="um_ospi_sections"></a> This is a basic example of minimal use of the OSPI in an application with OctaFlash.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define OSPI_B_EXAMPLE_DATA_LENGTH    (1024)</span></div><div class="line"></div><div class="line">uint8_t g_dest[OSPI_B_EXAMPLE_DATA_LENGTH];</div><div class="line"></div><div class="line"><span class="comment">/* Place data in the .ospi_flash section to flash it during programming. */</span></div><div class="line"><span class="keyword">const</span> uint8_t g_src[OSPI_B_EXAMPLE_DATA_LENGTH] BSP_PLACE_IN_SECTION(<span class="stringliteral">&quot;.ospi0_cs1&quot;</span>) = <span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</div><div class="line"></div><div class="line"><span class="comment">/* Place code in the .ospi0_cs1_code section to flash it during programming. */</span></div><div class="line"><span class="keywordtype">void</span> r_ospi_b_example_function(<span class="keywordtype">void</span>) BSP_PLACE_IN_SECTION(<span class="stringliteral">&quot;.ospi0_cs1_code&quot;</span>) __attribute__((noinline));</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> r_ospi_b_example_function (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Add code here. */</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> r_ospi_b_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line"></div><div class="line">    <span class="comment">/* Open the OSPI instance. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___o_s_p_i___b.html#ga9134500bd9ee50551e218a81868f5b1a">R_OSPI_B_Open</a>(&amp;g_ospi0_ctrl, &amp;g_ospi0_cfg);</div><div class="line"></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Change SPI to DOPI mode */</span></div><div class="line">    ospi_b_change_mode(<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#gga17c347a498a8a9d38ffc36c0de49a535acf8fc61585bd2209fc3953d8d2eb4606">SPI_FLASH_PROTOCOL_8D_8D_8D</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* After R_OSPI_B_Open() and any required device specific initialization, data can be read directly from the OSPI flash. */</span></div><div class="line">    memcpy(&amp;g_dest[0], &amp;g_src[0], OSPI_B_EXAMPLE_DATA_LENGTH);</div><div class="line"></div><div class="line">    <span class="comment">/* After R_OSPI_B_Open() and any required device specific initialization, functions in the OSPI flash can be called. */</span></div><div class="line">    r_ospi_b_example_function();</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h3>Reading Status Register Example (R_OSPI_B_DirectTransfer)</h3>
<p>This is an example of using R_OSPI_B_DirectWrite followed by R_OSPI_B_DirectRead to send the read status register command and read back the status register from the device.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define OSPI_B_COMMAND_READ_STATUS_REGISTER    (0x05U)</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> r_ospi_b_direct_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__direct__transfer__t">spi_flash_direct_transfer_t</a> ospi_b_test_direct_transfer =</div><div class="line">    {</div><div class="line">        .<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ab20fca5fa35e25becd87abc7539a4246">command</a>        = OSPI_B_COMMAND_READ_STATUS_SPI_MODE,</div><div class="line">        .address        = 0U,</div><div class="line">        .data           = 0U,</div><div class="line">        .command_length = 1U,</div><div class="line">        .address_length = 0U,</div><div class="line">        .data_length    = 0U,</div><div class="line">        .dummy_cycles   = 0U</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Open the OSPI instance. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___o_s_p_i___b.html#ga9134500bd9ee50551e218a81868f5b1a">R_OSPI_B_Open</a>(&amp;g_ospi0_ctrl, &amp;g_ospi0_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Write Enable */</span></div><div class="line">    err = <a class="code" href="group___o_s_p_i___b.html#ga7b42dbc86db7f4c82ed640620743c609">R_OSPI_B_DirectTransfer</a>(&amp;g_ospi0_ctrl, &amp;ospi_b_test_direct_transfer, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Read Status Register */</span></div><div class="line">    ospi_b_test_direct_transfer.<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ab20fca5fa35e25becd87abc7539a4246">command</a>     = OSPI_B_COMMAND_READ_STATUS_SPI_MODE;</div><div class="line">    ospi_b_test_direct_transfer.<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a5e3c48eb88187944722f745231f955f3">data_length</a> = 1U;</div><div class="line">    err = <a class="code" href="group___o_s_p_i___b.html#ga7b42dbc86db7f4c82ed640620743c609">R_OSPI_B_DirectTransfer</a>(&amp;g_ospi0_ctrl, &amp;ospi_b_test_direct_transfer, SPI_FLASH_DIRECT_TRANSFER_DIR_READ);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Check if Write Enable is set */</span></div><div class="line">    <span class="keywordflow">if</span> (OSPI_B_WEN_BIT_MASK != (ospi_b_test_direct_transfer.data &amp; OSPI_B_WEN_BIT_MASK))</div><div class="line">    {</div><div class="line">        __BKPT(0);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h3>Auto-calibration Example (R_OSPI_B_DirectTransfer, R_OSPI_B_Write, R_OSPI_B_SpiProtocolSet)</h3>
<p>This is an example of using R_OSPI_B_SpiProtocolSet to change the operating mode from SPI to DOPI and allow the driver to initiate auto-calibration.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define OSPI_B_DOPI_PREAMBLE_PATTERN_LENGTH_BYTES    (16U)</span></div><div class="line"><span class="preprocessor">#define OSPI_B_EXAMPLE_PREAMBLE_ADDRESS              (0x90000000U) </span><span class="comment">/* Device connected to CS1 */</span><span class="preprocessor"></span></div><div class="line"><span class="keyword">const</span> uint8_t g_preamble_bytes[OSPI_B_DOPI_PREAMBLE_PATTERN_LENGTH_BYTES] =</div><div class="line">{</div><div class="line">    0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x08, 0x00, 0x00, 0xF7, 0xFF, 0x00, 0x08, 0xF7, 0x00, 0xF7</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> ospi_b_wait_until_wip (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>          err = FSP_SUCCESS;</div><div class="line">    <a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__status__t">spi_flash_status_t</a> status;</div><div class="line">    status.<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ae20d4bed523ca4e802f5da6fdec4ca43">write_in_progress</a> = <span class="keyword">true</span>;</div><div class="line">    uint32_t timeout = UINT32_MAX;</div><div class="line">    <span class="keywordflow">while</span> ((status.<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ae20d4bed523ca4e802f5da6fdec4ca43">write_in_progress</a>) &amp;&amp; (--timeout))</div><div class="line">    {</div><div class="line"></div><div class="line">        err = <a class="code" href="group___o_s_p_i___b.html#gae5936464390d82c29e2d03f6c04880e2">R_OSPI_B_StatusGet</a>(&amp;g_ospi0_ctrl, &amp;status);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (0 == timeout)</div><div class="line">    {</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> r_ospi_b_auto_calibrate_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Open the OSPI instance. */</span></div><div class="line">    <span class="comment">/* Set data_latch_delay_clocks to 0x0 to enable auto-calibration */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___o_s_p_i___b.html#ga9134500bd9ee50551e218a81868f5b1a">R_OSPI_B_Open</a>(&amp;g_ospi0_ctrl, &amp;g_ospi0_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    uint8_t * preamble_pattern_addr = (uint8_t *) OSPI_B_EXAMPLE_PREAMBLE_ADDRESS;</div><div class="line"></div><div class="line"></div><div class="line">    err = <a class="code" href="group___o_s_p_i___b.html#gabeb33594cd4d4f031f090857a7b3832b">R_OSPI_B_Write</a>(&amp;g_ospi0_ctrl, g_preamble_bytes, preamble_pattern_addr, OSPI_B_EXAMPLE_PREAMBLE_ADDRESS);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Wait until write has been completed */</span></div><div class="line">    ospi_b_wait_until_wip();</div><div class="line"></div><div class="line">    <span class="comment">/* Change from SPI to DOPI mode */</span></div><div class="line">    ospi_b_change_mode(<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#gga17c347a498a8a9d38ffc36c0de49a535acf8fc61585bd2209fc3953d8d2eb4606">SPI_FLASH_PROTOCOL_8D_8D_8D</a>);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h3>Octaclk Update Example (R_OSPI_B_SpiProtocolSet)</h3>
<p>This is an example of using R_BSP_OctaclkUpdate to change the Octal-SPI clock frequency during run time. The OCTACLK frequency must be updated before calling the R_OSPI_B_SpiProtocolSet with appropriate clock source and divider settings required to be set for the new SPI protocol mode. Ensure that the clock source selected is started.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Changes the OCTACLK divider; assumes PLL2 is being used as the source for OCTACLK.</span></div><div class="line"><span class="comment"> * @param divider New clock divider to switch to.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> ospi_b_change_omclk (bsp_clocks_octaclk_div_t divider)</div><div class="line">{</div><div class="line">    <span class="comment">/* Ensure clock source (PLL2 in this example) is running before changing the OCTACLK frequency */</span></div><div class="line">    bsp_octaclk_settings_t octaclk_settings;</div><div class="line">    octaclk_settings.source_clock = BSP_CLOCKS_CLOCK_PLL2;</div><div class="line">    octaclk_settings.divider      = divider;</div><div class="line">    R_BSP_OctaclkUpdate(&amp;octaclk_settings);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h3>Using a Custom xSPI Command Set Example</h3>
<p>This is an example of using custom command sets for 8D-8D-8D and 4S-4S-4S protocol modes.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">/* Custom two-byte erase commands. */</span></div><div class="line"><a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__erase__command__t">spi_flash_erase_command_t</a> g_2B_erase_commands[] =</div><div class="line">{</div><div class="line">    {.<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a27f37ac5d1f031fd33f3b2ff5b914751">command</a> = OSPI_B_COMMAND_BLOCK_ERASE_DOPI_MODE,  .size = OSPI_B_BLOCK_ERASE_SIZE        },</div><div class="line">    {.command = OSPI_B_COMMAND_SECTOR_ERASE_DOPI_MODE, .size = OSPI_B_SECTOR_ERASE_SIZE       },</div><div class="line">    {.command = OSPI_B_COMMAND_CHIP_ERASE_DOPI_MODE,   .size = SPI_FLASH_ERASE_SIZE_CHIP_ERASE},</div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="group___o_s_p_i___b.html#structospi__b__table__t">ospi_b_table_t</a> g_2B_erase_table =</div><div class="line">{</div><div class="line">    .<a class="code" href="group___o_s_p_i___b.html#a1002da50d4a396df19f505f370ea85b3">p_table</a> = g_2B_erase_commands,</div><div class="line">    .length  = (uint8_t) (<span class="keyword">sizeof</span>(g_2B_erase_commands) / <span class="keyword">sizeof</span>(g_2B_erase_commands[0])),</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* Custom command sets. */</span></div><div class="line"><a class="code" href="group___o_s_p_i___b.html#structospi__b__xspi__command__set__t">ospi_b_xspi_command_set_t</a> g_command_sets[] =</div><div class="line">{</div><div class="line">    <span class="comment">/* 8D-8D-8D example with inverted lower command byte. */</span></div><div class="line">    {</div><div class="line">        .<a class="code" href="group___o_s_p_i___b.html#a71f30710dcb8f6a40f5254d408f38216">protocol</a>             = <a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#gga17c347a498a8a9d38ffc36c0de49a535acf8fc61585bd2209fc3953d8d2eb4606">SPI_FLASH_PROTOCOL_8D_8D_8D</a>,</div><div class="line">        .command_bytes        = <a class="code" href="group___o_s_p_i___b.html#gga4bf54e3468d5d4de83db9e021bdbb2d3a165af2425e8e2fbcc301f0c7081cf9e2">OSPI_B_COMMAND_BYTES_2</a>,</div><div class="line">        .read_command         = OSPI_B_COMMAND_READ_DOPI_MODE,</div><div class="line">        .program_command      = OSPI_B_COMMAND_PROGRAM_DOPI_MODE,</div><div class="line">        .write_enable_command = OSPI_B_COMMAND_WRITE_ENABLE_DOPI_MODE,</div><div class="line">        .status_command       = OSPI_B_COMMAND_STATUS_DOPI_MODE,</div><div class="line">        .read_dummy_cycles    = 20U,</div><div class="line">        .program_dummy_cycles = 0U,</div><div class="line">        .status_dummy_cycles  = 3U,</div><div class="line">        .p_erase_commands     = &amp;g_2B_erase_table</div><div class="line">    },</div><div class="line"></div><div class="line">    <span class="comment">/* 4S-4S-4S example with different .read_command and dummy cycles. */</span></div><div class="line">    {</div><div class="line">        .protocol             = <a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#gga17c347a498a8a9d38ffc36c0de49a535a21ac68039ffa6d214173ada7fe558a05">SPI_FLASH_PROTOCOL_4S_4S_4S</a>,</div><div class="line">        .command_bytes        = <a class="code" href="group___o_s_p_i___b.html#gga4bf54e3468d5d4de83db9e021bdbb2d3a6aa3fcd6c65bf42cb3ee95b050fe12dd">OSPI_B_COMMAND_BYTES_1</a>,</div><div class="line">        .read_command         = OSPI_B_COMMAND_READ_QSPI_MODE,</div><div class="line">        .program_command      = OSPI_B_COMMAND_PROGRAM_QSPI_MODE,</div><div class="line">        .write_enable_command = OSPI_B_COMMAND_WRITE_ENABLE_QSPI_MODE,</div><div class="line">        .status_command       = OSPI_B_COMMAND_STATUS_QSPI_MODE,</div><div class="line">        .read_dummy_cycles    = 10U,</div><div class="line">        .program_dummy_cycles = 0U,</div><div class="line">        .status_dummy_cycles  = 1U,</div><div class="line">        .p_erase_commands     = NULL,  <span class="comment">// Use the common erase definitions.</span></div><div class="line">    },</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> r_ospi_command_table_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Open the OSPI instance.</span></div><div class="line"><span class="comment">     * Specify `g_command_sets` using the configurator. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___o_s_p_i___b.html#ga9134500bd9ee50551e218a81868f5b1a">R_OSPI_B_Open</a>(&amp;g_ospi0_ctrl, &amp;g_ospi0_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Change SPI to DOPI mode */</span></div><div class="line">    ospi_b_change_mode(<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#gga17c347a498a8a9d38ffc36c0de49a535acf8fc61585bd2209fc3953d8d2eb4606">SPI_FLASH_PROTOCOL_8D_8D_8D</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* After R_OSPI_B_Open() and any required device specific initialization, data can be read directly from the OSPI flash. */</span></div><div class="line">    memcpy(&amp;g_dest[0], &amp;g_src[0], OSPI_B_EXAMPLE_DATA_LENGTH);</div><div class="line"></div><div class="line">    <span class="comment">/* After R_OSPI_B_Open() and any required device specific initialization, functions in the OSPI flash can be called. */</span></div><div class="line">    r_ospi_b_example_function();</div><div class="line"></div><div class="line">    <span class="comment">/* Change SPI to QSPI mode */</span></div><div class="line">    ospi_b_change_mode(<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#gga17c347a498a8a9d38ffc36c0de49a535a21ac68039ffa6d214173ada7fe558a05">SPI_FLASH_PROTOCOL_4S_4S_4S</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Read data from an external device, this time in QSPI mode. */</span></div><div class="line">    memcpy(&amp;g_dest[0], &amp;g_src[0], OSPI_B_EXAMPLE_DATA_LENGTH);</div><div class="line"></div><div class="line">    <span class="comment">/* Run the example function again in QSPI mode. */</span></div><div class="line">    r_ospi_b_example_function();</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h3>Change Protocol Mode Example (R_OSPI_B_DirectTransfer, R_OSPI_B_SpiProtocolSet)</h3>
<p>This is an example of using R_OSPI_B_DirectTransfer to change the attached flash device to a new protocol mode during run time.</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * This example file is only intended for use with Infineon S28HS256 flash devices and is non-exhaustive.</span></div><div class="line"><span class="comment"> * Other flash devices will require modification of command codes, addresses, and/or command sequences.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;r_ospi_b.h&quot;</span></div><div class="line"></div><div class="line"><span class="comment">/***********************************************************************************************************************</span></div><div class="line"><span class="comment"> * Macro definitions</span></div><div class="line"><span class="comment"> **********************************************************************************************************************/</span></div><div class="line"></div><div class="line"><span class="comment">/* Command code for enabling write operations. */</span></div><div class="line"><span class="preprocessor">#define OSPI_B_COMMAND_WRITE_ENABLE_SPI_MODE      (0x06U)</span></div><div class="line"></div><div class="line"><span class="comment">/* Command code to query the status register. */</span></div><div class="line"><span class="preprocessor">#define OSPI_B_COMMAND_READ_STATUS_SPI_MODE       (0x05U)</span></div><div class="line"></div><div class="line"><span class="comment">/* Command code to read a configuration register. */</span></div><div class="line"><span class="preprocessor">#define OSPI_B_COMMAND_READ_REGISTER_SPI_MODE     (0x65U)</span></div><div class="line"></div><div class="line"><span class="comment">/* Command code to write to a configuration register. */</span></div><div class="line"><span class="preprocessor">#define OSPI_B_COMMAND_WRITE_REGISTER_SPI_MODE    (0x71U)</span></div><div class="line"></div><div class="line"><span class="comment">/* Location of the write-enable bit in the status register. */</span></div><div class="line"><span class="preprocessor">#define OSPI_B_WEN_BIT_MASK                       (0x02U)</span></div><div class="line"></div><div class="line"><span class="comment">/* Register setting for CFR5 of the Infineon S28HS256 to enable 8D-8D-8D mode. */</span></div><div class="line"><span class="preprocessor">#define OSPI_B_DOPI_REGISTER_SETTING              (0x43U)</span></div><div class="line"></div><div class="line"><span class="comment">/* Register setting for CFR3 of the Infineon S28HS256 to support faster clock rates (up to 166 MHz DOPI). */</span></div><div class="line"><span class="preprocessor">#define OSPI_B_FAST_CLOCK_REGISTER_SETTING        (0x80U)</span></div><div class="line"></div><div class="line"><span class="comment">/* Address of the CFR3 volatile register for the Infineon S28HS256. */</span></div><div class="line"><span class="preprocessor">#define OSPI_B_CFR3V_ADDRESS                      (0x800004)</span></div><div class="line"></div><div class="line"><span class="comment">/* Address of the CFR5 volatile register for the Infineon S28HS256. */</span></div><div class="line"><span class="preprocessor">#define OSPI_B_CFR5V_ADDRESS                      (0x800006)</span></div><div class="line"></div><div class="line"><span class="comment">/***********************************************************************************************************************</span></div><div class="line"><span class="comment"> * Function prototypes</span></div><div class="line"><span class="comment"> **********************************************************************************************************************/</span></div><div class="line"><span class="keywordtype">void</span> r_ospi_b_example_spi_to_dopi(<a class="code" href="group___o_s_p_i___b.html#structospi__b__instance__ctrl__t">ospi_b_instance_ctrl_t</a> * <span class="keyword">const</span> p_ctrl);</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> ospi_b_write_enable_and_verify(<a class="code" href="group___o_s_p_i___b.html#structospi__b__instance__ctrl__t">ospi_b_instance_ctrl_t</a> * <span class="keyword">const</span> p_ctrl, <span class="keywordtype">bool</span> is_8d);</div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> ospi_b_change_omclk(bsp_clocks_octaclk_div_t divider);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Enables write operations on the target flash and verifies the change by reading the status register.</span></div><div class="line"><span class="comment"> * @param [in] p_ctrl Pointer to the OSPI_B control struct.</span></div><div class="line"><span class="comment"> * @param is_8d Indicates the target is currently configured for 8D-8D-8D protocol mode.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> ospi_b_write_enable_and_verify (<a class="code" href="group___o_s_p_i___b.html#structospi__b__instance__ctrl__t">ospi_b_instance_ctrl_t</a> * <span class="keyword">const</span> p_ctrl, <span class="keywordtype">bool</span> is_8d)</div><div class="line">{</div><div class="line">    <a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__direct__transfer__t">spi_flash_direct_transfer_t</a> ospi_b_test_direct_transfer =</div><div class="line">    {</div><div class="line">        .<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ab20fca5fa35e25becd87abc7539a4246">command</a>        = OSPI_B_COMMAND_WRITE_ENABLE_SPI_MODE,</div><div class="line">        .address        = 0U,</div><div class="line">        .data           = 0U,</div><div class="line">        .command_length = 1U,</div><div class="line">        .address_length = 0U,</div><div class="line">        .data_length    = 0U,</div><div class="line">        .dummy_cycles   = 0U</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Write Enable */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___o_s_p_i___b.html#ga7b42dbc86db7f4c82ed640620743c609">R_OSPI_B_DirectTransfer</a>(p_ctrl, &amp;ospi_b_test_direct_transfer, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    ospi_b_test_direct_transfer.<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ab20fca5fa35e25becd87abc7539a4246">command</a>     = OSPI_B_COMMAND_READ_STATUS_SPI_MODE;</div><div class="line">    ospi_b_test_direct_transfer.<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a5e3c48eb88187944722f745231f955f3">data_length</a> = 1U;</div><div class="line"></div><div class="line">    <span class="comment">/* Adjust the dummy cycles if currently operating in 8D-8D-8D mode. */</span></div><div class="line">    <span class="keywordflow">if</span> (is_8d)</div><div class="line">    {</div><div class="line">        ospi_b_test_direct_transfer.<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ad4a653cf90fd97dc9d0a5f8fce3c3795">dummy_cycles</a> = 5U;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Read Status Register */</span></div><div class="line">    err = <a class="code" href="group___o_s_p_i___b.html#ga7b42dbc86db7f4c82ed640620743c609">R_OSPI_B_DirectTransfer</a>(p_ctrl, &amp;ospi_b_test_direct_transfer, SPI_FLASH_DIRECT_TRANSFER_DIR_READ);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (OSPI_B_WEN_BIT_MASK != (ospi_b_test_direct_transfer.data &amp; OSPI_B_WEN_BIT_MASK))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Verification of the write enable status failed. */</span></div><div class="line">        __BKPT(0);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Changes the OCTACLK divider; assumes PLL2 is being used as the source for OCTACLK.</span></div><div class="line"><span class="comment"> * @param divider New clock divider to switch to.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> ospi_b_change_omclk (bsp_clocks_octaclk_div_t divider)</div><div class="line">{</div><div class="line">    <span class="comment">/* Ensure clock source (PLL2 in this example) is running before changing the OCTACLK frequency */</span></div><div class="line">    bsp_octaclk_settings_t octaclk_settings;</div><div class="line">    octaclk_settings.source_clock = BSP_CLOCKS_CLOCK_PLL2;</div><div class="line">    octaclk_settings.divider      = divider;</div><div class="line">    R_BSP_OctaclkUpdate(&amp;octaclk_settings);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Example function to change from 1S-1S-1S (SPI) to 8D-8D-8D (DOPI) protocol mode.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This assumes S28HS256 is in default factory configuration:</span></div><div class="line"><span class="comment"> *  - 3-byte address lengths</span></div><div class="line"><span class="comment"> *  - Memory read latency of 8/20 (1S/8S) up to 166 MHz DOPI</span></div><div class="line"><span class="comment"> *  - Register read latency of 0/3 up to 25 MHz DPOI</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @param [in] p_ctrl Pointer to the OSPI_B control struct.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The OCTACLK source must be within range to support this example as written. Clocks are intended to be configured</span></div><div class="line"><span class="comment"> * as follows to obtain a PLL2P frequency of 240 MHz and OCTACLK starting frequency of 60 MHz.</span></div><div class="line"><span class="comment"> * HOCO (48 MHz) -&gt; PLL2 -&gt; /3 -&gt; x60.0 {960 MHz} -&gt; PLL2P /4 {240 MHz} -&gt; OCTACLK -&gt; /4 -&gt; {60 MHz}.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">void</span> r_ospi_b_example_spi_to_dopi (<a class="code" href="group___o_s_p_i___b.html#structospi__b__instance__ctrl__t">ospi_b_instance_ctrl_t</a> * <span class="keyword">const</span> p_ctrl)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Step 1: Enable write access to the registers. */</span></div><div class="line">    ospi_b_write_enable_and_verify(p_ctrl, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* Step 2: Adjust the dummy cycles for a faster clock later.</span></div><div class="line"><span class="comment">     * Changes the dummy cycles for register commands to 1 for SPI and 5 for OSPI.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__direct__transfer__t">spi_flash_direct_transfer_t</a> xfer_adjust_cfr3 =</div><div class="line">    {</div><div class="line">        .<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ab20fca5fa35e25becd87abc7539a4246">command</a>        = OSPI_B_COMMAND_WRITE_REGISTER_SPI_MODE,</div><div class="line">        .address        = OSPI_B_CFR3V_ADDRESS,</div><div class="line">        .data           = OSPI_B_FAST_CLOCK_REGISTER_SETTING,</div><div class="line">        .command_length = 1U,</div><div class="line">        .address_length = 3U,</div><div class="line">        .data_length    = 1U,</div><div class="line">        .dummy_cycles   = 0U</div><div class="line">    };</div><div class="line">    err = <a class="code" href="group___o_s_p_i___b.html#ga7b42dbc86db7f4c82ed640620743c609">R_OSPI_B_DirectTransfer</a>(p_ctrl, &amp;xfer_adjust_cfr3, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Step 3: Change the target flash&#39;s configuration to use 8D-8D-8D mode. */</span></div><div class="line">    <a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__direct__transfer__t">spi_flash_direct_transfer_t</a> xfer_change_mode =</div><div class="line">    {</div><div class="line">        .<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ab20fca5fa35e25becd87abc7539a4246">command</a>        = OSPI_B_COMMAND_WRITE_REGISTER_SPI_MODE,</div><div class="line">        .address        = OSPI_B_CFR5V_ADDRESS,</div><div class="line">        .data           = OSPI_B_DOPI_REGISTER_SETTING,</div><div class="line">        .command_length = 1U,</div><div class="line">        .address_length = 3U,</div><div class="line">        .data_length    = 1U,</div><div class="line">        .dummy_cycles   = 0U</div><div class="line">    };</div><div class="line">    err = <a class="code" href="group___o_s_p_i___b.html#ga7b42dbc86db7f4c82ed640620743c609">R_OSPI_B_DirectTransfer</a>(p_ctrl, &amp;xfer_change_mode, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Step 4: Speed up the bus by lowering the input divider.</span></div><div class="line"><span class="comment">     * If using the suggested clock settings this will increase the bus speed from 60 MHz to 120 MHz. */</span></div><div class="line">    ospi_b_change_omclk(BSP_CLOCKS_OCTACLK_DIV_2);</div><div class="line"></div><div class="line">    <span class="comment">/* Step 5: Transition the OSPI peripheral to DOPI mode. This will initiate auto calibration as MDTR is 0.</span></div><div class="line"><span class="comment">     * This must happen after the device has been re-configured to the new mode. Otherwise, communications will be</span></div><div class="line"><span class="comment">     * lost as both MCU and flash device will be in different modes. */</span></div><div class="line">    err = <a class="code" href="group___o_s_p_i___b.html#ga39b3c250a591ffd092cd6ded8c45249c">R_OSPI_B_SpiProtocolSet</a>(p_ctrl, <a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#gga17c347a498a8a9d38ffc36c0de49a535afd83f451b4164b209b240ebb0f4bb158">SPI_FLASH_PROTOCOL_DOPI</a>);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Step 6: Verify that the chip is in requested DOPI mode. */</span></div><div class="line">    <a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__direct__transfer__t">spi_flash_direct_transfer_t</a> xfer_read_register =</div><div class="line">    {</div><div class="line">        .<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ab20fca5fa35e25becd87abc7539a4246">command</a>        = OSPI_B_COMMAND_READ_REGISTER_SPI_MODE,</div><div class="line">        .address        = OSPI_B_CFR5V_ADDRESS,</div><div class="line">        .data           = 0,</div><div class="line">        .command_length = 1U,</div><div class="line">        .address_length = 4U,</div><div class="line">        .data_length    = 1U,</div><div class="line">        .dummy_cycles   = 5U,</div><div class="line">    };</div><div class="line">    err = <a class="code" href="group___o_s_p_i___b.html#ga7b42dbc86db7f4c82ed640620743c609">R_OSPI_B_DirectTransfer</a>(p_ctrl, &amp;xfer_read_register, SPI_FLASH_DIRECT_TRANSFER_DIR_READ);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (OSPI_B_DOPI_REGISTER_SETTING != xfer_read_register.data)</div><div class="line">    {</div><div class="line">        __BKPT(0);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structospi__b__table__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#structospi__b__table__t">ospi_b_table_t</a></td></tr>
<tr class="separator:structospi__b__table__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structospi__b__timing__setting__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#structospi__b__timing__setting__t">ospi_b_timing_setting_t</a></td></tr>
<tr class="separator:structospi__b__timing__setting__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structospi__b__xspi__command__set__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#structospi__b__xspi__command__set__t">ospi_b_xspi_command_set_t</a></td></tr>
<tr class="separator:structospi__b__xspi__command__set__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structospi__b__dotf__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#structospi__b__dotf__cfg__t">ospi_b_dotf_cfg_t</a></td></tr>
<tr class="separator:structospi__b__dotf__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structospi__b__extended__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#structospi__b__extended__cfg__t">ospi_b_extended_cfg_t</a></td></tr>
<tr class="separator:structospi__b__extended__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structospi__b__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#structospi__b__instance__ctrl__t">ospi_b_instance_ctrl_t</a></td></tr>
<tr class="separator:structospi__b__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga84d19b0f9d6698d68364b7c4c2bb1126"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#ga84d19b0f9d6698d68364b7c4c2bb1126">OSPI_B_MAX_WRITE_ENABLE_POLLING_LOOPS</a></td></tr>
<tr class="separator:ga84d19b0f9d6698d68364b7c4c2bb1126"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga76971feb991ff5a55ffdc3e1c6834c1f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#ga76971feb991ff5a55ffdc3e1c6834c1f">ospi_b_device_number_t</a> </td></tr>
<tr class="separator:ga76971feb991ff5a55ffdc3e1c6834c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bf54e3468d5d4de83db9e021bdbb2d3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#ga4bf54e3468d5d4de83db9e021bdbb2d3">ospi_b_command_bytes_t</a> </td></tr>
<tr class="separator:ga4bf54e3468d5d4de83db9e021bdbb2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga570e0018e1e0dd225038e20f4a56d041"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#ga570e0018e1e0dd225038e20f4a56d041">ospi_b_command_interval_clocks_t</a> </td></tr>
<tr class="separator:ga570e0018e1e0dd225038e20f4a56d041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga910082046980b0d68cf3927d2a465e4b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#ga910082046980b0d68cf3927d2a465e4b">ospi_b_command_cs_pullup_clocks_t</a> </td></tr>
<tr class="separator:ga910082046980b0d68cf3927d2a465e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6aad607f2de843932644cf1137eeeac"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#gab6aad607f2de843932644cf1137eeeac">ospi_b_command_cs_pulldown_clocks_t</a> </td></tr>
<tr class="separator:gab6aad607f2de843932644cf1137eeeac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b8f9d8f7c05070b5b4826882dbb15fa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#ga7b8f9d8f7c05070b5b4826882dbb15fa">ospi_b_ds_timing_delay_t</a> </td></tr>
<tr class="separator:ga7b8f9d8f7c05070b5b4826882dbb15fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f788d0293774da421928e43112397c0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#ga6f788d0293774da421928e43112397c0">ospi_b_sdr_drive_timing_t</a> </td></tr>
<tr class="separator:ga6f788d0293774da421928e43112397c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae27c294bf3112e9fa6ef652cc470e12d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#gae27c294bf3112e9fa6ef652cc470e12d">ospi_b_ck_edge_t</a> </td></tr>
<tr class="separator:gae27c294bf3112e9fa6ef652cc470e12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga936cdfcd8adcd5e8623598ff2abea12e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#ga936cdfcd8adcd5e8623598ff2abea12e">ospi_b_sdr_sampling_delay_t</a> </td></tr>
<tr class="separator:ga936cdfcd8adcd5e8623598ff2abea12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80c573b83c220daa0a6cf15c9f238bf2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#ga80c573b83c220daa0a6cf15c9f238bf2">ospi_b_ddr_sampling_extension_t</a> </td></tr>
<tr class="separator:ga80c573b83c220daa0a6cf15c9f238bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada8a65f95a308ffd7a5bfa58a8a2b183"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#gada8a65f95a308ffd7a5bfa58a8a2b183">ospi_b_frame_format_t</a> </td></tr>
<tr class="separator:gada8a65f95a308ffd7a5bfa58a8a2b183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fb4c8bc061b939bd501610e8a687359"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#ga5fb4c8bc061b939bd501610e8a687359">ospi_b_latency_mode_t</a> </td></tr>
<tr class="separator:ga5fb4c8bc061b939bd501610e8a687359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga131fd33e93249afc3733475ad2786a3b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#ga131fd33e93249afc3733475ad2786a3b">ospi_b_prefetch_function_t</a> </td></tr>
<tr class="separator:ga131fd33e93249afc3733475ad2786a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d821ba8f342427fa60390abdf6cdf87"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#ga7d821ba8f342427fa60390abdf6cdf87">ospi_b_combination_function_t</a> </td></tr>
<tr class="separator:ga7d821ba8f342427fa60390abdf6cdf87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69496e54ec435e56d55603fe640e8ee9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#ga69496e54ec435e56d55603fe640e8ee9">ospi_b_dotf_aes_key_length_words_t</a> </td></tr>
<tr class="separator:ga69496e54ec435e56d55603fe640e8ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b36b2f02fae01eb700990fbaa76ef8e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#ga0b36b2f02fae01eb700990fbaa76ef8e">ospi_b_dotf_aes_key_type_t</a> </td></tr>
<tr class="separator:ga0b36b2f02fae01eb700990fbaa76ef8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c462523a81690b9897c68f30ddd7464"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_p_i___b.html#ga6c462523a81690b9897c68f30ddd7464">ospi_b_dotf_key_format_t</a> </td></tr>
<tr class="separator:ga6c462523a81690b9897c68f30ddd7464"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structospi__b__table__t" id="structospi__b__table__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structospi__b__table__t">&#9670;&nbsp;</a></span>ospi_b_table_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ospi_b_table_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Simple array length table structure. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a1002da50d4a396df19f505f370ea85b3"></a>void *</td>
<td class="fieldname">
p_table</td>
<td class="fielddoc">
Pointer to the table array. </td></tr>
<tr><td class="fieldtype">
<a id="a2d15a55ed1278e918f7e4bb5542f8873"></a>uint8_t</td>
<td class="fieldname">
length</td>
<td class="fielddoc">
Number of entries in the table. </td></tr>
</table>

</div>
</div>
<a name="structospi__b__timing__setting__t" id="structospi__b__timing__setting__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structospi__b__timing__setting__t">&#9670;&nbsp;</a></span>ospi_b_timing_setting_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ospi_b_timing_setting_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Fixed timing configuration for bus signals. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="af0e0540243e26295aabcca09b184cd50"></a><a class="el" href="group___o_s_p_i___b.html#ga570e0018e1e0dd225038e20f4a56d041">ospi_b_command_interval_clocks_t</a></td>
<td class="fieldname">
command_to_command_interval</td>
<td class="fielddoc">
Interval between 2 consecutive commands. </td></tr>
<tr><td class="fieldtype">
<a id="a603a91ae60d9fa42498306e0275c6f55"></a><a class="el" href="group___o_s_p_i___b.html#ga910082046980b0d68cf3927d2a465e4b">ospi_b_command_cs_pullup_clocks_t</a></td>
<td class="fieldname">
cs_pullup_lag</td>
<td class="fielddoc">
Duration to de-assert CS line after the last command. </td></tr>
<tr><td class="fieldtype">
<a id="ac8f8a74990e7ffb6f9efc1b36a5c6ad0"></a><a class="el" href="group___o_s_p_i___b.html#gab6aad607f2de843932644cf1137eeeac">ospi_b_command_cs_pulldown_clocks_t</a></td>
<td class="fieldname">
cs_pulldown_lead</td>
<td class="fielddoc">
Duration to assert CS line before the first command. </td></tr>
<tr><td class="fieldtype">
<a id="aa1a699aabe5a094bc91914d64f0012d9"></a><a class="el" href="group___o_s_p_i___b.html#ga6f788d0293774da421928e43112397c0">ospi_b_sdr_drive_timing_t</a></td>
<td class="fieldname">
sdr_drive_timing</td>
<td class="fielddoc">
Data signal timing relative to the rising-edge of the CK signal. </td></tr>
<tr><td class="fieldtype">
<a id="a84fcde7cfd0c05ba7110f54ee97275ee"></a><a class="el" href="group___o_s_p_i___b.html#gae27c294bf3112e9fa6ef652cc470e12d">ospi_b_ck_edge_t</a></td>
<td class="fieldname">
sdr_sampling_edge</td>
<td class="fielddoc">
Selects the clock edge to sample the data signal. </td></tr>
<tr><td class="fieldtype">
<a id="a8d579ef2c6da8af85efa5a15048c873a"></a><a class="el" href="group___o_s_p_i___b.html#ga936cdfcd8adcd5e8623598ff2abea12e">ospi_b_sdr_sampling_delay_t</a></td>
<td class="fieldname">
sdr_sampling_delay</td>
<td class="fielddoc">
Number of cycles to delay before sampling the data signal. </td></tr>
<tr><td class="fieldtype">
<a id="ada634ce7da29913306be35a68c72cea7"></a><a class="el" href="group___o_s_p_i___b.html#ga80c573b83c220daa0a6cf15c9f238bf2">ospi_b_ddr_sampling_extension_t</a></td>
<td class="fieldname">
ddr_sampling_extension</td>
<td class="fielddoc">
Number of cycles to extending the data sampling window in DDR mode. </td></tr>
</table>

</div>
</div>
<a name="structospi__b__xspi__command__set__t" id="structospi__b__xspi__command__set__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structospi__b__xspi__command__set__t">&#9670;&nbsp;</a></span>ospi_b_xspi_command_set_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ospi_b_xspi_command_set_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Command set used for a protocol mode. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a71f30710dcb8f6a40f5254d408f38216"></a><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga17c347a498a8a9d38ffc36c0de49a535">spi_flash_protocol_t</a></td>
<td class="fieldname">
protocol</td>
<td class="fielddoc">
Protocol mode associated with this command set. </td></tr>
<tr><td class="fieldtype">
<a id="add13f94149340dec69e96c4a35eccf7b"></a><a class="el" href="group___o_s_p_i___b.html#gada8a65f95a308ffd7a5bfa58a8a2b183">ospi_b_frame_format_t</a></td>
<td class="fieldname">
frame_format</td>
<td class="fielddoc">
Frame format to use for this command set. </td></tr>
<tr><td class="fieldtype">
<a id="a00f0550cb7be11932add1ab09ca2daa8"></a><a class="el" href="group___o_s_p_i___b.html#ga5fb4c8bc061b939bd501610e8a687359">ospi_b_latency_mode_t</a></td>
<td class="fieldname">
latency_mode</td>
<td class="fielddoc">
Configurable or variable latency, only valid for OSPI_B_FRAME_FORMAT_XSPI_PROFILE_2 and OSPI_B_FRAME_FORMAT_XSPI_PROFILE_2_EXTENDED. </td></tr>
<tr><td class="fieldtype">
<a id="ac84822e6456c6d507ed77584d0bbeac1"></a><a class="el" href="group___o_s_p_i___b.html#ga4bf54e3468d5d4de83db9e021bdbb2d3">ospi_b_command_bytes_t</a></td>
<td class="fieldname">
command_bytes</td>
<td class="fielddoc">
Number of command bytes for each command code. </td></tr>
<tr><td class="fieldtype">
<a id="a06e423259b6456b5c7a177fafa4e1eba"></a><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga289ef915326b8e75e7d0dd331c2d0797">spi_flash_address_bytes_t</a></td>
<td class="fieldname">
address_bytes</td>
<td class="fielddoc">
Number of bytes used during the address phase. </td></tr>
<tr><td class="fieldtype">
<a id="a00f83d7b93418be05caa4310ee86b065"></a>uint16_t</td>
<td class="fieldname">
read_command</td>
<td class="fielddoc">
Read command. </td></tr>
<tr><td class="fieldtype">
<a id="aef831de4dec7f7dca345791db9da02a7"></a>uint16_t</td>
<td class="fieldname">
program_command</td>
<td class="fielddoc">
Memory program/write command. </td></tr>
<tr><td class="fieldtype">
<a id="a6a3858f70d10ad02727a77db3dc7812e"></a>uint16_t</td>
<td class="fieldname">
write_enable_command</td>
<td class="fielddoc">
Command to enable write or erase, set to 0x00 to ignore. </td></tr>
<tr><td class="fieldtype">
<a id="aaa8203b5b53605fee6a89d155f2d3281"></a>uint16_t</td>
<td class="fieldname">
status_command</td>
<td class="fielddoc">
Command to read the write status, set to 0x00 to ignore. </td></tr>
<tr><td class="fieldtype">
<a id="a33b0b9b9466be77656b5528d5071ab4d"></a>uint16_t</td>
<td class="fieldname">
row_load_command</td>
<td class="fielddoc">
Load a page into the device's internal buffer, set to 0x00 to ignore. </td></tr>
<tr><td class="fieldtype">
<a id="ac9c8360552cd4692d23cdedd1b30124e"></a>uint16_t</td>
<td class="fieldname">
row_store_command</td>
<td class="fielddoc">
Stores the device's internal buffer to the memory page, set to 0x00 to ignore. </td></tr>
<tr><td class="fieldtype">
<a id="aefcc9d11688943faff97d79d0a7580b8"></a>uint8_t</td>
<td class="fieldname">
read_dummy_cycles</td>
<td class="fielddoc">
Dummy cycles to be inserted for read commands. </td></tr>
<tr><td class="fieldtype">
<a id="a6322dc0be297d305d55ec25632687a55"></a>uint8_t</td>
<td class="fieldname">
program_dummy_cycles</td>
<td class="fielddoc">
Dummy cycles to be inserted for page program commands. </td></tr>
<tr><td class="fieldtype">
<a id="ae881924edab459fec5c1f0a4519ad77a"></a>uint8_t</td>
<td class="fieldname">
status_dummy_cycles</td>
<td class="fielddoc">
Dummy cycles to be inserted for status read commands. </td></tr>
<tr><td class="fieldtype">
<a id="aba7c637ada23d85938025e622e6f705d"></a>uint8_t</td>
<td class="fieldname">
row_load_dummy_cycles</td>
<td class="fielddoc">
Dummy cycles to be inserted for the page load command. </td></tr>
<tr><td class="fieldtype">
<a id="a0526d05dcd366ee7ebad1f88714001b9"></a>uint8_t</td>
<td class="fieldname">
row_store_dummy_cycles</td>
<td class="fielddoc">
Dummy cycles to be inserted for the page store command. </td></tr>
<tr><td class="fieldtype">
<a id="abef464c831b5cc1705c8e51085ef0dd8"></a>uint8_t</td>
<td class="fieldname">
address_msb_mask</td>
<td class="fielddoc">
Mask of bits to zero when using memory-mapped operations; only applies to the most-significant byte. </td></tr>
<tr><td class="fieldtype">
<a id="a8702c9b52d6ae6ba2a1be6db6ab702cb"></a>bool</td>
<td class="fieldname">
status_needs_address</td>
<td class="fielddoc">
Indicates that reading the status register requires an address stage. </td></tr>
<tr><td class="fieldtype">
<a id="a186b5ffb2bc40c5a1043d681bbe39db7"></a>uint32_t</td>
<td class="fieldname">
status_address</td>
<td class="fielddoc">
Address to use for reading the status register with "busy" and "write-enable" flags. </td></tr>
<tr><td class="fieldtype">
<a id="a07dbd2c6892093be321f57711848d2f3"></a><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga289ef915326b8e75e7d0dd331c2d0797">spi_flash_address_bytes_t</a></td>
<td class="fieldname">
status_address_bytes</td>
<td class="fielddoc">
Number of bytes used for status register addressing. </td></tr>
<tr><td class="fieldtype">
<a id="adcbff92ffccf92dc8bf1272dab7e294a"></a><a class="el" href="group___o_s_p_i___b.html#structospi__b__table__t">ospi_b_table_t</a> const  *</td>
<td class="fieldname">
p_erase_commands</td>
<td class="fielddoc">
List of all erase commands and associated sizes. </td></tr>
</table>

</div>
</div>
<a name="structospi__b__dotf__cfg__t" id="structospi__b__dotf__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structospi__b__dotf__cfg__t">&#9670;&nbsp;</a></span>ospi_b_dotf_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ospi_b_dotf_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure is used to hold all the DOTF related configuration. </p>
</div>
</div>
</div>
<a name="structospi__b__extended__cfg__t" id="structospi__b__extended__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structospi__b__extended__cfg__t">&#9670;&nbsp;</a></span>ospi_b_extended_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ospi_b_extended_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>OSPI_B Extended configuration. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a1090b1cb176b529d4386e38e8040b472"></a>uint8_t</td>
<td class="fieldname">
ospi_b_unit</td>
<td class="fielddoc">
The OSPI_B unit corresponding to the selected channel. </td></tr>
<tr><td class="fieldtype">
<a id="a7e2e7c493d3ca31a1dde6b4307e4d725"></a><a class="el" href="group___o_s_p_i___b.html#ga76971feb991ff5a55ffdc3e1c6834c1f">ospi_b_device_number_t</a></td>
<td class="fieldname">
channel</td>
<td class="fielddoc">
Device number to be used for memory device. </td></tr>
<tr><td class="fieldtype">
<a id="a6cf36a43b286b455e32b5d3557662966"></a><a class="el" href="group___o_s_p_i___b.html#structospi__b__timing__setting__t">ospi_b_timing_setting_t</a> const  *</td>
<td class="fieldname">
p_timing_settings</td>
<td class="fielddoc">
Fixed protocol timing settings. </td></tr>
<tr><td class="fieldtype">
<a id="a508364a048f6aeec3f7ba9aa56053da0"></a><a class="el" href="group___o_s_p_i___b.html#structospi__b__table__t">ospi_b_table_t</a> const  *</td>
<td class="fieldname">
p_xspi_command_set</td>
<td class="fielddoc">
Additional protocol command sets; if additional protocol commands set are not used set this to NULL. </td></tr>
<tr><td class="fieldtype">
<a id="aa3273ae681e006597303a7c4671673fd"></a><a class="el" href="group___o_s_p_i___b.html#ga7b8f9d8f7c05070b5b4826882dbb15fa">ospi_b_ds_timing_delay_t</a></td>
<td class="fieldname">
data_latch_delay_clocks</td>
<td class="fielddoc">
Delay after assertion of the DS signal where data should be latched. </td></tr>
<tr><td class="fieldtype">
<a id="a8562f207c43dc832c1f78ac06f9b522a"></a>uint8_t *</td>
<td class="fieldname">
p_autocalibration_preamble_pattern_addr</td>
<td class="fielddoc">
OctaFlash memory address holding the preamble pattern. </td></tr>
<tr><td class="fieldtype">
<a id="a61141668e0ed6019ecabfaba780f2cf0"></a><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__instance__t">transfer_instance_t</a> const  *</td>
<td class="fieldname">
p_lower_lvl_transfer</td>
<td class="fielddoc">
DMA Transfer instance used for data transmission. </td></tr>
</table>

</div>
</div>
<a name="structospi__b__instance__ctrl__t" id="structospi__b__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structospi__b__instance__ctrl__t">&#9670;&nbsp;</a></span>ospi_b_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ospi_b_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Instance control block. DO NOT INITIALIZE. Initialization occurs when <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a75a4468493abb92f6bf484ed93718f6f">spi_flash_api_t::open</a> is called </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a4fa5199637964dc5a2890aa94dd29cb8"></a><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__cfg__t">spi_flash_cfg_t</a> const  *</td>
<td class="fieldname">
p_cfg</td>
<td class="fielddoc">
Pointer to initial configuration. </td></tr>
<tr><td class="fieldtype">
<a id="ab3666fb8e1312a2c7c8b16b8f95d94bb"></a>uint32_t</td>
<td class="fieldname">
open</td>
<td class="fielddoc">
Whether or not driver is open. </td></tr>
<tr><td class="fieldtype">
<a id="afd8dc5866bca51974a80b793bff2fa81"></a><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga17c347a498a8a9d38ffc36c0de49a535">spi_flash_protocol_t</a></td>
<td class="fieldname">
spi_protocol</td>
<td class="fielddoc">
Current OSPI protocol selected. </td></tr>
<tr><td class="fieldtype">
<a id="af12618bf3fa4bf86967dca5eeb918ca3"></a><a class="el" href="group___o_s_p_i___b.html#ga76971feb991ff5a55ffdc3e1c6834c1f">ospi_b_device_number_t</a></td>
<td class="fieldname">
channel</td>
<td class="fielddoc">
Device number to be used for memory device. </td></tr>
<tr><td class="fieldtype">
<a id="ab80b799761f032f97c0effe0c68748bb"></a>uint8_t</td>
<td class="fieldname">
ospi_b_unit</td>
<td class="fielddoc">
OSPI_B instance number. </td></tr>
<tr><td class="fieldtype">
<a id="a1bf3034bfe77a6165e54d1ab593bfcdb"></a><a class="el" href="group___o_s_p_i___b.html#structospi__b__xspi__command__set__t">ospi_b_xspi_command_set_t</a> const  *</td>
<td class="fieldname">
p_cmd_set</td>
<td class="fielddoc">
Command set for the active protocol mode. </td></tr>
<tr><td class="fieldtype">
<a id="a220f063a15c4b9a60e75ee7c50dfbbfe"></a>R_XSPI0_Type *</td>
<td class="fieldname">
p_reg</td>
<td class="fielddoc">
Address for the OSPI peripheral associated with this channel. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga84d19b0f9d6698d68364b7c4c2bb1126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84d19b0f9d6698d68364b7c4c2bb1126">&#9670;&nbsp;</a></span>OSPI_B_MAX_WRITE_ENABLE_POLLING_LOOPS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSPI_B_MAX_WRITE_ENABLE_POLLING_LOOPS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum number of status polling checks after enabling memory writes. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga76971feb991ff5a55ffdc3e1c6834c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76971feb991ff5a55ffdc3e1c6834c1f">&#9670;&nbsp;</a></span>ospi_b_device_number_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___o_s_p_i___b.html#ga76971feb991ff5a55ffdc3e1c6834c1f">ospi_b_device_number_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>OSPI Flash chip select </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga76971feb991ff5a55ffdc3e1c6834c1fa92f8ffbf2e66985d3809b4e4b538be6b"></a>OSPI_B_DEVICE_NUMBER_0&#160;</td><td class="fielddoc"><p>Device connected to Chip-Select 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga76971feb991ff5a55ffdc3e1c6834c1fa0f6cd25fb2ea2323c39f116ea0f60643"></a>OSPI_B_DEVICE_NUMBER_1&#160;</td><td class="fielddoc"><p>Device connected to Chip-Select 1. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga4bf54e3468d5d4de83db9e021bdbb2d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bf54e3468d5d4de83db9e021bdbb2d3">&#9670;&nbsp;</a></span>ospi_b_command_bytes_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___o_s_p_i___b.html#ga4bf54e3468d5d4de83db9e021bdbb2d3">ospi_b_command_bytes_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>OSPI flash number of command code bytes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4bf54e3468d5d4de83db9e021bdbb2d3a6aa3fcd6c65bf42cb3ee95b050fe12dd"></a>OSPI_B_COMMAND_BYTES_1&#160;</td><td class="fielddoc"><p>Command codes are 1 byte long. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4bf54e3468d5d4de83db9e021bdbb2d3a165af2425e8e2fbcc301f0c7081cf9e2"></a>OSPI_B_COMMAND_BYTES_2&#160;</td><td class="fielddoc"><p>Command codes are 2 bytes long. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga570e0018e1e0dd225038e20f4a56d041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga570e0018e1e0dd225038e20f4a56d041">&#9670;&nbsp;</a></span>ospi_b_command_interval_clocks_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___o_s_p_i___b.html#ga570e0018e1e0dd225038e20f4a56d041">ospi_b_command_interval_clocks_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>OSPI frame to frame interval </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga570e0018e1e0dd225038e20f4a56d041aa3297766c58c3d622fc90a296fe13de8"></a>OSPI_B_COMMAND_INTERVAL_CLOCKS_1&#160;</td><td class="fielddoc"><p>1 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="gga570e0018e1e0dd225038e20f4a56d041a23a043628c6910bb166caa362c90066f"></a>OSPI_B_COMMAND_INTERVAL_CLOCKS_2&#160;</td><td class="fielddoc"><p>2 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="gga570e0018e1e0dd225038e20f4a56d041ace3a2305b1596b80d1f39e912194054b"></a>OSPI_B_COMMAND_INTERVAL_CLOCKS_3&#160;</td><td class="fielddoc"><p>3 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="gga570e0018e1e0dd225038e20f4a56d041a17d7e54ee6efffe299524d685a0f3e16"></a>OSPI_B_COMMAND_INTERVAL_CLOCKS_4&#160;</td><td class="fielddoc"><p>4 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="gga570e0018e1e0dd225038e20f4a56d041a8af9eb95b1b676874ce2229d51df9b3f"></a>OSPI_B_COMMAND_INTERVAL_CLOCKS_5&#160;</td><td class="fielddoc"><p>5 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="gga570e0018e1e0dd225038e20f4a56d041a907b1266492c3ed833c3a6029cbdbd1d"></a>OSPI_B_COMMAND_INTERVAL_CLOCKS_6&#160;</td><td class="fielddoc"><p>6 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="gga570e0018e1e0dd225038e20f4a56d041a25e06717470ce3ad18dbba19f66cd0dc"></a>OSPI_B_COMMAND_INTERVAL_CLOCKS_7&#160;</td><td class="fielddoc"><p>7 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="gga570e0018e1e0dd225038e20f4a56d041ad8f151924a7de41b649373d3845a95df"></a>OSPI_B_COMMAND_INTERVAL_CLOCKS_8&#160;</td><td class="fielddoc"><p>8 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="gga570e0018e1e0dd225038e20f4a56d041aae9cfe00744d313e74f635bf1cfb3654"></a>OSPI_B_COMMAND_INTERVAL_CLOCKS_9&#160;</td><td class="fielddoc"><p>9 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="gga570e0018e1e0dd225038e20f4a56d041ae5b870aaac797d738d8a1043b753353d"></a>OSPI_B_COMMAND_INTERVAL_CLOCKS_10&#160;</td><td class="fielddoc"><p>10 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="gga570e0018e1e0dd225038e20f4a56d041a5cc48e74fa430db86fa2ce1beaa72630"></a>OSPI_B_COMMAND_INTERVAL_CLOCKS_11&#160;</td><td class="fielddoc"><p>11 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="gga570e0018e1e0dd225038e20f4a56d041aeacb60ba48f417c39ff708755a5c5eaa"></a>OSPI_B_COMMAND_INTERVAL_CLOCKS_12&#160;</td><td class="fielddoc"><p>12 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="gga570e0018e1e0dd225038e20f4a56d041a803540312e867e64f3cd939e95b42490"></a>OSPI_B_COMMAND_INTERVAL_CLOCKS_13&#160;</td><td class="fielddoc"><p>13 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="gga570e0018e1e0dd225038e20f4a56d041a01d97278b32aa4403ce0b4c3153385fd"></a>OSPI_B_COMMAND_INTERVAL_CLOCKS_14&#160;</td><td class="fielddoc"><p>14 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="gga570e0018e1e0dd225038e20f4a56d041a3982fcadc8c47ab6265b820e179c5346"></a>OSPI_B_COMMAND_INTERVAL_CLOCKS_15&#160;</td><td class="fielddoc"><p>15 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="gga570e0018e1e0dd225038e20f4a56d041a39cbd91fd8f8d4d441f96db680090654"></a>OSPI_B_COMMAND_INTERVAL_CLOCKS_16&#160;</td><td class="fielddoc"><p>16 interval clocks </p>
</td></tr>
</table>

</div>
</div>
<a id="ga910082046980b0d68cf3927d2a465e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga910082046980b0d68cf3927d2a465e4b">&#9670;&nbsp;</a></span>ospi_b_command_cs_pullup_clocks_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___o_s_p_i___b.html#ga910082046980b0d68cf3927d2a465e4b">ospi_b_command_cs_pullup_clocks_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>OSPI chip select de-assertion duration </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga910082046980b0d68cf3927d2a465e4ba974ee50a3742b03de4bfabe3364ef903"></a>OSPI_B_COMMAND_CS_PULLUP_CLOCKS_NO_EXTENSION&#160;</td><td class="fielddoc"><p>CS asserting No extension. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga910082046980b0d68cf3927d2a465e4ba47e862894eb5a341163a1eb726976124"></a>OSPI_B_COMMAND_CS_PULLUP_CLOCKS_1&#160;</td><td class="fielddoc"><p>CS asserting Extend 1 cycle. </p>
</td></tr>
</table>

</div>
</div>
<a id="gab6aad607f2de843932644cf1137eeeac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6aad607f2de843932644cf1137eeeac">&#9670;&nbsp;</a></span>ospi_b_command_cs_pulldown_clocks_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___o_s_p_i___b.html#gab6aad607f2de843932644cf1137eeeac">ospi_b_command_cs_pulldown_clocks_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>OSPI chip select assertion duration </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab6aad607f2de843932644cf1137eeeacae46135ac72afa0bea87eccfb6ecce566"></a>OSPI_B_COMMAND_CS_PULLDOWN_CLOCKS_NO_EXTENSION&#160;</td><td class="fielddoc"><p>CS negating No extension. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab6aad607f2de843932644cf1137eeeaca4fa5ffc6899c6e6d8cb69168c3e8627c"></a>OSPI_B_COMMAND_CS_PULLDOWN_CLOCKS_1&#160;</td><td class="fielddoc"><p>CS negating Extend 1 cycle. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga7b8f9d8f7c05070b5b4826882dbb15fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b8f9d8f7c05070b5b4826882dbb15fa">&#9670;&nbsp;</a></span>ospi_b_ds_timing_delay_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___o_s_p_i___b.html#ga7b8f9d8f7c05070b5b4826882dbb15fa">ospi_b_ds_timing_delay_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>OSPI data strobe delay. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faa866af4a57107ec1f8e1ce50d7d3a1be1"></a>OSPI_B_DS_TIMING_DELAY_NONE&#160;</td><td class="fielddoc"><p>Sample without delay. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faaf63effc13d9736337456da954173bc64"></a>OSPI_B_DS_TIMING_DELAY_1&#160;</td><td class="fielddoc"><p>Delay sampling by 1 clock cell. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faa1909a5ef1344e1844f214a472dac3d1e"></a>OSPI_B_DS_TIMING_DELAY_2&#160;</td><td class="fielddoc"><p>Delay sampling by 2 clock cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faa525a46d783e425279495c7577a087160"></a>OSPI_B_DS_TIMING_DELAY_3&#160;</td><td class="fielddoc"><p>Delay sampling by 3 clock cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faa5637c6ea1b3744644428c35d5257f125"></a>OSPI_B_DS_TIMING_DELAY_4&#160;</td><td class="fielddoc"><p>Delay sampling by 4 clock cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faa9d433678f1b985a398fbe2f4815c64ca"></a>OSPI_B_DS_TIMING_DELAY_5&#160;</td><td class="fielddoc"><p>Delay sampling by 5 clock cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faa8e6d4130108e6d02661ff6e844ad4b1e"></a>OSPI_B_DS_TIMING_DELAY_6&#160;</td><td class="fielddoc"><p>Delay sampling by 6 clock cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faad5db99ec58b5a6a1c1e8a503fe91000f"></a>OSPI_B_DS_TIMING_DELAY_7&#160;</td><td class="fielddoc"><p>Delay sampling by 7 clock cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faa831e2554bc4ddeb3f91a43b4472811bd"></a>OSPI_B_DS_TIMING_DELAY_8&#160;</td><td class="fielddoc"><p>Delay sampling by 8 clock cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faa96953ca77d475071af0a6505cfc63876"></a>OSPI_B_DS_TIMING_DELAY_9&#160;</td><td class="fielddoc"><p>Delay sampling by 9 clock cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faae649dcc9c4464b6b56823de95661fa69"></a>OSPI_B_DS_TIMING_DELAY_10&#160;</td><td class="fielddoc"><p>Delay sampling by 10 clock cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faa7650eccd88381e2c549a4f3f05f98452"></a>OSPI_B_DS_TIMING_DELAY_11&#160;</td><td class="fielddoc"><p>Delay sampling by 11 clock cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faa29751edf8ce3c00957a38d5a1d370613"></a>OSPI_B_DS_TIMING_DELAY_12&#160;</td><td class="fielddoc"><p>Delay sampling by 12 clock cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faa64f7af03a6ec5f43ca25ec574f32c0f6"></a>OSPI_B_DS_TIMING_DELAY_13&#160;</td><td class="fielddoc"><p>Delay sampling by 13 clock cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faae2e979e2ae5912f3fc7c1f5013e415af"></a>OSPI_B_DS_TIMING_DELAY_14&#160;</td><td class="fielddoc"><p>Delay sampling by 14 clock cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faa0b91a9a412f722da82d83f774ba8a5f5"></a>OSPI_B_DS_TIMING_DELAY_15&#160;</td><td class="fielddoc"><p>Delay sampling by 15 clock cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faa84109b879cb5046bf02caaaae8094f2b"></a>OSPI_B_DS_TIMING_DELAY_16&#160;</td><td class="fielddoc"><p>Delay sampling by 16 clock cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faa26e50cf9966c02fb8f1286f9aafabfe8"></a>OSPI_B_DS_TIMING_DELAY_17&#160;</td><td class="fielddoc"><p>Delay sampling by 17 clock cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faa75aec25ef776fb372913322c40f0cb16"></a>OSPI_B_DS_TIMING_DELAY_18&#160;</td><td class="fielddoc"><p>Delay sampling by 18 clock cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faaa3ad7ad49bbb5f1ced665fab13dd4e9b"></a>OSPI_B_DS_TIMING_DELAY_19&#160;</td><td class="fielddoc"><p>Delay sampling by 19 clock cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faab62d36b86156eaf71f4a288c14b8dd05"></a>OSPI_B_DS_TIMING_DELAY_20&#160;</td><td class="fielddoc"><p>Delay sampling by 20 clock cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faab03c2761ddee55d3bcccca791a46bdf3"></a>OSPI_B_DS_TIMING_DELAY_21&#160;</td><td class="fielddoc"><p>Delay sampling by 21 clock cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faa2b9304d3764cb5cafcc92714d16eefe5"></a>OSPI_B_DS_TIMING_DELAY_22&#160;</td><td class="fielddoc"><p>Delay sampling by 22 clock cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faa55d664ab669d71c1e775295f56cf0199"></a>OSPI_B_DS_TIMING_DELAY_23&#160;</td><td class="fielddoc"><p>Delay sampling by 23 clock cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faaaea80d13a1fb72e37e1c58043dc5d816"></a>OSPI_B_DS_TIMING_DELAY_24&#160;</td><td class="fielddoc"><p>Delay sampling by 24 clock cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faa7a1b01d09b27fb37f1eef35daceabadc"></a>OSPI_B_DS_TIMING_DELAY_25&#160;</td><td class="fielddoc"><p>Delay sampling by 25 clock cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faa0f2968601f05c21d890e47ac3961bb93"></a>OSPI_B_DS_TIMING_DELAY_26&#160;</td><td class="fielddoc"><p>Delay sampling by 26 clock cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faa5d0c6d8ff66bec6e097e95f94b0241ba"></a>OSPI_B_DS_TIMING_DELAY_27&#160;</td><td class="fielddoc"><p>Delay sampling by 27 clock cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faa9cbea51eb280ccf19faeb8c878a62935"></a>OSPI_B_DS_TIMING_DELAY_28&#160;</td><td class="fielddoc"><p>Delay sampling by 28 clock cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faa9c002310cda757e04e39d02edbc64c5a"></a>OSPI_B_DS_TIMING_DELAY_29&#160;</td><td class="fielddoc"><p>Delay sampling by 29 clock cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faa3e67aa925afb0ed8a507bf1ce73026cc"></a>OSPI_B_DS_TIMING_DELAY_30&#160;</td><td class="fielddoc"><p>Delay sampling by 30 clock cells. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b8f9d8f7c05070b5b4826882dbb15faaa757baa9dee40a468c2b24732819f999"></a>OSPI_B_DS_TIMING_DELAY_31&#160;</td><td class="fielddoc"><p>Delay sampling by 31 clock cells. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga6f788d0293774da421928e43112397c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f788d0293774da421928e43112397c0">&#9670;&nbsp;</a></span>ospi_b_sdr_drive_timing_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___o_s_p_i___b.html#ga6f788d0293774da421928e43112397c0">ospi_b_sdr_drive_timing_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>OSPI SDR signal drive timing. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6f788d0293774da421928e43112397c0a65a6b65c9fa75feda107e436e53433ae"></a>OSPI_B_SDR_DRIVE_TIMING_BEFORE_CK&#160;</td><td class="fielddoc"><p>SDR is asserted 1/2 cycle before the rising-edge of CK. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6f788d0293774da421928e43112397c0a002dddb081f4281905c4b2353cbf51e2"></a>OSPI_B_SDR_DRIVE_TIMING_AT_CK&#160;</td><td class="fielddoc"><p>SDR is asserted at the rising-edge of CK. </p>
</td></tr>
</table>

</div>
</div>
<a id="gae27c294bf3112e9fa6ef652cc470e12d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae27c294bf3112e9fa6ef652cc470e12d">&#9670;&nbsp;</a></span>ospi_b_ck_edge_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___o_s_p_i___b.html#gae27c294bf3112e9fa6ef652cc470e12d">ospi_b_ck_edge_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clock edge useed to sample data in SDR mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae27c294bf3112e9fa6ef652cc470e12da6b199035d0c7fca722a4cb7fd043b321"></a>OSPI_B_CK_EDGE_FALLING&#160;</td><td class="fielddoc"><p>Falling-edge of CK signal. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae27c294bf3112e9fa6ef652cc470e12da52a33dd79fa38ea8f78d343c90afab1a"></a>OSPI_B_CK_EDGE_RISING&#160;</td><td class="fielddoc"><p>Rising-edge of CK signal. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga936cdfcd8adcd5e8623598ff2abea12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga936cdfcd8adcd5e8623598ff2abea12e">&#9670;&nbsp;</a></span>ospi_b_sdr_sampling_delay_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___o_s_p_i___b.html#ga936cdfcd8adcd5e8623598ff2abea12e">ospi_b_sdr_sampling_delay_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SDR sampling window delay. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga936cdfcd8adcd5e8623598ff2abea12eab1efb7515f395381b43ce27caf406d55"></a>OSPI_B_SDR_SAMPLING_DELAY_NONE&#160;</td><td class="fielddoc"><p>No sampling delay. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga936cdfcd8adcd5e8623598ff2abea12eaa86bbb0eae7b03b1bf48ccfd3763220f"></a>OSPI_B_SDR_SAMPLING_DELAY_1&#160;</td><td class="fielddoc"><p>Delay sampling by 1 cycle. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga936cdfcd8adcd5e8623598ff2abea12eaf99d0dd0eb6e386321b6588625f4acce"></a>OSPI_B_SDR_SAMPLING_DELAY_2&#160;</td><td class="fielddoc"><p>Delay sampling by 2 cycles. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga936cdfcd8adcd5e8623598ff2abea12ea283367fffd00325be788fa3809bfcf17"></a>OSPI_B_SDR_SAMPLING_DELAY_3&#160;</td><td class="fielddoc"><p>Delay sampling by 3 cycles. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga936cdfcd8adcd5e8623598ff2abea12eadb86a30e6c553cad2d3c4aa550468b72"></a>OSPI_B_SDR_SAMPLING_DELAY_4&#160;</td><td class="fielddoc"><p>Delay sampling by 4 cycles. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga936cdfcd8adcd5e8623598ff2abea12ea9fa78fc8affc012a87f6f812ce1db265"></a>OSPI_B_SDR_SAMPLING_DELAY_5&#160;</td><td class="fielddoc"><p>Delay sampling by 5 cycles. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga936cdfcd8adcd5e8623598ff2abea12ea9b00206e11fc532e2f5ff339fbb970fe"></a>OSPI_B_SDR_SAMPLING_DELAY_6&#160;</td><td class="fielddoc"><p>Delay sampling by 6 cycles. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga936cdfcd8adcd5e8623598ff2abea12ea1855da65c9e700e70dccfdec100e7882"></a>OSPI_B_SDR_SAMPLING_DELAY_7&#160;</td><td class="fielddoc"><p>Delay sampling by 7 cycles. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga80c573b83c220daa0a6cf15c9f238bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80c573b83c220daa0a6cf15c9f238bf2">&#9670;&nbsp;</a></span>ospi_b_ddr_sampling_extension_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___o_s_p_i___b.html#ga80c573b83c220daa0a6cf15c9f238bf2">ospi_b_ddr_sampling_extension_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DDR sampling window extension. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga80c573b83c220daa0a6cf15c9f238bf2a6c0c0e52ce891457429582926f893061"></a>OSPI_B_DDR_SAMPLING_EXTENSION_NONE&#160;</td><td class="fielddoc"><p>No sampling extension. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga80c573b83c220daa0a6cf15c9f238bf2a166df5fcfc26217dc36fc5c88349f5e6"></a>OSPI_B_DDR_SAMPLING_EXTENSION_1&#160;</td><td class="fielddoc"><p>Sampling extended by 1 cycle. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga80c573b83c220daa0a6cf15c9f238bf2aae89918bb8530c6e71e653fef38c93f6"></a>OSPI_B_DDR_SAMPLING_EXTENSION_2&#160;</td><td class="fielddoc"><p>Sampling extended by 2 cycles. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga80c573b83c220daa0a6cf15c9f238bf2a2a44da0203e93abcac977fecd2b0165c"></a>OSPI_B_DDR_SAMPLING_EXTENSION_3&#160;</td><td class="fielddoc"><p>Sampling extended by 3 cycles. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga80c573b83c220daa0a6cf15c9f238bf2aa194d392dd8eb9c9932fa3a03207b9be"></a>OSPI_B_DDR_SAMPLING_EXTENSION_4&#160;</td><td class="fielddoc"><p>Sampling extended by 4 cycles. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga80c573b83c220daa0a6cf15c9f238bf2a53931ec25391c197f7fd78469c39326b"></a>OSPI_B_DDR_SAMPLING_EXTENSION_5&#160;</td><td class="fielddoc"><p>Sampling extended by 5 cycles. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga80c573b83c220daa0a6cf15c9f238bf2a14ba326da28a6f3f12bf4dc10e557cce"></a>OSPI_B_DDR_SAMPLING_EXTENSION_6&#160;</td><td class="fielddoc"><p>Sampling extended by 6 cycles. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga80c573b83c220daa0a6cf15c9f238bf2a6ef8e2bf6d1f727651b0cc0e4123aa5c"></a>OSPI_B_DDR_SAMPLING_EXTENSION_7&#160;</td><td class="fielddoc"><p>Sampling extended by 7 cycles. </p>
</td></tr>
</table>

</div>
</div>
<a id="gada8a65f95a308ffd7a5bfa58a8a2b183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada8a65f95a308ffd7a5bfa58a8a2b183">&#9670;&nbsp;</a></span>ospi_b_frame_format_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___o_s_p_i___b.html#gada8a65f95a308ffd7a5bfa58a8a2b183">ospi_b_frame_format_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Format of data frames used for communicating with the target device. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggada8a65f95a308ffd7a5bfa58a8a2b183af9ddf00cc395878dfd4486dcd6354db8"></a>OSPI_B_FRAME_FORMAT_STANDARD&#160;</td><td class="fielddoc"><p>Standard frame with command, address, and data phases. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada8a65f95a308ffd7a5bfa58a8a2b183ad7a6eeb97b3ac2b5df3fc03ce41258b2"></a>OSPI_B_FRAME_FORMAT_XSPI_PROFILE_1&#160;</td><td class="fielddoc"><p>JEDEC XSPI 8D-8D-8D Profile 1.0 frame. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada8a65f95a308ffd7a5bfa58a8a2b183aa17e9454fae1fdbe8bc1090adf6dd213"></a>OSPI_B_FRAME_FORMAT_XSPI_PROFILE_2&#160;</td><td class="fielddoc"><p>JEDEC XSPI 8D-8D-8D Profile 2.0 frame. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada8a65f95a308ffd7a5bfa58a8a2b183a737189d3185afa26ec870a453ecec645"></a>OSPI_B_FRAME_FORMAT_XSPI_PROFILE_2_EXTENDED&#160;</td><td class="fielddoc"><p>JEDEC XSPI 8D-8D-8D Profile 2.0 extended 6-byte command-address frame, used with HyperRAM. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga5fb4c8bc061b939bd501610e8a687359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fb4c8bc061b939bd501610e8a687359">&#9670;&nbsp;</a></span>ospi_b_latency_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___o_s_p_i___b.html#ga5fb4c8bc061b939bd501610e8a687359">ospi_b_latency_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variable or fixed latency selection for flash devices which can notify the host of requiring additional time. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga5fb4c8bc061b939bd501610e8a687359ab9c47d1045bfdab42bb95e2599fb194f"></a>OSPI_B_LATENCY_MODE_FIXED&#160;</td><td class="fielddoc"><p>Latency is fixed to the number of dummy cycles for the command. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5fb4c8bc061b939bd501610e8a687359a8f75b46c5467ffde0834594a821ee41f"></a>OSPI_B_LATENCY_MODE_VARIABLE&#160;</td><td class="fielddoc"><p>The flash target signifies additional latency (2x dummy cycles) by asserting the DQS line during the address phase. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga131fd33e93249afc3733475ad2786a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga131fd33e93249afc3733475ad2786a3b">&#9670;&nbsp;</a></span>ospi_b_prefetch_function_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___o_s_p_i___b.html#ga131fd33e93249afc3733475ad2786a3b">ospi_b_prefetch_function_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prefetch function settings </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga131fd33e93249afc3733475ad2786a3ba7c4c7495152f1c522f914833daac9877"></a>OSPI_B_PREFETCH_FUNCTION_DISABLE&#160;</td><td class="fielddoc"><p>Prefetch function disable. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga131fd33e93249afc3733475ad2786a3baa55d93dc648aaa44af7e46d996fef6c9"></a>OSPI_B_PREFETCH_FUNCTION_ENABLE&#160;</td><td class="fielddoc"><p>Prefetch function enable. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga7d821ba8f342427fa60390abdf6cdf87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d821ba8f342427fa60390abdf6cdf87">&#9670;&nbsp;</a></span>ospi_b_combination_function_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___o_s_p_i___b.html#ga7d821ba8f342427fa60390abdf6cdf87">ospi_b_combination_function_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Combination function settings </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga7d821ba8f342427fa60390abdf6cdf87a5bd421f37fe950db1c67ecd1b5f8f166"></a>OSPI_B_COMBINATION_FUNCTION_DISABLE&#160;</td><td class="fielddoc"><p>Combination function disable. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7d821ba8f342427fa60390abdf6cdf87ab50cce32e55529ec5226a08496438e5b"></a>OSPI_B_COMBINATION_FUNCTION_4BYTE&#160;</td><td class="fielddoc"><p>Combine up to 4 bytes. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7d821ba8f342427fa60390abdf6cdf87aa9a341e65e9d10337b58b3a1d3126119"></a>OSPI_B_COMBINATION_FUNCTION_8BYTE&#160;</td><td class="fielddoc"><p>Combine up to 8 bytes. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7d821ba8f342427fa60390abdf6cdf87a1f7c4ee0b25af1190d5d5560e609abe6"></a>OSPI_B_COMBINATION_FUNCTION_12BYTE&#160;</td><td class="fielddoc"><p>Combine up to 12 bytes. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7d821ba8f342427fa60390abdf6cdf87aa10a7205b373799998172ff1a507177c"></a>OSPI_B_COMBINATION_FUNCTION_16BYTE&#160;</td><td class="fielddoc"><p>Combine up to 16 bytes. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7d821ba8f342427fa60390abdf6cdf87ad10a3a7c69946554f59e57b8a8ec2440"></a>OSPI_B_COMBINATION_FUNCTION_20BYTE&#160;</td><td class="fielddoc"><p>Combine up to 20 bytes. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7d821ba8f342427fa60390abdf6cdf87a02bbe0905eef2a7363c74b52fb84c2a3"></a>OSPI_B_COMBINATION_FUNCTION_24BYTE&#160;</td><td class="fielddoc"><p>Combine up to 24 bytes. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7d821ba8f342427fa60390abdf6cdf87a4c45fbb0021afb121eaa7c40fdd35e9b"></a>OSPI_B_COMBINATION_FUNCTION_28BYTE&#160;</td><td class="fielddoc"><p>Combine up to 28 bytes. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7d821ba8f342427fa60390abdf6cdf87ad963958401829eac618f5109cb0e1723"></a>OSPI_B_COMBINATION_FUNCTION_32BYTE&#160;</td><td class="fielddoc"><p>Combine up to 32 bytes. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7d821ba8f342427fa60390abdf6cdf87a0eb3bcc5ce232c18334b15593a1308a7"></a>OSPI_B_COMBINATION_FUNCTION_36BYTE&#160;</td><td class="fielddoc"><p>Combine up to 36 bytes. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7d821ba8f342427fa60390abdf6cdf87a080c813d4d96c7f4f460cf2534fb2698"></a>OSPI_B_COMBINATION_FUNCTION_40BYTE&#160;</td><td class="fielddoc"><p>Combine up to 40 bytes. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7d821ba8f342427fa60390abdf6cdf87a45adb20dd50f49645f3c97e571cab3bd"></a>OSPI_B_COMBINATION_FUNCTION_44BYTE&#160;</td><td class="fielddoc"><p>Combine up to 44 bytes. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7d821ba8f342427fa60390abdf6cdf87a3d1971534dcbb7ac481140e4447e9dcc"></a>OSPI_B_COMBINATION_FUNCTION_48BYTE&#160;</td><td class="fielddoc"><p>Combine up to 48 bytes. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7d821ba8f342427fa60390abdf6cdf87ac250c9d3fe55f92f55fc2fd98b4927fb"></a>OSPI_B_COMBINATION_FUNCTION_52BYTE&#160;</td><td class="fielddoc"><p>Combine up to 52 bytes. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7d821ba8f342427fa60390abdf6cdf87a25da316829b1720e1e4d263b0c64547d"></a>OSPI_B_COMBINATION_FUNCTION_56BYTE&#160;</td><td class="fielddoc"><p>Combine up to 56 bytes. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7d821ba8f342427fa60390abdf6cdf87a485cfef768ecd41267d535233429d76e"></a>OSPI_B_COMBINATION_FUNCTION_60BYTE&#160;</td><td class="fielddoc"><p>Combine up to 60 bytes. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7d821ba8f342427fa60390abdf6cdf87a2cac3d12b16db8e64d1065eceeb31ab2"></a>OSPI_B_COMBINATION_FUNCTION_64BYTE&#160;</td><td class="fielddoc"><p>Combine up to 64 bytes. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7d821ba8f342427fa60390abdf6cdf87a65f73049ac27e6a8fe5b1c27f1bce385"></a>OSPI_B_COMBINATION_FUNCTION_2BYTE&#160;</td><td class="fielddoc"><p>Combine up to 2 bytes. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga69496e54ec435e56d55603fe640e8ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69496e54ec435e56d55603fe640e8ee9">&#9670;&nbsp;</a></span>ospi_b_dotf_aes_key_length_words_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___o_s_p_i___b.html#ga69496e54ec435e56d55603fe640e8ee9">ospi_b_dotf_aes_key_length_words_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>OSPI DOTF AES Key Lengths. </p>

</div>
</div>
<a id="ga0b36b2f02fae01eb700990fbaa76ef8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b36b2f02fae01eb700990fbaa76ef8e">&#9670;&nbsp;</a></span>ospi_b_dotf_aes_key_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___o_s_p_i___b.html#ga0b36b2f02fae01eb700990fbaa76ef8e">ospi_b_dotf_aes_key_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>PSPI DOTF AES Type. </p>

</div>
</div>
<a id="ga6c462523a81690b9897c68f30ddd7464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c462523a81690b9897c68f30ddd7464">&#9670;&nbsp;</a></span>ospi_b_dotf_key_format_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___o_s_p_i___b.html#ga6c462523a81690b9897c68f30ddd7464">ospi_b_dotf_key_format_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>OSPI DOTF key Type. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9134500bd9ee50551e218a81868f5b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9134500bd9ee50551e218a81868f5b1a">&#9670;&nbsp;</a></span>R_OSPI_B_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_OSPI_B_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__cfg__t">spi_flash_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open the xSPI device. After the driver is open, the xSPI device can be accessed like internal flash memory.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a75a4468493abb92f6bf484ed93718f6f">spi_flash_api_t::open</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Configuration was successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>The parameter p_ctrl or p_cfg is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Driver has already been opened with the same p_ctrl. </td></tr>
    <tr><td class="paramname">FSP_ERR_CALIBRATE_FAILED</td><td>Failed to perform auto-calibrate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae419ec1af4afc888da2d59403ca8225a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae419ec1af4afc888da2d59403ca8225a">&#9670;&nbsp;</a></span>R_OSPI_B_DirectWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_OSPI_B_DirectWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *const&#160;</td>
          <td class="paramname"><em>p_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>read_after_write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes raw data directly to the OctaFlash. API not supported. Use R_OSPI_B_DirectTransfer</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#aebfa0317034f04f53b6b788da0debe80">spi_flash_api_t::directWrite</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>API not supported by OSPI. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad0f52f7bbbbf2f94305f6334ad06b2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0f52f7bbbbf2f94305f6334ad06b2d8">&#9670;&nbsp;</a></span>R_OSPI_B_DirectRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_OSPI_B_DirectRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>p_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads raw data directly from the OctaFlash. API not supported. Use R_OSPI_B_DirectTransfer.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a4b3bfefb3b1ff0580fe1cce97b81c56f">spi_flash_api_t::directRead</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>API not supported by OSPI. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7b42dbc86db7f4c82ed640620743c609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b42dbc86db7f4c82ed640620743c609">&#9670;&nbsp;</a></span>R_OSPI_B_DirectTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_OSPI_B_DirectTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__direct__transfer__t">spi_flash_direct_transfer_t</a> *const&#160;</td>
          <td class="paramname"><em>p_transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga80ecf65e658f5b36bfe0bf2d88dd3ca5">spi_flash_direct_transfer_dir_t</a>&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read/Write raw data directly with the OctaFlash.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a875857cdb3d6ebf0971115737b9e2989">spi_flash_api_t::directTransfer</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The flash was programmed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga15282e9d7ef4d8c5471be859da55dd4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15282e9d7ef4d8c5471be859da55dd4a">&#9670;&nbsp;</a></span>R_OSPI_B_XipEnter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_OSPI_B_XipEnter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enters XIP (execute in place) mode.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a48a9a0db1f5bcb24acc9cc1cea14f0ab">spi_flash_api_t::xipEnter</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>XiP mode was entered successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>XiP support is not enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga96bc15adf392eccfa44eed3fb91fa7ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96bc15adf392eccfa44eed3fb91fa7ef">&#9670;&nbsp;</a></span>R_OSPI_B_XipExit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_OSPI_B_XipExit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exits XIP (execute in place) mode.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a00317079cf31b5311592d0845caa4d8a">spi_flash_api_t::xipExit</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>XiP mode was entered successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>XiP support is not enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabeb33594cd4d4f031f090857a7b3832b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabeb33594cd4d4f031f090857a7b3832b">&#9670;&nbsp;</a></span>R_OSPI_B_Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_OSPI_B_Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *const&#160;</td>
          <td class="paramname"><em>p_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>p_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>byte_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Program a page of data to the flash.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a35480fe077054fff8bd41c67dbce88fb">spi_flash_api_t::write</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The flash was programmed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_instance_ctrl, p_dest or p_src is NULL, or byte_count crosses a page boundary. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_SIZE</td><td>Insufficient space remaining in page or write length is not a multiple of CPU access size when not using the DMAC. </td></tr>
    <tr><td class="paramname">FSP_ERR_DEVICE_BUSY</td><td>Another Write/Erase transaction is in progress. </td></tr>
    <tr><td class="paramname">FSP_ERR_WRITE_FAILED</td><td>Write operation failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ADDRESS</td><td>Destination or source is not aligned to CPU access alignment when not using the DMAC. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga043d8c26f4d9c08a145bec1a3df4a2a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga043d8c26f4d9c08a145bec1a3df4a2a2">&#9670;&nbsp;</a></span>R_OSPI_B_Erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_OSPI_B_Erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>p_device_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>byte_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Erase a block or sector of flash. The byte_count must exactly match one of the erase sizes defined in <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__cfg__t">spi_flash_cfg_t</a>. For chip erase, byte_count must be SPI_FLASH_ERASE_SIZE_CHIP_ERASE.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a4fb48ee9af80243cf7f8f966b4c6c56e">spi_flash_api_t::erase</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The command to erase the flash was executed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_instance_ctrl or p_device_address is NULL, byte_count doesn't match an erase size defined in <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__cfg__t">spi_flash_cfg_t</a>, or byte_count is set to 0. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_DEVICE_BUSY</td><td>The device is busy. </td></tr>
    <tr><td class="paramname">FSP_ERR_WRITE_FAILED</td><td>Write operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae5936464390d82c29e2d03f6c04880e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5936464390d82c29e2d03f6c04880e2">&#9670;&nbsp;</a></span>R_OSPI_B_StatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_OSPI_B_StatusGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__status__t">spi_flash_status_t</a> *const&#160;</td>
          <td class="paramname"><em>p_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the write or erase status of the flash.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a36600006109effd5c9d47283a7760ce6">spi_flash_api_t::statusGet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The write status is in p_status. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_instance_ctrl or p_status is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga353dc5f34b95e0fac9f4f3074e52df70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga353dc5f34b95e0fac9f4f3074e52df70">&#9670;&nbsp;</a></span>R_OSPI_B_BankSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_OSPI_B_BankSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Selects the bank to access. Use ospi_b_bank_select_t as the bank value.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ae581e587fb514ab784257d07a77d6b32">spi_flash_api_t::bankSet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>This function is unsupported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga39b3c250a591ffd092cd6ded8c45249c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39b3c250a591ffd092cd6ded8c45249c">&#9670;&nbsp;</a></span>R_OSPI_B_SpiProtocolSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_OSPI_B_SpiProtocolSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga17c347a498a8a9d38ffc36c0de49a535">spi_flash_protocol_t</a>&#160;</td>
          <td class="paramname"><em>spi_protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the SPI protocol.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a423e63cd15ce3984410c2f5cdf717e35">spi_flash_api_t::spiProtocolSet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>SPI protocol updated on MPU peripheral. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_CALIBRATE_FAILED</td><td>Failed to perform auto-calibrate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4070e46f2fadda4ec4cb8b8f023c1a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4070e46f2fadda4ec4cb8b8f023c1a00">&#9670;&nbsp;</a></span>R_OSPI_B_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_OSPI_B_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close the OSPI driver module.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a28bdae798428b85222739a0b9fd43a15">spi_flash_api_t::close</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Configuration was successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_instance_ctrl is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac3441de6c487a640fae584248007a3a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3441de6c487a640fae584248007a3a6">&#9670;&nbsp;</a></span>R_OSPI_B_AutoCalibrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_OSPI_B_AutoCalibrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>AutoCalibrate the OSPI_B DS signal.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ac78c55ffe2b7d99681612ce796a384c5">spi_flash_api_t::autoCalibrate</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Autocalibration completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Autocalibration support is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_CALIBRATE_FAILED</td><td>Failed to perform auto-calibrate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf8ca05a2a44468130ef9e97aee6e9f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8ca05a2a44468130ef9e97aee6e9f66">&#9670;&nbsp;</a></span>R_OSPI_B_RowLoad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_OSPI_B_RowLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>row_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads a row into the page buffer on devices which support row addressing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_ctrl</td><td>Pointer to a driver handle. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">row_index</td><td>Index of the row in the OSPI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Page transaction succeeded. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ARGUMENT</td><td>Invalid argument. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Row addressing support is not enabled </td></tr>
    <tr><td class="paramname">FSP_ERR_DEVICE_BUSY</td><td>On going asynchronous operation or the device in in XiP mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafd7b272b5cd5d961d742d681bdc651bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd7b272b5cd5d961d742d681bdc651bc">&#9670;&nbsp;</a></span>R_OSPI_B_RowStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_OSPI_B_RowStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>row_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores (programs) the page buffer to a row on devices which support row addressing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_ctrl</td><td>Pointer to a driver handle. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">row_index</td><td>Index of the row in the OSPI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Page transaction succeeded. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ARGUMENT</td><td>Invalid argument. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Row addressing support is not enabled </td></tr>
    <tr><td class="paramname">FSP_ERR_DEVICE_BUSY</td><td>On going asynchronous operation or the device in in XiP mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga215959cccab9f53a2516920ed0182dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga215959cccab9f53a2516920ed0182dfc">&#9670;&nbsp;</a></span>R_OSPI_B_DOTF_Configure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_OSPI_B_DOTF_Configure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___o_s_p_i___b.html#structospi__b__dotf__cfg__t">ospi_b_dotf_cfg_t</a> *const&#160;</td>
          <td class="paramname"><em>p_dotf_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure DOTF</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_ctrl</td><td>Pointer to OSPI specific control structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_dotf_cfg</td><td>Pointer to DOTF configuration structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>DOTF enabled successfully </td></tr>
    <tr><td class="paramname">FSP_ERR_CRYPTO_SCE_KEY_SET_FAIL</td><td>Key initialization failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CRYPTO_SCE_FAIL</td><td>Key wrapping failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ARGUMENT</td><td>Invalid key type argument. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>DOTF support is not enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v6.1.0 User's Manual Copyright  (2025) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
