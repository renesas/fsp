<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: General PWM Timer (r_gpt)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v0.8.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___g_p_t.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">General PWM Timer (r_gpt)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1e6af74d7faaf735f5847a34121eff71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga1e6af74d7faaf735f5847a34121eff71">R_GPT_Stop</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:ga1e6af74d7faaf735f5847a34121eff71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2769f9fda49613246bc84dba41aa4863"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga2769f9fda49613246bc84dba41aa4863">R_GPT_Start</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:ga2769f9fda49613246bc84dba41aa4863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5eb494add3d40775dbc48c5498e15a3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga5eb494add3d40775dbc48c5498e15a3a">R_GPT_Reset</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:ga5eb494add3d40775dbc48c5498e15a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e14d15c781e316e640c280b4983be28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga6e14d15c781e316e640c280b4983be28">R_GPT_Enable</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:ga6e14d15c781e316e640c280b4983be28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga338dd3c38477ee40c90c13f3a4c9ecfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga338dd3c38477ee40c90c13f3a4c9ecfd">R_GPT_Disable</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:ga338dd3c38477ee40c90c13f3a4c9ecfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafedbfd8bc3f534d06969588ff10a351b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#gafedbfd8bc3f534d06969588ff10a351b">R_GPT_PeriodSet</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl, uint32_t const period_counts)</td></tr>
<tr class="separator:gafedbfd8bc3f534d06969588ff10a351b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad14bacf6fb7fce88f3e877160be529ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#gad14bacf6fb7fce88f3e877160be529ea">R_GPT_DutyCycleSet</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl, uint32_t const duty_cycle_counts, uint32_t const pin)</td></tr>
<tr class="separator:gad14bacf6fb7fce88f3e877160be529ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca62ac33de2c05918b0fc359aeaebd97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#gaca62ac33de2c05918b0fc359aeaebd97">R_GPT_InfoGet</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl, <a class="el" href="group___t_i_m_e_r___a_p_i.html#structtimer__info__t">timer_info_t</a> *const p_info)</td></tr>
<tr class="separator:gaca62ac33de2c05918b0fc359aeaebd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6234faf45320a83382d7ea1923a2c49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#gaa6234faf45320a83382d7ea1923a2c49">R_GPT_StatusGet</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl, <a class="el" href="group___t_i_m_e_r___a_p_i.html#structtimer__status__t">timer_status_t</a> *const p_status)</td></tr>
<tr class="separator:gaa6234faf45320a83382d7ea1923a2c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fc5d6a737a00948802e2bb77fbe8d8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga2fc5d6a737a00948802e2bb77fbe8d8c">R_GPT_Close</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:ga2fc5d6a737a00948802e2bb77fbe8d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84b2245c5b4ed778ea2b220470ce69c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga84b2245c5b4ed778ea2b220470ce69c5">R_GPT_VersionGet</a> (<a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#unionfsp__version__t">fsp_version_t</a> *const p_version)</td></tr>
<tr class="separator:ga84b2245c5b4ed778ea2b220470ce69c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the GPT32 and GPT16 peripherals on RA MCUs. This module implements the <a class="el" href="group___t_i_m_e_r___a_p_i.html">Timer Interface</a>. </p>
<h1><a class="anchor" id="r-gpt-overview"></a>
Overview</h1>
<p>The GPT module can be used to count events, measure external input signals, generate a periodic interrupt, or output a periodic or PWM signal to a GTIOC pin.</p>
<p>This module supports the GPT peripherals GPT32EH, GPT32E, GPT32, and GPT16. GPT16 is a 16-bit timer. The other peripherals (GPT32EH, GPT32E, and GPT32) are 32-bit timers. The 32-bit timers are all treated the same in this module from the API perspective.</p>
<h2><a class="anchor" id="r-gpt-features"></a>
Features</h2>
<p>The GPT module has the following features:</p><ul>
<li>Supports periodic mode, one-shot mode, and PWM mode.</li>
<li>Supports count source of PCLK, GTETRG pins, GTIOC pins, or ELC events.<a class="anchor" id="um_gpt_event_count_gtetrg"></a><a class="anchor" id="um_gpt_event_count_gtioc"></a><a class="anchor" id="um_gpt_event_count_elc"></a></li>
<li>Supports debounce filter on GTIOC pins.<a class="anchor" id="um_timer_input_debounce_filter"></a></li>
<li>Signal can be output to a pin.<a class="anchor" id="um_timer_output_disable"></a></li>
<li>Configurable period (counts per timer cycle).</li>
<li>Configurable duty cycle in PWM mode.</li>
<li>Supports runtime reconfiguration of period.</li>
<li>Supports runtime reconfiguration of duty cycle in PWM mode.</li>
<li>APIs are provided to start, stop, and reset the counter.</li>
<li>APIs are provided to get the current period, source clock frequency, and count direction.<a class="anchor" id="um_timer_count_direction"></a></li>
<li>APIs are provided to get the current timer status and counter value.<a class="anchor" id="um_timer_status"></a></li>
<li>Supports start, stop, clear, count up, count down, and capture by external sources from GTETRG pins, GTIOC pins, or ELC events.<a class="anchor" id="um_gpt_count_down_external_source"></a><a class="anchor" id="um_gpt_start_external_source"></a><a class="anchor" id="um_gpt_stop_external_source"></a><a class="anchor" id="um_gpt_clear_external_source"></a> </li>
</ul>
<h2><a class="anchor" id="r-gpt-selecting-a-timer"></a>
Selecting a Timer</h2>
<p>RA MCUs have two timer peripherals: the General PWM Timer (GPT) and the Asynchronous General Purpose Timer (AGT). When selecting between them, consider these factors:</p>
<table class="doxtable">
<tr>
<th></th><th>GPT </th><th>AGT  </th></tr>
<tr>
<td>Low Power Modes</td><td>The GPT can operate in sleep mode.</td><td>The AGT can operate in all low power modes. </td></tr>
<tr>
<td>Available Channels</td><td>The number of GPT channels is device specific. All currently supported MCUs have at least 7 GPT channels.</td><td>All MCUs have 2 AGT channels. </td></tr>
<tr>
<td>Timer Resolution</td><td>All MCUs have at least one 32-bit GPT timer.</td><td>The AGT timers are 16-bit timers. </td></tr>
<tr>
<td>Clock Source</td><td>The GPT runs off PCLKD with a configurable divider up to 1024. It can also be configured to count ELC events or external pulses.</td><td>The AGT runs off PCLKB, LOCO, or subclock. </td></tr>
</table>
<h1><a class="anchor" id="r-gpt-configuration"></a>
Configuration</h1>
<p><a class="anchor" id="um_timer_multiple_channels"></a> <h2>Build Time Configurations for r_gpt</h2>
The following build time configurations are defined in fsp_cfg/r_gpt_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Description </th></tr>
<tr>
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr>
<td>Pin Output Support</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>If selected code for outputting a waveform to a pin is included in the build. </td></tr>
</table>
 <h2>Configurations for Timer Driver on r_gpt</h2>
This module can be added to the Threads tab from New -&gt; Driver -&gt; Timers -&gt; Timer Driver on r_gpt:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Description </th></tr>
<tr>
<td>General|Name</td><td>Name must be a valid C symbol</td><td>Module name. </td></tr>
<tr>
<td>General|Channel</td><td>Channel number does not exist</td><td>Specify the hardware channel. </td></tr>
<tr>
<td>General|Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Periodic</li>
<li>
One-Shot</li>
<li>
PWM</li>
</ul>
</td><td>Mode selection. Note: One-shot mode is implemented in software. ISR's must be enabled for one shot even if callback is unused. </td></tr>
<tr>
<td>General|Period</td><td>Value must be a non-negative integer less than or equal to 0x40000000000</td><td>Specify the timer period in units selected below. Setting the period to 0x100000000 raw counts results in the maximum period. Set the period to 0x100000000 raw counts for a free running timer or an input capture configuration. The period can be set up to 0x40000000000, which will use a divider of 1024 with the maximum period. </td></tr>
<tr>
<td>General|Period Unit</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Raw Counts</li>
<li>
Nanoseconds</li>
<li>
Microseconds</li>
<li>
Milliseconds</li>
<li>
Seconds</li>
<li>
Hertz</li>
<li>
Kilohertz</li>
</ul>
</td><td>Unit of the period specified above </td></tr>
<tr>
<td>Output|Duty Cycle Percent (only applicable in PWM mode)</td><td>Value must be between 0 and 100</td><td>Specify the timer duty cycle percent. Only used in PWM mode. </td></tr>
<tr>
<td>Output|Duty Cycle Range (only applicable in PWM mode)</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Shortest: 2 PCLK, Longest: (Period - 1) PCLK</li>
<li>
Shortest: 1 PCLK, Longest: (Period - 2) PCLK</li>
</ul>
</td><td>Select the duty cycle range. Due to hardware limitations, one PCLK cycle is added before the output pin toggles after the duty cycle is reached. This extra clock cycle is added to the ON time (if Shortest: 2 PCLK is selected) or the OFF time (if Shortest: 1 PCLK is selected) based on this configuration. </td></tr>
<tr>
<td>Output|GTIOCA Output Enabled</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
True</li>
<li>
False</li>
</ul>
</td><td>Enable the output of GTIOCA on a pin. </td></tr>
<tr>
<td>Output|GTIOCA Stop Level</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Pin Level Low</li>
<li>
Pin Level High</li>
<li>
Pin Level Retained</li>
</ul>
</td><td>Select the behavior of the output pin when the timer is stopped. </td></tr>
<tr>
<td>Output|GTIOCB Output Enabled</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
True</li>
<li>
False</li>
</ul>
</td><td>Enable the output of GTIOCB on a pin. </td></tr>
<tr>
<td>Output|GTIOCB Stop Level</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Pin Level Low</li>
<li>
Pin Level High</li>
<li>
Pin Level Retained</li>
</ul>
</td><td>Select the behavior of the output pin when the timer is stopped. </td></tr>
<tr>
<td>Input|Count Up Source</td><td>MCU Specific Options</td><td>Select external source that will increment the counter. If any count up source is selected, the timer will count the external sources only. It will not count PCLKD cycles. </td></tr>
<tr>
<td>Input|Count Down Source</td><td>MCU Specific Options</td><td>Select external source that will decrement the counter. If any count down source is selected, the timer will count the external sources only. It will not count PCLKD cycles. </td></tr>
<tr>
<td>Input|Start Source</td><td>MCU Specific Options</td><td>Select external source that will start the timer. <br />
<br />
 For pulse width measurement, set the Start Source and the Clear Source to the trigger edge (the edge to start the measurement), and set the Stop Source and Capture Source (either A or B) to the opposite edge (the edge to stop the measurement). <br />
<br />
 For pulse period measurement, set the Start Source, the Clear Source, and the Capture Source (either A or B) to the trigger edge (the edge to start the measurement). </td></tr>
<tr>
<td>Input|Stop Source</td><td>MCU Specific Options</td><td>Select external source that will stop the timer. </td></tr>
<tr>
<td>Input|Clear Source</td><td>MCU Specific Options</td><td>Select external source that will clear the timer. </td></tr>
<tr>
<td>Input|Capture A Source</td><td>MCU Specific Options</td><td>Select external source that will trigger a capture A event. </td></tr>
<tr>
<td>Input|Capture B Source</td><td>MCU Specific Options</td><td>Select external source that will trigger a capture B event. </td></tr>
<tr>
<td>Input|GTIOCA Input Filter</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
No Filter</li>
<li>
Filter PCLKD / 1</li>
<li>
Filter PCLKD / 4</li>
<li>
Filter PCLKD / 16</li>
<li>
Filter PCLKD / 64</li>
</ul>
</td><td>Select the input filter for GTIOCA. </td></tr>
<tr>
<td>Input|GTIOCB Input Filter</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
No Filter</li>
<li>
Filter PCLKD / 1</li>
<li>
Filter PCLKD / 4</li>
<li>
Filter PCLKD / 16</li>
<li>
Filter PCLKD / 64</li>
</ul>
</td><td>Select the input filter for GTIOCB. </td></tr>
<tr>
<td>Interrupts|Callback</td><td>Name must be a valid C symbol</td><td>A user callback function can be specified here. If this callback function is provided, it will be called from the interrupt service routine (ISR) each time the timer period elapses </td></tr>
<tr>
<td>Interrupts|Overflow Interrupt Priority</td><td>MCU Specific Options</td><td>Select the overflow interrupt priority. </td></tr>
<tr>
<td>Interrupts|Capture A Interrupt Priority</td><td>MCU Specific Options</td><td>Select the interrupt priority for capture A. </td></tr>
<tr>
<td>Interrupts|Capture B Interrupt Priority</td><td>MCU Specific Options</td><td>Select the interrupt priority for capture B. </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-gpt-clock-configuration"></a>
Clock Configuration</h2>
<p>The GPT clock is based on the PCLKD frequency. You can set the PCLKD frequency using the clock configurator in the ISDE or using the CGC Interface at run-time.</p>
<h2><a class="anchor" id="r-gpt-pin-configuration"></a>
Pin Configuration</h2>
<p>This module can use GTETRGA, GTETRGB, GTETRGC, GTETRGD, GTIOCA and GTIOCB pins as count sources.</p>
<p>This module can use GTIOCA and GTIOCB pins as output pins for periodic or PWM signals.</p>
<h1><a class="anchor" id="r-gpt-usage_notes"></a>
Usage Notes</h1>
<h2>Maximum Period for GPT32</h2>
<p>The maximum period for a 32-bit GPT is 0x100000000. This number overflows the 32-bit value for <a class="el" href="group___t_i_m_e_r___a_p_i.html#aa892b6997a1972de6a6ebd48e0fb9233" title="Period in raw timer counts. ">timer_cfg_t::period_counts</a>. To configure the timer for the maximum period, set <a class="el" href="group___t_i_m_e_r___a_p_i.html#aa892b6997a1972de6a6ebd48e0fb9233" title="Period in raw timer counts. ">timer_cfg_t::period_counts</a> to 0.</p>
<h2>Updating Period and Duty Cycle</h2>
<p>The period and duty cycle are updated after the next counter overflow after calling <a class="el" href="group___g_p_t.html#gafedbfd8bc3f534d06969588ff10a351b">R_GPT_PeriodSet()</a> or <a class="el" href="group___g_p_t.html#gad14bacf6fb7fce88f3e877160be529ea">R_GPT_DutyCycleSet()</a>. To force them to update before the next counter overflow, call <a class="el" href="group___g_p_t.html#ga5eb494add3d40775dbc48c5498e15a3a">R_GPT_Reset()</a> while the counter is running.</p>
<h2>One-Shot Mode</h2>
<p><a class="anchor" id="um_timer_one_shot_mode"></a> The GPT timer does not support one-shot mode natively. One-shot mode is achieved by stopping the timer in the interrupt service routine before the callback is called. If the interrupt is not serviced before the timer period expires again, the timer generates more than one event. The callback is only called once in this case, but multiple events may be generated if the timer is linked to the <a class="el" href="group___d_t_c.html">Data Transfer Controller (r_dtc)</a>.</p>
<h3>One-Shot Mode Output</h3>
<p><a class="anchor" id="um_timer_one_shot_output"></a> The output waveform in one-shot mode is one PCLKD cycle less than the configured period. The configured period must be at least 2 counts to generate an output pulse.</p>
<p>Examples of one-shot signals that can be generated by this module are shown below:</p>
<div class="image">
<object type="image/svg+xml" data="r_gpt_one_shot_output.svg">r_gpt_one_shot_output.svg</object>
<div class="caption">
GPT One-Shot Output</div></div>
 <h2>Periodic Output</h2>
<p><a class="anchor" id="um_timer_periodic_output"></a> The GTIOC pin toggles twice each time the timer expires in periodic mode. This is achieved by defining a PWM wave at a 50 percent duty cycle so that the period of the resulting square wave (from rising edge to rising edge) matches the period of the GPT timer. Since the periodic output is actually a PWM output, the time at the stop level is one cycle shorter than the time opposite the stop level for odd period values.</p>
<p>Examples of periodic signals that can be generated by this module are shown below:</p>
<div class="image">
<object type="image/svg+xml" data="r_gpt_periodic_output.svg">r_gpt_periodic_output.svg</object>
<div class="caption">
GPT Periodic Output</div></div>
 <h2>PWM Output</h2>
<p><a class="anchor" id="um_timer_pwm_output"></a> This module does not support in phase PWM output. The PWM output signal is high at the beginning of the cycle and low at the end of the cycle. If <a class="el" href="group___g_p_t.html#a92c97688b2a90cca95531955c102945b" title="Shortest PWM signal level. ">gpt_extended_cfg_t::shortest_pwm_signal</a> is set to GPT_SHORTEST_LEVEL_ON, the PWM output signal is low at the beginning of the cycle and high at the end of the cycle.</p>
<p>Examples of PWM signals that can be generated by this module are shown below:</p>
<div class="image">
<object type="image/svg+xml" data="r_gpt_pwm_output.svg">r_gpt_pwm_output.svg</object>
<div class="caption">
GPT PWM Output</div></div>
 <h2>Event Counting</h2>
<p>Event counting can be done by selecting up or down counting sources from GTETRG pins, ELC events, or GTIOC pins. In event counting mode, the GPT counter is not affected by PCLKD.</p>
<dl class="section note"><dt>Note</dt><dd>In event counting mode, the application must call <a class="el" href="group___g_p_t.html#ga2769f9fda49613246bc84dba41aa4863">R_GPT_Start()</a> to enable event counting. The counter will not change after calling <a class="el" href="group___g_p_t.html#ga2769f9fda49613246bc84dba41aa4863">R_GPT_Start()</a> until an event occurs.</dd></dl>
<h2>Pulse Width Measurement</h2>
<p>If the opposite edge occurs before the trigger edge in pulse width measurement, the first capture is invalid (0).</p>
<h2>Pulse Period Measurement</h2>
<p>If the opposite edge occurs before the trigger edge in pulse width measurement, the first capture may be invalid (0).</p>
<h2>Controlling GPT with GTETRG Edges</h2>
<p>The GPT timer can be configured to stop, start, clear, count up, or count down when a GTETRG rising or falling edge occurs.</p>
<dl class="section note"><dt>Note</dt><dd>The GTETRG pins are shared by all GPT channels.</dd>
<dd>
GTETRG pins require POEG to be on (example code for this is provided in GPT Free Running Counter Example). If input filtering is required on the GTETRG pins, that must also be handled outside this module.</dd></dl>
<h2>Controlling GPT with ELC Events</h2>
<p>The GPT timer can be configured to stop, start, clear, count up, or count down when an ELC event occurs.</p>
<dl class="section note"><dt>Note</dt><dd>The configurable ELC GPT sources are shared by all GPT channels.</dd>
<dd>
The event links for the ELC must be configured outside this module.</dd></dl>
<h2>Triggering ELC Events with GPT</h2>
<p>The GPT timer can trigger the start of other peripherals. The <a class="el" href="group___e_l_c.html">Event Link Controller (r_elc)</a> guide provides a list of all available peripherals.</p>
<h2>Enabling External Sources for Start, Stop, Clear, or Capture</h2>
<p><a class="anchor" id="um_timer_enable_disable"></a> <a class="el" href="group___g_p_t.html#ga6e14d15c781e316e640c280b4983be28">R_GPT_Enable()</a> must be called when external sources are used for start, stop, clear, or capture.</p>
<h1><a class="anchor" id="r-gpt-examples"></a>
Examples</h1>
<h2>GPT Basic Example</h2>
<p>This is a basic example of minimal use of the GPT in an application.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> gpt_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#ga97d0a9c1a8fb6b88d1c12756dd8ce2d2">R_GPT_Open</a>(&amp;g_timer0_ctrl, &amp;g_timer0_cfg);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Start the timer. */</span></div><div class="line">    (void) <a class="code" href="group___g_p_t.html#ga2769f9fda49613246bc84dba41aa4863">R_GPT_Start</a>(&amp;g_timer0_ctrl);</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>GPT Callback Example</h2>
<p>This is an example of a timer callback.</p>
<p><a class="anchor" id="um_timer_user_notification_of_events"></a> </p><div class="fragment"><div class="line"></div><div class="line"><span class="comment">/* Example callback called when timer expires. */</span></div><div class="line"><span class="keywordtype">void</span> timer_callback (<a class="code" href="group___t_i_m_e_r___a_p_i.html#structtimer__callback__args__t">timer_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___t_i_m_e_r___a_p_i.html#ggac3bee51f7c9078f794c5ac19522f91ebae310bef0d640f06765c01b4b91a5b84c">TIMER_EVENT_CYCLE_END</a> == p_args-&gt;<a class="code" href="group___t_i_m_e_r___a_p_i.html#a61b9aabfcafc5e362dce56af7ea36bcf">event</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Add application code to be called periodically here. */</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>GPT Free Running Counter Example</h2>
<p><a class="anchor" id="um_timer_reset"></a><a class="anchor" id="um_timer_start"></a><a class="anchor" id="um_timer_stop"></a><a class="anchor" id="um_timer_counter"></a> To use the GPT as a free running counter, select periodic mode and set the the Period to 0xFFFFFFFF for a 32-bit timer or 0xFFFF for a 16-bit timer.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> gpt_counter_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) If event count mode is used to count edges on a GTETRG pin, POEG must be started to use GTETRG.</span></div><div class="line"><span class="comment">     * Reference Note 1 of Table 23.2 &quot;GPT functions&quot; in the RA6M3 manual R01UH0886EJ0100. */</span></div><div class="line">    <a class="code" href="group___b_s_p___m_c_u.html#gaf0a730b79b5bbe76759b6e8efafe2000">R_BSP_MODULE_START</a>(<a class="code" href="group___b_s_p___m_c_u.html#gga7880302f0edd7cc4290c037809975950acfc9bb8ff007a7b82cf4fd845dfce053">FSP_IP_POEG</a>, 0U);</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#ga97d0a9c1a8fb6b88d1c12756dd8ce2d2">R_GPT_Open</a>(&amp;g_timer0_ctrl, &amp;g_timer0_cfg);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    <span class="comment">/* Start the timer. */</span></div><div class="line">    (void) <a class="code" href="group___g_p_t.html#ga2769f9fda49613246bc84dba41aa4863">R_GPT_Start</a>(&amp;g_timer0_ctrl);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Stop the timer. */</span></div><div class="line">    (void) <a class="code" href="group___g_p_t.html#ga1e6af74d7faaf735f5847a34121eff71">R_GPT_Stop</a>(&amp;g_timer0_ctrl);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Read the current counter value. Counter value is in status.counter. */</span></div><div class="line">    <a class="code" href="group___t_i_m_e_r___a_p_i.html#structtimer__status__t">timer_status_t</a> status;</div><div class="line">    (void) <a class="code" href="group___g_p_t.html#gaa6234faf45320a83382d7ea1923a2c49">R_GPT_StatusGet</a>(&amp;g_timer0_ctrl, &amp;status);</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>GPT Input Capture Example</h2>
<p><a class="anchor" id="um_timer_capture_pulse_width"></a><a class="anchor" id="um_timer_capture_pulse_period"></a> This is an example of using the GPT to capture pulse width or pulse period measurements.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">/* Example callback called when a capture occurs. */</span></div><div class="line">uint64_t g_captured_time     = 0U;</div><div class="line">uint32_t g_capture_overflows = 0U;</div><div class="line"><span class="keywordtype">void</span> timer_capture_callback (<a class="code" href="group___t_i_m_e_r___a_p_i.html#structtimer__callback__args__t">timer_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> ((<a class="code" href="group___t_i_m_e_r___a_p_i.html#ggac3bee51f7c9078f794c5ac19522f91eba4bc1252f63147f4a01f7b7ba88afac1d">TIMER_EVENT_CAPTURE_A</a> == p_args-&gt;<a class="code" href="group___t_i_m_e_r___a_p_i.html#a61b9aabfcafc5e362dce56af7ea36bcf">event</a>) || (<a class="code" href="group___t_i_m_e_r___a_p_i.html#ggac3bee51f7c9078f794c5ac19522f91ebab7b635fbf34ede5a3e2f55b5a60ac21b">TIMER_EVENT_CAPTURE_B</a> == p_args-&gt;<a class="code" href="group___t_i_m_e_r___a_p_i.html#a61b9aabfcafc5e362dce56af7ea36bcf">event</a>))</div><div class="line">    {</div><div class="line"></div><div class="line">        <span class="comment">/* (Optional) Get the current period if not known. */</span></div><div class="line">        <a class="code" href="group___t_i_m_e_r___a_p_i.html#structtimer__info__t">timer_info_t</a> info;</div><div class="line">        (void) <a class="code" href="group___g_p_t.html#gaca62ac33de2c05918b0fc359aeaebd97">R_GPT_InfoGet</a>(&amp;g_timer0_ctrl, &amp;info);</div><div class="line">        uint64_t period = info.<a class="code" href="group___t_i_m_e_r___a_p_i.html#a08b897cfbf2d0cefafe8d3abb1afc747">period_counts</a>;</div><div class="line"></div><div class="line">        <span class="comment">/* The maximum period is one more than the maximum 32-bit number, but will be reflected as 0 in</span></div><div class="line"><span class="comment">         * timer_info_t::period_counts. */</span></div><div class="line">        <span class="keywordflow">if</span> (0U == period)</div><div class="line">        {</div><div class="line">            period = UINT32_MAX + 1U;</div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line">        g_captured_time     = (period * g_capture_overflows) + p_args-&gt;capture;</div><div class="line">        g_capture_overflows = 0U;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___t_i_m_e_r___a_p_i.html#ggac3bee51f7c9078f794c5ac19522f91ebae310bef0d640f06765c01b4b91a5b84c">TIMER_EVENT_CYCLE_END</a> == p_args-&gt;<a class="code" href="group___t_i_m_e_r___a_p_i.html#a61b9aabfcafc5e362dce56af7ea36bcf">event</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* An overflow occurred during capture. This must be accounted for at the application layer. */</span></div><div class="line">        g_capture_overflows++;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> gpt_capture_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#ga97d0a9c1a8fb6b88d1c12756dd8ce2d2">R_GPT_Open</a>(&amp;g_timer0_ctrl, &amp;g_timer0_cfg);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Enable captures. Captured values arrive in the interrupt. */</span></div><div class="line">    (void) <a class="code" href="group___g_p_t.html#ga6e14d15c781e316e640c280b4983be28">R_GPT_Enable</a>(&amp;g_timer0_ctrl);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Disable captures. */</span></div><div class="line">    (void) <a class="code" href="group___g_p_t.html#ga338dd3c38477ee40c90c13f3a4c9ecfd">R_GPT_Disable</a>(&amp;g_timer0_ctrl);</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>GPT Period Update Example</h2>
<p><a class="anchor" id="um_timer_period_set"></a><a class="anchor" id="um_timer_clock_frequency"></a> This an example of updating the period.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define GPT_EXAMPLE_MSEC_PER_SEC           (1000)</span></div><div class="line"><span class="preprocessor">#define GPT_EXAMPLE_DESIRED_PERIOD_MSEC    (20)</span></div><div class="line"></div><div class="line"><span class="comment">/* This example shows how to calculate a new period value at runtime. */</span></div><div class="line"><span class="keywordtype">void</span> gpt_period_calculation_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#ga97d0a9c1a8fb6b88d1c12756dd8ce2d2">R_GPT_Open</a>(&amp;g_timer0_ctrl, &amp;g_timer0_cfg);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    <span class="comment">/* Start the timer. */</span></div><div class="line">    (void) <a class="code" href="group___g_p_t.html#ga2769f9fda49613246bc84dba41aa4863">R_GPT_Start</a>(&amp;g_timer0_ctrl);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Get the source clock frequency (in Hz). There are 3 ways to do this in Flex software:</span></div><div class="line"><span class="comment">     *  - If the PCLKD frequency has not changed since reset, the source clock frequency is</span></div><div class="line"><span class="comment">     *    BSP_STARTUP_PCLKD_HZ &gt;&gt; timer_cfg_t::source_div</span></div><div class="line"><span class="comment">     *  - Use the R_GPT_InfoGet function (it accounts for the divider).</span></div><div class="line"><span class="comment">     *  - Calculate the current PCLKD frequency using R_FSP_SystemClockHzGet(FSP_PRIV_CLOCK_PCLKD) and right shift</span></div><div class="line"><span class="comment">     *    by timer_cfg_t::source_div.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * This example uses the 3rd option (R_FSP_SystemClockHzGet).</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    uint32_t pclkd_freq_hz = R_FSP_SystemClockHzGet(FSP_PRIV_CLOCK_PCLKD) &gt;&gt; g_timer0_cfg.source_div;</div><div class="line"></div><div class="line">    <span class="comment">/* Calculate the desired period based on the current clock. Note that this calculation could overflow if the</span></div><div class="line"><span class="comment">     * desired period is larger than UINT32_MAX / pclkd_freq_hz. A cast to uint64_t is used to prevent this. */</span></div><div class="line">    uint32_t period_counts =</div><div class="line">        (uint32_t) (((uint64_t) pclkd_freq_hz * GPT_EXAMPLE_DESIRED_PERIOD_MSEC) / GPT_EXAMPLE_MSEC_PER_SEC);</div><div class="line"></div><div class="line">    <span class="comment">/* Set the calculated period. */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#gafedbfd8bc3f534d06969588ff10a351b">R_GPT_PeriodSet</a>(&amp;g_timer0_ctrl, period_counts);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>GPT Duty Cycle Update Example</h2>
<p><a class="anchor" id="um_timer_duty_cycle_set"></a> This an example of updating the duty cycle.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define GPT_EXAMPLE_DESIRED_DUTY_CYCLE_PERCENT    (25)</span></div><div class="line"><span class="preprocessor">#define GPT_EXAMPLE_MAX_PERCENT                   (100)</span></div><div class="line"></div><div class="line"><span class="comment">/* This example shows how to calculate a new duty cycle value at runtime. */</span></div><div class="line"><span class="keywordtype">void</span> gpt_duty_cycle_calculation_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#ga97d0a9c1a8fb6b88d1c12756dd8ce2d2">R_GPT_Open</a>(&amp;g_timer0_ctrl, &amp;g_timer0_cfg);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    <span class="comment">/* Start the timer. */</span></div><div class="line">    (void) <a class="code" href="group___g_p_t.html#ga2769f9fda49613246bc84dba41aa4863">R_GPT_Start</a>(&amp;g_timer0_ctrl);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Get the current period setting. */</span></div><div class="line">    <a class="code" href="group___t_i_m_e_r___a_p_i.html#structtimer__info__t">timer_info_t</a> info;</div><div class="line">    (void) <a class="code" href="group___g_p_t.html#gaca62ac33de2c05918b0fc359aeaebd97">R_GPT_InfoGet</a>(&amp;g_timer0_ctrl, &amp;info);</div><div class="line">    uint32_t current_period_counts = info.<a class="code" href="group___t_i_m_e_r___a_p_i.html#a08b897cfbf2d0cefafe8d3abb1afc747">period_counts</a>;</div><div class="line"></div><div class="line">    <span class="comment">/* Calculate the desired duty cycle based on the current period. Note that if the period could be larger than</span></div><div class="line"><span class="comment">     * UINT32_MAX / 100, this calculation could overflow. A cast to uint64_t is used to prevent this. The cast is</span></div><div class="line"><span class="comment">     * not required for 16-bit timers. */</span></div><div class="line">    uint32_t duty_cycle_counts =</div><div class="line">        (uint32_t) (((uint64_t) current_period_counts * GPT_EXAMPLE_DESIRED_DUTY_CYCLE_PERCENT) /</div><div class="line">                    GPT_EXAMPLE_MAX_PERCENT);</div><div class="line"></div><div class="line">    <span class="comment">/* Set the calculated duty cycle. */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#gad14bacf6fb7fce88f3e877160be529ea">R_GPT_DutyCycleSet</a>(&amp;g_timer0_ctrl, duty_cycle_counts, <a class="code" href="group___g_p_t.html#ggaabd4a03d16b1b4254cc44c7779f44c60aebd74a7b9507fb082ec4cce60ebe9369">GPT_IO_PIN_GTIOCB</a>);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structgpt__output__pin__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#structgpt__output__pin__t">gpt_output_pin_t</a></td></tr>
<tr class="separator:structgpt__output__pin__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structgpt__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#structgpt__instance__ctrl__t">gpt_instance_ctrl_t</a></td></tr>
<tr class="separator:structgpt__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structgpt__extended__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#structgpt__extended__cfg__t">gpt_extended_cfg_t</a></td></tr>
<tr class="separator:structgpt__extended__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaabd4a03d16b1b4254cc44c7779f44c60"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#gaabd4a03d16b1b4254cc44c7779f44c60">gpt_io_pin_t</a> </td></tr>
<tr class="separator:gaabd4a03d16b1b4254cc44c7779f44c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga454c639e426428470ce78115af5d3648"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga454c639e426428470ce78115af5d3648">gpt_pin_level_t</a> </td></tr>
<tr class="separator:ga454c639e426428470ce78115af5d3648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0579e86d3b176b4e3c7da752874649a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#gab0579e86d3b176b4e3c7da752874649a">gpt_shortest_level_t</a> </td></tr>
<tr class="separator:gab0579e86d3b176b4e3c7da752874649a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1457c9c1f178fff4dd1558832db196a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#gaa1457c9c1f178fff4dd1558832db196a">gpt_source_t</a> </td></tr>
<tr class="separator:gaa1457c9c1f178fff4dd1558832db196a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4781e2b42b2ef339318ea0a70b250cd5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga4781e2b42b2ef339318ea0a70b250cd5">gpt_capture_filter_t</a> </td></tr>
<tr class="separator:ga4781e2b42b2ef339318ea0a70b250cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97d0a9c1a8fb6b88d1c12756dd8ce2d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga97d0a9c1a8fb6b88d1c12756dd8ce2d2">R_GPT_Open</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl, <a class="el" href="group___t_i_m_e_r___a_p_i.html#structtimer__cfg__t">timer_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:ga97d0a9c1a8fb6b88d1c12756dd8ce2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structgpt__output__pin__t" id="structgpt__output__pin__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structgpt__output__pin__t">&#9670;&nbsp;</a></span>gpt_output_pin_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct gpt_output_pin_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Configurations for output pins. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a5f0b69cc2d3cfe89baefcf348563df21"></a>bool</td>
<td class="fieldname">
output_enabled</td>
<td class="fielddoc">
Set to true to enable output, false to disable output. </td></tr>
<tr><td class="fieldtype">
<a id="a5805853871548d015520f71f3ab00e93"></a><a class="el" href="group___g_p_t.html#ga454c639e426428470ce78115af5d3648">gpt_pin_level_t</a></td>
<td class="fieldname">
stop_level</td>
<td class="fielddoc">
Select a stop level from <a class="el" href="group___g_p_t.html#ga454c639e426428470ce78115af5d3648">gpt_pin_level_t</a>. </td></tr>
</table>

</div>
</div>
<a name="structgpt__instance__ctrl__t" id="structgpt__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structgpt__instance__ctrl__t">&#9670;&nbsp;</a></span>gpt_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct gpt_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Channel control block. DO NOT INITIALIZE. Initialization occurs when <a class="el" href="group___t_i_m_e_r___a_p_i.html#af49a90087a53c8019d642a3f7abaa8ad">timer_api_t::open</a> is called. </p>
</div>
</div>
</div>
<a name="structgpt__extended__cfg__t" id="structgpt__extended__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structgpt__extended__cfg__t">&#9670;&nbsp;</a></span>gpt_extended_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct gpt_extended_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>GPT extension configures the output pins for GPT. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ad323c6db6a695028d2926dfbf0a0dda8"></a><a class="el" href="group___g_p_t.html#structgpt__output__pin__t">gpt_output_pin_t</a></td>
<td class="fieldname">
gtioca</td>
<td class="fielddoc">
Configuration for GPT I/O pin A. </td></tr>
<tr><td class="fieldtype">
<a id="a78476af74debd54ee8394dd0aa6d2505"></a><a class="el" href="group___g_p_t.html#structgpt__output__pin__t">gpt_output_pin_t</a></td>
<td class="fieldname">
gtiocb</td>
<td class="fielddoc">
Configuration for GPT I/O pin B. </td></tr>
<tr><td class="fieldtype">
<a id="a92c97688b2a90cca95531955c102945b"></a><a class="el" href="group___g_p_t.html#gab0579e86d3b176b4e3c7da752874649a">gpt_shortest_level_t</a></td>
<td class="fieldname">
shortest_pwm_signal</td>
<td class="fielddoc">
Shortest PWM signal level. </td></tr>
<tr><td class="fieldtype">
<a id="a3b894424ab45e17d02938de9c211911a"></a><a class="el" href="group___g_p_t.html#gaa1457c9c1f178fff4dd1558832db196a">gpt_source_t</a></td>
<td class="fieldname">
start_source</td>
<td class="fielddoc">
Event sources that trigger the timer to start. </td></tr>
<tr><td class="fieldtype">
<a id="a41333514ba7ccb2b4e2d6475a51dcc26"></a><a class="el" href="group___g_p_t.html#gaa1457c9c1f178fff4dd1558832db196a">gpt_source_t</a></td>
<td class="fieldname">
stop_source</td>
<td class="fielddoc">
Event sources that trigger the timer to stop. </td></tr>
<tr><td class="fieldtype">
<a id="ad5614740946c3c06e1633d369d08f5c3"></a><a class="el" href="group___g_p_t.html#gaa1457c9c1f178fff4dd1558832db196a">gpt_source_t</a></td>
<td class="fieldname">
clear_source</td>
<td class="fielddoc">
Event sources that trigger the timer to clear. </td></tr>
<tr><td class="fieldtype">
<a id="aad7e19c30d43b6d0f88943c27e9afa4c"></a><a class="el" href="group___g_p_t.html#gaa1457c9c1f178fff4dd1558832db196a">gpt_source_t</a></td>
<td class="fieldname">
capture_a_source</td>
<td class="fielddoc">
Event sources that trigger capture of GTIOCA. </td></tr>
<tr><td class="fieldtype">
<a id="aca22811f5aebe0ee236214b53f9f6bbd"></a><a class="el" href="group___g_p_t.html#gaa1457c9c1f178fff4dd1558832db196a">gpt_source_t</a></td>
<td class="fieldname">
capture_b_source</td>
<td class="fielddoc">
Event sources that trigger capture of GTIOCB. </td></tr>
<tr><td class="fieldtype">
<a id="ae96b1fce9515b779078f947aa3885618"></a><a class="el" href="group___g_p_t.html#gaa1457c9c1f178fff4dd1558832db196a">gpt_source_t</a></td>
<td class="fieldname">
count_up_source</td>
<td class="fielddoc">
<p>Event sources that trigger a single up count. If GPT_SOURCE_NONE is selected for both count_up_source and count_down_source, then the timer count source is PCLK. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a2ecf880963c441f20c3c8a2ac7a854ea"></a><a class="el" href="group___g_p_t.html#gaa1457c9c1f178fff4dd1558832db196a">gpt_source_t</a></td>
<td class="fieldname">
count_down_source</td>
<td class="fielddoc">
<p>Event sources that trigger a single down count. If GPT_SOURCE_NONE is selected for both count_up_source and count_down_source, then the timer count source is PCLK. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac51fec5c943957b888ffa9be91f33615"></a><a class="el" href="group___g_p_t.html#ga4781e2b42b2ef339318ea0a70b250cd5">gpt_capture_filter_t</a></td>
<td class="fieldname">
capture_filter_gtioca</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a3ba662387c753b54c5509f283ff1857e"></a><a class="el" href="group___g_p_t.html#ga4781e2b42b2ef339318ea0a70b250cd5">gpt_capture_filter_t</a></td>
<td class="fieldname">
capture_filter_gtiocb</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a7e5402bac34e2c3d3006b68ee0b8ab2a"></a>uint8_t</td>
<td class="fieldname">
capture_a_ipl</td>
<td class="fielddoc">
Capture A interrupt priority. </td></tr>
<tr><td class="fieldtype">
<a id="aae4ebebdd346531add1c9ce3bee52106"></a>uint8_t</td>
<td class="fieldname">
capture_b_ipl</td>
<td class="fielddoc">
Capture B interrupt priority. </td></tr>
<tr><td class="fieldtype">
<a id="a630c77adb426ddddb5eac8b974fd7c85"></a>IRQn_Type</td>
<td class="fieldname">
capture_a_irq</td>
<td class="fielddoc">
Capture A interrupt. </td></tr>
<tr><td class="fieldtype">
<a id="a22eb63abdf43064c9c83d81287c67c88"></a>IRQn_Type</td>
<td class="fieldname">
capture_b_irq</td>
<td class="fielddoc">
Capture B interrupt. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaabd4a03d16b1b4254cc44c7779f44c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabd4a03d16b1b4254cc44c7779f44c60">&#9670;&nbsp;</a></span>gpt_io_pin_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___g_p_t.html#gaabd4a03d16b1b4254cc44c7779f44c60">gpt_io_pin_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Input/Output pins, used to select which duty cycle to update in <a class="el" href="group___g_p_t.html#gad14bacf6fb7fce88f3e877160be529ea">R_GPT_DutyCycleSet()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaabd4a03d16b1b4254cc44c7779f44c60aec2d2c471241869efb57a9a48a5d0eda"></a>GPT_IO_PIN_GTIOCA&#160;</td><td class="fielddoc"><p>GTIOCA. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaabd4a03d16b1b4254cc44c7779f44c60aebd74a7b9507fb082ec4cce60ebe9369"></a>GPT_IO_PIN_GTIOCB&#160;</td><td class="fielddoc"><p>GTIOCB. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga454c639e426428470ce78115af5d3648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga454c639e426428470ce78115af5d3648">&#9670;&nbsp;</a></span>gpt_pin_level_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___g_p_t.html#ga454c639e426428470ce78115af5d3648">gpt_pin_level_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Level of GPT pin </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga454c639e426428470ce78115af5d3648a3270f1165e7a86c5b12eecb9501390f4"></a>GPT_PIN_LEVEL_LOW&#160;</td><td class="fielddoc"><p>Pin level low. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga454c639e426428470ce78115af5d3648adc8ebfd0f787322b884ca5d087b3a6a3"></a>GPT_PIN_LEVEL_HIGH&#160;</td><td class="fielddoc"><p>Pin level high. </p>
</td></tr>
</table>

</div>
</div>
<a id="gab0579e86d3b176b4e3c7da752874649a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0579e86d3b176b4e3c7da752874649a">&#9670;&nbsp;</a></span>gpt_shortest_level_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___g_p_t.html#gab0579e86d3b176b4e3c7da752874649a">gpt_shortest_level_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>GPT PWM shortest pin level </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab0579e86d3b176b4e3c7da752874649aa7683eae71f5ed5ec08473c3b4d0292b3"></a>GPT_SHORTEST_LEVEL_OFF&#160;</td><td class="fielddoc"><p>1 extra PCLK in ON time. Minimum ON time will be limited to 2 PCLK raw counts. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab0579e86d3b176b4e3c7da752874649aa0c89d7bd6d02245ba1077b51f91037be"></a>GPT_SHORTEST_LEVEL_ON&#160;</td><td class="fielddoc"><p>1 extra PCLK in OFF time. Minimum ON time will be limited to 1 PCLK raw counts. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaa1457c9c1f178fff4dd1558832db196a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1457c9c1f178fff4dd1558832db196a">&#9670;&nbsp;</a></span>gpt_source_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___g_p_t.html#gaa1457c9c1f178fff4dd1558832db196a">gpt_source_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sources can be used to start the timer, stop the timer, count up, or count down. These enumerations represent a bitmask. Multiple sources can be ORed together. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aae376db52803d52361481b2384c3a3bd8"></a>GPT_SOURCE_NONE&#160;</td><td class="fielddoc"><p>No active event sources. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aa2ea3ebb2e30c10d0c5c087e198175220"></a>GPT_SOURCE_GTETRGA_RISING&#160;</td><td class="fielddoc"><p>Action performed on GTETRGA rising edge. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aab4c7fdaf7cfdd2d3730525965e68c982"></a>GPT_SOURCE_GTETRGA_FALLING&#160;</td><td class="fielddoc"><p>Action performed on GTETRGA falling edge. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aa7af2b58b26be8c9b04ec5c31fdd66bab"></a>GPT_SOURCE_GTETRGB_RISING&#160;</td><td class="fielddoc"><p>Action performed on GTETRGB rising edge. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aad01f879dc9132b0e05827cc7f4219a81"></a>GPT_SOURCE_GTETRGB_FALLING&#160;</td><td class="fielddoc"><p>Action performed on GTETRGB falling edge. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aa5daee2c8037bdc04a019192efdd8af09"></a>GPT_SOURCE_GTETRGC_RISING&#160;</td><td class="fielddoc"><p>Action performed on GTETRGC rising edge. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aaceecdd0276a5d1591246c1a2a294ddd3"></a>GPT_SOURCE_GTETRGC_FALLING&#160;</td><td class="fielddoc"><p>Action performed on GTETRGC falling edge. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aaaa3e97349fb24f8ba0a431392a92f95e"></a>GPT_SOURCE_GTETRGD_RISING&#160;</td><td class="fielddoc"><p>Action performed on GTETRGB rising edge. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aad6f7ad7ca2dce583089104f23e27ed2c"></a>GPT_SOURCE_GTETRGD_FALLING&#160;</td><td class="fielddoc"><p>Action performed on GTETRGB falling edge. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aa1435f9ba57da19cfc255ea6f64ea7853"></a>GPT_SOURCE_GTIOCA_RISING_WHILE_GTIOCB_LOW&#160;</td><td class="fielddoc"><p>Action performed when GTIOCA input rises while GTIOCB is low. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aaa03328ca033b8043537b813ecabe1c50"></a>GPT_SOURCE_GTIOCA_RISING_WHILE_GTIOCB_HIGH&#160;</td><td class="fielddoc"><p>Action performed when GTIOCA input rises while GTIOCB is high. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aa58b8714367e4bb5ec9eb6902c98fdb2e"></a>GPT_SOURCE_GTIOCA_FALLING_WHILE_GTIOCB_LOW&#160;</td><td class="fielddoc"><p>Action performed when GTIOCA input falls while GTIOCB is low. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aab844b52adc17cebabf04603fa993f176"></a>GPT_SOURCE_GTIOCA_FALLING_WHILE_GTIOCB_HIGH&#160;</td><td class="fielddoc"><p>Action performed when GTIOCA input falls while GTIOCB is high. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aa4b546eda998208d87d6da5d0ad2f927a"></a>GPT_SOURCE_GTIOCB_RISING_WHILE_GTIOCA_LOW&#160;</td><td class="fielddoc"><p>Action performed when GTIOCB input rises while GTIOCA is low. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aaf6245811e4016299ba0acf0575389ba6"></a>GPT_SOURCE_GTIOCB_RISING_WHILE_GTIOCA_HIGH&#160;</td><td class="fielddoc"><p>Action performed when GTIOCB input rises while GTIOCA is high. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aa3c659f3a22223a65ffdc96524249eec7"></a>GPT_SOURCE_GTIOCB_FALLING_WHILE_GTIOCA_LOW&#160;</td><td class="fielddoc"><p>Action performed when GTIOCB input falls while GTIOCA is low. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aa037a151c14fea20ef0530f5a995f99e5"></a>GPT_SOURCE_GTIOCB_FALLING_WHILE_GTIOCA_HIGH&#160;</td><td class="fielddoc"><p>Action performed when GTIOCB input falls while GTIOCA is high. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aa8a81917a5ac9b747df42b174e5ae1ee6"></a>GPT_SOURCE_GPT_A&#160;</td><td class="fielddoc"><p>Action performed on ELC GPTA event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aa7b3ab8f76f2a808dbace3ede3e3faf06"></a>GPT_SOURCE_GPT_B&#160;</td><td class="fielddoc"><p>Action performed on ELC GPTB event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aaeb63eaa38e2640b48259ddf029c27f54"></a>GPT_SOURCE_GPT_C&#160;</td><td class="fielddoc"><p>Action performed on ELC GPTC event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aaa23869f7d7ae4b5d82dac3d2301959b9"></a>GPT_SOURCE_GPT_D&#160;</td><td class="fielddoc"><p>Action performed on ELC GPTD event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aaff70b0b5e755028cd77f859abb16fe06"></a>GPT_SOURCE_GPT_E&#160;</td><td class="fielddoc"><p>Action performed on ELC GPTE event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aa010a99aa6c4e838ac1bce47abcbe38e5"></a>GPT_SOURCE_GPT_F&#160;</td><td class="fielddoc"><p>Action performed on ELC GPTF event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aa51db9e1734d93f834b00868a9246db95"></a>GPT_SOURCE_GPT_G&#160;</td><td class="fielddoc"><p>Action performed on ELC GPTG event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aa19df9d1f4ee5e610a74642fc14a212a3"></a>GPT_SOURCE_GPT_H&#160;</td><td class="fielddoc"><p>Action performed on ELC GPTH event. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga4781e2b42b2ef339318ea0a70b250cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4781e2b42b2ef339318ea0a70b250cd5">&#9670;&nbsp;</a></span>gpt_capture_filter_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___g_p_t.html#ga4781e2b42b2ef339318ea0a70b250cd5">gpt_capture_filter_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Input capture signal noise filter (debounce) setting. Only available for input signals GTIOCxA and GTIOCxB. The noise filter samples the external signal at intervals of the PCLK divided by one of the values. When 3 consecutive samples are at the same level (high or low), then that level is passed on as the observed state of the signal. See "Noise Filter Function" in the hardware manual, GPT section. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4781e2b42b2ef339318ea0a70b250cd5a9b2d993dbb736347b473101f14c1fde6"></a>GPT_CAPTURE_FILTER_NONE&#160;</td><td class="fielddoc"><p>None - no filtering. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4781e2b42b2ef339318ea0a70b250cd5adb3e7f4af05808c080e29f22c6b71c3a"></a>GPT_CAPTURE_FILTER_PCLKD_DIV_1&#160;</td><td class="fielddoc"><p>PCLK/1 - fast sampling. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4781e2b42b2ef339318ea0a70b250cd5adbeb79df335efd366023ec9118407de8"></a>GPT_CAPTURE_FILTER_PCLKD_DIV_4&#160;</td><td class="fielddoc"><p>PCLK/4. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4781e2b42b2ef339318ea0a70b250cd5a4058fd8fd2af5d30c572dd8aacc5ae9a"></a>GPT_CAPTURE_FILTER_PCLKD_DIV_16&#160;</td><td class="fielddoc"><p>PCLK/16. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4781e2b42b2ef339318ea0a70b250cd5a37769ce411256b3c4ec01cb1eed5a825"></a>GPT_CAPTURE_FILTER_PCLKD_DIV_64&#160;</td><td class="fielddoc"><p>PCLK/64 - slow sampling. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga97d0a9c1a8fb6b88d1c12756dd8ce2d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97d0a9c1a8fb6b88d1c12756dd8ce2d2">&#9670;&nbsp;</a></span>R_GPT_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#structtimer__cfg__t">timer_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the timer module and applies configurations. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#af49a90087a53c8019d642a3f7abaa8ad">timer_api_t::open</a>.</p>
<p>GPT hardware does not support one-shot functionality natively. When using one-shot mode, the timer will be stopped in an ISR after the requested period has elapsed.</p>
<p>The GPT implementation of the general timer can accept a <a class="el" href="group___g_p_t.html#structgpt__extended__cfg__t">gpt_extended_cfg_t</a> extension parameter.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#ga97d0a9c1a8fb6b88d1c12756dd8ce2d2">R_GPT_Open</a>(&amp;g_timer0_ctrl, &amp;g_timer0_cfg);</div><div class="line">    handle_error(err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Initialization was successful and timer has started. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required input pointer is NULL or the source divider is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Module is already open. </td></tr>
    <tr><td class="paramname">FSP_ERR_IRQ_BSP_DISABLED</td><td><a class="el" href="group___t_i_m_e_r___a_p_i.html#a9519afc7ea8aec3aaf1eb787b39cc97c" title="Select enumerated value from timer_mode_t. ">timer_cfg_t::mode</a> is <a class="el" href="group___t_i_m_e_r___a_p_i.html#gga6d4cd64aed5c0009ac26803efc9c13b2a140f07675d67258a7ca9a95a9a793e3a" title="Timer will stop after delay periods. ">TIMER_MODE_ONE_SHOT</a> or <a class="el" href="group___t_i_m_e_r___a_p_i.html#a7d2f434f07723a53b504751e9e5ac540">timer_cfg_t::p_callback</a> is not NULL, but ISR is not enabled. ISR must be enabled to use one-shot mode or callback. </td></tr>
    <tr><td class="paramname">FSP_ERR_IP_CHANNEL_NOT_PRESENT</td><td>The channel requested in the p_cfg parameter is not available on this device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1e6af74d7faaf735f5847a34121eff71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e6af74d7faaf735f5847a34121eff71">&#9670;&nbsp;</a></span>R_GPT_Stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops timer. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#aed0139dbf5102e39719ddbc51f16a21e">timer_api_t::stop</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Stop the timer. */</span></div><div class="line">    (void) <a class="code" href="group___g_p_t.html#ga1e6af74d7faaf735f5847a34121eff71">R_GPT_Stop</a>(&amp;g_timer0_ctrl);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Timer successfully stopped. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2769f9fda49613246bc84dba41aa4863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2769f9fda49613246bc84dba41aa4863">&#9670;&nbsp;</a></span>R_GPT_Start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts timer. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#afcc7e85d01c3d7dc0c6e09954631f47f">timer_api_t::start</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Start the timer. */</span></div><div class="line">    (void) <a class="code" href="group___g_p_t.html#ga2769f9fda49613246bc84dba41aa4863">R_GPT_Start</a>(&amp;g_timer0_ctrl);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Timer successfully started. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5eb494add3d40775dbc48c5498e15a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5eb494add3d40775dbc48c5498e15a3a">&#9670;&nbsp;</a></span>R_GPT_Reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the counter value to 0. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#ab1c62157861ef1ea8393bb3cafd72102">timer_api_t::reset</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function also updates to the new period if no counter overflow has occurred since the last call to <a class="el" href="group___g_p_t.html#gafedbfd8bc3f534d06969588ff10a351b">R_GPT_PeriodSet()</a>.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Counter value written successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6e14d15c781e316e640c280b4983be28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e14d15c781e316e640c280b4983be28">&#9670;&nbsp;</a></span>R_GPT_Enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_Enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables external event triggers that start, stop, clear, or capture the counter. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#a13cb48d1657a9eda3380c111ba33aa2a">timer_api_t::enable</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Enable captures. Captured values arrive in the interrupt. */</span></div><div class="line">    (void) <a class="code" href="group___g_p_t.html#ga6e14d15c781e316e640c280b4983be28">R_GPT_Enable</a>(&amp;g_timer0_ctrl);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>External events successfully enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga338dd3c38477ee40c90c13f3a4c9ecfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga338dd3c38477ee40c90c13f3a4c9ecfd">&#9670;&nbsp;</a></span>R_GPT_Disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_Disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables external event triggers that start, stop, clear, or capture the counter. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#a8b69fad02aee5d83b941ed02fca18aca">timer_api_t::disable</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The timer could be running after <a class="el" href="group___g_p_t.html#ga338dd3c38477ee40c90c13f3a4c9ecfd">R_GPT_Disable()</a>. To ensure it is stopped, call <a class="el" href="group___g_p_t.html#ga1e6af74d7faaf735f5847a34121eff71">R_GPT_Stop()</a>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Disable captures. */</span></div><div class="line">    (void) <a class="code" href="group___g_p_t.html#ga338dd3c38477ee40c90c13f3a4c9ecfd">R_GPT_Disable</a>(&amp;g_timer0_ctrl);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>External events successfully disabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafedbfd8bc3f534d06969588ff10a351b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafedbfd8bc3f534d06969588ff10a351b">&#9670;&nbsp;</a></span>R_GPT_PeriodSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_PeriodSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>period_counts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets period value provided. If the timer is running, the period will be updated after the next counter overflow. If the timer is stopped, this function resets the counter and updates the period. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#ae9aad84a01ccd7ce0039ed491faeff19">timer_api_t::periodSet</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>If periodic output is used, the duty cycle buffer registers are updated after the period buffer register. If this function is called while the timer is running and a GPT overflow occurs during processing, the duty cycle will not be the desired 50% duty cycle until the counter overflow after processing completes.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Get the source clock frequency (in Hz). There are 3 ways to do this in Flex software:</span></div><div class="line"><span class="comment">     *  - If the PCLKD frequency has not changed since reset, the source clock frequency is</span></div><div class="line"><span class="comment">     *    BSP_STARTUP_PCLKD_HZ &gt;&gt; timer_cfg_t::source_div</span></div><div class="line"><span class="comment">     *  - Use the R_GPT_InfoGet function (it accounts for the divider).</span></div><div class="line"><span class="comment">     *  - Calculate the current PCLKD frequency using R_FSP_SystemClockHzGet(FSP_PRIV_CLOCK_PCLKD) and right shift</span></div><div class="line"><span class="comment">     *    by timer_cfg_t::source_div.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * This example uses the 3rd option (R_FSP_SystemClockHzGet).</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    uint32_t pclkd_freq_hz = R_FSP_SystemClockHzGet(FSP_PRIV_CLOCK_PCLKD) &gt;&gt; g_timer0_cfg.source_div;</div><div class="line"></div><div class="line">    <span class="comment">/* Calculate the desired period based on the current clock. Note that this calculation could overflow if the</span></div><div class="line"><span class="comment">     * desired period is larger than UINT32_MAX / pclkd_freq_hz. A cast to uint64_t is used to prevent this. */</span></div><div class="line">    uint32_t period_counts =</div><div class="line">        (uint32_t) (((uint64_t) pclkd_freq_hz * GPT_EXAMPLE_DESIRED_PERIOD_MSEC) / GPT_EXAMPLE_MSEC_PER_SEC);</div><div class="line"></div><div class="line">    <span class="comment">/* Set the calculated period. */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#gafedbfd8bc3f534d06969588ff10a351b">R_GPT_PeriodSet</a>(&amp;g_timer0_ctrl, period_counts);</div><div class="line">    handle_error(err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Period value written successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad14bacf6fb7fce88f3e877160be529ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad14bacf6fb7fce88f3e877160be529ea">&#9670;&nbsp;</a></span>R_GPT_DutyCycleSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_DutyCycleSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>duty_cycle_counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>pin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets duty cycle on requested pin. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#a819ed0740ca426ace0d6b67e16c6ddfc">timer_api_t::dutyCycleSet</a>.</p>
<p>Duty cycle is updated in the buffer register. The updated duty cycle is reflected after the next cycle end (counter overflow).</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Get the current period setting. */</span></div><div class="line">    <a class="code" href="group___t_i_m_e_r___a_p_i.html#structtimer__info__t">timer_info_t</a> info;</div><div class="line">    (void) <a class="code" href="group___g_p_t.html#gaca62ac33de2c05918b0fc359aeaebd97">R_GPT_InfoGet</a>(&amp;g_timer0_ctrl, &amp;info);</div><div class="line">    uint32_t current_period_counts = info.<a class="code" href="group___t_i_m_e_r___a_p_i.html#a08b897cfbf2d0cefafe8d3abb1afc747">period_counts</a>;</div><div class="line"></div><div class="line">    <span class="comment">/* Calculate the desired duty cycle based on the current period. Note that if the period could be larger than</span></div><div class="line"><span class="comment">     * UINT32_MAX / 100, this calculation could overflow. A cast to uint64_t is used to prevent this. The cast is</span></div><div class="line"><span class="comment">     * not required for 16-bit timers. */</span></div><div class="line">    uint32_t duty_cycle_counts =</div><div class="line">        (uint32_t) (((uint64_t) current_period_counts * GPT_EXAMPLE_DESIRED_DUTY_CYCLE_PERCENT) /</div><div class="line">                    GPT_EXAMPLE_MAX_PERCENT);</div><div class="line"></div><div class="line">    <span class="comment">/* Set the calculated duty cycle. */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#gad14bacf6fb7fce88f3e877160be529ea">R_GPT_DutyCycleSet</a>(&amp;g_timer0_ctrl, duty_cycle_counts, <a class="code" href="group___g_p_t.html#ggaabd4a03d16b1b4254cc44c7779f44c60aebd74a7b9507fb082ec4cce60ebe9369">GPT_IO_PIN_GTIOCB</a>);</div><div class="line">    handle_error(err);</div><div class="line"></div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_ctrl</td><td>Pointer to instance control block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">duty_cycle_counts</td><td>Duty cycle to set in counts. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pin</td><td>Use gpt_io_pin_t to select GPT_IO_PIN_GTIOCA or GPT_IO_PIN_GTIOCB</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Duty cycle updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl was NULL or the pin is not one of gpt_io_pin_t </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance is not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ARGUMENT</td><td>Duty cycle is larger than period. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>GPT_CFG_OUTPUT_SUPPORT_ENABLE is 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaca62ac33de2c05918b0fc359aeaebd97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca62ac33de2c05918b0fc359aeaebd97">&#9670;&nbsp;</a></span>R_GPT_InfoGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_InfoGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#structtimer__info__t">timer_info_t</a> *const&#160;</td>
          <td class="paramname"><em>p_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get timer information and store it in provided pointer p_info. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#aeaea79f26305c493566e4b45ae9e294c">timer_api_t::infoGet</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">        <span class="comment">/* (Optional) Get the current period if not known. */</span></div><div class="line">        <a class="code" href="group___t_i_m_e_r___a_p_i.html#structtimer__info__t">timer_info_t</a> info;</div><div class="line">        (void) <a class="code" href="group___g_p_t.html#gaca62ac33de2c05918b0fc359aeaebd97">R_GPT_InfoGet</a>(&amp;g_timer0_ctrl, &amp;info);</div><div class="line">        uint64_t period = info.<a class="code" href="group___t_i_m_e_r___a_p_i.html#a08b897cfbf2d0cefafe8d3abb1afc747">period_counts</a>;</div><div class="line"></div><div class="line">        <span class="comment">/* The maximum period is one more than the maximum 32-bit number, but will be reflected as 0 in</span></div><div class="line"><span class="comment">         * timer_info_t::period_counts. */</span></div><div class="line">        <span class="keywordflow">if</span> (0U == period)</div><div class="line">        {</div><div class="line">            period = UINT32_MAX + 1U;</div><div class="line">        }</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Period, count direction, frequency, and ELC event written to caller's structure successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl or p_info was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa6234faf45320a83382d7ea1923a2c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6234faf45320a83382d7ea1923a2c49">&#9670;&nbsp;</a></span>R_GPT_StatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_StatusGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#structtimer__status__t">timer_status_t</a> *const&#160;</td>
          <td class="paramname"><em>p_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get current timer status and store it in provided pointer p_status. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#a11321e8dde7c33a4e6835a1bf64f7689">timer_api_t::statusGet</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Read the current counter value. Counter value is in status.counter. */</span></div><div class="line">    <a class="code" href="group___t_i_m_e_r___a_p_i.html#structtimer__status__t">timer_status_t</a> status;</div><div class="line">    (void) <a class="code" href="group___g_p_t.html#gaa6234faf45320a83382d7ea1923a2c49">R_GPT_StatusGet</a>(&amp;g_timer0_ctrl, &amp;status);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Current timer state and counter value set successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl or p_status was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2fc5d6a737a00948802e2bb77fbe8d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fc5d6a737a00948802e2bb77fbe8d8c">&#9670;&nbsp;</a></span>R_GPT_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops counter, disables output pins, and clears internal driver data. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#a9e8b8140010a28082aedd758390fac97">timer_api_t::close</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful close. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga84b2245c5b4ed778ea2b220470ce69c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84b2245c5b4ed778ea2b220470ce69c5">&#9670;&nbsp;</a></span>R_GPT_VersionGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_VersionGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#unionfsp__version__t">fsp_version_t</a> *const&#160;</td>
          <td class="paramname"><em>p_version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets driver version based on compile time macros. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#afd486e90a2c3214bdf156ab47560d236">timer_api_t::versionGet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Version stored in p_version. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_version was NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP v0.8.0 User's Manual Rev0.80 R11UM0137EU0080 Copyright  (2019) Renesas Electronics Corporation. All Rights Reserved.</li>
    <li class="footer">Generated by FSP v0.8.0
    </li>
  </ul>
</div>
</body>
</html>
