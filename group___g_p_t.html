<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: Timer, General PWM (r_gpt)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
    $(document).ready(function() {
        $("tr.tree_lvl_1").nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
		$("tr.tree_lvl_1").data("expanded","0");
		$("tr.tree_lvl_2").data("expanded","0");
		$("tr.tree_lvl_3").data("expanded","0");
		$("tr.tree_lvl_4").data("expanded","0");
		$("tr.tree_lvl_5").data("expanded","0");
        $("tr.tree_lvl_1").click(function() {
		    var lvl_1_is_open = $(this).data("expanded");
		    if (lvl_1_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2, tr.tree_lvl_1_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_2").click(function() {
		    var lvl_2_is_open = $(this).data("expanded");
		    if (lvl_2_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3, tr.tree_lvl_2_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_3").click(function() {
		    var lvl_3_is_open = $(this).data("expanded");
		    if (lvl_3_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_3_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_4").click(function() {
		    var lvl_4_is_open = $(this).data("expanded");
		    if (lvl_4_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5, tr.tree_lvl_4_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_5").click(function() {
		    var lvl_5_is_open = $(this).data("expanded");
		    if (lvl_5_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4_item,tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
     });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v6.2.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">

    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text">
      </span>
      <span class="right">
          &nbsp;
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___g_p_t.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body.
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len));
            }
          }
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element.
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">Timer, General PWM (r_gpt)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___t_i_m_e_r_s___m_o_d_u_l_e_s.html">Timers</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga97d0a9c1a8fb6b88d1c12756dd8ce2d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga97d0a9c1a8fb6b88d1c12756dd8ce2d2">R_GPT_Open</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl, <a class="el" href="group___t_i_m_e_r___a_p_i.html#structtimer__cfg__t">timer_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:ga97d0a9c1a8fb6b88d1c12756dd8ce2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e6af74d7faaf735f5847a34121eff71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga1e6af74d7faaf735f5847a34121eff71">R_GPT_Stop</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:ga1e6af74d7faaf735f5847a34121eff71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2769f9fda49613246bc84dba41aa4863"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga2769f9fda49613246bc84dba41aa4863">R_GPT_Start</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:ga2769f9fda49613246bc84dba41aa4863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5eb494add3d40775dbc48c5498e15a3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga5eb494add3d40775dbc48c5498e15a3a">R_GPT_Reset</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:ga5eb494add3d40775dbc48c5498e15a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e14d15c781e316e640c280b4983be28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga6e14d15c781e316e640c280b4983be28">R_GPT_Enable</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:ga6e14d15c781e316e640c280b4983be28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga338dd3c38477ee40c90c13f3a4c9ecfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga338dd3c38477ee40c90c13f3a4c9ecfd">R_GPT_Disable</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:ga338dd3c38477ee40c90c13f3a4c9ecfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafedbfd8bc3f534d06969588ff10a351b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#gafedbfd8bc3f534d06969588ff10a351b">R_GPT_PeriodSet</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl, uint32_t const period_counts)</td></tr>
<tr class="separator:gafedbfd8bc3f534d06969588ff10a351b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad14bacf6fb7fce88f3e877160be529ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#gad14bacf6fb7fce88f3e877160be529ea">R_GPT_DutyCycleSet</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl, uint32_t const duty_cycle_counts, uint32_t const pin)</td></tr>
<tr class="separator:gad14bacf6fb7fce88f3e877160be529ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga834be7c118edc5297a74cf588a447106"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga834be7c118edc5297a74cf588a447106">R_GPT_CompareMatchSet</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl, uint32_t const compare_match_value, <a class="el" href="group___t_i_m_e_r___a_p_i.html#gaf5f22f5e34fe6ea640fd6a1c7e864cd9">timer_compare_match_t</a> const match_channel)</td></tr>
<tr class="separator:ga834be7c118edc5297a74cf588a447106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca62ac33de2c05918b0fc359aeaebd97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#gaca62ac33de2c05918b0fc359aeaebd97">R_GPT_InfoGet</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl, <a class="el" href="group___t_i_m_e_r___a_p_i.html#structtimer__info__t">timer_info_t</a> *const p_info)</td></tr>
<tr class="separator:gaca62ac33de2c05918b0fc359aeaebd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6234faf45320a83382d7ea1923a2c49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#gaa6234faf45320a83382d7ea1923a2c49">R_GPT_StatusGet</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl, <a class="el" href="group___t_i_m_e_r___a_p_i.html#structtimer__status__t">timer_status_t</a> *const p_status)</td></tr>
<tr class="separator:gaa6234faf45320a83382d7ea1923a2c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4126139a9c63f1963ffdaea6cc697fe9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga4126139a9c63f1963ffdaea6cc697fe9">R_GPT_CounterSet</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl, uint32_t counter)</td></tr>
<tr class="separator:ga4126139a9c63f1963ffdaea6cc697fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e6638508ec1d5441713195c877bb7a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga0e6638508ec1d5441713195c877bb7a7">R_GPT_OutputEnable</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl, <a class="el" href="group___g_p_t.html#gaabd4a03d16b1b4254cc44c7779f44c60">gpt_io_pin_t</a> pin)</td></tr>
<tr class="separator:ga0e6638508ec1d5441713195c877bb7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae204e5d6c9305923e98724005dcdf03d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#gae204e5d6c9305923e98724005dcdf03d">R_GPT_OutputDisable</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl, <a class="el" href="group___g_p_t.html#gaabd4a03d16b1b4254cc44c7779f44c60">gpt_io_pin_t</a> pin)</td></tr>
<tr class="separator:gae204e5d6c9305923e98724005dcdf03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga311c91c55f20338f7082fa4369e7c80f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga311c91c55f20338f7082fa4369e7c80f">R_GPT_AdcTriggerSet</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl, <a class="el" href="group___g_p_t.html#ga2a838fffcbafd97778bbe3ffbfbf54b1">gpt_adc_compare_match_t</a> which_compare_match, uint32_t compare_match_value)</td></tr>
<tr class="separator:ga311c91c55f20338f7082fa4369e7c80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff2d30ece9bd30b5a9cc2117623834c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#gaff2d30ece9bd30b5a9cc2117623834c6">R_GPT_PwmOutputDelaySet</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl, <a class="el" href="group___g_p_t.html#ga6a1389fe5c3bef2301d294b88263628e">gpt_pwm_output_delay_edge_t</a> edge, <a class="el" href="group___g_p_t.html#ga749be81f99469c5607a684976d9ae374">gpt_pwm_output_delay_setting_t</a> delay_setting, uint32_t const pin)</td></tr>
<tr class="separator:gaff2d30ece9bd30b5a9cc2117623834c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cd6772e3474cf80cb49b562b11c269e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga6cd6772e3474cf80cb49b562b11c269e">R_GPT_CallbackSet</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_api_ctrl, void(*p_callback)(<a class="el" href="group___t_i_m_e_r___a_p_i.html#structtimer__callback__args__t">timer_callback_args_t</a> *), void *const p_context, <a class="el" href="group___t_i_m_e_r___a_p_i.html#structtimer__callback__args__t">timer_callback_args_t</a> *const p_callback_memory)</td></tr>
<tr class="separator:ga6cd6772e3474cf80cb49b562b11c269e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fc5d6a737a00948802e2bb77fbe8d8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga2fc5d6a737a00948802e2bb77fbe8d8c">R_GPT_Close</a> (<a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:ga2fc5d6a737a00948802e2bb77fbe8d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada982ef1873ca00147f9692b42aba8f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#gada982ef1873ca00147f9692b42aba8f0">R_GPT_PwmOutputDelayInitialize</a> ()</td></tr>
<tr class="separator:gada982ef1873ca00147f9692b42aba8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the GPT32 and GPT16 peripherals on RA MCUs. This module implements the <a class="el" href="group___t_i_m_e_r___a_p_i.html">Timer Interface</a>. </p>
<h1><a class="anchor" id="r-gpt-overview"></a>
Overview</h1>
<p>The GPT module can be used to count events, measure external input signals, generate a periodic interrupt, or output a periodic or PWM signal to a GTIOC pin.</p>
<p>This module supports the GPT peripherals GPT32EH, GPT32E, GPT32, and GPT16. GPT16 is a 16-bit timer. The other peripherals (GPT32EH, GPT32E, and GPT32) are 32-bit timers. The 32-bit timers are all treated the same in this module from the API perspective.</p>
<h2><a class="anchor" id="r-gpt-features"></a>
Features</h2>
<p>The GPT module has the following features:</p><ul>
<li>Supports periodic mode, one-shot mode, and PWM mode.</li>
<li>Supports count source of PCLK, GTETRG pins, GTIOC pins, or ELC events.<a class="anchor" id="um_gpt_event_count_gtetrg"></a><a class="anchor" id="um_gpt_event_count_gtioc"></a><a class="anchor" id="um_gpt_event_count_elc"></a></li>
<li>Supports debounce filter on GTIOC pins.<a class="anchor" id="um_timer_input_debounce_filter"></a></li>
<li>Signal can be output to a pin.<a class="anchor" id="um_timer_output_disable"></a></li>
<li>Configurable period (counts per timer cycle).</li>
<li>Configurable duty cycle in PWM mode.</li>
<li>Supports runtime reconfiguration of period.</li>
<li>Supports runtime reconfiguration of duty cycle in PWM mode.</li>
<li>Supports runtime reconfiguration of compare match value.</li>
<li>APIs are provided to start, stop, and reset the counter.</li>
<li>APIs are provided to get the current period, source clock frequency, and count direction.<a class="anchor" id="um_timer_count_direction"></a></li>
<li>APIs are provided to get the current timer status and counter value.<a class="anchor" id="um_timer_status"></a></li>
<li>Supports start, stop, clear, count up, count down, and capture by external sources from GTETRG pins, GTIOC pins, or ELC events.<a class="anchor" id="um_gpt_count_down_external_source"></a><a class="anchor" id="um_gpt_start_external_source"></a><a class="anchor" id="um_gpt_stop_external_source"></a><a class="anchor" id="um_gpt_clear_external_source"></a></li>
<li>Supports symmetric and asymmetric PWM waveform generation.<a class="anchor" id="um_gpt_symmetric_pwm"></a><a class="anchor" id="um_gpt_asymmetric_pwm"></a><a class="anchor" id="um_gpt_pwm_mode3"></a></li>
<li>Supports One shot synchronous pulse waveform generation.<a class="anchor" id="um_gpt_one_shot_pulse_mode"></a></li>
<li>Supports automatic addition of dead time.<a class="anchor" id="um_gpt_pwm_dead_time"></a></li>
<li>Supports generating ELC events to start an ADC scan at a compare match value (see <a class="el" href="group___e_l_c.html">Event Link Controller (r_elc)</a>) and updating the compare match value.<a class="anchor" id="um_gpt_adc_trigger"></a><a class="anchor" id="um_gpt_adc_trigger_update"></a></li>
<li>Supports linking with a POEG channel to automatically disable GPT output when an error condition is detected.<a class="anchor" id="um_gpt_poeg_link"></a></li>
<li>Supports setting the counter value while the timer is stopped.<a class="anchor" id="um_gpt_counter_set"></a></li>
<li>Supports enabling and disabling output pins.<a class="anchor" id="um_gpt_output_disable"></a><a class="anchor" id="um_gpt_output_enable"></a></li>
<li>Supports skipping up to seven overflow/underflow (crest/trough) interrupts at a time<a class="anchor" id="um_gpt_interrupt_skip"></a></li>
<li>Supports generating custom PWM waveforms by configuring the pin's output level at each compare match and cycle end.<a class="anchor" id="um_gpt_custom_waveform"></a></li>
<li>Supports GTIOCnA and GTIOCnB input/output polarity control.<a class="anchor" id="um_gpt_GTIOC_polarity_control"></a> </li>
</ul>
<h2><a class="anchor" id="r-gpt-selecting-a-timer"></a>
Selecting a Timer</h2>
<p>RA MCUs have two timer peripherals: the General PWM Timer (GPT) and the Asynchronous General Purpose Timer (AGT). When selecting between them, consider these factors:</p>
<table class="doxtable">
<tr>
<th></th><th>GPT </th><th>AGT  </th></tr>
<tr>
<td>Low Power Modes</td><td>The GPT can operate in sleep mode.</td><td>The AGT can operate in all low power modes. </td></tr>
<tr>
<td>Available Channels</td><td>The number of GPT channels is device specific. All currently supported MCUs have at least 7 GPT channels.</td><td>All MCUs have 2 AGT channels. </td></tr>
<tr>
<td>Timer Resolution</td><td>All MCUs have at least one 32-bit GPT timer.</td><td>The AGT timers are 16-bit timers. </td></tr>
<tr>
<td>Clock Source</td><td>The GPT runs off PCLKD with a configurable divider up to 1024. It can also be configured to count ELC events or external pulses.</td><td>The AGT runs off PCLKB, LOCO, or subclock. </td></tr>
</table>
<h1><a class="anchor" id="r-gpt-configuration"></a>
Configuration</h1>
<p><a class="anchor" id="um_timer_multiple_channels"></a> <h2>Build Time Configurations for r_gpt</h2>
The following build time configurations are defined in fsp_cfg/r_gpt_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr class="tree_none">
<td>Pin Output Support</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
<li>
Enabled with Extra Features</li>
</ul>
</td><td>Disabled </td><td>Enables or disables support for outputting PWM waveforms on GTIOCx pins. The "Enabled with Extra Features" option enables support for Triangle wave modes and also enables the features located in the "Extra Features" section of each module instance. </td></tr>
<tr class="tree_none">
<td>Write Protect Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>If selected write protection is applied to all GPT channels. </td></tr>
</table>
 <h2>Configurations for Timers &gt; Timer, General PWM (r_gpt)</h2>
This module can be added to the Stacks tab via New Stack &gt; Timers &gt; Timer, General PWM (r_gpt). Non-secure callable guard functions can be generated for this module by right clicking the module in the RA Configuration tool and checking the "Non-secure Callable" box.<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> General  </td></tr>
<tr class="tree_lvl_2">
<td class="tree_lvl_2" colspan="4"><span class="chevron-collapsed"></span> General &gt; Compare Match  </td></tr>
<tr class="tree_lvl_3">
<td class="tree_lvl_3" colspan="4"><span class="chevron-collapsed"></span> General &gt; Compare Match &gt; Compare Match A  </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Status</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td></td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Compare match value</td><td>Value must be a non-negative integer less than or equal to 0x40000000000</td><td>0 </td><td>Specify the compare match A value in units that selected in Period Unit section. </td></tr>
<tr class="tree_lvl_3">
<td class="tree_lvl_3" colspan="4"><span class="chevron-collapsed"></span> General &gt; Compare Match &gt; Compare Match B  </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Status</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td></td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Compare match value</td><td>Value must be a non-negative integer less than or equal to 0x40000000000</td><td>0 </td><td>Specify the compare match B value in units that selected in Period Unit section. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Name</td><td>Name must be a valid C symbol</td><td>g_timer0 </td><td>Module name. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Channel</td><td>Enter the supported Channel number</td><td>0 </td><td>Specify the hardware channel. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Periodic</li>
<li>
One-Shot</li>
<li>
One-Shot Pulse</li>
<li>
Saw-wave PWM</li>
<li>
Triangle-wave PWM (symmetric, Mode 1)</li>
<li>
Triangle-wave PWM (asymmetric, Mode 2)</li>
<li>
Triangle-wave PWM (asymmetric, Mode 3)</li>
</ul>
</td><td>Periodic </td><td>Mode selection.<br />
Periodic: Generates periodic interrupts or square waves.<br />
One-shot: Generate a single interrupt or a pulse wave. Note: One-shot mode is implemented in software. ISRs must be enabled for one-shot even if callback is unused.<br />
One-Shot Pulse: Counter performs saw-wave operation with fixed buffer operation.<br />
Saw-wave PWM: Generates basic saw-wave PWM waveforms.<br />
Triangle-wave PWM (symmetric, Mode 1): Generates symmetric PWM waveforms with duty cycle determined by compare match set with 32-bit transfer during a crest event and updated at the next trough with single or double buffer operation.<br />
Triangle-wave PWM (asymmetric, Mode 2): Generates asymmetric PWM waveforms with duty cycle determined by compare match set with 32-bit transfer during a crest/trough event and updated at the next trough/crest.<br />
Triangle-wave PWM (asymmetric, Mode 3): Generates PWM waveforms with duty cycle determined by compare match set with 64-bit transfer during a crest interrupt and updated at the next trough with fixed buffer operation. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Period</td><td>Value must be a non-negative integer less than or equal to 0x40000000000</td><td>0x10000 </td><td>Specify the timer period in units selected below. Set the period to 0x100000000 (32-bit) or 0x10000 (16-bit) raw counts for a free running timer or an input capture configuration. The period can be set up to 0x40000000000 (32-bit) or 0x4000000 (16-bit) which will use a divider of 1024 with the maximum period.<br />
<br />
If the requested period cannot be achieved, the settings with the largest possible period that is less than or equal to the requested period are used. The theoretical calculated period is printed in a comment in the generated <a class="el" href="group___t_i_m_e_r___a_p_i.html#structtimer__cfg__t">timer_cfg_t</a> structure. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Period Unit</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Raw Counts</li>
<li>
Nanoseconds</li>
<li>
Microseconds</li>
<li>
Milliseconds</li>
<li>
Seconds</li>
<li>
Hertz</li>
<li>
Kilohertz</li>
</ul>
</td><td>Raw Counts </td><td>Unit of the period specified above </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Output  </td></tr>
<tr class="tree_lvl_2">
<td class="tree_lvl_2" colspan="4"><span class="chevron-collapsed"></span> Output &gt; Custom Waveform  </td></tr>
<tr class="tree_lvl_3">
<td class="tree_lvl_3" colspan="4"><span class="chevron-collapsed"></span> Output &gt; Custom Waveform &gt; GTIOA  </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Initial Output Level</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Pin Level Low</li>
<li>
Pin Level High</li>
</ul>
</td><td>Pin Level Low </td><td>Set the initial output level of GTIOCxA. </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Cycle End Output Level</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Pin Level Retain</li>
<li>
Pin Level Low</li>
<li>
Pin Level High</li>
<li>
Pin Level Toggle</li>
</ul>
</td><td>Pin Level Retain </td><td>Set the output level of GTIOCxA at cycle end. </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Compare Match Output Level</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Pin Level Retain</li>
<li>
Pin Level Low</li>
<li>
Pin Level High</li>
<li>
Pin Level Toggle</li>
</ul>
</td><td>Pin Level Retain </td><td>Set the output level of GTIOCxA at compare match. </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Retain Output Level at Count Stop</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>Retain the current GTIOxA output level when counting is stopped. </td></tr>
<tr class="tree_lvl_3">
<td class="tree_lvl_3" colspan="4"><span class="chevron-collapsed"></span> Output &gt; Custom Waveform &gt; GTIOB  </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Initial Output Level</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Pin Level Low</li>
<li>
Pin Level High</li>
</ul>
</td><td>Pin Level Low </td><td>Set the initial output level of GTIOCxB. </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Cycle End Output Level</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Pin Level Retain</li>
<li>
Pin Level Low</li>
<li>
Pin Level High</li>
<li>
Pin Level Toggle</li>
</ul>
</td><td>Pin Level Retain </td><td>Set the output level of GTIOCxB at cycle end. </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Compare Match Output Level</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Pin Level Retain</li>
<li>
Pin Level Low</li>
<li>
Pin Level High</li>
<li>
Pin Level Toggle</li>
</ul>
</td><td>Pin Level Retain </td><td>Set the output level of GTIOCxB at compare match. </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">Retain Output Level at Count Stop</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>Retain the current GTIOxB output level when counting is stopped. </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Custom Waveform Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>Enable custom waveform configuration. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Duty Cycle Percent (only applicable in PWM mode)</td><td>Value must be between 0 and 100</td><td>50 </td><td>Specify the timer duty cycle percent. Only used in PWM mode. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">GTIOCA Output Enabled</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
True</li>
<li>
False</li>
</ul>
</td><td>False </td><td>Enable the output of GTIOCA on a pin. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">GTIOCA Stop Level</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Pin Level Low</li>
<li>
Pin Level High</li>
</ul>
</td><td>Pin Level Low </td><td>Select the behavior of the output pin when the timer is stopped. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">GTIOCB Output Enabled</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
True</li>
<li>
False</li>
</ul>
</td><td>False </td><td>Enable the output of GTIOCB on a pin. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">GTIOCB Stop Level</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Pin Level Low</li>
<li>
Pin Level High</li>
</ul>
</td><td>Pin Level Low </td><td>Select the behavior of the output pin when the timer is stopped. </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Input  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Count Up Source</td><td>MCU Specific Options</td><td></td><td>Select external source that will increment the counter. If any count up source is selected, the timer will count the external sources only. It will not count PCLKD cycles. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Count Down Source</td><td>MCU Specific Options</td><td></td><td>Select external source that will decrement the counter. If any count down source is selected, the timer will count the external sources only. It will not count PCLKD cycles. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Start Source</td><td>MCU Specific Options</td><td></td><td>Select external source that will start the timer. <br />
<br />
 For pulse width measurement, set the Start Source and the Clear Source to the trigger edge (the edge to start the measurement), and set the Stop Source and Capture Source (either A or B) to the opposite edge (the edge to stop the measurement). <br />
<br />
 For pulse period measurement, set the Start Source, the Clear Source, and the Capture Source (either A or B) to the trigger edge (the edge to start the measurement). </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Stop Source</td><td>MCU Specific Options</td><td></td><td>Select external source that will stop the timer. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Clear Source</td><td>MCU Specific Options</td><td></td><td>Select external source that will clear the timer. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Capture A Source</td><td>MCU Specific Options</td><td></td><td>Select external source that will trigger a capture A event. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Capture B Source</td><td>MCU Specific Options</td><td></td><td>Select external source that will trigger a capture B event. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Noise Filter A Sampling Clock Select</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
No Filter</li>
<li>
Filter PCLKD / 1</li>
<li>
Filter PCLKD / 4</li>
<li>
Filter PCLKD / 16</li>
<li>
Filter PCLKD / 64</li>
</ul>
</td><td>No Filter </td><td>Select the input filter for GTIOCA. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Noise Filter B Sampling Clock Select</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
No Filter</li>
<li>
Filter PCLKD / 1</li>
<li>
Filter PCLKD / 4</li>
<li>
Filter PCLKD / 16</li>
<li>
Filter PCLKD / 64</li>
</ul>
</td><td>No Filter </td><td>Select the input filter for GTIOCB. </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Pin Polarity  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">GTIOCnA Polarity</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Normal</li>
<li>
Inverted</li>
</ul>
</td><td>Normal </td><td>Input/output polarity control for GTIOCnA pin. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">GTIOCnB Polarity</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Normal</li>
<li>
Inverted</li>
</ul>
</td><td>Normal </td><td>Input/output polarity control for GTIOCnB pin. </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Interrupts  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Callback</td><td>Name must be a valid C symbol</td><td>NULL </td><td>A user callback function can be specified here. If this callback function is provided, it will be called from the interrupt service routine (ISR) each time the timer period elapses </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Overflow/Crest Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select the overflow interrupt priority. This is the crest interrupt for triangle-wave PWM. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Capture/Compare match A Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select the interrupt priority for Capture/Compare match A. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Capture/Compare match B Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select the interrupt priority for Capture/Compare match B. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Underflow/Trough Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select the interrupt priority for the trough interrupt (triangle-wave PWM only). </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Extra Features  </td></tr>
<tr class="tree_lvl_2">
<td class="tree_lvl_2" colspan="4"><span class="chevron-collapsed"></span> Extra Features &gt; Output Disable  </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">POEG Link</td><td>MCU Specific Options</td><td></td><td>Select which POEG to link this GPT channel to. </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Output Disable POEG Trigger</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Dead Time Error</li>
<li>
GTIOCA and GTIOCB High Level</li>
<li>
GTIOCA and GTIOCB Low Level</li>
</ul>
</td><td></td><td>Select which errors send an output disable trigger to POEG. Dead time error is only available GPT channels that have GTINTAD.GRPDTE. </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">GTIOCA Disable Setting</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disable Prohibited</li>
<li>
Set Hi Z</li>
<li>
Level Low</li>
<li>
Level High</li>
</ul>
</td><td>Disable Prohibited </td><td>Select the disable setting for GTIOCA. </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">GTIOCB Disable Setting</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disable Prohibited</li>
<li>
Set Hi Z</li>
<li>
Level Low</li>
<li>
Level High</li>
</ul>
</td><td>Disable Prohibited </td><td>Select the disable setting for GTIOCB. </td></tr>
<tr class="tree_lvl_2">
<td class="tree_lvl_2" colspan="4"><span class="chevron-collapsed"></span> Extra Features &gt; ADC Trigger  </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Start Event Trigger (Channels with GTINTAD only)</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Trigger Event A/D Converter Start Request A During Up Counting</li>
<li>
Trigger Event A/D Converter Start Request A During Down Counting</li>
<li>
Trigger Event A/D Converter Start Request B During Up Counting</li>
<li>
Trigger Event A/D Converter Start Request B During Down Counting</li>
</ul>
</td><td></td><td>Select which A/D converter start request interrupts to generate and at which point in the cycle to generate them. </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">ADC A Compare Match (Raw Counts)</td><td>Must be a valid non-negative integer with a maximum configurable value of 4294967295 (0xffffffff).</td><td>0 </td><td>Select the compare match value that generates a GPTn AD TRIG A event. </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">ADC B Compare Match (Raw Counts)</td><td>Must be a valid non-negative integer with a maximum configurable value of 4294967295 (0xffffffff).</td><td>0 </td><td>Select the compare match value that generates a GPTn AD TRIG B event. </td></tr>
<tr class="tree_lvl_2">
<td class="tree_lvl_2" colspan="4"><span class="chevron-collapsed"></span> Extra Features &gt; Dead Time (Value range varies with Channel)  </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Dead Time Count Up (Raw Counts)</td><td>Must be a valid non-negative integer with a maximum configurable value of 4294967295 (0xffffffff).</td><td>0 </td><td>Select the dead time to apply during up counting. This value also applies during down counting for channels that do not have GTDVD. The dead time count up value can be set up to 0xffffffff (32-bit) or 0xffff (16-bit). </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Dead Time Count Down (Raw Counts) (Channels with GTDVD only)</td><td>Must be a valid non-negative integer with a maximum configurable value of 4294967295 (0xffffffff).</td><td>0 </td><td>Select the dead time to apply during down counting. The dead time count down value can be set up to 0xffffffff (32-bit) or 0xffff (16-bit). </td></tr>
<tr class="tree_lvl_2">
<td class="tree_lvl_2" colspan="4"><span class="chevron-collapsed"></span> Extra Features &gt; Interrupt Skipping (Channels with GTITC only)  </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Interrupt to Count</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
None</li>
<li>
Overflow and Underflow (sawtooth)</li>
<li>
Crest (triangle)</li>
<li>
Trough (triangle)</li>
</ul>
</td><td>None </td><td>Select the count source for interrupt skipping. The interrupt skip counter increments after each source event. All crest/overflow and trough/underflow interrupts are skipped when the interrupt skip counter is non-zero. </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Interrupt Skip Count</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
0</li>
<li>
1</li>
<li>
2</li>
<li>
3</li>
<li>
4</li>
<li>
5</li>
<li>
6</li>
<li>
7</li>
</ul>
</td><td>0 </td><td>Select the number of interrupts to skip. </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Skip ADC Events</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
None</li>
<li>
ADC A Compare Match</li>
<li>
ADC B Compare Match</li>
<li>
ADC A and B Compare Match</li>
</ul>
</td><td>None </td><td>Select ADC events to suppress when the interrupt skip count is not zero. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Extra Features</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Select whether to enable extra features on this channel. </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-gpt-clock-configuration"></a>
Clock Configuration</h2>
<p>The GPT clock is based on the PCLKD frequency. You can set the PCLKD frequency using the <b>Clocks</b> tab of the RA Configuration editor or by using the CGC Interface at run-time.</p>
<h2><a class="anchor" id="r-gpt-pin-configuration"></a>
Pin Configuration</h2>
<p>This module can use GTETRGA, GTETRGB, GTETRGC, GTETRGD, GTIOCA and GTIOCB pins as count sources.</p>
<p>This module can use GTIOCA and GTIOCB pins as output pins for periodic or PWM signals.</p>
<p>This module can use GTIOCA and GTIOCB as input pins to measure input signals.</p>
<h1><a class="anchor" id="r-gpt-usage_notes"></a>
Usage Notes</h1>
<h2>Maximum Period</h2>
<p>The RA Configuration editor will automatically calculate the period count value and source clock divider based on the selected period time, units and clock speed.</p>
<p>When the selected period unit is "Raw counts", the maximum period setting is 0x40000000000 on a 32-bit timer or 0x4000000 on a 16-bit timer. This will configure the timer with the maximum period and a count clock divisor of 1024.</p>
<dl class="section note"><dt>Note</dt><dd>16-bit channels inherently have a reduced maximum period compared to 32-bit channels. When setting period values of hundreds of milliseconds or more on 16-bit channels be sure to check the generated output to confirm the actual configured value as it will clip much earlier than 32-bit channels. In general, it is recommended to use a lower-power timer like AGT or RTC if long hardware delays are required.</dd></dl>
<h2>Updating Period and Duty Cycle</h2>
<p>The period and duty cycle are updated after the next counter overflow after calling <a class="el" href="group___g_p_t.html#gafedbfd8bc3f534d06969588ff10a351b">R_GPT_PeriodSet()</a> or <a class="el" href="group___g_p_t.html#gad14bacf6fb7fce88f3e877160be529ea">R_GPT_DutyCycleSet()</a>. To force them to update before the next counter overflow, call <a class="el" href="group___g_p_t.html#ga5eb494add3d40775dbc48c5498e15a3a">R_GPT_Reset()</a> while the counter is running.</p>
<dl class="section note"><dt>Note</dt><dd>When manually changing the timer period counts the maximum value for a 32-bit GPT is 0x100000000. This number overflows the 32-bit value for <a class="el" href="group___t_i_m_e_r___a_p_i.html#aa892b6997a1972de6a6ebd48e0fb9233" title="Period in raw timer counts. ">timer_cfg_t::period_counts</a>. To configure the timer for the maximum period, set <a class="el" href="group___t_i_m_e_r___a_p_i.html#aa892b6997a1972de6a6ebd48e0fb9233" title="Period in raw timer counts. ">timer_cfg_t::period_counts</a> to 0.</dd>
<dd>
When changing the period and duty cycle at the same time when Parameter Checking is enabled, call R_GPT_PeriodSet first followed by R_GPT_DutyCycleSet to ensure input validation is performed correctly.</dd></dl>
<h2>One-Shot Mode</h2>
<p><a class="anchor" id="um_timer_one_shot_mode"></a> The GPT timer does not support one-shot mode natively. One-shot mode is achieved by stopping the timer in the interrupt service routine before the callback is called. If the interrupt is not serviced before the timer period expires again, the timer generates more than one event. The callback is only called once in this case, but multiple events may be generated if the timer is linked to the <a class="el" href="group___d_t_c.html">Transfer (r_dtc)</a>.</p>
<h3>One-Shot Mode Output</h3>
<p><a class="anchor" id="um_timer_one_shot_output"></a> The output waveform in one-shot mode is one PCLKD cycle less than the configured period. The configured period must be at least 2 counts to generate an output pulse.</p>
<p>Examples of one-shot signals that can be generated by this module are shown below:</p>
<div class="image">
<object type="image/svg+xml" data="r_gpt_one_shot_output.svg">r_gpt_one_shot_output.svg</object>
<div class="caption">
GPT One-Shot Output</div></div>
 <h2>One-Shot Pulse Mode</h2>
<p>The one-shot pulse mode is an asymmetric PWM mode that provides more control over the rising and falling edges of the output. The user provides a period and initial output level and controls the signal by specifying compare match values for the leading and trailing edges each period.</p>
<dl class="section note"><dt>Note</dt><dd>Despite its name, the One-Shot Pulse Mode operates continuously and does not stop after the first period.</dd></dl>
<h3>One-Shot Pulse Mode Output</h3>
<p>Examples of PWM signals that can be generated by this module are shown below. The leading and trailing edge match values can be modified using <a class="el" href="group___g_p_t.html#gad14bacf6fb7fce88f3e877160be529ea">R_GPT_DutyCycleSet()</a> in the overflow interrupt.</p>
<div class="image">
<object type="image/svg+xml" data="r_gpt_one_shot_pulse_output.svg">r_gpt_one_shot_pulse_output.svg</object>
<div class="caption">
GPT One-Shot Pulse Output (without dead time)</div></div>
<p> If dead time is enabled only match values for GTIOCnA need to be set; the match values for GTIOCnB will be automatically configured in hardware.</p>
<div class="image">
<object type="image/svg+xml" data="r_gpt_one_shot_pulse_output_dead_time.svg">r_gpt_one_shot_pulse_output_dead_time.svg</object>
<div class="caption">
GPT One-Shot Pulse Output (with dead time)</div></div>
 <h2>Periodic Output</h2>
<p><a class="anchor" id="um_timer_periodic_output"></a> The GTIOC pin toggles twice each time the timer expires in periodic mode. This is achieved by defining a PWM wave at a 50 percent duty cycle so that the period of the resulting square wave (from rising edge to rising edge) matches the period of the GPT timer. Since the periodic output is actually a PWM output, the time at the stop level is one cycle shorter than the time opposite the stop level for odd period values.</p>
<p>Examples of periodic signals that can be generated by this module are shown below:</p>
<div class="image">
<object type="image/svg+xml" data="r_gpt_periodic_output.svg">r_gpt_periodic_output.svg</object>
<div class="caption">
GPT Periodic Output</div></div>
 <h2>PWM Output</h2>
<p><a class="anchor" id="um_timer_pwm_output"></a> The PWM output signal is high at the beginning of the cycle and low at the end of the cycle.</p>
<p>Examples of PWM signals that can be generated by this module are shown below:</p>
<div class="image">
<object type="image/svg+xml" data="r_gpt_pwm_output.svg">r_gpt_pwm_output.svg</object>
<div class="caption">
GPT PWM Output</div></div>
 <h2>Triangle-Wave PWM Output</h2>
<p>Examples of PWM signals that can be generated by this module are shown below. The duty_cycle_counts can be modified using <a class="el" href="group___g_p_t.html#gad14bacf6fb7fce88f3e877160be529ea">R_GPT_DutyCycleSet()</a> in the crest interrupt and updated at the following trough for symmetric PWM or modified in both the crest/trough interrupts and updated at the following trough/crest for asymmetric PWM.</p>
<div class="image">
<object type="image/svg+xml" data="r_gpt_triangle_wave_pwm_output.svg">r_gpt_triangle_wave_pwm_output.svg</object>
<div class="caption">
GPT Triangle-Wave PWM Output</div></div>
 <h2>PWM Output Delay Circuit<a class="anchor" id="um_gpt_pwm_output_delay"></a></h2>
<p>On select MCUs, an additional PWM output delay circuit can be configured in order to fine tune the rising and falling edge delays in increments of 1/32 times the period of the GPT core clock. The PWM output delay function must be configured prior to initializing the GPT channels using <a class="el" href="group___g_p_t.html#gada982ef1873ca00147f9692b42aba8f0">R_GPT_PwmOutputDelayInitialize</a>.</p>
<dl class="section note"><dt>Note</dt><dd>1. In Saw-wave PWM mode, the output delay setting cannot be changed while the capture compare setting (GTCCRn) is greater than or equal the period setting (GTPR) - 2. </dd>
<dd>
2. In Triangle PWM modes, the output delay setting cannot be changed while the counter is counting down, and the capture compare setting (GTCCRn) is less than or equal to 2. </dd>
<dd>
3. When the PWM Output Delay Circuit is enabled, the PWM signal is delayed by 3 GPT core clock cycles. </dd>
<dd>
4. When the GPTCLK is used as the GPT core clock, the following delay is required between writes to the rising or falling edge output delay setting for a given pin: <code>Write_Interval[ns] = Period_of_PCLKA [ns] × 6 + Period_of_GPTCLK [ns] × 4</code>).</dd></dl>
<h2>Event Counting</h2>
<p>Event counting can be done by selecting up or down counting sources from GTETRG pins, ELC events, or GTIOC pins. In event counting mode, the GPT counter is not affected by PCLKD.</p>
<dl class="section note"><dt>Note</dt><dd>In event counting mode, the application must call <a class="el" href="group___g_p_t.html#ga2769f9fda49613246bc84dba41aa4863">R_GPT_Start()</a> to enable event counting. The counter will not change after calling <a class="el" href="group___g_p_t.html#ga2769f9fda49613246bc84dba41aa4863">R_GPT_Start()</a> until an event occurs.</dd></dl>
<h2>Pulse Measurement</h2>
<p>If the capture edge occurs before the start edge in pulse measurement, the first capture is invalid (0).</p>
<h2>Controlling GPT with GTETRG Edges</h2>
<p>The GPT timer can be configured to stop, start, clear, count up, or count down when a GTETRG rising or falling edge occurs.</p>
<dl class="section note"><dt>Note</dt><dd>The GTETRG pins are shared by all GPT channels.</dd>
<dd>
GTETRG pins require POEG to be on (example code for this is provided in GPT Free Running Counter Example). If input filtering is required on the GTETRG pins, that must also be handled outside this module.</dd></dl>
<h2>Controlling GPT with ELC Events</h2>
<p>The GPT timer can be configured to stop, start, clear, count up, or count down when an ELC event occurs.</p>
<dl class="section note"><dt>Note</dt><dd>The configurable ELC GPT sources are shared by all GPT channels.</dd>
<dd>
The event links for the ELC must be configured outside this module.</dd></dl>
<h2>Triggering ELC Events with GPT</h2>
<p>The GPT timer can trigger the start of other peripherals. The <a class="el" href="group___e_l_c.html">Event Link Controller (r_elc)</a> guide provides a list of all available peripherals.</p>
<h2>Enabling External Sources for Start, Stop, Clear, or Capture</h2>
<p><a class="anchor" id="um_timer_enable_disable"></a> <a class="el" href="group___g_p_t.html#ga6e14d15c781e316e640c280b4983be28">R_GPT_Enable()</a> must be called when external sources are used for start, stop, clear, or capture.</p>
<h2>Interrupt Skipping</h2>
<p>When an interrupt skipping source is selected a hardware counter will increment each time the selected event occurs. Each interrupt past the first (up to the specified skip count) will be suppressed. If ADC events are selected for skipping they will also be suppressed except during the timer period leading to the selected interrupt skipping event (see below diagram).</p>
<div class="image">
<img src="r_gpt_interrupt_skipping.png" alt="r_gpt_interrupt_skipping.png"/>
<div class="caption">
Crest interrupt skipping in triangle-wave PWM modes (skip count 2)</div></div>
 <h2>Complementary Output</h2>
<p>By using the Custom Waveform option the output pins can be made to output complementary waveforms. To ensure these waveforms stay in sync, the duty cycle for both pins can be set simultaneously by calling R_GPT_DutyCycleSet once with a pin parameter of GPT_IO_PIN_GTIOCA_AND_GTIOCB.</p>
<dl class="section note"><dt>Note</dt><dd>The pin level for 0% and 100% duty cycle is determined by the Cycle End Output Level in normal PWM mode and the Initial Output Level in triangle PWM modes. 100% duty will output the configured level and 0% will output the opposite. Do not use Pin Level Toggle or Pin Level Retain for the Cycle End Output Level if normal PWM waveforms are desired.</dd></dl>
<h1><a class="anchor" id="r-gpt-examples"></a>
Examples</h1>
<h2>GPT Basic Example</h2>
<p>This is a basic example of minimal use of the GPT in an application.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> gpt_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#ga97d0a9c1a8fb6b88d1c12756dd8ce2d2">R_GPT_Open</a>(&amp;g_timer0_ctrl, &amp;g_timer0_cfg);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Start the timer. */</span></div><div class="line">    (void) <a class="code" href="group___g_p_t.html#ga2769f9fda49613246bc84dba41aa4863">R_GPT_Start</a>(&amp;g_timer0_ctrl);</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>GPT Callback Example</h2>
<p>This is an example of a timer callback.</p>
<p><a class="anchor" id="um_timer_user_notification_of_events"></a> </p><div class="fragment"><div class="line"></div><div class="line"><span class="comment">/* Example callback called when timer expires. */</span></div><div class="line"><span class="keywordtype">void</span> timer_callback (<a class="code" href="group___t_i_m_e_r___a_p_i.html#structtimer__callback__args__t">timer_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___t_i_m_e_r___a_p_i.html#ggac3bee51f7c9078f794c5ac19522f91ebae310bef0d640f06765c01b4b91a5b84c">TIMER_EVENT_CYCLE_END</a> == p_args-&gt;<a class="code" href="group___t_i_m_e_r___a_p_i.html#a61b9aabfcafc5e362dce56af7ea36bcf">event</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Add application code to be called periodically here. */</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>GPT Free Running Counter Example</h2>
<p><a class="anchor" id="um_timer_reset"></a><a class="anchor" id="um_timer_start"></a><a class="anchor" id="um_timer_stop"></a><a class="anchor" id="um_timer_counter"></a> To use the GPT as a free running counter, select periodic mode and set the the Period to 0xFFFFFFFF for a 32-bit timer or 0xFFFF for a 16-bit timer.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> gpt_counter_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) If event count mode is used to count edges on a GTETRG pin, POEG must be started to use GTETRG.</span></div><div class="line"><span class="comment">     * Reference Note 1 of Table &quot;GPT functions&quot; in the relevant hardware manual. */</span></div><div class="line">    <a class="code" href="group___b_s_p___m_c_u.html#gaf0a730b79b5bbe76759b6e8efafe2000">R_BSP_MODULE_START</a>(<a class="code" href="group___b_s_p___m_c_u.html#gga7880302f0edd7cc4290c037809975950acfc9bb8ff007a7b82cf4fd845dfce053">FSP_IP_POEG</a>, 0U);</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#ga97d0a9c1a8fb6b88d1c12756dd8ce2d2">R_GPT_Open</a>(&amp;g_timer0_ctrl, &amp;g_timer0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Start the timer. */</span></div><div class="line">    (void) <a class="code" href="group___g_p_t.html#ga2769f9fda49613246bc84dba41aa4863">R_GPT_Start</a>(&amp;g_timer0_ctrl);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Stop the timer. */</span></div><div class="line">    (void) <a class="code" href="group___g_p_t.html#ga1e6af74d7faaf735f5847a34121eff71">R_GPT_Stop</a>(&amp;g_timer0_ctrl);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Read the current counter value. Counter value is in status.counter. */</span></div><div class="line">    <a class="code" href="group___t_i_m_e_r___a_p_i.html#structtimer__status__t">timer_status_t</a> status;</div><div class="line">    (void) <a class="code" href="group___g_p_t.html#gaa6234faf45320a83382d7ea1923a2c49">R_GPT_StatusGet</a>(&amp;g_timer0_ctrl, &amp;status);</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>GPT Input Capture Example</h2>
<p><a class="anchor" id="um_timer_capture_pulse_width"></a><a class="anchor" id="um_timer_capture_pulse_period"></a> This is an example of using the GPT to capture pulse width or pulse period measurements.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">/* Example callback called when a capture occurs. */</span></div><div class="line">uint64_t g_captured_time     = 0U;</div><div class="line">uint32_t g_capture_overflows = 0U;</div><div class="line"><span class="keywordtype">void</span> timer_capture_callback (<a class="code" href="group___t_i_m_e_r___a_p_i.html#structtimer__callback__args__t">timer_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> ((<a class="code" href="group___t_i_m_e_r___a_p_i.html#ggac3bee51f7c9078f794c5ac19522f91eba4bc1252f63147f4a01f7b7ba88afac1d">TIMER_EVENT_CAPTURE_A</a> == p_args-&gt;<a class="code" href="group___t_i_m_e_r___a_p_i.html#a61b9aabfcafc5e362dce56af7ea36bcf">event</a>) || (<a class="code" href="group___t_i_m_e_r___a_p_i.html#ggac3bee51f7c9078f794c5ac19522f91ebab7b635fbf34ede5a3e2f55b5a60ac21b">TIMER_EVENT_CAPTURE_B</a> == p_args-&gt;<a class="code" href="group___t_i_m_e_r___a_p_i.html#a61b9aabfcafc5e362dce56af7ea36bcf">event</a>))</div><div class="line">    {</div><div class="line"></div><div class="line">        <span class="comment">/* (Optional) Get the current period if not known. */</span></div><div class="line">        <a class="code" href="group___t_i_m_e_r___a_p_i.html#structtimer__info__t">timer_info_t</a> info;</div><div class="line">        (void) <a class="code" href="group___g_p_t.html#gaca62ac33de2c05918b0fc359aeaebd97">R_GPT_InfoGet</a>(&amp;g_timer0_ctrl, &amp;info);</div><div class="line">        uint64_t period = info.<a class="code" href="group___t_i_m_e_r___a_p_i.html#a08b897cfbf2d0cefafe8d3abb1afc747">period_counts</a>;</div><div class="line"></div><div class="line">        <span class="comment">/* The maximum period is one more than the maximum 32-bit number, but will be reflected as 0 in</span></div><div class="line"><span class="comment">         * timer_info_t::period_counts. */</span></div><div class="line">        <span class="keywordflow">if</span> (0U == period)</div><div class="line">        {</div><div class="line">            period = UINT32_MAX + 1U;</div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line">        g_captured_time     = (period * g_capture_overflows) + p_args-&gt;<a class="code" href="group___t_i_m_e_r___a_p_i.html#a8abd12cdf1a993cf8054be6ba9d96a6f">capture</a>;</div><div class="line">        g_capture_overflows = 0U;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___t_i_m_e_r___a_p_i.html#ggac3bee51f7c9078f794c5ac19522f91ebae310bef0d640f06765c01b4b91a5b84c">TIMER_EVENT_CYCLE_END</a> == p_args-&gt;<a class="code" href="group___t_i_m_e_r___a_p_i.html#a61b9aabfcafc5e362dce56af7ea36bcf">event</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* An overflow occurred during capture. This must be accounted for at the application layer. */</span></div><div class="line">        g_capture_overflows++;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> gpt_capture_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#ga97d0a9c1a8fb6b88d1c12756dd8ce2d2">R_GPT_Open</a>(&amp;g_timer0_ctrl, &amp;g_timer0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Enable captures. Captured values arrive in the interrupt. */</span></div><div class="line">    (void) <a class="code" href="group___g_p_t.html#ga6e14d15c781e316e640c280b4983be28">R_GPT_Enable</a>(&amp;g_timer0_ctrl);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Disable captures. */</span></div><div class="line">    (void) <a class="code" href="group___g_p_t.html#ga338dd3c38477ee40c90c13f3a4c9ecfd">R_GPT_Disable</a>(&amp;g_timer0_ctrl);</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>GPT Period Update Example</h2>
<p><a class="anchor" id="um_timer_period_set"></a><a class="anchor" id="um_timer_clock_frequency"></a> This an example of updating the period.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define GPT_EXAMPLE_MSEC_PER_SEC           (1000)</span></div><div class="line"><span class="preprocessor">#define GPT_EXAMPLE_DESIRED_PERIOD_MSEC    (20)</span></div><div class="line"></div><div class="line"><span class="comment">/* This example shows how to calculate a new period value at runtime. */</span></div><div class="line"><span class="keywordtype">void</span> gpt_period_calculation_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#ga97d0a9c1a8fb6b88d1c12756dd8ce2d2">R_GPT_Open</a>(&amp;g_timer0_ctrl, &amp;g_timer0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Start the timer. */</span></div><div class="line">    (void) <a class="code" href="group___g_p_t.html#ga2769f9fda49613246bc84dba41aa4863">R_GPT_Start</a>(&amp;g_timer0_ctrl);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Get the source clock frequency (in Hz). There are 3 ways to do this in FSP:</span></div><div class="line"><span class="comment">     *  - If the PCLKD frequency has not changed since reset, the source clock frequency is</span></div><div class="line"><span class="comment">     *    BSP_STARTUP_PCLKD_HZ &gt;&gt; timer_cfg_t::source_div</span></div><div class="line"><span class="comment">     *  - Use the R_GPT_InfoGet function (it accounts for the divider).</span></div><div class="line"><span class="comment">     *  - Calculate the current PCLKD frequency using R_FSP_SystemClockHzGet(FSP_PRIV_CLOCK_PCLKD) and right shift</span></div><div class="line"><span class="comment">     *    by timer_cfg_t::source_div.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * This example uses the 3rd option (R_FSP_SystemClockHzGet).</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    uint32_t pclkd_freq_hz = <a class="code" href="group___b_s_p___m_c_u.html#gaac289335b731d0bdb5cb8e6d243898ef">R_FSP_SystemClockHzGet</a>(FSP_PRIV_CLOCK_PCLKD) &gt;&gt; g_timer0_cfg.source_div;</div><div class="line"></div><div class="line">    <span class="comment">/* Calculate the desired period based on the current clock. Note that this calculation could overflow if the</span></div><div class="line"><span class="comment">     * desired period is larger than UINT32_MAX / pclkd_freq_hz. A cast to uint64_t is used to prevent this. */</span></div><div class="line">    uint32_t period_counts =</div><div class="line">        (uint32_t) (((uint64_t) pclkd_freq_hz * GPT_EXAMPLE_DESIRED_PERIOD_MSEC) / GPT_EXAMPLE_MSEC_PER_SEC);</div><div class="line"></div><div class="line">    <span class="comment">/* Set the calculated period. */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#gafedbfd8bc3f534d06969588ff10a351b">R_GPT_PeriodSet</a>(&amp;g_timer0_ctrl, period_counts);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>GPT Duty Cycle Update Example</h2>
<p><a class="anchor" id="um_timer_duty_cycle_set"></a> This an example of updating the duty cycle.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define GPT_EXAMPLE_DESIRED_DUTY_CYCLE_PERCENT    (25)</span></div><div class="line"><span class="preprocessor">#define GPT_EXAMPLE_MAX_PERCENT                   (100)</span></div><div class="line"></div><div class="line"><span class="comment">/* This example shows how to calculate a new duty cycle value at runtime. */</span></div><div class="line"><span class="keywordtype">void</span> gpt_duty_cycle_calculation_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#ga97d0a9c1a8fb6b88d1c12756dd8ce2d2">R_GPT_Open</a>(&amp;g_timer0_ctrl, &amp;g_timer0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Start the timer. */</span></div><div class="line">    (void) <a class="code" href="group___g_p_t.html#ga2769f9fda49613246bc84dba41aa4863">R_GPT_Start</a>(&amp;g_timer0_ctrl);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Get the current period setting. */</span></div><div class="line">    <a class="code" href="group___t_i_m_e_r___a_p_i.html#structtimer__info__t">timer_info_t</a> info;</div><div class="line">    (void) <a class="code" href="group___g_p_t.html#gaca62ac33de2c05918b0fc359aeaebd97">R_GPT_InfoGet</a>(&amp;g_timer0_ctrl, &amp;info);</div><div class="line">    uint32_t current_period_counts = info.<a class="code" href="group___t_i_m_e_r___a_p_i.html#a08b897cfbf2d0cefafe8d3abb1afc747">period_counts</a>;</div><div class="line"></div><div class="line">    <span class="comment">/* Calculate the desired duty cycle based on the current period. Note that if the period could be larger than</span></div><div class="line"><span class="comment">     * UINT32_MAX / 100, this calculation could overflow. A cast to uint64_t is used to prevent this. The cast is</span></div><div class="line"><span class="comment">     * not required for 16-bit timers. */</span></div><div class="line">    uint32_t duty_cycle_counts =</div><div class="line">        (uint32_t) (((uint64_t) current_period_counts * GPT_EXAMPLE_DESIRED_DUTY_CYCLE_PERCENT) /</div><div class="line">                    GPT_EXAMPLE_MAX_PERCENT);</div><div class="line"></div><div class="line">    <span class="comment">/* Set the calculated duty cycle. */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#gad14bacf6fb7fce88f3e877160be529ea">R_GPT_DutyCycleSet</a>(&amp;g_timer0_ctrl, duty_cycle_counts, <a class="code" href="group___g_p_t.html#ggaabd4a03d16b1b4254cc44c7779f44c60aebd74a7b9507fb082ec4cce60ebe9369">GPT_IO_PIN_GTIOCB</a>);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>GPT A/D Converter Start Request Example</h2>
<p>This is an example of using the GPT to start the ADC at a configurable A/D converter compare match value.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#if ((1U &lt;&lt; GPT_EXAMPLE_CHANNEL) &amp; (BSP_FEATURE_GPT_GPTE_CHANNEL_MASK | BSP_FEATURE_GPT_GPTEH_CHANNEL_MASK | \</span></div><div class="line"><span class="preprocessor">                                    BSP_FEATURE_GPT_AD_DIRECT_START_CHANNEL_MASK))</span></div><div class="line"></div><div class="line"><span class="comment">/* This example shows how to configure the GPT to generate an A/D start request at an A/D start request compare</span></div><div class="line"><span class="comment"> * match value. This example can only be used with GPTE or GPTEH variants. */</span></div><div class="line"><span class="keywordtype">void</span> gpt_adc_start_request_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line"><span class="preprocessor"> #if ((BSP_FEATURE_GPT_GPTE_SUPPORTED | BSP_FEATURE_GPT_GPTEH_SUPPORTED) &amp;&amp; !BSP_FEATURE_GPT_AD_DIRECT_START_SUPPORTED)</span></div><div class="line"></div><div class="line">    <span class="comment">/* Initialize and configure the ELC. */</span></div><div class="line">    err = <a class="code" href="group___e_l_c.html#ga35864de459d2ef45a03da4343729712f">R_ELC_Open</a>(&amp;g_elc_ctrl, &amp;g_elc_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Configure the ELC to start a scan on ADC unit 0 when GPT channel 0. Note: This is typically configured in</span></div><div class="line"><span class="comment">     * g_elc_cfg and already set during R_ELC_Open. */</span></div><div class="line">    err = <a class="code" href="group___e_l_c.html#ga4b40a4cb59194b6315cf608cd5e36bd9">R_ELC_LinkSet</a>(&amp;g_elc_ctrl, ELC_PERIPHERAL_ADC0, ELC_EVENT_GPT0_AD_TRIG_A);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Globally enable ELC events. */</span></div><div class="line">    err = <a class="code" href="group___e_l_c.html#ga4bcac22edb575069ba86d87ce9aea84c">R_ELC_Enable</a>(&amp;g_elc_ctrl);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"><span class="preprocessor"> #else                                 </span><span class="comment">/* BSP_FEATURE_GPT_AD_DIRECT_START_SUPPORTED */</span><span class="preprocessor"></span></div><div class="line">    <span class="comment">/* Do not configure AD ELC trigger for devices with GPT ADC direct-start support */</span></div><div class="line"><span class="preprocessor"> #endif</span></div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the ADC to start a scan based on an GPT compare-match event trigger. Set adc_cfg_t::trigger to</span></div><div class="line"><span class="comment">     * ADC_TRIGGER_SYNC_ELC.  */</span></div><div class="line">    err = p_adc_api-&gt;open(&amp;g_adc0_ctrl, &amp;g_adc0_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    err = p_adc_api-&gt;scanCfg(&amp;g_adc0_ctrl, &amp;g_adc0_channel_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable synchronous triggers by calling R_ADC_ScanStart(). */</span></div><div class="line">    (void) p_adc_api-&gt;scanStart(&amp;g_adc0_ctrl);</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the GPT module. Configure gpt_extended_pwm_cfg_t::adc_trigger to set when the A/D start request</span></div><div class="line"><span class="comment">     * is generated. Set gpt_extended_pwm_cfg_t::adc_a_compare_match to set the desired compare match value. */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#ga97d0a9c1a8fb6b88d1c12756dd8ce2d2">R_GPT_Open</a>(&amp;g_timer0_ctrl, &amp;g_timer0_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Start the timer. A/D converter start request events are generated each time the counter is equal to the</span></div><div class="line"><span class="comment">     * A/D start request compare match value. */</span></div><div class="line">    (void) <a class="code" href="group___g_p_t.html#ga2769f9fda49613246bc84dba41aa4863">R_GPT_Start</a>(&amp;g_timer0_ctrl);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div></div><!-- fragment --> <h2>GPT One-Shot Pulse Mode Example</h2>
<p>This example demonstrates the configuration and use of one-shot pulse mode with GPT timer.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">/* Example callback called when timer overflows. */</span></div><div class="line"><span class="keywordtype">void</span> gpt_overflow_callback (<a class="code" href="group___t_i_m_e_r___a_p_i.html#structtimer__callback__args__t">timer_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___t_i_m_e_r___a_p_i.html#ggac3bee51f7c9078f794c5ac19522f91ebae310bef0d640f06765c01b4b91a5b84c">TIMER_EVENT_CYCLE_END</a> == p_args-&gt;<a class="code" href="group___t_i_m_e_r___a_p_i.html#a61b9aabfcafc5e362dce56af7ea36bcf">event</a>)</div><div class="line">    {</div><div class="line">        g_timer_cycle_end_counter++;</div><div class="line"></div><div class="line">        <span class="comment">/* Use R_GPT_DutyCycleSet() API to set new values for each cycle.</span></div><div class="line"><span class="comment">         * - Use GPT_IO_PIN_ONE_SHOT_LEADING_EDGE to set the leading edge transition match value (GTCCRC or GTCCRE register).</span></div><div class="line"><span class="comment">         * - Use GPT_IO_PIN_ONE_SHOT_TRAILING_EDGE to set the trailing edge transition match value (GTCCRD or GTCCRF register).</span></div><div class="line"><span class="comment">         */</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* GTIOCA (configured for active-high) first and second pulse will be:</span></div><div class="line"><span class="comment"> * - 1/2 period, offset by 3/8 period</span></div><div class="line"><span class="comment"> * - 1/4 period, offset by 1/4 period */</span></div><div class="line"><span class="preprocessor">#define GPT_ONE_SHOT_EXAMPLE_FIRST_EDGE_PIN_A     ((g_timer0_cfg.period_counts * 3) / 8)</span></div><div class="line"><span class="preprocessor">#define GPT_ONE_SHOT_EXAMPLE_SECOND_EDGE_PIN_A    ((g_timer0_cfg.period_counts * 7) / 8)</span></div><div class="line"><span class="preprocessor">#define GPT_ONE_SHOT_EXAMPLE_THIRD_EDGE_PIN_A     ((g_timer0_cfg.period_counts * 1) / 4)</span></div><div class="line"><span class="preprocessor">#define GPT_ONE_SHOT_EXAMPLE_FOURTH_EDGE_PIN_A    ((g_timer0_cfg.period_counts * 2) / 4)</span></div><div class="line"></div><div class="line"><span class="comment">/* GTIOCB (configured for active-low) first and second pulse will be:</span></div><div class="line"><span class="comment"> * - 1/2 period, offset by 1/4 period</span></div><div class="line"><span class="comment"> * - 1/4 period, offset by 1/2 period */</span></div><div class="line"><span class="preprocessor">#define GPT_ONE_SHOT_EXAMPLE_FIRST_EDGE_PIN_B     ((g_timer0_cfg.period_counts * 1) / 4)</span></div><div class="line"><span class="preprocessor">#define GPT_ONE_SHOT_EXAMPLE_SECOND_EDGE_PIN_B    ((g_timer0_cfg.period_counts * 3) / 4)</span></div><div class="line"><span class="preprocessor">#define GPT_ONE_SHOT_EXAMPLE_THIRD_EDGE_PIN_B     ((g_timer0_cfg.period_counts * 2) / 4)</span></div><div class="line"><span class="preprocessor">#define GPT_ONE_SHOT_EXAMPLE_FOURTH_EDGE_PIN_B    ((g_timer0_cfg.period_counts * 3) / 4)</span></div><div class="line"></div><div class="line"><span class="comment">/* Configure and output a one-shot pulse that resembles what is shown in the example above. */</span></div><div class="line"><span class="keywordtype">void</span> gpt_one_shot_pulse_mode_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#ga97d0a9c1a8fb6b88d1c12756dd8ce2d2">R_GPT_Open</a>(&amp;g_timer0_ctrl, &amp;g_timer0_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Set first edge transition count for GTIOCA and GTIOCB.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * Notes:</span></div><div class="line"><span class="comment">     *  - Two temporary registers (A and B) are used for the second edge.</span></div><div class="line"><span class="comment">     *  - Temporary register A and Temporary register B may only be loaded by shifting from GTCCRD and GTCCRF, which is why the GPT_BUFFER_FORCE_PUSH is necessary</span></div><div class="line"><span class="comment">     *  - If GPT_BUFFER_FORCE_PUSH is not used, timing for the first pulse will be undefined.</span></div><div class="line"><span class="comment">     *  - For more information, see &quot;Example setting for saw-wave one-shot pulse mode&quot; in the UM for your MCU. */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#gad14bacf6fb7fce88f3e877160be529ea">R_GPT_DutyCycleSet</a>(&amp;g_timer0_ctrl,</div><div class="line">                             GPT_ONE_SHOT_EXAMPLE_FIRST_EDGE_PIN_A,</div><div class="line">                             <a class="code" href="group___g_p_t.html#ggaabd4a03d16b1b4254cc44c7779f44c60aec2d2c471241869efb57a9a48a5d0eda">GPT_IO_PIN_GTIOCA</a> | <a class="code" href="group___g_p_t.html#ggaabd4a03d16b1b4254cc44c7779f44c60ae3e479af00c84f4ccf6e7376b4b44c8d">GPT_IO_PIN_ONE_SHOT_LEADING_EDGE</a>);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">    err = <a class="code" href="group___g_p_t.html#gad14bacf6fb7fce88f3e877160be529ea">R_GPT_DutyCycleSet</a>(&amp;g_timer0_ctrl,</div><div class="line">                             GPT_ONE_SHOT_EXAMPLE_FIRST_EDGE_PIN_B,</div><div class="line">                             <a class="code" href="group___g_p_t.html#ggaabd4a03d16b1b4254cc44c7779f44c60aebd74a7b9507fb082ec4cce60ebe9369">GPT_IO_PIN_GTIOCB</a> | <a class="code" href="group___g_p_t.html#ggaabd4a03d16b1b4254cc44c7779f44c60ae3e479af00c84f4ccf6e7376b4b44c8d">GPT_IO_PIN_ONE_SHOT_LEADING_EDGE</a>);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Set third edge transition count for GTIOCA and GTIOCB</span></div><div class="line"><span class="comment">     * Also force-push to shift all four counts into active buffer locations. */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#gad14bacf6fb7fce88f3e877160be529ea">R_GPT_DutyCycleSet</a>(&amp;g_timer0_ctrl,</div><div class="line">                             GPT_ONE_SHOT_EXAMPLE_SECOND_EDGE_PIN_A,</div><div class="line">                             <a class="code" href="group___g_p_t.html#ggaabd4a03d16b1b4254cc44c7779f44c60aec2d2c471241869efb57a9a48a5d0eda">GPT_IO_PIN_GTIOCA</a> | <a class="code" href="group___g_p_t.html#ggaabd4a03d16b1b4254cc44c7779f44c60a59f7576cde98e497d35b98a926732e52">GPT_IO_PIN_ONE_SHOT_TRAILING_EDGE</a>);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">    err = <a class="code" href="group___g_p_t.html#gad14bacf6fb7fce88f3e877160be529ea">R_GPT_DutyCycleSet</a>(&amp;g_timer0_ctrl,</div><div class="line">                             GPT_ONE_SHOT_EXAMPLE_SECOND_EDGE_PIN_B,</div><div class="line">                             <a class="code" href="group___g_p_t.html#ggaabd4a03d16b1b4254cc44c7779f44c60aebd74a7b9507fb082ec4cce60ebe9369">GPT_IO_PIN_GTIOCB</a> | <a class="code" href="group___g_p_t.html#ggaabd4a03d16b1b4254cc44c7779f44c60a59f7576cde98e497d35b98a926732e52">GPT_IO_PIN_ONE_SHOT_TRAILING_EDGE</a> | <a class="code" href="group___g_p_t.html#gga8abd050b841fe99c9b641a22c69501c5a23c94706bd1a34c9f1b9cfffea30f4cc">GPT_BUFFER_FORCE_PUSH</a>);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Set third leading edge transition count for GTIOCA and GTIOCB.</span></div><div class="line"><span class="comment">     * Note: It is not necessary to set third and fourth transition edges if it is not required by the application. */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#gad14bacf6fb7fce88f3e877160be529ea">R_GPT_DutyCycleSet</a>(&amp;g_timer0_ctrl,</div><div class="line">                             GPT_ONE_SHOT_EXAMPLE_THIRD_EDGE_PIN_A,</div><div class="line">                             <a class="code" href="group___g_p_t.html#ggaabd4a03d16b1b4254cc44c7779f44c60aec2d2c471241869efb57a9a48a5d0eda">GPT_IO_PIN_GTIOCA</a> | <a class="code" href="group___g_p_t.html#ggaabd4a03d16b1b4254cc44c7779f44c60ae3e479af00c84f4ccf6e7376b4b44c8d">GPT_IO_PIN_ONE_SHOT_LEADING_EDGE</a>);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">    err = <a class="code" href="group___g_p_t.html#gad14bacf6fb7fce88f3e877160be529ea">R_GPT_DutyCycleSet</a>(&amp;g_timer0_ctrl,</div><div class="line">                             GPT_ONE_SHOT_EXAMPLE_THIRD_EDGE_PIN_B,</div><div class="line">                             <a class="code" href="group___g_p_t.html#ggaabd4a03d16b1b4254cc44c7779f44c60aebd74a7b9507fb082ec4cce60ebe9369">GPT_IO_PIN_GTIOCB</a> | <a class="code" href="group___g_p_t.html#ggaabd4a03d16b1b4254cc44c7779f44c60ae3e479af00c84f4ccf6e7376b4b44c8d">GPT_IO_PIN_ONE_SHOT_LEADING_EDGE</a>);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Set fourth edge transition count for GTIOCA and GTIOCB</span></div><div class="line"><span class="comment">     * Do not force-push, shifting third and fourth edges would overwrite active buffer locations (first and second edge counts). */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#gad14bacf6fb7fce88f3e877160be529ea">R_GPT_DutyCycleSet</a>(&amp;g_timer0_ctrl,</div><div class="line">                             GPT_ONE_SHOT_EXAMPLE_FOURTH_EDGE_PIN_A,</div><div class="line">                             <a class="code" href="group___g_p_t.html#ggaabd4a03d16b1b4254cc44c7779f44c60aec2d2c471241869efb57a9a48a5d0eda">GPT_IO_PIN_GTIOCA</a> | <a class="code" href="group___g_p_t.html#ggaabd4a03d16b1b4254cc44c7779f44c60a59f7576cde98e497d35b98a926732e52">GPT_IO_PIN_ONE_SHOT_TRAILING_EDGE</a>);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">    err = <a class="code" href="group___g_p_t.html#gad14bacf6fb7fce88f3e877160be529ea">R_GPT_DutyCycleSet</a>(&amp;g_timer0_ctrl,</div><div class="line">                             GPT_ONE_SHOT_EXAMPLE_FOURTH_EDGE_PIN_B,</div><div class="line">                             <a class="code" href="group___g_p_t.html#ggaabd4a03d16b1b4254cc44c7779f44c60aebd74a7b9507fb082ec4cce60ebe9369">GPT_IO_PIN_GTIOCB</a> | <a class="code" href="group___g_p_t.html#ggaabd4a03d16b1b4254cc44c7779f44c60a59f7576cde98e497d35b98a926732e52">GPT_IO_PIN_ONE_SHOT_TRAILING_EDGE</a>);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Start the timer. */</span></div><div class="line">    <a class="code" href="group___g_p_t.html#ga2769f9fda49613246bc84dba41aa4863">R_GPT_Start</a>(&amp;g_timer0_ctrl);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for the one-shot pulse output to complete then stop GPT</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * Notes:</span></div><div class="line"><span class="comment">     *  - FSP driver does not currently support automatically stopping one-shot pulse. If GPT is not stopped the last waveform timing will be repeated indefinitely.</span></div><div class="line"><span class="comment">     *  - Some (more recent) MCUs added a new register (GTPC) that could be used to automatically stop GPT after a set number of periods. Software driver support for this is scheduled to be added in the future.</span></div><div class="line"><span class="comment">     *  - The last transition edge timings will continue to be used indefinitely until the user application stops GPT operation. */</span></div><div class="line">    <span class="keywordflow">while</span> (g_timer_cycle_end_counter &lt; 2)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait for one-shot pulse output to complete (two pulses) */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Stop the timer. */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#ga1e6af74d7faaf735f5847a34121eff71">R_GPT_Stop</a>(&amp;g_timer0_ctrl);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>GPT Compare Match Set Example</h2>
<p><a class="anchor" id="um_timer_compare_match_set"></a> This example demonstrates the configuration and use of compare match with GPT timer.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">/* Example callback called when compare match occurs. */</span></div><div class="line"><span class="keywordtype">void</span> gpt_compare_match_callback (<a class="code" href="group___t_i_m_e_r___a_p_i.html#structtimer__callback__args__t">timer_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___t_i_m_e_r___a_p_i.html#ggac3bee51f7c9078f794c5ac19522f91ebabc52a1efe80272e318bc5c62e327f33f">TIMER_EVENT_COMPARE_A</a> == p_args-&gt;<a class="code" href="group___t_i_m_e_r___a_p_i.html#a61b9aabfcafc5e362dce56af7ea36bcf">event</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Add application code to be called periodically here. */</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#define GPT_COMPARE_MATCH_EXAMPLE_VALUE    (0x2000U)</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> gpt_compare_match_set_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#ga97d0a9c1a8fb6b88d1c12756dd8ce2d2">R_GPT_Open</a>(&amp;g_timer0_ctrl, &amp;g_timer0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Set the compare match value (GPT_COMPARE_MATCH_EXAMPLE_VALUE). This value must be less than or equal to period value. */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#ga834be7c118edc5297a74cf588a447106">R_GPT_CompareMatchSet</a>(&amp;g_timer0_ctrl, GPT_COMPARE_MATCH_EXAMPLE_VALUE, <a class="code" href="group___t_i_m_e_r___a_p_i.html#ggaf5f22f5e34fe6ea640fd6a1c7e864cd9aaaad342d8de564fe934da6046de43b1b">TIMER_COMPARE_MATCH_A</a>);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Start the timer. */</span></div><div class="line">    (void) <a class="code" href="group___g_p_t.html#ga2769f9fda49613246bc84dba41aa4863">R_GPT_Start</a>(&amp;g_timer0_ctrl);</div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Stop the timer. */</span></div><div class="line">    (void) <a class="code" href="group___g_p_t.html#ga1e6af74d7faaf735f5847a34121eff71">R_GPT_Stop</a>(&amp;g_timer0_ctrl);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structgpt__output__pin__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#structgpt__output__pin__t">gpt_output_pin_t</a></td></tr>
<tr class="separator:structgpt__output__pin__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structgpt__gtior__setting__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#structgpt__gtior__setting__t">gpt_gtior_setting_t</a></td></tr>
<tr class="separator:structgpt__gtior__setting__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structgpt__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#structgpt__instance__ctrl__t">gpt_instance_ctrl_t</a></td></tr>
<tr class="separator:structgpt__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structgpt__extended__pwm__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#structgpt__extended__pwm__cfg__t">gpt_extended_pwm_cfg_t</a></td></tr>
<tr class="separator:structgpt__extended__pwm__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structgpt__extended__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#structgpt__extended__cfg__t">gpt_extended_cfg_t</a></td></tr>
<tr class="separator:structgpt__extended__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaabd4a03d16b1b4254cc44c7779f44c60"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#gaabd4a03d16b1b4254cc44c7779f44c60">gpt_io_pin_t</a> </td></tr>
<tr class="separator:gaabd4a03d16b1b4254cc44c7779f44c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8abd050b841fe99c9b641a22c69501c5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga8abd050b841fe99c9b641a22c69501c5">gpt_buffer_force_push</a> </td></tr>
<tr class="separator:ga8abd050b841fe99c9b641a22c69501c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga454c639e426428470ce78115af5d3648"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga454c639e426428470ce78115af5d3648">gpt_pin_level_t</a> </td></tr>
<tr class="separator:ga454c639e426428470ce78115af5d3648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1457c9c1f178fff4dd1558832db196a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#gaa1457c9c1f178fff4dd1558832db196a">gpt_source_t</a> </td></tr>
<tr class="separator:gaa1457c9c1f178fff4dd1558832db196a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4781e2b42b2ef339318ea0a70b250cd5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga4781e2b42b2ef339318ea0a70b250cd5">gpt_capture_filter_t</a> </td></tr>
<tr class="separator:ga4781e2b42b2ef339318ea0a70b250cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dfe4ddfb53ba52c674039fd20b6c2b6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga6dfe4ddfb53ba52c674039fd20b6c2b6">gpt_adc_trigger_t</a> </td></tr>
<tr class="separator:ga6dfe4ddfb53ba52c674039fd20b6c2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac13c16f82e0b7cafcdb8eb6892722943"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#gac13c16f82e0b7cafcdb8eb6892722943">gpt_poeg_link_t</a> </td></tr>
<tr class="separator:gac13c16f82e0b7cafcdb8eb6892722943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e57d68f5f5d9757bab01857e8252ade"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga7e57d68f5f5d9757bab01857e8252ade">gpt_output_disable_t</a> </td></tr>
<tr class="separator:ga7e57d68f5f5d9757bab01857e8252ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82d61d33edf38d50f1247d1d55ec506b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga82d61d33edf38d50f1247d1d55ec506b">gpt_gtioc_disable_t</a> </td></tr>
<tr class="separator:ga82d61d33edf38d50f1247d1d55ec506b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a838fffcbafd97778bbe3ffbfbf54b1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga2a838fffcbafd97778bbe3ffbfbf54b1">gpt_adc_compare_match_t</a> </td></tr>
<tr class="separator:ga2a838fffcbafd97778bbe3ffbfbf54b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88d6114404f61d9ca10684f393deb613"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga88d6114404f61d9ca10684f393deb613">gpt_interrupt_skip_source_t</a> </td></tr>
<tr class="separator:ga88d6114404f61d9ca10684f393deb613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac737ceea25e4989a9afbf47969a71ba3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#gac737ceea25e4989a9afbf47969a71ba3">gpt_interrupt_skip_count_t</a> </td></tr>
<tr class="separator:gac737ceea25e4989a9afbf47969a71ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9928e374919fa53240edaca52412beaa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga9928e374919fa53240edaca52412beaa">gpt_interrupt_skip_adc_t</a> </td></tr>
<tr class="separator:ga9928e374919fa53240edaca52412beaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga749be81f99469c5607a684976d9ae374"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga749be81f99469c5607a684976d9ae374">gpt_pwm_output_delay_setting_t</a> </td></tr>
<tr class="separator:ga749be81f99469c5607a684976d9ae374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a1389fe5c3bef2301d294b88263628e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga6a1389fe5c3bef2301d294b88263628e">gpt_pwm_output_delay_edge_t</a> </td></tr>
<tr class="separator:ga6a1389fe5c3bef2301d294b88263628e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6382ba99cb9e28fd3580598dee92b6dd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_p_t.html#ga6382ba99cb9e28fd3580598dee92b6dd">gpt_gtioc_polarity_t</a> </td></tr>
<tr class="separator:ga6382ba99cb9e28fd3580598dee92b6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structgpt__output__pin__t" id="structgpt__output__pin__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structgpt__output__pin__t">&#9670;&nbsp;</a></span>gpt_output_pin_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct gpt_output_pin_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Configurations for output pins. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a5f0b69cc2d3cfe89baefcf348563df21"></a>bool</td>
<td class="fieldname">
output_enabled</td>
<td class="fielddoc">
Set to true to enable output, false to disable output. </td></tr>
<tr><td class="fieldtype">
<a id="a5805853871548d015520f71f3ab00e93"></a><a class="el" href="group___g_p_t.html#ga454c639e426428470ce78115af5d3648">gpt_pin_level_t</a></td>
<td class="fieldname">
stop_level</td>
<td class="fielddoc">
Select a stop level from <a class="el" href="group___g_p_t.html#ga454c639e426428470ce78115af5d3648">gpt_pin_level_t</a>. </td></tr>
</table>

</div>
</div>
<a name="structgpt__gtior__setting__t" id="structgpt__gtior__setting__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structgpt__gtior__setting__t">&#9670;&nbsp;</a></span>gpt_gtior_setting_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct gpt_gtior_setting_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Custom GTIOR settings used for configuring GTIOCxA and GTIOCxB pins. </p>
</div>
</div>
</div>
<a name="structgpt__instance__ctrl__t" id="structgpt__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structgpt__instance__ctrl__t">&#9670;&nbsp;</a></span>gpt_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct gpt_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Channel control block. DO NOT INITIALIZE. Initialization occurs when <a class="el" href="group___t_i_m_e_r___a_p_i.html#af49a90087a53c8019d642a3f7abaa8ad">timer_api_t::open</a> is called. </p>
</div>
</div>
</div>
<a name="structgpt__extended__pwm__cfg__t" id="structgpt__extended__pwm__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structgpt__extended__pwm__cfg__t">&#9670;&nbsp;</a></span>gpt_extended_pwm_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct gpt_extended_pwm_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>GPT extension for advanced PWM features. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ad908895a31952a884009f3a63fdac8d0"></a>uint8_t</td>
<td class="fieldname">
trough_ipl</td>
<td class="fielddoc">
Trough interrupt priority. </td></tr>
<tr><td class="fieldtype">
<a id="af69392faec97dd6cf86b0634e6b79b44"></a>IRQn_Type</td>
<td class="fieldname">
trough_irq</td>
<td class="fielddoc">
Trough interrupt. </td></tr>
<tr><td class="fieldtype">
<a id="aaf087f74d802f87ccac4e0a04e90cc04"></a><a class="el" href="group___g_p_t.html#gac13c16f82e0b7cafcdb8eb6892722943">gpt_poeg_link_t</a></td>
<td class="fieldname">
poeg_link</td>
<td class="fielddoc">
Select which POEG channel controls output disable for this GPT channel. </td></tr>
<tr><td class="fieldtype">
<a id="ac1bab8a37aeb13d8f27d05e44d567bc9"></a><a class="el" href="group___g_p_t.html#ga7e57d68f5f5d9757bab01857e8252ade">gpt_output_disable_t</a></td>
<td class="fieldname">
output_disable</td>
<td class="fielddoc">
Select which trigger sources request output disable from POEG. </td></tr>
<tr><td class="fieldtype">
<a id="aa39314cc7482a5855e27b0c2daa111ea"></a><a class="el" href="group___g_p_t.html#ga6dfe4ddfb53ba52c674039fd20b6c2b6">gpt_adc_trigger_t</a></td>
<td class="fieldname">
adc_trigger</td>
<td class="fielddoc">
Select trigger sources to start A/D conversion. </td></tr>
<tr><td class="fieldtype">
<a id="ad6a0d3919d4334ec367619aecd96b0f0"></a>uint32_t</td>
<td class="fieldname">
dead_time_count_up</td>
<td class="fielddoc">
Set a dead time value for counting up. </td></tr>
<tr><td class="fieldtype">
<a id="aafd7df5d2639958e4602b2f05b877707"></a>uint32_t</td>
<td class="fieldname">
dead_time_count_down</td>
<td class="fielddoc">
Set a dead time value for counting down (available on GPT32E and GPT32EH only) </td></tr>
<tr><td class="fieldtype">
<a id="abc2a1fdb7655945b5ef571c60bf7b4b0"></a>uint32_t</td>
<td class="fieldname">
adc_a_compare_match</td>
<td class="fielddoc">
Select the compare match value used to trigger an A/D conversion start request using ELC_EVENT_GPT&lt;channel&gt;_AD_TRIG_A. </td></tr>
<tr><td class="fieldtype">
<a id="a078a97f54349c6895fbebc67857c479a"></a>uint32_t</td>
<td class="fieldname">
adc_b_compare_match</td>
<td class="fielddoc">
Select the compare match value used to trigger an A/D conversion start request using ELC_EVENT_GPT&lt;channel&gt;_AD_TRIG_B. </td></tr>
<tr><td class="fieldtype">
<a id="a4d31e40df7ea5e4be69fcbbe559a8213"></a><a class="el" href="group___g_p_t.html#ga88d6114404f61d9ca10684f393deb613">gpt_interrupt_skip_source_t</a></td>
<td class="fieldname">
interrupt_skip_source</td>
<td class="fielddoc">
Interrupt source to count for interrupt skipping. </td></tr>
<tr><td class="fieldtype">
<a id="ac516350c554b9851aa9c66615e89b93b"></a><a class="el" href="group___g_p_t.html#gac737ceea25e4989a9afbf47969a71ba3">gpt_interrupt_skip_count_t</a></td>
<td class="fieldname">
interrupt_skip_count</td>
<td class="fielddoc">
Number of interrupts to skip between events. </td></tr>
<tr><td class="fieldtype">
<a id="ab5abdaac972544ec4e58df69d1f8a08f"></a><a class="el" href="group___g_p_t.html#ga9928e374919fa53240edaca52412beaa">gpt_interrupt_skip_adc_t</a></td>
<td class="fieldname">
interrupt_skip_adc</td>
<td class="fielddoc">
ADC events to skip when interrupt skipping is enabled. </td></tr>
<tr><td class="fieldtype">
<a id="af8c63e238ee298b4f1dac545a597eff7"></a><a class="el" href="group___g_p_t.html#ga82d61d33edf38d50f1247d1d55ec506b">gpt_gtioc_disable_t</a></td>
<td class="fieldname">
gtioca_disable_setting</td>
<td class="fielddoc">
Select how to configure GTIOCA when output is disabled. </td></tr>
<tr><td class="fieldtype">
<a id="aa34079abac90aaced078650c626c9820"></a><a class="el" href="group___g_p_t.html#ga82d61d33edf38d50f1247d1d55ec506b">gpt_gtioc_disable_t</a></td>
<td class="fieldname">
gtiocb_disable_setting</td>
<td class="fielddoc">
Select how to configure GTIOCB when output is disabled. </td></tr>
</table>

</div>
</div>
<a name="structgpt__extended__cfg__t" id="structgpt__extended__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structgpt__extended__cfg__t">&#9670;&nbsp;</a></span>gpt_extended_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct gpt_extended_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>GPT extension configures the output pins for GPT. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ad323c6db6a695028d2926dfbf0a0dda8"></a><a class="el" href="group___g_p_t.html#structgpt__output__pin__t">gpt_output_pin_t</a></td>
<td class="fieldname">
gtioca</td>
<td class="fielddoc">
Configuration for GPT I/O pin A. </td></tr>
<tr><td class="fieldtype">
<a id="a78476af74debd54ee8394dd0aa6d2505"></a><a class="el" href="group___g_p_t.html#structgpt__output__pin__t">gpt_output_pin_t</a></td>
<td class="fieldname">
gtiocb</td>
<td class="fielddoc">
Configuration for GPT I/O pin B. </td></tr>
<tr><td class="fieldtype">
<a id="a3b894424ab45e17d02938de9c211911a"></a><a class="el" href="group___g_p_t.html#gaa1457c9c1f178fff4dd1558832db196a">gpt_source_t</a></td>
<td class="fieldname">
start_source</td>
<td class="fielddoc">
Event sources that trigger the timer to start. </td></tr>
<tr><td class="fieldtype">
<a id="a41333514ba7ccb2b4e2d6475a51dcc26"></a><a class="el" href="group___g_p_t.html#gaa1457c9c1f178fff4dd1558832db196a">gpt_source_t</a></td>
<td class="fieldname">
stop_source</td>
<td class="fielddoc">
Event sources that trigger the timer to stop. </td></tr>
<tr><td class="fieldtype">
<a id="ad5614740946c3c06e1633d369d08f5c3"></a><a class="el" href="group___g_p_t.html#gaa1457c9c1f178fff4dd1558832db196a">gpt_source_t</a></td>
<td class="fieldname">
clear_source</td>
<td class="fielddoc">
Event sources that trigger the timer to clear. </td></tr>
<tr><td class="fieldtype">
<a id="aad7e19c30d43b6d0f88943c27e9afa4c"></a><a class="el" href="group___g_p_t.html#gaa1457c9c1f178fff4dd1558832db196a">gpt_source_t</a></td>
<td class="fieldname">
capture_a_source</td>
<td class="fielddoc">
Event sources that trigger capture of GTIOCA. </td></tr>
<tr><td class="fieldtype">
<a id="aca22811f5aebe0ee236214b53f9f6bbd"></a><a class="el" href="group___g_p_t.html#gaa1457c9c1f178fff4dd1558832db196a">gpt_source_t</a></td>
<td class="fieldname">
capture_b_source</td>
<td class="fielddoc">
Event sources that trigger capture of GTIOCB. </td></tr>
<tr><td class="fieldtype">
<a id="ae96b1fce9515b779078f947aa3885618"></a><a class="el" href="group___g_p_t.html#gaa1457c9c1f178fff4dd1558832db196a">gpt_source_t</a></td>
<td class="fieldname">
count_up_source</td>
<td class="fielddoc">
<p>Event sources that trigger a single up count. If GPT_SOURCE_NONE is selected for both count_up_source and count_down_source, then the timer count source is PCLK. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a2ecf880963c441f20c3c8a2ac7a854ea"></a><a class="el" href="group___g_p_t.html#gaa1457c9c1f178fff4dd1558832db196a">gpt_source_t</a></td>
<td class="fieldname">
count_down_source</td>
<td class="fielddoc">
<p>Event sources that trigger a single down count. If GPT_SOURCE_NONE is selected for both count_up_source and count_down_source, then the timer count source is PCLK. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac51fec5c943957b888ffa9be91f33615"></a><a class="el" href="group___g_p_t.html#ga4781e2b42b2ef339318ea0a70b250cd5">gpt_capture_filter_t</a></td>
<td class="fieldname">
capture_filter_gtioca</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a3ba662387c753b54c5509f283ff1857e"></a><a class="el" href="group___g_p_t.html#ga4781e2b42b2ef339318ea0a70b250cd5">gpt_capture_filter_t</a></td>
<td class="fieldname">
capture_filter_gtiocb</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a7e5402bac34e2c3d3006b68ee0b8ab2a"></a>uint8_t</td>
<td class="fieldname">
capture_a_ipl</td>
<td class="fielddoc">
Capture A interrupt priority. </td></tr>
<tr><td class="fieldtype">
<a id="aae4ebebdd346531add1c9ce3bee52106"></a>uint8_t</td>
<td class="fieldname">
capture_b_ipl</td>
<td class="fielddoc">
Capture B interrupt priority. </td></tr>
<tr><td class="fieldtype">
<a id="a630c77adb426ddddb5eac8b974fd7c85"></a>IRQn_Type</td>
<td class="fieldname">
capture_a_irq</td>
<td class="fielddoc">
Capture A interrupt. </td></tr>
<tr><td class="fieldtype">
<a id="a22eb63abdf43064c9c83d81287c67c88"></a>IRQn_Type</td>
<td class="fieldname">
capture_b_irq</td>
<td class="fielddoc">
Capture B interrupt. </td></tr>
<tr><td class="fieldtype">
<a id="a675417f6a403fed9258fe678ae934171"></a>uint32_t</td>
<td class="fieldname">
compare_match_value[2]</td>
<td class="fielddoc">
Storing compare match value for channels. </td></tr>
<tr><td class="fieldtype">
<a id="a9220b2bd52f1ae03647b04e48610b8ff"></a>uint8_t</td>
<td class="fieldname">
compare_match_status</td>
<td class="fielddoc">
Storing the compare match register status. </td></tr>
<tr><td class="fieldtype">
<a id="a55e5f85f57b77fd7ee5a1de7ff39da27"></a><a class="el" href="group___g_p_t.html#structgpt__extended__pwm__cfg__t">gpt_extended_pwm_cfg_t</a> const  *</td>
<td class="fieldname">
p_pwm_cfg</td>
<td class="fielddoc">
Advanced PWM features, optional. </td></tr>
<tr><td class="fieldtype">
<a id="ad8b8b467339a151f016017d175df2f9c"></a><a class="el" href="group___g_p_t.html#structgpt__gtior__setting__t">gpt_gtior_setting_t</a></td>
<td class="fieldname">
gtior_setting</td>
<td class="fielddoc">
Custom GTIOR settings used for configuring GTIOCxA and GTIOCxB pins. </td></tr>
<tr><td class="fieldtype">
<a id="ac74969a4dcc449fc1f94742f70754a5d"></a><a class="el" href="group___g_p_t.html#ga6382ba99cb9e28fd3580598dee92b6dd">gpt_gtioc_polarity_t</a></td>
<td class="fieldname">
gtioca_polarity</td>
<td class="fielddoc">
Polarity control for GTIOCxA input/output pin. </td></tr>
<tr><td class="fieldtype">
<a id="ad169a7acd47a1cdaeab62ea659a0a4d3"></a><a class="el" href="group___g_p_t.html#ga6382ba99cb9e28fd3580598dee92b6dd">gpt_gtioc_polarity_t</a></td>
<td class="fieldname">
gtiocb_polarity</td>
<td class="fielddoc">
Polarity control for GTIOCxB input/output pin. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaabd4a03d16b1b4254cc44c7779f44c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabd4a03d16b1b4254cc44c7779f44c60">&#9670;&nbsp;</a></span>gpt_io_pin_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___g_p_t.html#gaabd4a03d16b1b4254cc44c7779f44c60">gpt_io_pin_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Input/Output pins, used to select which duty cycle to update in <a class="el" href="group___g_p_t.html#gad14bacf6fb7fce88f3e877160be529ea">R_GPT_DutyCycleSet()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaabd4a03d16b1b4254cc44c7779f44c60aec2d2c471241869efb57a9a48a5d0eda"></a>GPT_IO_PIN_GTIOCA&#160;</td><td class="fielddoc"><p>GTIOCA. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaabd4a03d16b1b4254cc44c7779f44c60aebd74a7b9507fb082ec4cce60ebe9369"></a>GPT_IO_PIN_GTIOCB&#160;</td><td class="fielddoc"><p>GTIOCB. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaabd4a03d16b1b4254cc44c7779f44c60a2b44d1e05050c34cc6e8d9ee4093294d"></a>GPT_IO_PIN_GTIOCA_AND_GTIOCB&#160;</td><td class="fielddoc"><p>GTIOCA and GTIOCB. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaabd4a03d16b1b4254cc44c7779f44c60ac68b7e1ef5c48c55960faacd7eb538b9"></a>GPT_IO_PIN_TROUGH&#160;</td><td class="fielddoc"><p>Used in <a class="el" href="group___g_p_t.html#gad14bacf6fb7fce88f3e877160be529ea">R_GPT_DutyCycleSet</a> when Triangle-wave PWM Mode 3 is selected. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaabd4a03d16b1b4254cc44c7779f44c60acb3ba96929217eb6bb1ec5b2f1ccf9d4"></a>GPT_IO_PIN_CREST&#160;</td><td class="fielddoc"><p>Used in <a class="el" href="group___g_p_t.html#gad14bacf6fb7fce88f3e877160be529ea">R_GPT_DutyCycleSet</a> when Triangle-wave PWM Mode 3 is selected. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaabd4a03d16b1b4254cc44c7779f44c60ae3e479af00c84f4ccf6e7376b4b44c8d"></a>GPT_IO_PIN_ONE_SHOT_LEADING_EDGE&#160;</td><td class="fielddoc"><p>Used in <a class="el" href="group___g_p_t.html#gad14bacf6fb7fce88f3e877160be529ea">R_GPT_DutyCycleSet</a> to set GTCCRC and GTCCRE registers when One-Shot Pulse mode is selected. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaabd4a03d16b1b4254cc44c7779f44c60a59f7576cde98e497d35b98a926732e52"></a>GPT_IO_PIN_ONE_SHOT_TRAILING_EDGE&#160;</td><td class="fielddoc"><p>Used in <a class="el" href="group___g_p_t.html#gad14bacf6fb7fce88f3e877160be529ea">R_GPT_DutyCycleSet</a> to set GTCCRD and GTCCRF registers when One-Shot Pulse mode is selected. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga8abd050b841fe99c9b641a22c69501c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8abd050b841fe99c9b641a22c69501c5">&#9670;&nbsp;</a></span>gpt_buffer_force_push</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___g_p_t.html#ga8abd050b841fe99c9b641a22c69501c5">gpt_buffer_force_push</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Forced buffer push operation used in One-Sot Pulse mode with <a class="el" href="group___g_p_t.html#gad14bacf6fb7fce88f3e877160be529ea">R_GPT_DutyCycleSet()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga8abd050b841fe99c9b641a22c69501c5a23c94706bd1a34c9f1b9cfffea30f4cc"></a>GPT_BUFFER_FORCE_PUSH&#160;</td><td class="fielddoc"><p>Used in <a class="el" href="group___g_p_t.html#gad14bacf6fb7fce88f3e877160be529ea">R_GPT_DutyCycleSet</a> to force push the data from GTCCRn registers to temporary buffer A or B when One-Shot Pulse mode is selected. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga454c639e426428470ce78115af5d3648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga454c639e426428470ce78115af5d3648">&#9670;&nbsp;</a></span>gpt_pin_level_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___g_p_t.html#ga454c639e426428470ce78115af5d3648">gpt_pin_level_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Level of GPT pin </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga454c639e426428470ce78115af5d3648a3270f1165e7a86c5b12eecb9501390f4"></a>GPT_PIN_LEVEL_LOW&#160;</td><td class="fielddoc"><p>Pin level low. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga454c639e426428470ce78115af5d3648adc8ebfd0f787322b884ca5d087b3a6a3"></a>GPT_PIN_LEVEL_HIGH&#160;</td><td class="fielddoc"><p>Pin level high. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaa1457c9c1f178fff4dd1558832db196a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1457c9c1f178fff4dd1558832db196a">&#9670;&nbsp;</a></span>gpt_source_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___g_p_t.html#gaa1457c9c1f178fff4dd1558832db196a">gpt_source_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sources can be used to start the timer, stop the timer, count up, or count down. These enumerations represent a bitmask. Multiple sources can be ORed together. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aae376db52803d52361481b2384c3a3bd8"></a>GPT_SOURCE_NONE&#160;</td><td class="fielddoc"><p>No active event sources. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aa2ea3ebb2e30c10d0c5c087e198175220"></a>GPT_SOURCE_GTETRGA_RISING&#160;</td><td class="fielddoc"><p>Action performed on GTETRGA rising edge. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aab4c7fdaf7cfdd2d3730525965e68c982"></a>GPT_SOURCE_GTETRGA_FALLING&#160;</td><td class="fielddoc"><p>Action performed on GTETRGA falling edge. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aa7af2b58b26be8c9b04ec5c31fdd66bab"></a>GPT_SOURCE_GTETRGB_RISING&#160;</td><td class="fielddoc"><p>Action performed on GTETRGB rising edge. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aad01f879dc9132b0e05827cc7f4219a81"></a>GPT_SOURCE_GTETRGB_FALLING&#160;</td><td class="fielddoc"><p>Action performed on GTETRGB falling edge. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aa5daee2c8037bdc04a019192efdd8af09"></a>GPT_SOURCE_GTETRGC_RISING&#160;</td><td class="fielddoc"><p>Action performed on GTETRGC rising edge. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aaceecdd0276a5d1591246c1a2a294ddd3"></a>GPT_SOURCE_GTETRGC_FALLING&#160;</td><td class="fielddoc"><p>Action performed on GTETRGC falling edge. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aaaa3e97349fb24f8ba0a431392a92f95e"></a>GPT_SOURCE_GTETRGD_RISING&#160;</td><td class="fielddoc"><p>Action performed on GTETRGB rising edge. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aad6f7ad7ca2dce583089104f23e27ed2c"></a>GPT_SOURCE_GTETRGD_FALLING&#160;</td><td class="fielddoc"><p>Action performed on GTETRGB falling edge. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aa1435f9ba57da19cfc255ea6f64ea7853"></a>GPT_SOURCE_GTIOCA_RISING_WHILE_GTIOCB_LOW&#160;</td><td class="fielddoc"><p>Action performed when GTIOCA input rises while GTIOCB is low. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aaa03328ca033b8043537b813ecabe1c50"></a>GPT_SOURCE_GTIOCA_RISING_WHILE_GTIOCB_HIGH&#160;</td><td class="fielddoc"><p>Action performed when GTIOCA input rises while GTIOCB is high. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aa58b8714367e4bb5ec9eb6902c98fdb2e"></a>GPT_SOURCE_GTIOCA_FALLING_WHILE_GTIOCB_LOW&#160;</td><td class="fielddoc"><p>Action performed when GTIOCA input falls while GTIOCB is low. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aab844b52adc17cebabf04603fa993f176"></a>GPT_SOURCE_GTIOCA_FALLING_WHILE_GTIOCB_HIGH&#160;</td><td class="fielddoc"><p>Action performed when GTIOCA input falls while GTIOCB is high. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aa4b546eda998208d87d6da5d0ad2f927a"></a>GPT_SOURCE_GTIOCB_RISING_WHILE_GTIOCA_LOW&#160;</td><td class="fielddoc"><p>Action performed when GTIOCB input rises while GTIOCA is low. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aaf6245811e4016299ba0acf0575389ba6"></a>GPT_SOURCE_GTIOCB_RISING_WHILE_GTIOCA_HIGH&#160;</td><td class="fielddoc"><p>Action performed when GTIOCB input rises while GTIOCA is high. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aa3c659f3a22223a65ffdc96524249eec7"></a>GPT_SOURCE_GTIOCB_FALLING_WHILE_GTIOCA_LOW&#160;</td><td class="fielddoc"><p>Action performed when GTIOCB input falls while GTIOCA is low. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aa037a151c14fea20ef0530f5a995f99e5"></a>GPT_SOURCE_GTIOCB_FALLING_WHILE_GTIOCA_HIGH&#160;</td><td class="fielddoc"><p>Action performed when GTIOCB input falls while GTIOCA is high. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aa8a81917a5ac9b747df42b174e5ae1ee6"></a>GPT_SOURCE_GPT_A&#160;</td><td class="fielddoc"><p>Action performed on ELC GPTA event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aa7b3ab8f76f2a808dbace3ede3e3faf06"></a>GPT_SOURCE_GPT_B&#160;</td><td class="fielddoc"><p>Action performed on ELC GPTB event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aaeb63eaa38e2640b48259ddf029c27f54"></a>GPT_SOURCE_GPT_C&#160;</td><td class="fielddoc"><p>Action performed on ELC GPTC event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aaa23869f7d7ae4b5d82dac3d2301959b9"></a>GPT_SOURCE_GPT_D&#160;</td><td class="fielddoc"><p>Action performed on ELC GPTD event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aaff70b0b5e755028cd77f859abb16fe06"></a>GPT_SOURCE_GPT_E&#160;</td><td class="fielddoc"><p>Action performed on ELC GPTE event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aa010a99aa6c4e838ac1bce47abcbe38e5"></a>GPT_SOURCE_GPT_F&#160;</td><td class="fielddoc"><p>Action performed on ELC GPTF event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aa51db9e1734d93f834b00868a9246db95"></a>GPT_SOURCE_GPT_G&#160;</td><td class="fielddoc"><p>Action performed on ELC GPTG event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1457c9c1f178fff4dd1558832db196aa19df9d1f4ee5e610a74642fc14a212a3"></a>GPT_SOURCE_GPT_H&#160;</td><td class="fielddoc"><p>Action performed on ELC GPTH event. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga4781e2b42b2ef339318ea0a70b250cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4781e2b42b2ef339318ea0a70b250cd5">&#9670;&nbsp;</a></span>gpt_capture_filter_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___g_p_t.html#ga4781e2b42b2ef339318ea0a70b250cd5">gpt_capture_filter_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Input capture signal noise filter (debounce) setting. Only available for input signals GTIOCxA and GTIOCxB. The noise filter samples the external signal at intervals of the PCLK divided by one of the values. When 3 consecutive samples are at the same level (high or low), then that level is passed on as the observed state of the signal. See "Noise Filter Function" in the hardware manual, GPT section. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4781e2b42b2ef339318ea0a70b250cd5a9b2d993dbb736347b473101f14c1fde6"></a>GPT_CAPTURE_FILTER_NONE&#160;</td><td class="fielddoc"><p>None - no filtering. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4781e2b42b2ef339318ea0a70b250cd5adb3e7f4af05808c080e29f22c6b71c3a"></a>GPT_CAPTURE_FILTER_PCLKD_DIV_1&#160;</td><td class="fielddoc"><p>PCLK/1 - fast sampling. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4781e2b42b2ef339318ea0a70b250cd5adbeb79df335efd366023ec9118407de8"></a>GPT_CAPTURE_FILTER_PCLKD_DIV_4&#160;</td><td class="fielddoc"><p>PCLK/4. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4781e2b42b2ef339318ea0a70b250cd5a4058fd8fd2af5d30c572dd8aacc5ae9a"></a>GPT_CAPTURE_FILTER_PCLKD_DIV_16&#160;</td><td class="fielddoc"><p>PCLK/16. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4781e2b42b2ef339318ea0a70b250cd5a37769ce411256b3c4ec01cb1eed5a825"></a>GPT_CAPTURE_FILTER_PCLKD_DIV_64&#160;</td><td class="fielddoc"><p>PCLK/64 - slow sampling. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga6dfe4ddfb53ba52c674039fd20b6c2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dfe4ddfb53ba52c674039fd20b6c2b6">&#9670;&nbsp;</a></span>gpt_adc_trigger_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___g_p_t.html#ga6dfe4ddfb53ba52c674039fd20b6c2b6">gpt_adc_trigger_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Trigger options to start A/D conversion. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6dfe4ddfb53ba52c674039fd20b6c2b6a2818f2fff3a64fd3086a7230dabd7a14"></a>GPT_ADC_TRIGGER_NONE&#160;</td><td class="fielddoc"><p>None - no output disable request. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6dfe4ddfb53ba52c674039fd20b6c2b6a2bd0475913403dab220b5e7d6c1acf72"></a>GPT_ADC_TRIGGER_UP_COUNT_START_ADC_A&#160;</td><td class="fielddoc"><p>Request A/D conversion from ADC unit 0 at up counting compare match of <a class="el" href="group___g_p_t.html#abc2a1fdb7655945b5ef571c60bf7b4b0">gpt_extended_pwm_cfg_t::adc_a_compare_match</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6dfe4ddfb53ba52c674039fd20b6c2b6afd744cee1c5e631263a043ec92af7510"></a>GPT_ADC_TRIGGER_DOWN_COUNT_START_ADC_A&#160;</td><td class="fielddoc"><p>Request A/D conversion from ADC unit 0 at down counting compare match of <a class="el" href="group___g_p_t.html#abc2a1fdb7655945b5ef571c60bf7b4b0">gpt_extended_pwm_cfg_t::adc_a_compare_match</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6dfe4ddfb53ba52c674039fd20b6c2b6a850b0227fd4a50c51c146d44efe7c838"></a>GPT_ADC_TRIGGER_UP_COUNT_START_ADC_B&#160;</td><td class="fielddoc"><p>Request A/D conversion from ADC unit 1 at up counting compare match of <a class="el" href="group___g_p_t.html#a078a97f54349c6895fbebc67857c479a">gpt_extended_pwm_cfg_t::adc_b_compare_match</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6dfe4ddfb53ba52c674039fd20b6c2b6a0d5922b5221be7b92ce2218c2d8fb50c"></a>GPT_ADC_TRIGGER_DOWN_COUNT_START_ADC_B&#160;</td><td class="fielddoc"><p>Request A/D conversion from ADC unit 1 at down counting compare match of <a class="el" href="group___g_p_t.html#a078a97f54349c6895fbebc67857c479a">gpt_extended_pwm_cfg_t::adc_b_compare_match</a>. </p>
</td></tr>
</table>

</div>
</div>
<a id="gac13c16f82e0b7cafcdb8eb6892722943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac13c16f82e0b7cafcdb8eb6892722943">&#9670;&nbsp;</a></span>gpt_poeg_link_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___g_p_t.html#gac13c16f82e0b7cafcdb8eb6892722943">gpt_poeg_link_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>POEG channel to link to this channel. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac13c16f82e0b7cafcdb8eb6892722943ae96e3845c4ea884a6d610a745a2c343c"></a>GPT_POEG_LINK_POEG0&#160;</td><td class="fielddoc"><p>Link this GPT channel to POEG channel 0 (GTETRGA) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac13c16f82e0b7cafcdb8eb6892722943ae9be405a3d64f348534f67710b37658c"></a>GPT_POEG_LINK_POEG1&#160;</td><td class="fielddoc"><p>Link this GPT channel to POEG channel 1 (GTETRGB) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac13c16f82e0b7cafcdb8eb6892722943a41eefcd7c70c85413a47d006127e112e"></a>GPT_POEG_LINK_POEG2&#160;</td><td class="fielddoc"><p>Link this GPT channel to POEG channel 2 (GTETRGC) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac13c16f82e0b7cafcdb8eb6892722943a7d98bec67e920f1f0f8a98ac18aaa7b5"></a>GPT_POEG_LINK_POEG3&#160;</td><td class="fielddoc"><p>Link this GPT channel to POEG channel 3 (GTETRGD) </p>
</td></tr>
</table>

</div>
</div>
<a id="ga7e57d68f5f5d9757bab01857e8252ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e57d68f5f5d9757bab01857e8252ade">&#9670;&nbsp;</a></span>gpt_output_disable_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___g_p_t.html#ga7e57d68f5f5d9757bab01857e8252ade">gpt_output_disable_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select trigger to send output disable request to POEG. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga7e57d68f5f5d9757bab01857e8252adeaa35910cb9d2f17f2488b4efdcb1b1fe9"></a>GPT_OUTPUT_DISABLE_NONE&#160;</td><td class="fielddoc"><p>None - no output disable request. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7e57d68f5f5d9757bab01857e8252adea36ab56234fbe2b5bb676c0962382bd96"></a>GPT_OUTPUT_DISABLE_DEAD_TIME_ERROR&#160;</td><td class="fielddoc"><p>Request output disable if a dead time error occurs. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7e57d68f5f5d9757bab01857e8252adea236f4400f00369f754b3b88c8efc35a7"></a>GPT_OUTPUT_DISABLE_GTIOCA_GTIOCB_HIGH&#160;</td><td class="fielddoc"><p>Request output disable if GTIOCA and GTIOCB are high at the same time. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7e57d68f5f5d9757bab01857e8252adea3004c3e75921fa586fdf0538b7ef5abe"></a>GPT_OUTPUT_DISABLE_GTIOCA_GTIOCB_LOW&#160;</td><td class="fielddoc"><p>Request output disable if GTIOCA and GTIOCB are low at the same time. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga82d61d33edf38d50f1247d1d55ec506b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82d61d33edf38d50f1247d1d55ec506b">&#9670;&nbsp;</a></span>gpt_gtioc_disable_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___g_p_t.html#ga82d61d33edf38d50f1247d1d55ec506b">gpt_gtioc_disable_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable level options for GTIOC pins. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga82d61d33edf38d50f1247d1d55ec506ba1756f7251a83337222f68cc80bc33dfb"></a>GPT_GTIOC_DISABLE_PROHIBITED&#160;</td><td class="fielddoc"><p>Do not allow output disable. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga82d61d33edf38d50f1247d1d55ec506bab3661e69b77c3086864f7872d264be75"></a>GPT_GTIOC_DISABLE_SET_HI_Z&#160;</td><td class="fielddoc"><p>Set GTIOC to high impedance when output is disabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga82d61d33edf38d50f1247d1d55ec506babb7208f6cf212d2da6b806bf7f094ca5"></a>GPT_GTIOC_DISABLE_LEVEL_LOW&#160;</td><td class="fielddoc"><p>Set GTIOC level low when output is disabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga82d61d33edf38d50f1247d1d55ec506ba2cd233e999331d566eafc32cd29ae9d0"></a>GPT_GTIOC_DISABLE_LEVEL_HIGH&#160;</td><td class="fielddoc"><p>Set GTIOC level high when output is disabled. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga2a838fffcbafd97778bbe3ffbfbf54b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a838fffcbafd97778bbe3ffbfbf54b1">&#9670;&nbsp;</a></span>gpt_adc_compare_match_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___g_p_t.html#ga2a838fffcbafd97778bbe3ffbfbf54b1">gpt_adc_compare_match_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Trigger options to start A/D conversion. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2a838fffcbafd97778bbe3ffbfbf54b1a6f5dba4e42352f1bea9dccd3201021cc"></a>GPT_ADC_COMPARE_MATCH_ADC_A&#160;</td><td class="fielddoc"><p>Set A/D conversion start request value for GPT A/D converter start request A. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2a838fffcbafd97778bbe3ffbfbf54b1abc17524a1e6137946784a36c5d31f27b"></a>GPT_ADC_COMPARE_MATCH_ADC_B&#160;</td><td class="fielddoc"><p>Set A/D conversion start request value for GPT A/D converter start request B. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga88d6114404f61d9ca10684f393deb613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88d6114404f61d9ca10684f393deb613">&#9670;&nbsp;</a></span>gpt_interrupt_skip_source_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___g_p_t.html#ga88d6114404f61d9ca10684f393deb613">gpt_interrupt_skip_source_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interrupt skipping modes </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga88d6114404f61d9ca10684f393deb613a88ebf7e3d8a17fa38f3a3251e76b76d4"></a>GPT_INTERRUPT_SKIP_SOURCE_NONE&#160;</td><td class="fielddoc"><p>Do not skip interrupts. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga88d6114404f61d9ca10684f393deb613a8525d45b1517b92b3b6d6f5b5a301083"></a>GPT_INTERRUPT_SKIP_SOURCE_OVERFLOW_UNDERFLOW&#160;</td><td class="fielddoc"><p>Count and skip overflow and underflow interrupts. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga88d6114404f61d9ca10684f393deb613a297710907b10befa05faa051f2e32be0"></a>GPT_INTERRUPT_SKIP_SOURCE_CREST&#160;</td><td class="fielddoc"><p>Count crest interrupts for interrupt skipping. Skip the number of crest and trough interrupts configured in <a class="el" href="group___g_p_t.html#gac737ceea25e4989a9afbf47969a71ba3">gpt_interrupt_skip_count_t</a>. When the interrupt does fire, the trough interrupt fires before the crest interrupt. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga88d6114404f61d9ca10684f393deb613a75e3083840b7df9aa2883cded3cd2704"></a>GPT_INTERRUPT_SKIP_SOURCE_TROUGH&#160;</td><td class="fielddoc"><p>Count trough interrupts for interrupt skipping. Skip the number of crest and trough interrupts configured in <a class="el" href="group___g_p_t.html#gac737ceea25e4989a9afbf47969a71ba3">gpt_interrupt_skip_count_t</a>. When the interrupt does fire, the crest interrupt fires before the trough interrupt. </p>
</td></tr>
</table>

</div>
</div>
<a id="gac737ceea25e4989a9afbf47969a71ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac737ceea25e4989a9afbf47969a71ba3">&#9670;&nbsp;</a></span>gpt_interrupt_skip_count_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___g_p_t.html#gac737ceea25e4989a9afbf47969a71ba3">gpt_interrupt_skip_count_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of interrupts to skip between events </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac737ceea25e4989a9afbf47969a71ba3a6a175bfcdc5102e24b2f10726968262e"></a>GPT_INTERRUPT_SKIP_COUNT_0&#160;</td><td class="fielddoc"><p>Do not skip interrupts. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac737ceea25e4989a9afbf47969a71ba3a0168263b8e97f370e2d999e40e57689a"></a>GPT_INTERRUPT_SKIP_COUNT_1&#160;</td><td class="fielddoc"><p>Skip one interrupt. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac737ceea25e4989a9afbf47969a71ba3af6d98ec31f682d5439b5381dcb5305e4"></a>GPT_INTERRUPT_SKIP_COUNT_2&#160;</td><td class="fielddoc"><p>Skip two interrupts. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac737ceea25e4989a9afbf47969a71ba3a3551066dcaffb033a40d7e329169a345"></a>GPT_INTERRUPT_SKIP_COUNT_3&#160;</td><td class="fielddoc"><p>Skip three interrupts. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac737ceea25e4989a9afbf47969a71ba3ab30f5da89de49b73e5d27e376a6702d9"></a>GPT_INTERRUPT_SKIP_COUNT_4&#160;</td><td class="fielddoc"><p>Skip four interrupts. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac737ceea25e4989a9afbf47969a71ba3a21aec2bf2296497576f4f746e83078e9"></a>GPT_INTERRUPT_SKIP_COUNT_5&#160;</td><td class="fielddoc"><p>Skip five interrupts. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac737ceea25e4989a9afbf47969a71ba3a46d2a195d3c9ab5c94c949ce243fbc46"></a>GPT_INTERRUPT_SKIP_COUNT_6&#160;</td><td class="fielddoc"><p>Skip six interrupts. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac737ceea25e4989a9afbf47969a71ba3a1f87ae8bbf43b55f063cbcdbdc329d18"></a>GPT_INTERRUPT_SKIP_COUNT_7&#160;</td><td class="fielddoc"><p>Skip seven interrupts. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga9928e374919fa53240edaca52412beaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9928e374919fa53240edaca52412beaa">&#9670;&nbsp;</a></span>gpt_interrupt_skip_adc_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___g_p_t.html#ga9928e374919fa53240edaca52412beaa">gpt_interrupt_skip_adc_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADC events to skip during interrupt skipping </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9928e374919fa53240edaca52412beaaa9dee91a158ffa61d322cbbdac1ed99bd"></a>GPT_INTERRUPT_SKIP_ADC_NONE&#160;</td><td class="fielddoc"><p>Do not skip ADC events. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9928e374919fa53240edaca52412beaaa43c4146c6bbaa9877dc6f1a34b6ccacf"></a>GPT_INTERRUPT_SKIP_ADC_A&#160;</td><td class="fielddoc"><p>Skip ADC A events. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9928e374919fa53240edaca52412beaaa9bc6d33154685e53dab457675e8161e8"></a>GPT_INTERRUPT_SKIP_ADC_B&#160;</td><td class="fielddoc"><p>Skip ADC B events. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9928e374919fa53240edaca52412beaaa872ee214e5d3998245ac518730f9dde6"></a>GPT_INTERRUPT_SKIP_ADC_A_AND_B&#160;</td><td class="fielddoc"><p>Skip ADC A and B events. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga749be81f99469c5607a684976d9ae374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga749be81f99469c5607a684976d9ae374">&#9670;&nbsp;</a></span>gpt_pwm_output_delay_setting_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___g_p_t.html#ga749be81f99469c5607a684976d9ae374">gpt_pwm_output_delay_setting_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delay setting for the PWM Delay Generation Circuit (PDG). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374ae167098278c50165bf61eec5987d4c53"></a>GPT_PWM_OUTPUT_DELAY_SETTING_0_32&#160;</td><td class="fielddoc"><p>Delay is not applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374a61477e753d166ccb25b77eced2e6f325"></a>GPT_PWM_OUTPUT_DELAY_SETTING_1_32&#160;</td><td class="fielddoc"><p>Delay of 1 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374a39fed861a0d36f04aa30f3f960e3d2d0"></a>GPT_PWM_OUTPUT_DELAY_SETTING_2_32&#160;</td><td class="fielddoc"><p>Delay of 2 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374a1f1aee9567a12196581000383e8d107b"></a>GPT_PWM_OUTPUT_DELAY_SETTING_3_32&#160;</td><td class="fielddoc"><p>Delay of 3 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374a8b235f3b68210961a821c11efa5bb205"></a>GPT_PWM_OUTPUT_DELAY_SETTING_4_32&#160;</td><td class="fielddoc"><p>Delay of 4 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374af0aae115f89d76e4f3f48a0d36cf361b"></a>GPT_PWM_OUTPUT_DELAY_SETTING_5_32&#160;</td><td class="fielddoc"><p>Delay of 5 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374a5e6950d7178ff3af05f8f4932436b488"></a>GPT_PWM_OUTPUT_DELAY_SETTING_6_32&#160;</td><td class="fielddoc"><p>Delay of 6 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374a6984fb835233689f0aaebc39c5f9c000"></a>GPT_PWM_OUTPUT_DELAY_SETTING_7_32&#160;</td><td class="fielddoc"><p>Delay of 7 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374acdb2fab565c1d8a20bdfb3822f326e81"></a>GPT_PWM_OUTPUT_DELAY_SETTING_8_32&#160;</td><td class="fielddoc"><p>Delay of 8 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374a0287632773cfa466bfa3016d67f14da5"></a>GPT_PWM_OUTPUT_DELAY_SETTING_9_32&#160;</td><td class="fielddoc"><p>Delay of 9 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374a196975439836e309f6244a8c0446f047"></a>GPT_PWM_OUTPUT_DELAY_SETTING_10_32&#160;</td><td class="fielddoc"><p>Delay of 10 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374a0198b5305a0a6853fc433ecf75d44f7f"></a>GPT_PWM_OUTPUT_DELAY_SETTING_11_32&#160;</td><td class="fielddoc"><p>Delay of 11 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374a1948c35883b0b199c8e6f89a64e53475"></a>GPT_PWM_OUTPUT_DELAY_SETTING_12_32&#160;</td><td class="fielddoc"><p>Delay of 12 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374a44d17777c6bee08909a70b95f86dc991"></a>GPT_PWM_OUTPUT_DELAY_SETTING_13_32&#160;</td><td class="fielddoc"><p>Delay of 13 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374a061a1822b878e73e25a3f5cc90ea0eea"></a>GPT_PWM_OUTPUT_DELAY_SETTING_14_32&#160;</td><td class="fielddoc"><p>Delay of 14 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374a8d827fe46b88273f1a3ecaafe74a6d72"></a>GPT_PWM_OUTPUT_DELAY_SETTING_15_32&#160;</td><td class="fielddoc"><p>Delay of 15 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374ac0195c74dd5aa183fe0ff13f3d037a47"></a>GPT_PWM_OUTPUT_DELAY_SETTING_16_32&#160;</td><td class="fielddoc"><p>Delay of 16 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374abc73975b9e30401bbdbb7c5da506025b"></a>GPT_PWM_OUTPUT_DELAY_SETTING_17_32&#160;</td><td class="fielddoc"><p>Delay of 17 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374a95c8ef43442706c12c2ff0d94e1fb4da"></a>GPT_PWM_OUTPUT_DELAY_SETTING_18_32&#160;</td><td class="fielddoc"><p>Delay of 18 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374ac1341d99df3034c6cebc7d6885fc46b8"></a>GPT_PWM_OUTPUT_DELAY_SETTING_19_32&#160;</td><td class="fielddoc"><p>Delay of 19 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374ad781616613593d77ed681403590659e4"></a>GPT_PWM_OUTPUT_DELAY_SETTING_20_32&#160;</td><td class="fielddoc"><p>Delay of 20 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374a84dede23a60f4e4b02604d18a7e3c80a"></a>GPT_PWM_OUTPUT_DELAY_SETTING_21_32&#160;</td><td class="fielddoc"><p>Delay of 21 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374aa29b8aeb45e93b8086d68f3ce7d60681"></a>GPT_PWM_OUTPUT_DELAY_SETTING_22_32&#160;</td><td class="fielddoc"><p>Delay of 22 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374afa386802f529b7a1e6440335f29c0803"></a>GPT_PWM_OUTPUT_DELAY_SETTING_23_32&#160;</td><td class="fielddoc"><p>Delay of 23 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374a15baac27b4f36979352681a5b5969517"></a>GPT_PWM_OUTPUT_DELAY_SETTING_24_32&#160;</td><td class="fielddoc"><p>Delay of 24 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374ab000f412ff95dd16ff74748a96a305f8"></a>GPT_PWM_OUTPUT_DELAY_SETTING_25_32&#160;</td><td class="fielddoc"><p>Delay of 25 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374a03edb9eb3fdef9a37dbc4f44a077db5a"></a>GPT_PWM_OUTPUT_DELAY_SETTING_26_32&#160;</td><td class="fielddoc"><p>Delay of 26 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374a046f632a922738bb125dd671e28fc7d8"></a>GPT_PWM_OUTPUT_DELAY_SETTING_27_32&#160;</td><td class="fielddoc"><p>Delay of 27 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374ac9942874a382d4e1f171bcd74db0ac62"></a>GPT_PWM_OUTPUT_DELAY_SETTING_28_32&#160;</td><td class="fielddoc"><p>Delay of 28 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374a9a0fa3e6bcc2de24f85ef0b9a1b4d914"></a>GPT_PWM_OUTPUT_DELAY_SETTING_29_32&#160;</td><td class="fielddoc"><p>Delay of 29 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374a1aeb241069f6fc33d5b9043bf2870596"></a>GPT_PWM_OUTPUT_DELAY_SETTING_30_32&#160;</td><td class="fielddoc"><p>Delay of 30 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374a8d0ff19f209e9c72f76c20b23a00c7a2"></a>GPT_PWM_OUTPUT_DELAY_SETTING_31_32&#160;</td><td class="fielddoc"><p>Delay of 31 / 32 GTCLK period applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga749be81f99469c5607a684976d9ae374af894b19d25eebc010ed5fc6ccea2cb29"></a>GPT_PWM_OUTPUT_DELAY_SETTING_BYPASS&#160;</td><td class="fielddoc"><p>Bypass the PWM Output Delay Circuit. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga6a1389fe5c3bef2301d294b88263628e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a1389fe5c3bef2301d294b88263628e">&#9670;&nbsp;</a></span>gpt_pwm_output_delay_edge_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___g_p_t.html#ga6a1389fe5c3bef2301d294b88263628e">gpt_pwm_output_delay_edge_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select which PWM Output Delay setting to apply. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6a1389fe5c3bef2301d294b88263628ea51901797e055f1ec3e4dbe96bff03086"></a>GPT_PWM_OUTPUT_DELAY_EDGE_RISING&#160;</td><td class="fielddoc"><p>Configure the PWM Output Delay setting for rising edge. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6a1389fe5c3bef2301d294b88263628eab5c109cf3de710e61c90c3be2d72d9b7"></a>GPT_PWM_OUTPUT_DELAY_EDGE_FALLING&#160;</td><td class="fielddoc"><p>Configure the PWM Output Delay setting for falling edge. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga6382ba99cb9e28fd3580598dee92b6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6382ba99cb9e28fd3580598dee92b6dd">&#9670;&nbsp;</a></span>gpt_gtioc_polarity_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___g_p_t.html#ga6382ba99cb9e28fd3580598dee92b6dd">gpt_gtioc_polarity_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Polarity inversion control for GTIOCnA/B pins. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6382ba99cb9e28fd3580598dee92b6ddaa4a8d9277f93ea8c88627b3849f48a61"></a>GPT_GTIOC_POLARITY_NORMAL&#160;</td><td class="fielddoc"><p>GPTIOCnA/B pin polarity is not changed. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6382ba99cb9e28fd3580598dee92b6dda281d35e2524db218c1698497d0d0bafa"></a>GPT_GTIOC_POLARITY_INVERTED&#160;</td><td class="fielddoc"><p>GPTIOCnA/B pin polarity is inverted. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga97d0a9c1a8fb6b88d1c12756dd8ce2d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97d0a9c1a8fb6b88d1c12756dd8ce2d2">&#9670;&nbsp;</a></span>R_GPT_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#structtimer__cfg__t">timer_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the timer module and applies configurations. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#af49a90087a53c8019d642a3f7abaa8ad">timer_api_t::open</a>.</p>
<p>GPT hardware does not support one-shot functionality natively. When using one-shot mode, the timer will be stopped in an ISR after the requested period has elapsed.</p>
<p>The GPT implementation of the general timer can accept a <a class="el" href="group___g_p_t.html#structgpt__extended__cfg__t">gpt_extended_cfg_t</a> extension parameter.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#ga97d0a9c1a8fb6b88d1c12756dd8ce2d2">R_GPT_Open</a>(&amp;g_timer0_ctrl, &amp;g_timer0_cfg);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Initialization was successful and timer has started. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required input pointer is NULL or the source divider is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Module is already open. </td></tr>
    <tr><td class="paramname">FSP_ERR_IRQ_BSP_DISABLED</td><td><a class="el" href="group___t_i_m_e_r___a_p_i.html#a9519afc7ea8aec3aaf1eb787b39cc97c" title="Select enumerated value from timer_mode_t. ">timer_cfg_t::mode</a> is <a class="el" href="group___t_i_m_e_r___a_p_i.html#gga6d4cd64aed5c0009ac26803efc9c13b2a140f07675d67258a7ca9a95a9a793e3a" title="Timer stops after period elapses. ">TIMER_MODE_ONE_SHOT</a> or <a class="el" href="group___t_i_m_e_r___a_p_i.html#a7d2f434f07723a53b504751e9e5ac540">timer_cfg_t::p_callback</a> is not NULL, but ISR is not enabled. ISR must be enabled to use one-shot mode or callback. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>Triangle wave PWM is only supported if GPT_CFG_OUTPUT_SUPPORT_ENABLE is 2. Selected channel does not support external count sources. External and event count sources not are available in this mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_IP_CHANNEL_NOT_PRESENT</td><td>The channel requested in the p_cfg parameter is not available on this device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1e6af74d7faaf735f5847a34121eff71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e6af74d7faaf735f5847a34121eff71">&#9670;&nbsp;</a></span>R_GPT_Stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops timer. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#aed0139dbf5102e39719ddbc51f16a21e">timer_api_t::stop</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Stop the timer. */</span></div><div class="line">    (void) <a class="code" href="group___g_p_t.html#ga1e6af74d7faaf735f5847a34121eff71">R_GPT_Stop</a>(&amp;g_timer0_ctrl);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Timer successfully stopped. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2769f9fda49613246bc84dba41aa4863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2769f9fda49613246bc84dba41aa4863">&#9670;&nbsp;</a></span>R_GPT_Start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts timer. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#afcc7e85d01c3d7dc0c6e09954631f47f">timer_api_t::start</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Start the timer. */</span></div><div class="line">    (void) <a class="code" href="group___g_p_t.html#ga2769f9fda49613246bc84dba41aa4863">R_GPT_Start</a>(&amp;g_timer0_ctrl);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Timer successfully started. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5eb494add3d40775dbc48c5498e15a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5eb494add3d40775dbc48c5498e15a3a">&#9670;&nbsp;</a></span>R_GPT_Reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the counter value to 0. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#ab1c62157861ef1ea8393bb3cafd72102">timer_api_t::reset</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function also updates to the new period if no counter overflow has occurred since the last call to <a class="el" href="group___g_p_t.html#gafedbfd8bc3f534d06969588ff10a351b">R_GPT_PeriodSet()</a>.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Counter value written successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6e14d15c781e316e640c280b4983be28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e14d15c781e316e640c280b4983be28">&#9670;&nbsp;</a></span>R_GPT_Enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_Enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables external event triggers that start, stop, clear, or capture the counter. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#a13cb48d1657a9eda3380c111ba33aa2a">timer_api_t::enable</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Enable captures. Captured values arrive in the interrupt. */</span></div><div class="line">    (void) <a class="code" href="group___g_p_t.html#ga6e14d15c781e316e640c280b4983be28">R_GPT_Enable</a>(&amp;g_timer0_ctrl);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>External events successfully enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga338dd3c38477ee40c90c13f3a4c9ecfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga338dd3c38477ee40c90c13f3a4c9ecfd">&#9670;&nbsp;</a></span>R_GPT_Disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_Disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables external event triggers that start, stop, clear, or capture the counter. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#a8b69fad02aee5d83b941ed02fca18aca">timer_api_t::disable</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The timer could be running after <a class="el" href="group___g_p_t.html#ga338dd3c38477ee40c90c13f3a4c9ecfd">R_GPT_Disable()</a>. To ensure it is stopped, call <a class="el" href="group___g_p_t.html#ga1e6af74d7faaf735f5847a34121eff71">R_GPT_Stop()</a>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Disable captures. */</span></div><div class="line">    (void) <a class="code" href="group___g_p_t.html#ga338dd3c38477ee40c90c13f3a4c9ecfd">R_GPT_Disable</a>(&amp;g_timer0_ctrl);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>External events successfully disabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafedbfd8bc3f534d06969588ff10a351b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafedbfd8bc3f534d06969588ff10a351b">&#9670;&nbsp;</a></span>R_GPT_PeriodSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_PeriodSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>period_counts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets period value provided. If the timer is running, the period will be updated after the next counter overflow. If the timer is stopped, this function resets the counter and updates the period. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#ae9aad84a01ccd7ce0039ed491faeff19">timer_api_t::periodSet</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>If periodic output is used, the duty cycle buffer registers are updated after the period buffer register. If this function is called while the timer is running and a GPT overflow occurs during processing, the duty cycle will not be the desired 50% duty cycle until the counter overflow after processing completes.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Get the source clock frequency (in Hz). There are 3 ways to do this in FSP:</span></div><div class="line"><span class="comment">     *  - If the PCLKD frequency has not changed since reset, the source clock frequency is</span></div><div class="line"><span class="comment">     *    BSP_STARTUP_PCLKD_HZ &gt;&gt; timer_cfg_t::source_div</span></div><div class="line"><span class="comment">     *  - Use the R_GPT_InfoGet function (it accounts for the divider).</span></div><div class="line"><span class="comment">     *  - Calculate the current PCLKD frequency using R_FSP_SystemClockHzGet(FSP_PRIV_CLOCK_PCLKD) and right shift</span></div><div class="line"><span class="comment">     *    by timer_cfg_t::source_div.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * This example uses the 3rd option (R_FSP_SystemClockHzGet).</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    uint32_t pclkd_freq_hz = <a class="code" href="group___b_s_p___m_c_u.html#gaac289335b731d0bdb5cb8e6d243898ef">R_FSP_SystemClockHzGet</a>(FSP_PRIV_CLOCK_PCLKD) &gt;&gt; g_timer0_cfg.source_div;</div><div class="line"></div><div class="line">    <span class="comment">/* Calculate the desired period based on the current clock. Note that this calculation could overflow if the</span></div><div class="line"><span class="comment">     * desired period is larger than UINT32_MAX / pclkd_freq_hz. A cast to uint64_t is used to prevent this. */</span></div><div class="line">    uint32_t period_counts =</div><div class="line">        (uint32_t) (((uint64_t) pclkd_freq_hz * GPT_EXAMPLE_DESIRED_PERIOD_MSEC) / GPT_EXAMPLE_MSEC_PER_SEC);</div><div class="line"></div><div class="line">    <span class="comment">/* Set the calculated period. */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#gafedbfd8bc3f534d06969588ff10a351b">R_GPT_PeriodSet</a>(&amp;g_timer0_ctrl, period_counts);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Period value written successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad14bacf6fb7fce88f3e877160be529ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad14bacf6fb7fce88f3e877160be529ea">&#9670;&nbsp;</a></span>R_GPT_DutyCycleSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_DutyCycleSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>duty_cycle_counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>pin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets duty cycle on requested pin. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#a819ed0740ca426ace0d6b67e16c6ddfc">timer_api_t::dutyCycleSet</a>.</p>
<p>Duty cycle is updated in the buffer register. The updated duty cycle is reflected after the next cycle end (counter overflow).</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Get the current period setting. */</span></div><div class="line">    <a class="code" href="group___t_i_m_e_r___a_p_i.html#structtimer__info__t">timer_info_t</a> info;</div><div class="line">    (void) <a class="code" href="group___g_p_t.html#gaca62ac33de2c05918b0fc359aeaebd97">R_GPT_InfoGet</a>(&amp;g_timer0_ctrl, &amp;info);</div><div class="line">    uint32_t current_period_counts = info.<a class="code" href="group___t_i_m_e_r___a_p_i.html#a08b897cfbf2d0cefafe8d3abb1afc747">period_counts</a>;</div><div class="line"></div><div class="line">    <span class="comment">/* Calculate the desired duty cycle based on the current period. Note that if the period could be larger than</span></div><div class="line"><span class="comment">     * UINT32_MAX / 100, this calculation could overflow. A cast to uint64_t is used to prevent this. The cast is</span></div><div class="line"><span class="comment">     * not required for 16-bit timers. */</span></div><div class="line">    uint32_t duty_cycle_counts =</div><div class="line">        (uint32_t) (((uint64_t) current_period_counts * GPT_EXAMPLE_DESIRED_DUTY_CYCLE_PERCENT) /</div><div class="line">                    GPT_EXAMPLE_MAX_PERCENT);</div><div class="line"></div><div class="line">    <span class="comment">/* Set the calculated duty cycle. */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#gad14bacf6fb7fce88f3e877160be529ea">R_GPT_DutyCycleSet</a>(&amp;g_timer0_ctrl, duty_cycle_counts, <a class="code" href="group___g_p_t.html#ggaabd4a03d16b1b4254cc44c7779f44c60aebd74a7b9507fb082ec4cce60ebe9369">GPT_IO_PIN_GTIOCB</a>);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_ctrl</td><td>Pointer to instance control block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">duty_cycle_counts</td><td>Duty cycle to set in counts. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pin</td><td>Use gpt_io_pin_t to select GPT_IO_PIN_GTIOCA or GPT_IO_PIN_GTIOCB</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Duty cycle updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl was NULL or the pin is not one of gpt_io_pin_t </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance is not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ARGUMENT</td><td>Duty cycle is larger than period. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>GPT_IO_PIN_TROUGH, and GPT_IO_PIN_CREST settings are invalid in the this mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>GPT_CFG_OUTPUT_SUPPORT_ENABLE is 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga834be7c118edc5297a74cf588a447106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga834be7c118edc5297a74cf588a447106">&#9670;&nbsp;</a></span>R_GPT_CompareMatchSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_CompareMatchSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>compare_match_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#gaf5f22f5e34fe6ea640fd6a1c7e864cd9">timer_compare_match_t</a> const&#160;</td>
          <td class="paramname"><em>match_channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set value for compare match feature. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#a01da35856c7e395c56ab65c3fe033b56">timer_api_t::compareMatchSet</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This API should be used when timer is stop counting. And shall not be used along with PWM operation.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Set the compare match value (GPT_COMPARE_MATCH_EXAMPLE_VALUE). This value must be less than or equal to period value. */</span></div><div class="line">    err = <a class="code" href="group___g_p_t.html#ga834be7c118edc5297a74cf588a447106">R_GPT_CompareMatchSet</a>(&amp;g_timer0_ctrl, GPT_COMPARE_MATCH_EXAMPLE_VALUE, <a class="code" href="group___t_i_m_e_r___a_p_i.html#ggaf5f22f5e34fe6ea640fd6a1c7e864cd9aaaad342d8de564fe934da6046de43b1b">TIMER_COMPARE_MATCH_A</a>);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Set the compare match value successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance is not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_ENABLED</td><td>Requested compare channel is disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaca62ac33de2c05918b0fc359aeaebd97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca62ac33de2c05918b0fc359aeaebd97">&#9670;&nbsp;</a></span>R_GPT_InfoGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_InfoGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#structtimer__info__t">timer_info_t</a> *const&#160;</td>
          <td class="paramname"><em>p_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get timer information and store it in provided pointer p_info. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#aeaea79f26305c493566e4b45ae9e294c">timer_api_t::infoGet</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">        <span class="comment">/* (Optional) Get the current period if not known. */</span></div><div class="line">        <a class="code" href="group___t_i_m_e_r___a_p_i.html#structtimer__info__t">timer_info_t</a> info;</div><div class="line">        (void) <a class="code" href="group___g_p_t.html#gaca62ac33de2c05918b0fc359aeaebd97">R_GPT_InfoGet</a>(&amp;g_timer0_ctrl, &amp;info);</div><div class="line">        uint64_t period = info.<a class="code" href="group___t_i_m_e_r___a_p_i.html#a08b897cfbf2d0cefafe8d3abb1afc747">period_counts</a>;</div><div class="line"></div><div class="line">        <span class="comment">/* The maximum period is one more than the maximum 32-bit number, but will be reflected as 0 in</span></div><div class="line"><span class="comment">         * timer_info_t::period_counts. */</span></div><div class="line">        <span class="keywordflow">if</span> (0U == period)</div><div class="line">        {</div><div class="line">            period = UINT32_MAX + 1U;</div><div class="line">        }</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Period, count direction, frequency, and ELC event written to caller's structure successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl or p_info was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa6234faf45320a83382d7ea1923a2c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6234faf45320a83382d7ea1923a2c49">&#9670;&nbsp;</a></span>R_GPT_StatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_StatusGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#structtimer__status__t">timer_status_t</a> *const&#160;</td>
          <td class="paramname"><em>p_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get current timer status and store it in provided pointer p_status. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#a11321e8dde7c33a4e6835a1bf64f7689">timer_api_t::statusGet</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Read the current counter value. Counter value is in status.counter. */</span></div><div class="line">    <a class="code" href="group___t_i_m_e_r___a_p_i.html#structtimer__status__t">timer_status_t</a> status;</div><div class="line">    (void) <a class="code" href="group___g_p_t.html#gaa6234faf45320a83382d7ea1923a2c49">R_GPT_StatusGet</a>(&amp;g_timer0_ctrl, &amp;status);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Current timer state and counter value set successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl or p_status was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4126139a9c63f1963ffdaea6cc697fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4126139a9c63f1963ffdaea6cc697fe9">&#9670;&nbsp;</a></span>R_GPT_CounterSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_CounterSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set counter value.</p>
<dl class="section note"><dt>Note</dt><dd>Do not call this API while the counter is counting. The counter value can only be updated while the counter is stopped.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Counter value updated. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl or p_status was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance is not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>The timer is running. Stop the timer before calling this function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0e6638508ec1d5441713195c877bb7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e6638508ec1d5441713195c877bb7a7">&#9670;&nbsp;</a></span>R_GPT_OutputEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_OutputEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___g_p_t.html#gaabd4a03d16b1b4254cc44c7779f44c60">gpt_io_pin_t</a>&#160;</td>
          <td class="paramname"><em>pin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable output for GTIOCA and/or GTIOCB.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Output is enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl or p_status was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae204e5d6c9305923e98724005dcdf03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae204e5d6c9305923e98724005dcdf03d">&#9670;&nbsp;</a></span>R_GPT_OutputDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_OutputDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___g_p_t.html#gaabd4a03d16b1b4254cc44c7779f44c60">gpt_io_pin_t</a>&#160;</td>
          <td class="paramname"><em>pin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable output for GTIOCA and/or GTIOCB.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Output is disabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl or p_status was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga311c91c55f20338f7082fa4369e7c80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga311c91c55f20338f7082fa4369e7c80f">&#9670;&nbsp;</a></span>R_GPT_AdcTriggerSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_AdcTriggerSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___g_p_t.html#ga2a838fffcbafd97778bbe3ffbfbf54b1">gpt_adc_compare_match_t</a>&#160;</td>
          <td class="paramname"><em>which_compare_match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>compare_match_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set A/D converter start request compare match value.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Counter value updated. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl or p_status was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaff2d30ece9bd30b5a9cc2117623834c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff2d30ece9bd30b5a9cc2117623834c6">&#9670;&nbsp;</a></span>R_GPT_PwmOutputDelaySet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_PwmOutputDelaySet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___g_p_t.html#ga6a1389fe5c3bef2301d294b88263628e">gpt_pwm_output_delay_edge_t</a>&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___g_p_t.html#ga749be81f99469c5607a684976d9ae374">gpt_pwm_output_delay_setting_t</a>&#160;</td>
          <td class="paramname"><em>delay_setting</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>pin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the Output Delay setting for the PWM output pin.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The output delay was set. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input parameter was invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance is not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_CHANNEL</td><td>The channel does not support this feature. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_INITIALIZED</td><td>The PWM Output Delay Circuit has not been initialized. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_STATE</td><td>The PWM Output Delay setting cannot be updated in the current state. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>This feature is not supported on this MCU. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6cd6772e3474cf80cb49b562b11c269e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cd6772e3474cf80cb49b562b11c269e">&#9670;&nbsp;</a></span>R_GPT_CallbackSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_CallbackSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="group___t_i_m_e_r___a_p_i.html#structtimer__callback__args__t">timer_callback_args_t</a> *)&#160;</td>
          <td class="paramname"><em>p_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>p_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#structtimer__callback__args__t">timer_callback_args_t</a> *const&#160;</td>
          <td class="paramname"><em>p_callback_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the user callback with the option to provide memory for the callback argument structure. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#a31de8e7c70c88d01f659facd65756e5d">timer_api_t::callbackSet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Callback updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_NO_CALLBACK_MEMORY</td><td>p_callback is non-secure and p_callback_memory is either secure or NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2fc5d6a737a00948802e2bb77fbe8d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fc5d6a737a00948802e2bb77fbe8d8c">&#9670;&nbsp;</a></span>R_GPT_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___a_p_i.html#ga2da99b474151cb687d5882ad21b09c2a">timer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops counter, disables output pins, and clears internal driver data. Implements <a class="el" href="group___t_i_m_e_r___a_p_i.html#a9e8b8140010a28082aedd758390fac97">timer_api_t::close</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful close. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gada982ef1873ca00147f9692b42aba8f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada982ef1873ca00147f9692b42aba8f0">&#9670;&nbsp;</a></span>R_GPT_PwmOutputDelayInitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_GPT_PwmOutputDelayInitialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the PWM Delay Generation Circuit (PDG). This function must be called before calling <a class="el" href="group___g_p_t.html#gaff2d30ece9bd30b5a9cc2117623834c6">R_GPT_PwmOutputDelaySet</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function will delay for 20 microseconds.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Initialization sequence completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_STATE</td><td>The source clock frequnecy is out of the required range for the PDG. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>This feature is not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v6.2.0 User's Manual Copyright © (2025) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
