<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: Ethernet (r_ether)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v3.0.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">
 
    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text"> 
      </span>
      <span class="right">
          &nbsp; 
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___e_t_h_e_r.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() { 
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body. 
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works 
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len)); 
            }
          } 
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }    
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element. 
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;  
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">Ethernet (r_ether)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab2b878c7b67357c06e1f9231265819fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_t_h_e_r.html#gab2b878c7b67357c06e1f9231265819fd">R_ETHER_Open</a> (<a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const p_ctrl, <a class="el" href="group___e_t_h_e_r___a_p_i.html#structether__cfg__t">ether_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="memdesc:gab2b878c7b67357c06e1f9231265819fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">After ETHERC, EDMAC and PHY-LSI are reset in software, an auto negotiation of PHY-LSI is begun. Afterwards, the link signal change interrupt is permitted. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#ae75458ac2a31861195b73120676d670c">ether_api_t::open</a>.  <a href="#gab2b878c7b67357c06e1f9231265819fd">More...</a><br /></td></tr>
<tr class="separator:gab2b878c7b67357c06e1f9231265819fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbd25f2b961e8e2a807444f04e08d158"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_t_h_e_r.html#gafbd25f2b961e8e2a807444f04e08d158">R_ETHER_Close</a> (<a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="memdesc:gafbd25f2b961e8e2a807444f04e08d158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables interrupts. Removes power and releases hardware lock. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#a1c0bc3caef73e0a216c2fe2edc4fff4b">ether_api_t::close</a>.  <a href="#gafbd25f2b961e8e2a807444f04e08d158">More...</a><br /></td></tr>
<tr class="separator:gafbd25f2b961e8e2a807444f04e08d158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga174de3d54336469ca7a1e5949820bd3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_t_h_e_r.html#ga174de3d54336469ca7a1e5949820bd3f">R_ETHER_Read</a> (<a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const p_ctrl, void *const p_buffer, uint32_t *const length_bytes)</td></tr>
<tr class="memdesc:ga174de3d54336469ca7a1e5949820bd3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive Ethernet frame. Receives data to the location specified by the pointer to the receive buffer. In zero copy mode, the address of the receive buffer is returned. In non zero copy mode, the received data in the internal buffer is copied to the pointer passed by the argument. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#a41d56c8843a454690b1969f8f766d65a">ether_api_t::read</a>.  <a href="#ga174de3d54336469ca7a1e5949820bd3f">More...</a><br /></td></tr>
<tr class="separator:ga174de3d54336469ca7a1e5949820bd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bc8e53a14aa52d4d2b9b247ddd7cce8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_t_h_e_r.html#ga3bc8e53a14aa52d4d2b9b247ddd7cce8">R_ETHER_BufferRelease</a> (<a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="memdesc:ga3bc8e53a14aa52d4d2b9b247ddd7cce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move to the next buffer in the circular receive buffer list. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#aa38e7f82e66fd26fd8d51b11f46ae6e6">ether_api_t::bufferRelease</a>.  <a href="#ga3bc8e53a14aa52d4d2b9b247ddd7cce8">More...</a><br /></td></tr>
<tr class="separator:ga3bc8e53a14aa52d4d2b9b247ddd7cce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ea6c9f72dc3b81cdcf6de7c84a87d53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_t_h_e_r.html#ga7ea6c9f72dc3b81cdcf6de7c84a87d53">R_ETHER_RxBufferUpdate</a> (<a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const p_ctrl, void *const p_buffer)</td></tr>
<tr class="memdesc:ga7ea6c9f72dc3b81cdcf6de7c84a87d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the buffer pointer of the current rx buffer descriptor. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#aa714b8287d1cef38d8442850dd9b9fb5">ether_api_t::rxBufferUpdate</a>.  <a href="#ga7ea6c9f72dc3b81cdcf6de7c84a87d53">More...</a><br /></td></tr>
<tr class="separator:ga7ea6c9f72dc3b81cdcf6de7c84a87d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad54ccf1420a5c32afe90762eebde112"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_t_h_e_r.html#gaad54ccf1420a5c32afe90762eebde112">R_ETHER_Write</a> (<a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const p_ctrl, void *const p_buffer, uint32_t const frame_length)</td></tr>
<tr class="memdesc:gaad54ccf1420a5c32afe90762eebde112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit Ethernet frame. Transmits data from the location specified by the pointer to the transmit buffer, with the data size equal to the specified frame length. In the non zero copy mode, transmits data after being copied to the internal buffer. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#a92e87f33f0a4e0ccb26464d697cdf233">ether_api_t::write</a>.  <a href="#gaad54ccf1420a5c32afe90762eebde112">More...</a><br /></td></tr>
<tr class="separator:gaad54ccf1420a5c32afe90762eebde112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab10af3abff76900b7895934685c43311"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_t_h_e_r.html#gab10af3abff76900b7895934685c43311">R_ETHER_LinkProcess</a> (<a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="memdesc:gab10af3abff76900b7895934685c43311"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Link up processing, the Link down processing, and the magic packet detection processing are executed. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#a125ca4ee69c6c63e1db42708324c0fb3">ether_api_t::linkProcess</a>.  <a href="#gab10af3abff76900b7895934685c43311">More...</a><br /></td></tr>
<tr class="separator:gab10af3abff76900b7895934685c43311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga992be578c310d212389be65762d1b6ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_t_h_e_r.html#ga992be578c310d212389be65762d1b6ea">R_ETHER_WakeOnLANEnable</a> (<a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="memdesc:ga992be578c310d212389be65762d1b6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The setting of ETHERC is changed from normal sending and receiving mode to magic packet detection mode. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#afabb87ef0be65717bb7675a4a004e3ad">ether_api_t::wakeOnLANEnable</a>.  <a href="#ga992be578c310d212389be65762d1b6ea">More...</a><br /></td></tr>
<tr class="separator:ga992be578c310d212389be65762d1b6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8993d43da08dc2f328d67be680fa85e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_t_h_e_r.html#ga8993d43da08dc2f328d67be680fa85e0">R_ETHER_TxStatusGet</a> (<a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const p_ctrl, void *const p_buffer_address)</td></tr>
<tr class="separator:ga8993d43da08dc2f328d67be680fa85e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the Ethernet peripheral on RA MCUs. This module implements the <a class="el" href="group___e_t_h_e_r___a_p_i.html">Ethernet Interface</a>. </p>
<h1><a class="anchor" id="r-ether-overview"></a>
Overview</h1>
<p>This module performs Ethernet frame transmission and reception using an Ethernet controller and an Ethernet DMA controller.</p>
<h2><a class="anchor" id="r-ether-features"></a>
Features</h2>
<p>The Ethernet module supports the following features:</p><ul>
<li>Transmit/receive processing</li>
<li>Optional zero-copy buffering</li>
<li>Callback function with returned event code</li>
<li>Magic packet detection mode support</li>
<li>Auto negotiation support</li>
<li>Flow control support</li>
<li>Multicast filtering support<a class="anchor" id="um_ether_skipping_multicast_frame_when_multicast_filter_enabled"></a></li>
<li>Broadcast filtering support<a class="anchor" id="um_ether_regurating_broadcast_packet_when_broadcast_filter_enable"></a></li>
<li>Promiscuous mode support<a class="anchor" id="um_ether_receiving_all_frame_when_promiscuous_mode_enabled"></a> </li>
</ul>
<h1><a class="anchor" id="r-ether-configuration"></a>
Configuration</h1>
<p><h2>Build Time Configurations for r_ether</h2>
The following build time configurations are defined in fsp_cfg/r_ether_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr>
<td>ET0_LINKSTA Pin Status Flag</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Fall -&gt; Rise</li>
<li>
Rise -&gt; Fall</li>
</ul>
</td><td>Fall -&gt; Rise </td><td>Specify the polarity of the link signal output by the PHY-LSI. When 0 is specified, link-up and link-down correspond respectively to the fall and rise of the LINKSTA signal. When 1 is specified, link-up and link-down correspond respectively to the rise and fall of the LINKSTA signal. </td></tr>
<tr>
<td>Link Signal Change Flag</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Used</li>
</ul>
</td><td>Unused </td><td>Use LINKSTA signal for detect link status changes 0 = unused (use PHY-LSI status register) 1 = use (use LINKSTA signal) </td></tr>
</table>
 <h2>Configurations for Driver &gt; Network &gt; Ethernet Driver on r_ether</h2>
This module can be added to the Stacks tab via New Stack &gt; Driver &gt; Network &gt; Ethernet Driver on r_ether.<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>General &gt; Name</td><td>Name must be a valid C symbol</td><td>g_ether0 </td><td>Module name. </td></tr>
<tr>
<td>General &gt; Channel</td><td>0</td><td>0 </td><td>Select the ether channel number. </td></tr>
<tr>
<td>General &gt; MAC address</td><td>Must be a valid MAC address</td><td>00:11:22:33:44:55 </td><td>MAC address of this channel. </td></tr>
<tr>
<td>General &gt; Zero-copy Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disable</li>
<li>
Enable</li>
</ul>
</td><td>Disable </td><td>Enable or disable zero-copy mode. </td></tr>
<tr>
<td>General &gt; Flow control functionality</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disable</li>
<li>
Enable</li>
</ul>
</td><td>Disable </td><td>Enable or disable flow control. </td></tr>
<tr>
<td>Filters &gt; Multicast Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disable</li>
<li>
Enable</li>
</ul>
</td><td>Enable </td><td>Enable or disable multicast frame reception. </td></tr>
<tr>
<td>Filters &gt; Promiscuous Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disable</li>
<li>
Enable</li>
</ul>
</td><td>Disable </td><td>Enable this option to receive packets addressed to other NICs. </td></tr>
<tr>
<td>Filters &gt; Broadcast filter</td><td>Must be a valid non-negative integer with maximum configurable value of 65535. </td><td>0 </td><td>Limit of the number of broadcast frames received continuously </td></tr>
<tr>
<td>Buffers &gt; Number of TX buffer</td><td>Must be an integer from 1 to 8</td><td>1 </td><td>Number of transmit buffers </td></tr>
<tr>
<td>Buffers &gt; Number of RX buffer</td><td>Must be an integer from 1 to 8</td><td>1 </td><td>Number of receive buffers </td></tr>
<tr>
<td>Buffers &gt; Allocate RX buffer</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disable</li>
<li>
Enable</li>
</ul>
</td><td>Enable </td><td>Allocates the RX buffer when generating the configuration structure </td></tr>
<tr>
<td>Buffers &gt; Buffer size</td><td>Must be at least 1514 which is the maximum Ethernet frame size.</td><td>1514 </td><td>Size of Ethernet buffer </td></tr>
<tr>
<td>Buffers &gt; Padding size</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disable</li>
<li>
1 Byte</li>
<li>
2 Bytes</li>
<li>
3 Bytes</li>
</ul>
</td><td>Disable </td><td>The padding size that is automatically inserted into the received packets </td></tr>
<tr>
<td>Buffers &gt; Padding offset</td><td>Must be less than 64 bytes.</td><td>0 </td><td>The offset into a receive buffer to insert padding bytes. </td></tr>
<tr>
<td>Interrupts &gt; Interrupt priority</td><td>MCU Specific Options</td><td></td><td>Select the EDMAC interrupt priority. </td></tr>
<tr>
<td>Interrupts &gt; Callback</td><td>Name must be a valid C symbol</td><td>NULL </td><td>Callback provided when an ISR occurs </td></tr>
</table>
</p>
<p><a class="anchor" id="um_ether_configuration_for_connection_mode"></a><a class="anchor" id="um_ether_configuration_of_mac_address"></a> </p>
<h2><a class="anchor" id="r-ether-interrupt-configuration"></a>
Interrupt Configuration</h2>
<p>The first <a class="el" href="group___e_t_h_e_r.html#gab2b878c7b67357c06e1f9231265819fd">R_ETHER_Open</a> function call sets EINT interrupts. The user could provide callback function which would be invoked when EINT interrupt handler has been completed. The callback arguments will contain information about a channel number, the ETHERC and EDMAC status, the event code, and a pointer to the user defined context.</p>
<h2><a class="anchor" id="r-ether-callback-configuration"></a>
Callback Configuration</h2>
<p>The user could provide callback function which would be invoked when either a magic packet or a link signal change is detected. When the callback function is called, a variable in which the channel number for which the detection occurred and a constant shown in Table 2.4 are stored is passed as an argument. If the value of this argument is to be used outside the callback function, its value should be copied into, for example, a global variable.</p>
<h2><a class="anchor" id="r-ether-clock-configuration"></a>
Clock Configuration</h2>
<p>The clock for this module is derived from the following peripheral clock for each MCU group:<br />
</p><table class="doxtable">
<tr>
<th>MCU Group</th><th>Peripheral Clock </th></tr>
<tr>
<td>RA6M2</td><td>PCLKA</td></tr>
<tr>
<td>RA6M3</td><td>PCLKA</td></tr>
<tr>
<td>RA6M4</td><td>PCLKA</td></tr>
<tr>
<td>RA6M5</td><td>PCLKA</td></tr>
</table>
</p>
<dl class="section note"><dt>Note</dt><dd>1. When using ETHERC, the PCLKA frequency is in the range 12.5 MHz &lt;= PCLKA &lt;= 120 MHz. </dd>
<dd>
2. When using ETHERC, PCLKA = ICLK.</dd></dl>
<h2><a class="anchor" id="r-ether-pin-configuration"></a>
Pin Configuration</h2>
<p>To use the Ethernet module, input/output signals of the peripheral function have to be allocated to pins with the multi-function pin controller (MPC). Please perform the pin setting before calling the <a class="el" href="group___e_t_h_e_r.html#gab2b878c7b67357c06e1f9231265819fd">R_ETHER_Open</a> function.</p>
<h1><a class="anchor" id="r-ether-usage_notes"></a>
Usage Notes</h1>
<h2>Ethernet Frame Format</h2>
<p>The Ethernet module supports the Ethernet II/IEEE 802.3 frame format.</p>
<h3>Frame Format for Data Transmission and Reception</h3>
<div class="image">
<object type="image/svg+xml" data="frame_format_image.svg">frame_format_image.svg</object>
<div class="caption">
Frame Format Image</div></div>
<p> The preamble and SFD signal the start of an Ethernet frame. The FCS contains the CRC of the Ethernet frame and is calculated on the transmitting side. When data is received the CRC value of the frame is calculated in hardware, and the Ethernet frame is discarded if the values do not match. When the hardware determines that the data is normal, the valid range of receive data is: (transmission destination address) + (transmission source address) + (length/type) + (data).</p>
<h3>PAUSE Frame Format</h3>
<div class="image">
<object type="image/svg+xml" data="pause_frame_format_image.svg">pause_frame_format_image.svg</object>
<div class="caption">
Pause Frame Format Image</div></div>
<p> The transmission destination address is specified as 01:80:C2:00:00:01 (a multicast address reserved for PAUSE frames). At the start of the payload the length/type is specified as 0x8808 and the operation code as 0x0001. The pause duration in the payload is specified by the value of the automatic PAUSE (AP) bits in the automatic PAUSE frame setting register (APR), or the manual PAUSE time setting (MP) bits in the manual PAUSE frame setting register (MPR).</p>
<h3>Magic Packet Frame Format</h3>
<div class="image">
<object type="image/svg+xml" data="magic_packet_frame_format_image.svg">magic_packet_frame_format_image.svg</object>
<div class="caption">
Magic Packet Frame Format Image</div></div>
<p> In a Magic Packet, the value FF:FF:FF:FF:FF:FF followed by the transmission destination address repeated 16 times is inserted somewhere in the Ethernet frame data.</p>
<h2><a class="anchor" id="r-ether-limitations"></a>
Limitations</h2>
<h3>Memory alignment limitation for Ethernet buffer</h3>
<p>The Ethernet Driver has several alignment constraints:</p><ul>
<li>16-byte alignment for the descriptor</li>
<li>32-byte aligned read buffer for <a class="el" href="group___e_t_h_e_r.html#ga7ea6c9f72dc3b81cdcf6de7c84a87d53">R_ETHER_RxBufferUpdate</a> when zero copy mode is enabled</li>
</ul>
<h3>Functional limitations in TrustZone Security Extensions</h3>
<p>The Ethernet Driver has several security constraints:</p>
<table class="doxtable">
<tr>
<th colspan="1" rowspan="2">MCU </th><th colspan="1" rowspan="2">Has Security Extension </th><th colspan="1" rowspan="2">Support Flat project </th><th colspan="2" rowspan="1">Support TZ project  </th></tr>
<tr>
<th colspan="1" rowspan="1">Secure </th><th colspan="1" rowspan="1">Non-Secure  </th></tr>
<tr>
<td align="center">RA6M2 </td><td align="center">- </td><td align="center">x </td><td align="center">- </td><td align="center">-  </td></tr>
<tr>
<td align="center">RA6M3 </td><td align="center">- </td><td align="center">x </td><td align="center">- </td><td align="center">-  </td></tr>
<tr>
<td align="center">RA6M4 </td><td align="center">- *1 </td><td align="center">x </td><td align="center">- </td><td align="center">x  </td></tr>
<tr>
<td align="center">RA6M5 </td><td align="center">- *1 </td><td align="center">x </td><td align="center">- </td><td align="center">x  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>1. ETHERC/EDMAC is always Non-secure peripheral in this MCU.</dd></dl>
<h1><a class="anchor" id="r-ether-examples"></a>
Examples</h1>
<h2>ETHER Basic Example</h2>
<p>This is a basic example of minimal use of the ETHER in an application.</p>
<dl class="section note"><dt>Note</dt><dd>In this example zero-copy mode is disabled and there are no restrictions on buffer alignment.</dd></dl>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define ETHER_EXAMPLE_MAXIMUM_ETHERNET_FRAME_SIZE     (1514)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define ETHER_EXAMPLE_TRANSMIT_ETHERNET_FRAME_SIZE    (60)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define ETHER_EXAMPLE_SOURCE_MAC_ADDRESS              0x74, 0x90, 0x50, 0x00, 0x79, 0x01</span></div><div class="line"><span class="preprocessor">#define ETHER_EXAMPLE_DESTINATION_MAC_ADDRESS         0x74, 0x90, 0x50, 0x00, 0x79, 0x02</span></div><div class="line"><span class="preprocessor">#define ETHER_EXAMPLE_FRAME_TYPE                      0x00, 0x2E</span></div><div class="line"><span class="preprocessor">#define ETHER_EXAMPLE_PAYLOAD                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \</span></div><div class="line"><span class="preprocessor">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                   \</span></div><div class="line"><span class="preprocessor">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                   \</span></div><div class="line"><span class="preprocessor">    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                   \</span></div><div class="line"><span class="preprocessor"></span></div><div class="line"></div><div class="line"><span class="comment">/* Receive data buffer */</span></div><div class="line"><span class="keyword">static</span> uint8_t gp_read_buffer[ETHER_EXAMPLE_MAXIMUM_ETHERNET_FRAME_SIZE] = {0};</div><div class="line"></div><div class="line"><span class="comment">/* Transmit data buffer */</span></div><div class="line"><span class="keyword">static</span> uint8_t gp_send_data[ETHER_EXAMPLE_TRANSMIT_ETHERNET_FRAME_SIZE] =</div><div class="line">{</div><div class="line">    ETHER_EXAMPLE_DESTINATION_MAC_ADDRESS, <span class="comment">/* Destination MAC address */</span></div><div class="line">    ETHER_EXAMPLE_SOURCE_MAC_ADDRESS,      <span class="comment">/* Source MAC address */</span></div><div class="line">    ETHER_EXAMPLE_FRAME_TYPE,              <span class="comment">/* Type field */</span></div><div class="line">    ETHER_EXAMPLE_PAYLOAD                  <span class="comment">/* Payload value (46byte) */</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> ether_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Source MAC Address */</span></div><div class="line">    <span class="keyword">static</span> uint8_t mac_address_source[6] = {ETHER_EXAMPLE_SOURCE_MAC_ADDRESS};</div><div class="line"></div><div class="line">    uint32_t read_data_size = 0;</div><div class="line"></div><div class="line">    g_ether0_cfg.p_mac_address = mac_address_source;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Open the ether instance with initial configuration. */</span></div><div class="line">    err = <a class="code" href="group___e_t_h_e_r.html#gab2b878c7b67357c06e1f9231265819fd">R_ETHER_Open</a>(&amp;g_ether0_ctrl, &amp;g_ether0_cfg);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* When the Ethernet link status read from the PHY-LSI Basic Status register is link-up,</span></div><div class="line"><span class="comment">         * Initializes the module and make auto negotiation. */</span></div><div class="line">        err = <a class="code" href="group___e_t_h_e_r.html#gab10af3abff76900b7895934685c43311">R_ETHER_LinkProcess</a>(&amp;g_ether0_ctrl);</div><div class="line">    } <span class="keywordflow">while</span> (FSP_SUCCESS != err);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Transmission is non-blocking. */</span></div><div class="line">    <span class="comment">/* User data copy to internal buffer and is transferred by DMA in the background. */</span></div><div class="line">    err = <a class="code" href="group___e_t_h_e_r.html#gaad54ccf1420a5c32afe90762eebde112">R_ETHER_Write</a>(&amp;g_ether0_ctrl, (<span class="keywordtype">void</span> *) gp_send_data, <span class="keyword">sizeof</span>(gp_send_data));</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* received data copy to user buffer from internal buffer. */</span></div><div class="line">    err = <a class="code" href="group___e_t_h_e_r.html#ga174de3d54336469ca7a1e5949820bd3f">R_ETHER_Read</a>(&amp;g_ether0_ctrl, (<span class="keywordtype">void</span> *) gp_read_buffer, &amp;read_data_size);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Disable transmission and receive function and close the ether instance. */</span></div><div class="line">    <a class="code" href="group___e_t_h_e_r.html#gafbd25f2b961e8e2a807444f04e08d158">R_ETHER_Close</a>(&amp;g_ether0_ctrl);</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>ETHER Advanced Example</h2>
<p>The example demonstrates using send and receive function in zero copy mode. Transmit buffers must be 32-byte aligned and the receive buffer must be released once its contents have been used.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define ETHER_EXAMPLE_FLAG_ON                  (1U)</span></div><div class="line"><span class="preprocessor">#define ETHER_EXAMPLE_FLAG_OFF                 (0U)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define ETHER_EXAMPLE_ETHER_ISR_EE_FR_MASK     (1UL &lt;&lt; 18)</span></div><div class="line"><span class="preprocessor">#define ETHER_EXAMPLE_ETHER_ISR_EE_TC_MASK     (1UL &lt;&lt; 21)</span></div><div class="line"><span class="preprocessor">#define ETHER_EXAMPLE_ETHER_ISR_EC_MPD_MASK    (1UL &lt;&lt; 1)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define ETHER_EXAMPLE_ALIGNMENT_32_BYTE        (32)</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> uint32_t g_example_receive_complete  = 0;</div><div class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> uint32_t g_example_transfer_complete = 0;</div><div class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> uint32_t g_example_magic_packet_done = 0;</div><div class="line"></div><div class="line"><span class="keyword">static</span> uint8_t gp_send_data_internal[ETHER_EXAMPLE_TRANSMIT_ETHERNET_FRAME_SIZE] =</div><div class="line">{</div><div class="line">    ETHER_EXAMPLE_DESTINATION_MAC_ADDRESS, <span class="comment">/* Destination MAC address */</span></div><div class="line">    ETHER_EXAMPLE_SOURCE_MAC_ADDRESS,      <span class="comment">/* Source MAC address */</span></div><div class="line">    ETHER_EXAMPLE_FRAME_TYPE,              <span class="comment">/* Type field */</span></div><div class="line">    ETHER_EXAMPLE_PAYLOAD                  <span class="comment">/* Payload value (46byte) */</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> ether_example_callback (<a class="code" href="group___e_t_h_e_r___a_p_i.html#structether__callback__args__t">ether_callback_args_t</a> * p_args) {</div><div class="line">    <span class="keywordflow">switch</span> (p_args-&gt;<a class="code" href="group___e_t_h_e_r___a_p_i.html#aa28fdd797448d1ed0d56604ec87b349a">event</a>)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___e_t_h_e_r___a_p_i.html#ggad029483e98651bf40e3e3439ed6d1973a1d528f77a7fdfb14f6fe93179ac2b5ee">ETHER_EVENT_INTERRUPT</a>:</div><div class="line">        {</div><div class="line">            <span class="keywordflow">if</span> (ETHER_EXAMPLE_ETHER_ISR_EC_MPD_MASK == (p_args-&gt;<a class="code" href="group___e_t_h_e_r___a_p_i.html#af3841da2d8c5298a41614fd264f429b3">status_ecsr</a> &amp; ETHER_EXAMPLE_ETHER_ISR_EC_MPD_MASK))</div><div class="line">            {</div><div class="line">                g_example_magic_packet_done = ETHER_EXAMPLE_FLAG_ON;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (ETHER_EXAMPLE_ETHER_ISR_EE_TC_MASK == (p_args-&gt;<a class="code" href="group___e_t_h_e_r___a_p_i.html#abf2b41c4e54e2e99bab4e00b131f8a7e">status_eesr</a> &amp; ETHER_EXAMPLE_ETHER_ISR_EE_TC_MASK))</div><div class="line">            {</div><div class="line">                g_example_transfer_complete = ETHER_EXAMPLE_FLAG_ON;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (ETHER_EXAMPLE_ETHER_ISR_EE_FR_MASK == (p_args-&gt;<a class="code" href="group___e_t_h_e_r___a_p_i.html#abf2b41c4e54e2e99bab4e00b131f8a7e">status_eesr</a> &amp; ETHER_EXAMPLE_ETHER_ISR_EE_FR_MASK))</div><div class="line">            {</div><div class="line">                g_example_receive_complete = ETHER_EXAMPLE_FLAG_ON;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">        {</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> ether_advanced_use_internal_buffer_example (<span class="keywordtype">void</span>) {</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Source MAC Address */</span></div><div class="line">    <span class="keyword">static</span> uint8_t mac_address_source[6] = {ETHER_EXAMPLE_SOURCE_MAC_ADDRESS};</div><div class="line"></div><div class="line">    <span class="keyword">static</span> uint8_t * p_read_buffer_nocopy;</div><div class="line">    uint32_t         read_data_size = 0;</div><div class="line"></div><div class="line">    g_ether0_cfg.p_mac_address = mac_address_source;</div><div class="line"></div><div class="line">    g_ether0_cfg.zerocopy   = <a class="code" href="group___e_t_h_e_r___a_p_i.html#ggad3c9ba84cbe05cc1ff9b37d25318dd07ae6b9b9b112795b5334d6198f088692ac">ETHER_ZEROCOPY_ENABLE</a>;</div><div class="line">    g_ether0_cfg.p_callback = (void (*)(<a class="code" href="group___e_t_h_e_r___a_p_i.html#structether__callback__args__t">ether_callback_args_t</a> *))ether_example_callback;</div><div class="line"></div><div class="line">    <span class="comment">/* Open the ether instance with initial configuration. */</span></div><div class="line">    err = <a class="code" href="group___e_t_h_e_r.html#gab2b878c7b67357c06e1f9231265819fd">R_ETHER_Open</a>(&amp;g_ether0_ctrl, &amp;g_ether0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* When the Ethernet link status read from the PHY-LSI Basic Status register is link-up,</span></div><div class="line"><span class="comment">         * Initializes the module and make auto negotiation. */</span></div><div class="line">        err = <a class="code" href="group___e_t_h_e_r.html#gab10af3abff76900b7895934685c43311">R_ETHER_LinkProcess</a>(&amp;g_ether0_ctrl);</div><div class="line">    } <span class="keywordflow">while</span> (FSP_SUCCESS != err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Set user buffer to TX descriptor and enable transmission. */</span></div><div class="line">    err = <a class="code" href="group___e_t_h_e_r.html#gaad54ccf1420a5c32afe90762eebde112">R_ETHER_Write</a>(&amp;g_ether0_ctrl, (<span class="keywordtype">void</span> *) gp_send_data_internal, <span class="keyword">sizeof</span>(gp_send_data_internal));</div><div class="line">    <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait for the transmission to complete. */</span></div><div class="line">        <span class="comment">/* Data array should not change in zero copy mode until transfer complete. */</span></div><div class="line">        <span class="keywordflow">while</span> (ETHER_EXAMPLE_FLAG_ON != g_example_transfer_complete)</div><div class="line">        {</div><div class="line">            ;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Get receive buffer from RX descriptor. */</span></div><div class="line">    err = <a class="code" href="group___e_t_h_e_r.html#ga174de3d54336469ca7a1e5949820bd3f">R_ETHER_Read</a>(&amp;g_ether0_ctrl, (<span class="keywordtype">void</span> *) &amp;p_read_buffer_nocopy, &amp;read_data_size);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Process received data here */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Release receive buffer to RX descriptor. */</span></div><div class="line">    err = <a class="code" href="group___e_t_h_e_r.html#ga3bc8e53a14aa52d4d2b9b247ddd7cce8">R_ETHER_BufferRelease</a>(&amp;g_ether0_ctrl);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Disable transmission and receive function and close the ether instance. */</span></div><div class="line">    <a class="code" href="group___e_t_h_e_r.html#gafbd25f2b961e8e2a807444f04e08d158">R_ETHER_Close</a>(&amp;g_ether0_ctrl);</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define ETHER_EXAMPLE_ALIGNMENT_32_BYTE                (32)</span></div><div class="line"><span class="preprocessor">#define ETHER_EXAMPLE_ETHERNET_FRAME_PAYLOAD_OFFSET    (14)</span></div><div class="line"></div><div class="line"><span class="comment">/* The data buffer must be 32-byte aligned when using zero copy mode. */</span></div><div class="line"><span class="keyword">static</span> uint8_t gp_send_data_external[ETHER_EXAMPLE_TRANSMIT_ETHERNET_FRAME_SIZE] =</div><div class="line">{</div><div class="line">    ETHER_EXAMPLE_DESTINATION_MAC_ADDRESS, <span class="comment">/* Destination MAC address */</span></div><div class="line">    ETHER_EXAMPLE_SOURCE_MAC_ADDRESS,      <span class="comment">/* Source MAC address */</span></div><div class="line">    ETHER_EXAMPLE_FRAME_TYPE,              <span class="comment">/* Type field */</span></div><div class="line">    ETHER_EXAMPLE_PAYLOAD                  <span class="comment">/* Payload value (46byte) */</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>st_buffer_node</div><div class="line">{</div><div class="line">    uint8_t               * p_buffer;</div><div class="line">    <span class="keyword">struct </span>st_buffer_node * p_next;</div><div class="line">} buffer_node_t;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> ether_advanced_use_external_buffer_example (<span class="keywordtype">void</span>) {</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Source MAC Address */</span></div><div class="line">    uint8_t mac_address_source[6] = {ETHER_EXAMPLE_SOURCE_MAC_ADDRESS};</div><div class="line"></div><div class="line">    uint8_t       * p_tx_buffer           = NULL;</div><div class="line">    uint8_t       * p_rx_buffer           = NULL;</div><div class="line">    uint8_t       * p_rx_allocate_buffer  = NULL;</div><div class="line">    uint8_t       * p_tx_last_sent_buffer = NULL;</div><div class="line">    buffer_node_t * p_tx_buffer_head;</div><div class="line">    buffer_node_t * p_tx_buffer_tail;</div><div class="line"></div><div class="line">    uint32_t read_data_size = 0;</div><div class="line">    uint8_t  i;</div><div class="line"></div><div class="line">    g_ether0_cfg.p_mac_address = mac_address_source;</div><div class="line"></div><div class="line">    g_ether0_cfg.zerocopy         = <a class="code" href="group___e_t_h_e_r___a_p_i.html#ggad3c9ba84cbe05cc1ff9b37d25318dd07ae6b9b9b112795b5334d6198f088692ac">ETHER_ZEROCOPY_ENABLE</a>;</div><div class="line">    g_ether0_cfg.pp_ether_buffers = NULL;</div><div class="line"></div><div class="line">    <span class="comment">/* Create ring buffer structure to manage transmit buffer.*/</span></div><div class="line">    p_tx_buffer_head = (buffer_node_t *) malloc(<span class="keyword">sizeof</span>(buffer_node_t));</div><div class="line">    p_tx_buffer_tail = p_tx_buffer_head;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; g_ether0_cfg.num_tx_descriptors - 1; i++)</div><div class="line">    {</div><div class="line">        p_tx_buffer_tail-&gt;p_buffer = NULL;</div><div class="line">        p_tx_buffer_tail-&gt;p_next   = (buffer_node_t *) malloc(<span class="keyword">sizeof</span>(buffer_node_t));</div><div class="line">        p_tx_buffer_tail           = p_tx_buffer_tail-&gt;p_next;</div><div class="line">    }</div><div class="line"></div><div class="line">    p_tx_buffer_tail-&gt;p_buffer = NULL;</div><div class="line">    p_tx_buffer_tail-&gt;p_next   = p_tx_buffer_head;</div><div class="line"></div><div class="line">    <span class="comment">/* Open the ether instance with initial configuration. */</span></div><div class="line">    err = <a class="code" href="group___e_t_h_e_r.html#gab2b878c7b67357c06e1f9231265819fd">R_ETHER_Open</a>(&amp;g_ether0_ctrl, &amp;g_ether0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    i = 0;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize receive buffer in Ethernet driver. */</span></div><div class="line">    <span class="keywordflow">while</span> (i &lt; g_ether0_cfg.num_rx_descriptors)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (posix_memalign((<span class="keywordtype">void</span> **) &amp;p_rx_allocate_buffer,</div><div class="line">                           ETHER_EXAMPLE_ALIGNMENT_32_BYTE,</div><div class="line">                           g_ether0_cfg.ether_buffer_size * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>)))</div><div class="line">        {</div><div class="line"></div><div class="line">            <span class="comment">/* Set receive buffer to Ethernet driver. */</span></div><div class="line">            err = <a class="code" href="group___e_t_h_e_r.html#ga7ea6c9f72dc3b81cdcf6de7c84a87d53">R_ETHER_RxBufferUpdate</a>(&amp;g_ether0_ctrl, (<span class="keywordtype">void</span> *) p_rx_allocate_buffer);</div><div class="line"></div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">            {</div><div class="line">                i++;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            assert(0);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* When the Ethernet link status read from the PHY-LSI Basic Status register is link-up,</span></div><div class="line"><span class="comment">         * Initializes the module and make auto negotiation. */</span></div><div class="line">        err = <a class="code" href="group___e_t_h_e_r.html#gab10af3abff76900b7895934685c43311">R_ETHER_LinkProcess</a>(&amp;g_ether0_ctrl);</div><div class="line">    } <span class="keywordflow">while</span> (FSP_SUCCESS != err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (1)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (NULL == p_tx_buffer_tail-&gt;p_buffer)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Allocate memory to transmit buffer */</span></div><div class="line">            p_tx_buffer = (uint8_t *) malloc(<span class="keyword">sizeof</span>(gp_send_data_external));</div><div class="line"></div><div class="line">            <span class="comment">/* Process transmit data here. */</span></div><div class="line">            memcpy(p_tx_buffer, gp_send_data_external, <span class="keyword">sizeof</span>(gp_send_data_external));</div><div class="line">            gp_send_data_external[ETHER_EXAMPLE_ETHERNET_FRAME_PAYLOAD_OFFSET]++;</div><div class="line"></div><div class="line">            <span class="comment">/* Set user buffer to TX descriptor and enable transmission. */</span></div><div class="line">            err = <a class="code" href="group___e_t_h_e_r.html#gaad54ccf1420a5c32afe90762eebde112">R_ETHER_Write</a>(&amp;g_ether0_ctrl, (<span class="keywordtype">void</span> *) gp_send_data_external, <span class="keyword">sizeof</span>(gp_send_data_external));</div><div class="line"></div><div class="line">            <span class="comment">/* Register transmit buffer to ring buffer. */</span></div><div class="line">            <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">            {</div><div class="line">                p_tx_buffer_tail-&gt;p_buffer = p_tx_buffer;</div><div class="line">                p_tx_buffer_tail           = p_tx_buffer_tail-&gt;p_next;</div><div class="line">            }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">            {</div><div class="line">                <span class="comment">/* Release transmit buffer. */</span></div><div class="line">                free(p_tx_buffer);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Get receive buffer from RX descriptor. */</span></div><div class="line">        err = <a class="code" href="group___e_t_h_e_r.html#ga174de3d54336469ca7a1e5949820bd3f">R_ETHER_Read</a>(&amp;g_ether0_ctrl, (<span class="keywordtype">void</span> *) &amp;p_rx_buffer, &amp;read_data_size);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Allocate new receive buffer and update receive buffer to RX descriptor. */</span></div><div class="line">            <span class="keywordflow">if</span> (0 == posix_memalign((<span class="keywordtype">void</span> **) &amp;p_rx_allocate_buffer,</div><div class="line">                                    ETHER_EXAMPLE_ALIGNMENT_32_BYTE,</div><div class="line">                                    g_ether0_cfg.ether_buffer_size * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>)))</div><div class="line">            {</div><div class="line">                <a class="code" href="group___e_t_h_e_r.html#ga7ea6c9f72dc3b81cdcf6de7c84a87d53">R_ETHER_RxBufferUpdate</a>(&amp;g_ether0_ctrl, p_rx_allocate_buffer);</div><div class="line">            }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">            {</div><div class="line">                assert(0);</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">/* Process received data here. */</span></div><div class="line"></div><div class="line">            <span class="comment">/* Release receive buffer. */</span></div><div class="line">            free(p_rx_buffer);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Release all transmitted buffer from the ring buffer. */</span></div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS == <a class="code" href="group___e_t_h_e_r.html#ga8993d43da08dc2f328d67be680fa85e0">R_ETHER_TxStatusGet</a>(&amp;g_ether0_ctrl, (<span class="keywordtype">void</span> *) &amp;p_tx_last_sent_buffer))</div><div class="line">        {</div><div class="line">            buffer_node_t * p_tx_buffer_current = p_tx_buffer_head;</div><div class="line">            <span class="keywordflow">for</span> (i = 0; i &lt; g_ether0_cfg.num_tx_descriptors; i++)</div><div class="line">            {</div><div class="line">                <span class="keywordflow">if</span> (p_tx_last_sent_buffer == p_tx_buffer_current-&gt;p_buffer)</div><div class="line">                {</div><div class="line">                    <span class="keywordflow">do</span></div><div class="line">                    {</div><div class="line">                        free(p_tx_buffer_head-&gt;p_buffer);</div><div class="line">                        p_tx_buffer_head-&gt;p_buffer = NULL;</div><div class="line">                        p_tx_buffer_head           = p_tx_buffer_head-&gt;p_next;</div><div class="line">                    } <span class="keywordflow">while</span> (p_tx_buffer_head != p_tx_buffer_current);</div><div class="line"></div><div class="line">                    free(p_tx_buffer_head-&gt;p_buffer);</div><div class="line">                    p_tx_buffer_head-&gt;p_buffer = NULL;</div><div class="line"></div><div class="line">                    <span class="keywordflow">break</span>;</div><div class="line">                }</div><div class="line"></div><div class="line">                p_tx_buffer_current = p_tx_buffer_current-&gt;p_next;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structether__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_t_h_e_r.html#structether__instance__ctrl__t">ether_instance_ctrl_t</a></td></tr>
<tr class="separator:structether__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga84685e14baf908ba6180ecbfafc18621"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_t_h_e_r.html#ga84685e14baf908ba6180ecbfafc18621">ether_previous_link_status_t</a> </td></tr>
<tr class="separator:ga84685e14baf908ba6180ecbfafc18621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0df8da3261a6a2dc9b9b430c00c6ad2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_t_h_e_r.html#gab0df8da3261a6a2dc9b9b430c00c6ad2">ether_link_change_t</a> </td></tr>
<tr class="separator:gab0df8da3261a6a2dc9b9b430c00c6ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac38559e233d4678a9b24d2ee16aa9d7b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_t_h_e_r.html#gac38559e233d4678a9b24d2ee16aa9d7b">ether_magic_packet_t</a> </td></tr>
<tr class="separator:gac38559e233d4678a9b24d2ee16aa9d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a49b9f7718ca059e906c12de43c0784"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_t_h_e_r.html#ga9a49b9f7718ca059e906c12de43c0784">ether_link_establish_status_t</a> </td></tr>
<tr class="separator:ga9a49b9f7718ca059e906c12de43c0784"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structether__instance__ctrl__t" id="structether__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structether__instance__ctrl__t">&#9670;&nbsp;</a></span>ether_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ether_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>ETHER control block. DO NOT INITIALIZE. Initialization occurs when <a class="el" href="group___e_t_h_e_r___a_p_i.html#ae75458ac2a31861195b73120676d670c">ether_api_t::open</a> is called. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a5a47551251fa2ce32c2eb47789bfc1ec"></a>uint32_t</td>
<td class="fieldname">
open</td>
<td class="fielddoc">
Used to determine if the channel is configured. </td></tr>
<tr><td class="fieldtype">
<a id="abe2e7e26edeea76c44da7a17cec958d0"></a><a class="el" href="group___e_t_h_e_r___a_p_i.html#structether__cfg__t">ether_cfg_t</a> const  *</td>
<td class="fieldname">
p_ether_cfg</td>
<td class="fielddoc">
Pointer to initial configurations. </td></tr>
<tr><td class="fieldtype">
<a id="a5f9f64bc5b34fd3a8c679511a3432b06"></a><a class="el" href="group___e_t_h_e_r___a_p_i.html#structether__instance__descriptor__t">ether_instance_descriptor_t</a> *</td>
<td class="fieldname">
p_rx_descriptor</td>
<td class="fielddoc">
Pointer to the currently referenced transmit descriptor. </td></tr>
<tr><td class="fieldtype">
<a id="a2a90ddc68dffa65649d6693d100c59b1"></a><a class="el" href="group___e_t_h_e_r___a_p_i.html#structether__instance__descriptor__t">ether_instance_descriptor_t</a> *</td>
<td class="fieldname">
p_tx_descriptor</td>
<td class="fielddoc">
Pointer to the currently referenced receive descriptor. </td></tr>
<tr><td class="fieldtype">
<a id="a88583eae336381d4fb07fb83449b0856"></a>void *</td>
<td class="fieldname">
p_reg_etherc</td>
<td class="fielddoc">
Base register of ethernet controller for this channel. </td></tr>
<tr><td class="fieldtype">
<a id="a8cb5a35a2882e21dd17808bc62ab7cf7"></a>void *</td>
<td class="fieldname">
p_reg_edmac</td>
<td class="fielddoc">
Base register of EDMA controller for this channel. </td></tr>
<tr><td class="fieldtype">
<a id="ad207a1be57e5eb9ceb79ff5344efb6a7"></a><a class="el" href="group___e_t_h_e_r.html#ga84685e14baf908ba6180ecbfafc18621">ether_previous_link_status_t</a></td>
<td class="fieldname">
previous_link_status</td>
<td class="fielddoc">
Previous link status. </td></tr>
<tr><td class="fieldtype">
<a id="a65bb4564fbf4e0a16fa2fe84762192db"></a><a class="el" href="group___e_t_h_e_r.html#gab0df8da3261a6a2dc9b9b430c00c6ad2">ether_link_change_t</a></td>
<td class="fieldname">
link_change</td>
<td class="fielddoc">
status of link change </td></tr>
<tr><td class="fieldtype">
<a id="a1f919131083d021455a2e75b0d1d2f4e"></a><a class="el" href="group___e_t_h_e_r.html#gac38559e233d4678a9b24d2ee16aa9d7b">ether_magic_packet_t</a></td>
<td class="fieldname">
magic_packet</td>
<td class="fielddoc">
status of magic packet detection </td></tr>
<tr><td class="fieldtype">
<a id="a72f0205de3ce7f074088034cbdbc6f06"></a><a class="el" href="group___e_t_h_e_r.html#ga9a49b9f7718ca059e906c12de43c0784">ether_link_establish_status_t</a></td>
<td class="fieldname">
link_establish_status</td>
<td class="fielddoc">
Current Link status. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga84685e14baf908ba6180ecbfafc18621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84685e14baf908ba6180ecbfafc18621">&#9670;&nbsp;</a></span>ether_previous_link_status_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___e_t_h_e_r.html#ga84685e14baf908ba6180ecbfafc18621">ether_previous_link_status_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga84685e14baf908ba6180ecbfafc18621a0cb808fc5ef37f4af6a44e9f0156c123"></a>ETHER_PREVIOUS_LINK_STATUS_DOWN&#160;</td><td class="fielddoc"><p>Previous link status is down. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga84685e14baf908ba6180ecbfafc18621afc172a815ac21e377ad33af9f15ca4be"></a>ETHER_PREVIOUS_LINK_STATUS_UP&#160;</td><td class="fielddoc"><p>Previous link status is up. </p>
</td></tr>
</table>

</div>
</div>
<a id="gab0df8da3261a6a2dc9b9b430c00c6ad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0df8da3261a6a2dc9b9b430c00c6ad2">&#9670;&nbsp;</a></span>ether_link_change_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___e_t_h_e_r.html#gab0df8da3261a6a2dc9b9b430c00c6ad2">ether_link_change_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab0df8da3261a6a2dc9b9b430c00c6ad2aadfc4290b54066048b67e26e367907e3"></a>ETHER_LINK_CHANGE_NO_CHANGE&#160;</td><td class="fielddoc"><p>Link status is no change. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab0df8da3261a6a2dc9b9b430c00c6ad2a705aae645a6a1aa81ab26d15197c1456"></a>ETHER_LINK_CHANGE_LINK_DOWN&#160;</td><td class="fielddoc"><p>Link status changes to down. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab0df8da3261a6a2dc9b9b430c00c6ad2a6c325e2fb4268597e346f6a21dfc4d02"></a>ETHER_LINK_CHANGE_LINK_UP&#160;</td><td class="fielddoc"><p>Link status changes to up. </p>
</td></tr>
</table>

</div>
</div>
<a id="gac38559e233d4678a9b24d2ee16aa9d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac38559e233d4678a9b24d2ee16aa9d7b">&#9670;&nbsp;</a></span>ether_magic_packet_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___e_t_h_e_r.html#gac38559e233d4678a9b24d2ee16aa9d7b">ether_magic_packet_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac38559e233d4678a9b24d2ee16aa9d7ba655f088c230f2c5495ef492408337e09"></a>ETHER_MAGIC_PACKET_NOT_DETECTED&#160;</td><td class="fielddoc"><p>Magic packet is not detected. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac38559e233d4678a9b24d2ee16aa9d7ba0e6a084b224d9f4cda97146dda0cb0f5"></a>ETHER_MAGIC_PACKET_DETECTED&#160;</td><td class="fielddoc"><p>Magic packet is detected. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga9a49b9f7718ca059e906c12de43c0784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a49b9f7718ca059e906c12de43c0784">&#9670;&nbsp;</a></span>ether_link_establish_status_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___e_t_h_e_r.html#ga9a49b9f7718ca059e906c12de43c0784">ether_link_establish_status_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9a49b9f7718ca059e906c12de43c0784aa8c8ee515baf9098d043094378fdf0c5"></a>ETHER_LINK_ESTABLISH_STATUS_DOWN&#160;</td><td class="fielddoc"><p>Link establish status is down. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a49b9f7718ca059e906c12de43c0784a52c3f79c649e8bb24e98b66480b2870f"></a>ETHER_LINK_ESTABLISH_STATUS_UP&#160;</td><td class="fielddoc"><p>Link establish status is up. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab2b878c7b67357c06e1f9231265819fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2b878c7b67357c06e1f9231265819fd">&#9670;&nbsp;</a></span>R_ETHER_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ETHER_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___e_t_h_e_r___a_p_i.html#structether__cfg__t">ether_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>After ETHERC, EDMAC and PHY-LSI are reset in software, an auto negotiation of PHY-LSI is begun. Afterwards, the link signal change interrupt is permitted. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#ae75458ac2a31861195b73120676d670c">ether_api_t::open</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Channel opened successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to ETHER control block or configuration structure is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Control block has already been opened or channel is being used by another instance. Call close() then open() to reconfigure. </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_ERROR_PHY_COMMUNICATION</td><td>Initialization of PHY-LSI failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_CHANNEL</td><td>Invalid channel number is given. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_POINTER</td><td>Pointer to MAC address is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ARGUMENT</td><td>Interrupt is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_PHY_ERROR_LINK</td><td>Initialization of PHY-LSI failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafbd25f2b961e8e2a807444f04e08d158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbd25f2b961e8e2a807444f04e08d158">&#9670;&nbsp;</a></span>R_ETHER_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ETHER_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables interrupts. Removes power and releases hardware lock. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#a1c0bc3caef73e0a216c2fe2edc4fff4b">ether_api_t::close</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Channel successfully closed. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to ETHER control block is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga174de3d54336469ca7a1e5949820bd3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga174de3d54336469ca7a1e5949820bd3f">&#9670;&nbsp;</a></span>R_ETHER_Read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ETHER_Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>p_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *const&#160;</td>
          <td class="paramname"><em>length_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive Ethernet frame. Receives data to the location specified by the pointer to the receive buffer. In zero copy mode, the address of the receive buffer is returned. In non zero copy mode, the received data in the internal buffer is copied to the pointer passed by the argument. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#a41d56c8843a454690b1969f8f766d65a">ether_api_t::read</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Processing completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to ETHER control block is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_ERROR_NO_DATA</td><td>There is no data in receive buffer. </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_ERROR_LINK</td><td>Auto-negotiation is not completed, and reception is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_ERROR_MAGIC_PACKET_MODE</td><td>As a Magic Packet is being detected, transmission and reception is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_ERROR_FILTERING</td><td>Multicast Frame filter is enable, and Multicast Address Frame is received. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_POINTER</td><td>Value of the pointer is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3bc8e53a14aa52d4d2b9b247ddd7cce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bc8e53a14aa52d4d2b9b247ddd7cce8">&#9670;&nbsp;</a></span>R_ETHER_BufferRelease()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ETHER_BufferRelease </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move to the next buffer in the circular receive buffer list. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#aa38e7f82e66fd26fd8d51b11f46ae6e6">ether_api_t::bufferRelease</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Processing completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to ETHER control block is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_ERROR_LINK</td><td>Auto-negotiation is not completed, and reception is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_ERROR_MAGIC_PACKET_MODE</td><td>As a Magic Packet is being detected, transmission and reception is not enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7ea6c9f72dc3b81cdcf6de7c84a87d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ea6c9f72dc3b81cdcf6de7c84a87d53">&#9670;&nbsp;</a></span>R_ETHER_RxBufferUpdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ETHER_RxBufferUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>p_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the buffer pointer of the current rx buffer descriptor. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#aa714b8287d1cef38d8442850dd9b9fb5">ether_api_t::rxBufferUpdate</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Processing completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A pointer argument is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_POINTER</td><td>The pointer of buffer is NULL or not aligned on a 32-bit boundary. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>Driver is configured to non zero copy mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_RECEIVE_BUFFER_ACTIVE</td><td>All descriptor is active. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaad54ccf1420a5c32afe90762eebde112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad54ccf1420a5c32afe90762eebde112">&#9670;&nbsp;</a></span>R_ETHER_Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ETHER_Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>p_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>frame_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit Ethernet frame. Transmits data from the location specified by the pointer to the transmit buffer, with the data size equal to the specified frame length. In the non zero copy mode, transmits data after being copied to the internal buffer. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#a92e87f33f0a4e0ccb26464d697cdf233">ether_api_t::write</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Processing completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to ETHER control block is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_ERROR_LINK</td><td>Auto-negotiation is not completed, and reception is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_ERROR_MAGIC_PACKET_MODE</td><td>As a Magic Packet is being detected, transmission and reception is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_ERROR_TRANSMIT_BUFFER_FULL</td><td>Transmit buffer is not empty. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_POINTER</td><td>Value of the pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ARGUMENT</td><td>Value of the send frame size is out of range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab10af3abff76900b7895934685c43311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab10af3abff76900b7895934685c43311">&#9670;&nbsp;</a></span>R_ETHER_LinkProcess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ETHER_LinkProcess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Link up processing, the Link down processing, and the magic packet detection processing are executed. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#a125ca4ee69c6c63e1db42708324c0fb3">ether_api_t::linkProcess</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Link is up. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to ETHER control block is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_ERROR_LINK</td><td>Link is down. </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_ERROR_PHY_COMMUNICATION</td><td>When reopening the PHY interface initialization of the PHY-LSI failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>When reopening the PHY interface it was already opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_CHANNEL</td><td>When reopening the PHY interface an invalid channel was passed. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_POINTER</td><td>When reopening the PHY interface the MAC address pointer was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ARGUMENT</td><td>When reopening the PHY interface the interrupt was not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_PHY_ERROR_LINK</td><td>Initialization of the PHY-LSI failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga992be578c310d212389be65762d1b6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga992be578c310d212389be65762d1b6ea">&#9670;&nbsp;</a></span>R_ETHER_WakeOnLANEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ETHER_WakeOnLANEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The setting of ETHERC is changed from normal sending and receiving mode to magic packet detection mode. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#afabb87ef0be65717bb7675a4a004e3ad">ether_api_t::wakeOnLANEnable</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Processing completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to ETHER control block is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_ERROR_LINK</td><td>Auto-negotiation is not completed, and reception is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_PHY_ERROR_LINK</td><td>Initialization of PHY-LSI failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8993d43da08dc2f328d67be680fa85e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8993d43da08dc2f328d67be680fa85e0">&#9670;&nbsp;</a></span>R_ETHER_TxStatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ETHER_TxStatusGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___e_t_h_e_r___a_p_i.html#gad9e606976602503ffeb95f3e2c717e6f">ether_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>p_buffer_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides status of Ethernet driver in the user provided pointer. Implements <a class="el" href="group___e_t_h_e_r___a_p_i.html#a6fde51a3fef6b43ed0fada563fadfb4e">ether_api_t::txStatusGet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Transmit buffer address is stored in provided p_buffer_address. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to ETHER control block is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_POINTER</td><td>p_status is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_FOUND</td><td>Transmit buffer address has been overwritten in transmit descriptor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v3.0.0 User's Manual Copyright  (2021) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
