<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: PTP (r_ptp)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v4.2.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">
 
    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text"> 
      </span>
      <span class="right">
          &nbsp; 
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___p_t_p.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() { 
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body. 
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works 
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len)); 
            }
          } 
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }    
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element. 
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;  
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<div class="title">PTP (r_ptp)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___n_e_t_w_o_r_k_i_n_g___m_o_d_u_l_e_s.html">Networking</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac64c5e4a41f886f32a2396020e6e9669"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_t_p.html#gac64c5e4a41f886f32a2396020e6e9669">R_PTP_Open</a> (ptp_ctrl_t *const p_ctrl, <a class="el" href="group___p_t_p___a_p_i.html#structptp__cfg__t">ptp_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:gac64c5e4a41f886f32a2396020e6e9669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cf674cbb8cafcd8a090608167b20271"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_t_p.html#ga1cf674cbb8cafcd8a090608167b20271">R_PTP_MacAddrSet</a> (ptp_ctrl_t *const p_ctrl, uint8_t const *const p_mac_addr)</td></tr>
<tr class="separator:ga1cf674cbb8cafcd8a090608167b20271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1147acf7f5f8b34247f6e2fda64fd794"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_t_p.html#ga1147acf7f5f8b34247f6e2fda64fd794">R_PTP_IpAddrSet</a> (ptp_ctrl_t *const p_ctrl, uint32_t ip_addr)</td></tr>
<tr class="separator:ga1147acf7f5f8b34247f6e2fda64fd794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd493ac1a0bb441a875b8f4cbcb48689"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_t_p.html#gadd493ac1a0bb441a875b8f4cbcb48689">R_PTP_LocalClockIdSet</a> (ptp_ctrl_t *const p_ctrl, uint8_t const *const p_clock_id)</td></tr>
<tr class="separator:gadd493ac1a0bb441a875b8f4cbcb48689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8a649eb2aed004ccf17135f527e9503"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_t_p.html#gaf8a649eb2aed004ccf17135f527e9503">R_PTP_MasterClockIdSet</a> (ptp_ctrl_t *const p_ctrl, uint8_t const *const p_clock_id, uint16_t port_id)</td></tr>
<tr class="separator:gaf8a649eb2aed004ccf17135f527e9503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb66200ebc5d880fb8b3bef9b091734c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_t_p.html#gadb66200ebc5d880fb8b3bef9b091734c">R_PTP_MessageFlagsSet</a> (ptp_ctrl_t *const p_ctrl, <a class="el" href="group___p_t_p___a_p_i.html#gad488af97304ef1466637952ecb35ea37">ptp_message_type_t</a> message_type, <a class="el" href="group___p_t_p___a_p_i.html#structptp__message__flags__t">ptp_message_flags_t</a> flags)</td></tr>
<tr class="separator:gadb66200ebc5d880fb8b3bef9b091734c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7c3176ad9d2b8fe00fda18d2faeac01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_t_p.html#gae7c3176ad9d2b8fe00fda18d2faeac01">R_PTP_CurrentUtcOffsetSet</a> (ptp_ctrl_t *const p_ctrl, uint16_t offset)</td></tr>
<tr class="separator:gae7c3176ad9d2b8fe00fda18d2faeac01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0850f602bdcc31584f8fd8652ad8dc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_t_p.html#gae0850f602bdcc31584f8fd8652ad8dc9">R_PTP_PortStateSet</a> (ptp_ctrl_t *const p_ctrl, uint32_t state)</td></tr>
<tr class="separator:gae0850f602bdcc31584f8fd8652ad8dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4c9e431f1209bb087dd3f6c7233c89a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_t_p.html#gad4c9e431f1209bb087dd3f6c7233c89a">R_PTP_MessageSend</a> (ptp_ctrl_t *const p_ctrl, <a class="el" href="group___p_t_p___a_p_i.html#structptp__message__t">ptp_message_t</a> const *const p_message, uint8_t const *const p_tlv_data, uint16_t tlv_data_size)</td></tr>
<tr class="separator:gad4c9e431f1209bb087dd3f6c7233c89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ce3801ef62ff464667916864e1f3e1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_t_p.html#ga6ce3801ef62ff464667916864e1f3e1a">R_PTP_LocalClockValueSet</a> (ptp_ctrl_t *const p_ctrl, <a class="el" href="group___p_t_p___a_p_i.html#structptp__time__t">ptp_time_t</a> const *const p_time)</td></tr>
<tr class="separator:ga6ce3801ef62ff464667916864e1f3e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacea3b3940af3df1f91101e722f26d6ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_t_p.html#gacea3b3940af3df1f91101e722f26d6ef">R_PTP_LocalClockValueGet</a> (ptp_ctrl_t *const p_ctrl, <a class="el" href="group___p_t_p___a_p_i.html#structptp__time__t">ptp_time_t</a> *const p_time)</td></tr>
<tr class="separator:gacea3b3940af3df1f91101e722f26d6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga805458fe513b8ad84e56ef4bc6b9efe3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_t_p.html#ga805458fe513b8ad84e56ef4bc6b9efe3">R_PTP_PulseTimerCommonConfig</a> (ptp_ctrl_t *const p_ctrl, <a class="el" href="group___p_t_p___a_p_i.html#structptp__pulse__timer__common__cfg__t">ptp_pulse_timer_common_cfg_t</a> *const p_timer_cfg)</td></tr>
<tr class="separator:ga805458fe513b8ad84e56ef4bc6b9efe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf42f6597cf6da5dd7f6cdf180826ede"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_t_p.html#gadf42f6597cf6da5dd7f6cdf180826ede">R_PTP_PulseTimerEnable</a> (ptp_ctrl_t *const p_ctrl, uint32_t channel, <a class="el" href="group___p_t_p___a_p_i.html#structptp__pulse__timer__cfg__t">ptp_pulse_timer_cfg_t</a> *const p_timer_cfg)</td></tr>
<tr class="separator:gadf42f6597cf6da5dd7f6cdf180826ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga449c98ce945e5d8821fa74c89b8dfb75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_t_p.html#ga449c98ce945e5d8821fa74c89b8dfb75">R_PTP_PulseTimerDisable</a> (ptp_ctrl_t *const p_ctrl, uint32_t channel)</td></tr>
<tr class="separator:ga449c98ce945e5d8821fa74c89b8dfb75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa87719b0a35125a830b14b03831e157"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_t_p.html#gafa87719b0a35125a830b14b03831e157">R_PTP_Close</a> (ptp_ctrl_t *const p_ctrl)</td></tr>
<tr class="separator:gafa87719b0a35125a830b14b03831e157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c12489999f0c1913362ef2369bc3765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_t_p.html#ga7c12489999f0c1913362ef2369bc3765">R_PTP_BestMasterClock</a> (<a class="el" href="group___p_t_p___a_p_i.html#structptp__message__t">ptp_message_t</a> const *const p_announce1, <a class="el" href="group___p_t_p___a_p_i.html#structptp__message__t">ptp_message_t</a> const *const p_announce2, int8_t *const p_comparison)</td></tr>
<tr class="separator:ga7c12489999f0c1913362ef2369bc3765"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the PTP peripheral on RA MCUs. This module implements the <a class="el" href="group___p_t_p___a_p_i.html">PTP Interface</a>. </p>
<h1><a class="anchor" id="r-ptp-overview"></a>
Overview</h1>
<p>PTP allows for multiple devices on a network to synchronize their clocks with very high precision. The PTP peripheral generates and processes PTP messages automatically. In slave mode, it also corrects the local time in order to adjust for any offset from the master clock time.</p>
<h2><a class="anchor" id="r-ptp-features"></a>
Features</h2>
<ul>
<li>Ordinary clock<ul>
<li>Master mode</li>
<li>Slave mode</li>
</ul>
</li>
<li>Peer-to-peer</li>
<li>End-to-end</li>
<li>Frame fromats<ul>
<li>Ethernet II frames</li>
<li>IEEE802.3 + LLC + SNAP frames</li>
<li>IPv4 + UDP</li>
</ul>
</li>
<li>Clock correction modes<ul>
<li>Mode 1: Add the offsetFromMaster value to the local time whenever it is updated.</li>
<li>Mode 2: Calculate a clock gradient and continuously adjust the local time in order to minimize the offsetFromMaster value.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="r-ptp-configuration"></a>
Configuration</h1>
<p><h2>Build Time Configurations for r_ptp</h2>
The following build time configurations are defined in fsp_cfg/r_ptp_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
</table>
 <h2>Configurations for Networking &gt; PTP (r_ptp)</h2>
This module can be added to the Stacks tab via New Stack &gt; Networking &gt; PTP (r_ptp).<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Clock Properties &gt; Priority 1</td><td>Value must in the range [0,255].</td><td>128 </td><td>Priority1 field advertised in generated announce packets. </td></tr>
<tr>
<td>Clock Properties &gt; Class</td><td>Value must in the range [0,255].</td><td>248 </td><td>Class field advertised in generated announce packets. </td></tr>
<tr>
<td>Clock Properties &gt; Accuracy</td><td>Value must in the range [0,255].</td><td>0xFE </td><td>Accuracy field advertised in generated announce packets. </td></tr>
<tr>
<td>Clock Properties &gt; Variance</td><td>Value must in the range [0,65535].</td><td>0xFFFF </td><td>Variance field advertised in generated announce packets. </td></tr>
<tr>
<td>Clock Properties &gt; Priority 2</td><td>Value must in the range [0,255].</td><td>128 </td><td>Priority2 field advertised in generated announce packets. </td></tr>
<tr>
<td>Clock Properties &gt; Time Source</td><td>Value must in the range [0,255].</td><td>160 </td><td>Time Source field advertised in generated announce packets. </td></tr>
<tr>
<td>Ethernet &gt; Multicast Filter MAC address</td><td>Must be a valid MAC address</td><td>01:1B:19:00:00:00 </td><td>In Multicast Filtered mode, only multicast addresses that match this address are received by the ETHERC EDMAC. </td></tr>
<tr>
<td>Ethernet &gt; Primary Destination MAC address</td><td>Must be a valid MAC address</td><td>01:1B:19:00:00:00 </td><td>The destination MAC address for primary PTP messages. </td></tr>
<tr>
<td>Ethernet &gt; PDelay Destination MAC address</td><td>Must be a valid MAC address</td><td>01:80:C2:00:00:0E </td><td>The destination MAC address for PDelay messages. </td></tr>
<tr>
<td>IP &gt; Primary Destination IP address</td><td>Must be a valid IP address</td><td>224.0.1.129 </td><td>The destination IPv4 address for primary messages. </td></tr>
<tr>
<td>IP &gt; PDelay Destination IP address</td><td>Must be a valid IP address</td><td>224.0.0.107 </td><td>The destination IPv4 address for PDelay messages. </td></tr>
<tr>
<td>IP &gt; Event Message TOS</td><td>Value must in the range [0,255].</td><td>0 </td><td>The IP packet TOS for event messages. </td></tr>
<tr>
<td>IP &gt; General Message TOS</td><td>Value must in the range [0,255].</td><td>0 </td><td>The IP packet TOS for general messages. </td></tr>
<tr>
<td>IP &gt; Primary Message TTL</td><td>Value must in the range [0,255].</td><td>1 </td><td>The IP packet TTL for primary messages. </td></tr>
<tr>
<td>IP &gt; PDelay Message TTL</td><td>Value must in the range [0,255].</td><td>1 </td><td>The IP packet TTL for p_delay messages. </td></tr>
<tr>
<td>IP &gt; Event Port</td><td>Value must in the range [0,65535].</td><td>319 </td><td>The UDP port for event messages. </td></tr>
<tr>
<td>IP &gt; General Port</td><td>Value must in the range [0,65535].</td><td>320 </td><td>The UDP port for general messages. </td></tr>
<tr>
<td>Synchronization Detection &gt; Threshold (Nanoseconds)</td><td>Value must be greater than 0.</td><td>1000000 </td><td>The minimum offsetFromMaster value required in order to synchronize with the master clock. </td></tr>
<tr>
<td>Synchronization Detection &gt; Count</td><td>Value must in the range [0,255].</td><td>5 </td><td>The number of times the calculated offsetFromMaster value must be less than the threshold in order to synchronize with the master clock. </td></tr>
<tr>
<td>Synchronization Lost Detection &gt; Threshold (Nanoseconds)</td><td>Value must be greater than 0.</td><td>10000000 </td><td>The minimum offsetFromMaster value required in order to lose synchronization with the master clock. </td></tr>
<tr>
<td>Synchronization Lost Detection &gt; Count</td><td>Value must in the range [0,255].</td><td>5 </td><td>The number of times the calculated offsetFromMaster value must be greater than the threshold in order to lose synchronization with the master. </td></tr>
<tr>
<td>Interrupts &gt; Callback</td><td>Name must be a valid C symbol</td><td>ptp0_user_callback </td><td>Called when a STCA/SYNFP event occurs, a PTP message is received, or if a Pulse Timer event occurs. </td></tr>
<tr>
<td>Interrupts &gt; MINT Interrupt priority</td><td>MCU Specific Options</td><td></td><td>Select the EPTPC MINT interrupt priority. </td></tr>
<tr>
<td>Interrupts &gt; Pulse Timer Interrupt priority</td><td>MCU Specific Options</td><td></td><td>Select the EPTPC IPLS priority. </td></tr>
<tr>
<td>Name</td><td>Name must be a valid C symbol</td><td>g_ptp0 </td><td>Module name. </td></tr>
<tr>
<td>Ethernet PHY Interface Type</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
MII</li>
<li>
RMII</li>
</ul>
</td><td>RMII </td><td>The interface type used to communicate with the Ethernet PHY. </td></tr>
<tr>
<td>Frame Filter</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Extended Promiscuous Mode</li>
<li>
Unicast and Multicast</li>
<li>
Unicast and Multicast Filtered</li>
<li>
Unicast</li>
</ul>
</td><td>Unicast </td><td>Selects how packets are filtered based on their destination MAC address. Packets that pass the filter are transferred to the ETHERC EDMAC. </td></tr>
<tr>
<td>Frame Format</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Ethernet II</li>
<li>
Ethernet II | IPv4 | UDP</li>
<li>
IEEE802.3 | LLC | SNAP</li>
<li>
IEEE802.3 | LLC | SNAP | IPv4 | UDP</li>
</ul>
</td><td>Ethernet II </td><td>The format of the frames that encapsulate the PTP messages. </td></tr>
<tr>
<td>Clock Domain</td><td>Value must in the range [0,255].</td><td>0 </td><td>The PTP clock will only respond to clocks in its domain. </td></tr>
<tr>
<td>Clock Domain Filter</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enable</li>
<li>
Disable</li>
</ul>
</td><td>Enable </td><td>Filter out PTP messages from other clock domains. </td></tr>
<tr>
<td>Buffer Size</td><td>Value must in the range [64,1536].</td><td>1536 </td><td>The maximum Ethernet packet size that can be transmitted or received by the application from the EDMAC. </td></tr>
<tr>
<td>Number of transmit buffers</td><td>Value must in the range [1,16].</td><td>4 </td><td>The number of transmit buffers in the packet queue. </td></tr>
<tr>
<td>Number of receive buffers</td><td>Value must in the range [1,16].</td><td>4 </td><td>The number of receive buffers in the packet queue. </td></tr>
<tr>
<td>Announce message interval.</td><td>MCU Specific Options</td><td></td><td>The period of time between generated announce messages. </td></tr>
<tr>
<td>Sync message interval.</td><td>MCU Specific Options</td><td></td><td>The period of time between generated sync messages. </td></tr>
<tr>
<td>Delay_req message interval.</td><td>MCU Specific Options</td><td></td><td>The period of time between generated delay_req messages. </td></tr>
<tr>
<td>Message timeout</td><td>Value must be greater than 0.</td><td>4000 </td><td>The time in milliseconds needed to generate timeout events after not receiving a sync or delay_resp message. </td></tr>
<tr>
<td>Clock Source</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
PCLKA / 1</li>
<li>
PCLKA / 2</li>
<li>
PCLKA / 3</li>
<li>
PCLKA / 4</li>
<li>
PCLKA / 5</li>
<li>
PCLKA / 6</li>
<li>
REF50CK0</li>
</ul>
</td><td>PCLKA / 6 </td><td>The STCA clock source must be 20Mhz, 25Mhz, 50Mhz, or 100Mhz. When REF50CK0 is selected, the STCA frequency is 25Mhz. </td></tr>
<tr>
<td>Clock Correction Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Clock Correction Mode 1</li>
<li>
Clock Correction Mode 2</li>
</ul>
</td><td>Clock Correction Mode 1 </td><td>Clock correction mode 1 corrects the local clock using the current offsetFromMaster value. Clock correction mode 2 calculates a clock gradient in order to continuously correct the local clock. </td></tr>
<tr>
<td>Gradient Worst10 Interval</td><td>Value must in the range [0,255].</td><td>32 </td><td>The number of sync messages to use when calculating the worst10 gradient values (Only applies to clock correction mode 2). </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-ptp-clock-configuration"></a>
Clock Configuration</h2>
<p>The STCA input clock can be the following clock sources:</p><ul>
<li>PCLKA / 1</li>
<li>PCLKA / 2</li>
<li>PCLKA / 3</li>
<li>PCLKA / 4</li>
<li>PCLKA / 5</li>
<li>PCLKA / 6</li>
<li>REF50CK0</li>
</ul>
<p>The STCA input clock is restricted to the following frequencies:</p><ul>
<li>20 Mhz</li>
<li>25 Mhz</li>
<li>50 Mhz</li>
<li>100 Mhz</li>
</ul>
<p>When REF50CK0 is selected, the input clock frequency is 25 Mhz.</p>
<h2><a class="anchor" id="r-ptp-pin-configuration"></a>
Pin Configuration</h2>
<p>The PTP module requires the <a class="el" href="group___e_t_h_e_r.html">Ethernet (r_ether)</a> instance in order to initialize the Ethernet PHY. This means that the ETHERC pins must be configured.</p>
<h1><a class="anchor" id="r-ptp-usage_notes"></a>
Usage Notes</h1>
<h2>PTP Port State</h2>
<p>The current PTP port state determines which messages need to be generated and processed by the PTP peripheral. It is the application's responsibility to determine what the current state of the PTP port should be.</p>
<p>The following messages can be generated by the PTP peripheral:</p><ul>
<li>Announce</li>
<li>Sync</li>
<li>Delay_req</li>
<li>Delay_resp</li>
<li>PDelay_req</li>
<li>PDelay_resp</li>
</ul>
<p>The following messages can be processed by the PTP peripheral:</p><ul>
<li>Sync</li>
<li>Follow_up</li>
<li>Delay_req</li>
<li>Delay_resp</li>
<li>PDelay_req</li>
<li>PDelay_resp</li>
<li>PDelay_resp_follow_up</li>
</ul>
<p>The application must receive the following messages in order to determine the current state of its PTP port:</p><ul>
<li>Announce</li>
<li>Management</li>
<li>Signaling</li>
</ul>
<p>The following messages can only be sent manually:</p><ul>
<li>Management</li>
<li>Signaling</li>
</ul>
<p>The PTP API defines the following states:</p>
<table class="doxtable">
<tr>
<th>State </th><th>Generated Messages </th><th>Processed Messages </th><th>Received Messages  </th></tr>
<tr>
<td>Disabled </td><td>N/A </td><td>N/A </td><td>N/A </td></tr>
<tr>
<td>Passive </td><td>N/A </td><td>N/A </td><td>Announce, Signaling, Management </td></tr>
<tr>
<td>E2E/P2P Slave </td><td>Delay_req/(PDelay_req, PDelay_resp) </td><td>Sync, Follow_up, Delay_resp/(PDelay_req, PDelay_resp) </td><td>Announce, Signaling, Management </td></tr>
<tr>
<td>E2E/P2P Master </td><td>Announce, Sync, Delay_resp/(PDelay_req, PDelay_resp) </td><td>delay_req/(PDelay_req, PDelay_resp) </td><td>Announce, Signaling, Management </td></tr>
</table>
<h2>Pulse Timers</h2>
<p>Pulse Timers are configurable timers used to generate interrupts and ELC events. Each pulse timer has a configurable start time, pulse, and period. At the start of each timer period, a rising edge occurs. After the pulse time has elapsed, a falling edge occurs. ELC events and IRQs can be generated on rising and/or falling edges for each Pulse Timer. There are two types of interrupts generated by each Pulse Timer; MINT and IPLS. </p><h3>MINT Interrupts</h3>
<p>MINT IRQs are only generated on the rising edge of a Pulse Timer channel. The callback will provide the channel number of the pulse timer that caused the interrupt. </p><h3>IPLS Interrupts</h3>
<p>Each Pulse Timer channel can be configured as a source for generating IPLS IRQs. All of the pulse timers that are selected as IPLS sources are OR'd together and rising and falling edge IRQs can be generated from the resulting signal. Below is an example of a resulting signal from two IPLS sources. Unlike MINT interrupts, IPLS interrupts do not provide any information about which Pulse Timer caused the IRQ because the IRQs from all the Pulse Timers are OR'd together.</p>
<div class="image">
<object type="image/svg+xml" data="r_ptp_pulse_timer_ipls.svg">r_ptp_pulse_timer_ipls.svg</object>
<div class="caption">
IPLS IRQ Generation</div></div>
 <h2>Ethernet Frame Filter</h2>
<p>The PTP driver can filter Ethernet frames that are received by <a class="el" href="group___e_t_h_e_r.html">Ethernet (r_ether)</a>. There are four different filtering modes:</p><ul>
<li>Extended Promiscuous - All Ethernet frames are received by <a class="el" href="group___e_t_h_e_r.html">Ethernet (r_ether)</a>.</li>
<li>Unicast and Multicast - All Unicast frames destined for the PTP and Multicast frames are received by <a class="el" href="group___e_t_h_e_r.html">Ethernet (r_ether)</a>.</li>
<li>Unicast and Multicast Filtered - All Unicast frames destined for the PTP are received by <a class="el" href="group___e_t_h_e_r.html">Ethernet (r_ether)</a>. All multicast frames that match <a class="el" href="group___p_t_p___a_p_i.html#a80d387b424e8e014e168acbfccad06e4">ptp_synfp_cfg_t::p_multicast_addr_filter</a> are received by <a class="el" href="group___e_t_h_e_r.html">Ethernet (r_ether)</a>.</li>
<li>Unicast - Only Unicast frames destined for the PTP are received by <a class="el" href="group___e_t_h_e_r.html">Ethernet (r_ether)</a>.</li>
</ul>
<h2><a class="anchor" id="r-ptp-limitations"></a>
Limitations</h2>
<p>Developers should be aware of the following limitations when using the PTP:</p>
<ul>
<li>PTP will not automatically initialize <a class="el" href="group___e_t_h_e_r.html">Ethernet (r_ether)</a>. This provides flexibility by allowing PTP to be used alongside 3rd party IP stacks (Eg. <a class="el" href="group___f_r_e_e_r_t_o_s___p_l_u_s___t_c_p.html">FreeRTOS+TCP Wrapper to r_ether (rm_freertos_plus_tcp)</a>), however this means the application must execute the <a class="el" href="group___e_t_h_e_r.html">Ethernet (r_ether)</a> link process in order to use PTP.</li>
<li>The driver will not detect announce message timeouts. This functionality must be handled by the application.</li>
<li>When IP + UDP frame format is selected, the driver will not automatically join the multicast group. This must be done by the application.</li>
<li>In order to call PTP API functions from ISRs, the MINT and IPLS interrupt priorities must be configured to be lower than BSP_CFG_IRQ_MASK_LEVEL_FOR_CRITICAL_SECTION. This is to guarantee that PTP register accesses are atomic.</li>
</ul>
<h1><a class="anchor" id="r-ptp-examples"></a>
Examples</h1>
<h2>Slave Mode</h2>
<p>This is a basic example of minimal use of PTP in slave mode.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keyword">volatile</span> <span class="keywordtype">bool</span> g_first_announce_message_received = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">volatile</span> <span class="keywordtype">bool</span> g_sync_acquired = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> slave_mode_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* The PTP Instance must be opened before R_ETHER is opened. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___p_t_p.html#gac64c5e4a41f886f32a2396020e6e9669">R_PTP_Open</a>(&amp;g_ptp_ctrl, &amp;g_ptp_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Configure the PTP MAC address. */</span></div><div class="line">    err = <a class="code" href="group___p_t_p.html#ga1cf674cbb8cafcd8a090608167b20271">R_PTP_MacAddrSet</a>(&amp;g_ptp_ctrl, g_ptp_mac_address);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Configure the PTP Local Clock ID (Usually generated from MAC address). */</span></div><div class="line">    err = <a class="code" href="group___p_t_p.html#gadd493ac1a0bb441a875b8f4cbcb48689">R_PTP_LocalClockIdSet</a>(&amp;g_ptp_ctrl, g_ptp_clock_id);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Open the r_ether_api instance. */</span></div><div class="line">    err = <a class="code" href="group___e_t_h_e_r.html#gab2b878c7b67357c06e1f9231265819fd">R_ETHER_Open</a>(&amp;g_ether_ctrl, &amp;g_ether_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for the link to be established. */</span></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        err = <a class="code" href="group___e_t_h_e_r.html#gab10af3abff76900b7895934685c43311">R_ETHER_LinkProcess</a>(&amp;g_ether_ctrl);</div><div class="line">    } <span class="keywordflow">while</span> (FSP_SUCCESS != err);</div><div class="line"></div><div class="line">    <span class="comment">/* Set the PTP instance to passive state and listen for announce message. */</span></div><div class="line">    err = <a class="code" href="group___p_t_p.html#gae0850f602bdcc31584f8fd8652ad8dc9">R_PTP_PortStateSet</a>(&amp;g_ptp_ctrl, <a class="code" href="group___p_t_p___a_p_i.html#gga5093799b09bcf8a2ec5865d38f1c46a1a2c8978d9c8c24739632e4ff8c736aed1">PTP_PORT_STATE_PASSIVE</a>);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for the first announce message (This will provide the master clock ID). */</span></div><div class="line">    uint32_t timeout = EXAMPLE_TIMEOUT;</div><div class="line">    <span class="keywordflow">while</span> (!g_first_announce_message_received &amp;&amp; --timeout)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___b_s_p___m_c_u.html#gaf3219448adfd1531cf69f68697ab184b">R_BSP_SoftwareDelay</a>(1, <a class="code" href="group___b_s_p___m_c_u.html#ggafd98e2a6f080d6a52a3ef72e3d731b2bacc709da08ef4acc99bf6e2e84946be5d">BSP_DELAY_UNITS_SECONDS</a>);</div><div class="line">    }</div><div class="line"></div><div class="line">    assert(0U != timeout);</div><div class="line"></div><div class="line">    <span class="comment">/* When a master clock is found, change to the slave state to start synchronizing</span></div><div class="line"><span class="comment">     * the local clock to the master clock. */</span></div><div class="line">    err = <a class="code" href="group___p_t_p.html#gae0850f602bdcc31584f8fd8652ad8dc9">R_PTP_PortStateSet</a>(&amp;g_ptp_ctrl, <a class="code" href="group___p_t_p___a_p_i.html#gga5093799b09bcf8a2ec5865d38f1c46a1a2ac6341131ac6c84164009a9ce395679">PTP_PORT_STATE_E2E_SLAVE</a>);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for local clock to be synchronized with the master clock. */</span></div><div class="line">    timeout = EXAMPLE_TIMEOUT;</div><div class="line">    <span class="keywordflow">while</span> (!g_sync_acquired &amp;&amp; --timeout)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___b_s_p___m_c_u.html#gaf3219448adfd1531cf69f68697ab184b">R_BSP_SoftwareDelay</a>(1, <a class="code" href="group___b_s_p___m_c_u.html#ggafd98e2a6f080d6a52a3ef72e3d731b2bacc709da08ef4acc99bf6e2e84946be5d">BSP_DELAY_UNITS_SECONDS</a>);</div><div class="line">    }</div><div class="line"></div><div class="line">    assert(0U != timeout);</div><div class="line"></div><div class="line">    <span class="comment">/* The local clock is now synchronized with the grand master clock. */</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Callback called whenever a PTP event occurs. */</span></div><div class="line"><span class="keywordtype">void</span> g_ptp_slave_callback_example (<a class="code" href="group___p_t_p___a_p_i.html#structptp__callback__args__t">ptp_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">switch</span> (p_args-&gt;<a class="code" href="group___p_t_p___a_p_i.html#a85b99f7657cc3c6be615f6aab23a990a">event</a>)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___p_t_p___a_p_i.html#ggabed0a6a111a82eb8e8eb55254e1f3c0cacfe4e6ee306be48c4cb06409cbdbd3f6">PTP_EVENT_SYNC_ACQUIRED</a>:</div><div class="line">        {</div><div class="line">            <span class="comment">/* The offsetFromMaster value is now within the configured threshold to be</span></div><div class="line"><span class="comment">             * synchronized with the master clock.</span></div><div class="line"><span class="comment">             */</span></div><div class="line">            g_sync_acquired = <span class="keyword">true</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___p_t_p___a_p_i.html#ggabed0a6a111a82eb8e8eb55254e1f3c0ca46c6365f5cd17178f8ff8ca96d32aae2">PTP_EVENT_MESSAGE_RECEIVED</a>:</div><div class="line">        {</div><div class="line">            <span class="keyword">static</span> <a class="code" href="group___p_t_p___a_p_i.html#structptp__message__t">ptp_message_t</a> g_current_master_announce_message;</div><div class="line"></div><div class="line">            <span class="keywordflow">switch</span> (p_args-&gt;<a class="code" href="group___p_t_p___a_p_i.html#a223a52551c562f3b009301aed9805a39">p_message</a>-&gt;<a class="code" href="group___p_t_p___a_p_i.html#a9fc56e8a4c02e45355b28387b6f4f8d7">header</a>.<a class="code" href="group___p_t_p___a_p_i.html#aec1dad61d1dcce0e13690e7f3c70615b">message_type</a>)</div><div class="line">            {</div><div class="line">                <span class="keywordflow">case</span> <a class="code" href="group___p_t_p___a_p_i.html#ggad488af97304ef1466637952ecb35ea37ad26c9ce538d7d315f7e7c35265696e27">PTP_MESSAGE_TYPE_ANNOUNCE</a>:</div><div class="line">                {</div><div class="line">                    int8_t comparison = 0;</div><div class="line"></div><div class="line">                    <span class="keywordflow">if</span> (!g_first_announce_message_received)</div><div class="line">                    {</div><div class="line">                        <span class="comment">/* If this is the first announce packet, immediately switch to this master clock. */</span></div><div class="line">                        comparison = 1;</div><div class="line">                        g_first_announce_message_received = <span class="keyword">true</span>;</div><div class="line">                    }</div><div class="line">                    <span class="keywordflow">else</span></div><div class="line">                    {</div><div class="line">                        <span class="comment">/*</span></div><div class="line"><span class="comment">                         * Run the &quot;Best Master Clock Algorithm&quot; to determine if the clock defined in this announce</span></div><div class="line"><span class="comment">                         * packet is better than the current master clock.</span></div><div class="line"><span class="comment">                         */</span></div><div class="line">                        <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___p_t_p.html#ga7c12489999f0c1913362ef2369bc3765">R_PTP_BestMasterClock</a>(&amp;g_current_master_announce_message,</div><div class="line">                                                              p_args-&gt;<a class="code" href="group___p_t_p___a_p_i.html#a223a52551c562f3b009301aed9805a39">p_message</a>,</div><div class="line">                                                              &amp;comparison);</div><div class="line">                        assert(FSP_SUCCESS == err);</div><div class="line">                    }</div><div class="line"></div><div class="line">                    <span class="keywordflow">if</span> (1 == comparison)</div><div class="line">                    {</div><div class="line">                        <span class="comment">/* Save the message as the new master announce message. */</span></div><div class="line">                        g_current_master_announce_message = *p_args-&gt;<a class="code" href="group___p_t_p___a_p_i.html#a223a52551c562f3b009301aed9805a39">p_message</a>;</div><div class="line"></div><div class="line">                        <span class="comment">/* Set the master clock ID and sourcePortID in the PTP instance so that it</span></div><div class="line"><span class="comment">                         * synchronizes with the new best master clock.</span></div><div class="line"><span class="comment">                         */</span></div><div class="line">                        <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___p_t_p.html#gaf8a649eb2aed004ccf17135f527e9503">R_PTP_MasterClockIdSet</a>(&amp;g_ptp_ctrl,</div><div class="line">                                                               g_current_master_announce_message.<a class="code" href="group___p_t_p___a_p_i.html#a9fc56e8a4c02e45355b28387b6f4f8d7">header</a>.<a class="code" href="group___p_t_p___a_p_i.html#ad16718c4538ce910c86d4ec2c9972e28">clock_id</a>,</div><div class="line">                                                               g_current_master_announce_message.<a class="code" href="group___p_t_p___a_p_i.html#a9fc56e8a4c02e45355b28387b6f4f8d7">header</a>.<a class="code" href="group___p_t_p___a_p_i.html#ac2e2ee9435d560a3abfdfd893dc54654">source_port_id</a>);</div><div class="line">                        assert(FSP_SUCCESS == err);</div><div class="line">                    }</div><div class="line"></div><div class="line">                    <span class="keywordflow">break</span>;</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="keywordflow">default</span>:</div><div class="line">                {</div><div class="line">                    <span class="keywordflow">break</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">        {</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Master Mode</h2>
<p>This is a basic example of minimal use of PTP in master mode.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define PTP_EXAMPLE_CURRENT_UTC_OFFSET    (37)</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> master_mode_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* The PTP Instance must be opened before R_ETHER is opened. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___p_t_p.html#gac64c5e4a41f886f32a2396020e6e9669">R_PTP_Open</a>(&amp;g_ptp_ctrl, &amp;g_ptp_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Configure the PTP MAC address. */</span></div><div class="line">    err = <a class="code" href="group___p_t_p.html#ga1cf674cbb8cafcd8a090608167b20271">R_PTP_MacAddrSet</a>(&amp;g_ptp_ctrl, g_ptp_mac_address);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Configure the PTP Local Clock ID (Usually generated from MAC address). */</span></div><div class="line">    err = <a class="code" href="group___p_t_p.html#gadd493ac1a0bb441a875b8f4cbcb48689">R_PTP_LocalClockIdSet</a>(&amp;g_ptp_ctrl, g_ptp_clock_id);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Get the current time from an external time source (Eg. RTC). */</span></div><div class="line">    <a class="code" href="group___p_t_p___a_p_i.html#structptp__time__t">ptp_time_t</a> current_time;</div><div class="line">    get_current_time_example(&amp;current_time);</div><div class="line"></div><div class="line">    <span class="comment">/* Set the PTP local time to the current time. */</span></div><div class="line">    err = <a class="code" href="group___p_t_p.html#ga6ce3801ef62ff464667916864e1f3e1a">R_PTP_LocalClockValueSet</a>(&amp;g_ptp_ctrl, &amp;current_time);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Set the currentUtcOffset field in announce messages. */</span></div><div class="line">    err = <a class="code" href="group___p_t_p.html#gae7c3176ad9d2b8fe00fda18d2faeac01">R_PTP_CurrentUtcOffsetSet</a>(&amp;g_ptp_ctrl, PTP_EXAMPLE_CURRENT_UTC_OFFSET);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Set message flags in announce messages to indicate that the current UTC offset is valid and that the PTP timescale is used. */</span></div><div class="line">    <a class="code" href="group___p_t_p___a_p_i.html#structptp__message__flags__t">ptp_message_flags_t</a> flags;</div><div class="line">    flags.value = 0;</div><div class="line">    flags.value_b.currentUtcOffsetValid = 1;</div><div class="line">    flags.value_b.ptpTimescale          = 1;</div><div class="line">    err = <a class="code" href="group___p_t_p.html#gadb66200ebc5d880fb8b3bef9b091734c">R_PTP_MessageFlagsSet</a>(&amp;g_ptp_ctrl, <a class="code" href="group___p_t_p___a_p_i.html#ggad488af97304ef1466637952ecb35ea37ad26c9ce538d7d315f7e7c35265696e27">PTP_MESSAGE_TYPE_ANNOUNCE</a>, flags);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Open the r_ether_api instance. */</span></div><div class="line">    err = <a class="code" href="group___e_t_h_e_r.html#gab2b878c7b67357c06e1f9231265819fd">R_ETHER_Open</a>(&amp;g_ether_ctrl, &amp;g_ether_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for the link to be established. */</span></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        err = <a class="code" href="group___e_t_h_e_r.html#gab10af3abff76900b7895934685c43311">R_ETHER_LinkProcess</a>(&amp;g_ether_ctrl);</div><div class="line">    } <span class="keywordflow">while</span> (FSP_SUCCESS != err);</div><div class="line"></div><div class="line">    <span class="comment">/* Set the PTP instance to passive state and listen for announce message. */</span></div><div class="line">    err = <a class="code" href="group___p_t_p.html#gae0850f602bdcc31584f8fd8652ad8dc9">R_PTP_PortStateSet</a>(&amp;g_ptp_ctrl, <a class="code" href="group___p_t_p___a_p_i.html#gga5093799b09bcf8a2ec5865d38f1c46a1a95c095177febe3f8f729dae1080f2c60">PTP_PORT_STATE_E2E_MASTER</a>);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * The master clock is now operational and will automatically generate announce and sync messages</span></div><div class="line"><span class="comment">     * as well as respond to delay_req messages.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Send PTP Messages</h2>
<p>This is a basic example of how to send PTP messages.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define PTP_MANAGEMENT_ACTION_GET                  (0U)</span></div><div class="line"><span class="preprocessor">#define PTP_TLV_TYPE_MANAGEMENT                    (1U)</span></div><div class="line"><span class="preprocessor">#define PTP_TLV_MANAGEMENT_ID_CLOCK_DESCRIPTION    (1U)</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> uint32_t g_transmit_complete = 0U;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> send_message_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="keyword">static</span> <a class="code" href="group___p_t_p___a_p_i.html#structptp__message__t">ptp_message_t</a> message;</div><div class="line">    <span class="keyword">static</span> uint8_t       p_tlv_data[6];</div><div class="line"></div><div class="line">    memset(&amp;message, 0, <span class="keyword">sizeof</span>(<a class="code" href="group___p_t_p___a_p_i.html#structptp__message__t">ptp_message_t</a>));</div><div class="line"></div><div class="line">    <span class="comment">/* Fill in the required fields for the message header (Note that appropriate fields will be endian swapped). */</span></div><div class="line">    message.<a class="code" href="group___p_t_p___a_p_i.html#a9fc56e8a4c02e45355b28387b6f4f8d7">header</a>.<a class="code" href="group___p_t_p___a_p_i.html#aec1dad61d1dcce0e13690e7f3c70615b">message_type</a> = <a class="code" href="group___p_t_p___a_p_i.html#ggad488af97304ef1466637952ecb35ea37a0666dd235df49faca6c7ea25a31d6107">PTP_MESSAGE_TYPE_MANAGEMENT</a>;</div><div class="line">    message.<a class="code" href="group___p_t_p___a_p_i.html#a9fc56e8a4c02e45355b28387b6f4f8d7">header</a>.<a class="code" href="group___p_t_p___a_p_i.html#a5d9dd652591f35448cc1fbb93eeb7698">version</a>      = 2;</div><div class="line"></div><div class="line">    <span class="comment">/* The message length is the total number of bytes in the PTP message (Including the message header). */</span></div><div class="line">    message.<a class="code" href="group___p_t_p___a_p_i.html#a9fc56e8a4c02e45355b28387b6f4f8d7">header</a>.<a class="code" href="group___p_t_p___a_p_i.html#a5f59ab0b3aad174817b679b0cf33efeb">message_length</a> = (uint16_t) (<span class="keyword">sizeof</span>(<a class="code" href="group___p_t_p___a_p_i.html#structptp__message__header__t">ptp_message_header_t</a>) +</div><div class="line">                                                <span class="keyword">sizeof</span>(<a class="code" href="group___p_t_p___a_p_i.html#structptp__message__management__t">ptp_message_management_t</a>) +</div><div class="line">                                                <span class="keyword">sizeof</span>(p_tlv_data));</div><div class="line">    memcpy(message.<a class="code" href="group___p_t_p___a_p_i.html#a9fc56e8a4c02e45355b28387b6f4f8d7">header</a>.<a class="code" href="group___p_t_p___a_p_i.html#ad16718c4538ce910c86d4ec2c9972e28">clock_id</a>, g_ptp_clock_id, <span class="keyword">sizeof</span>(g_ptp_clock_id));</div><div class="line">    message.<a class="code" href="group___p_t_p___a_p_i.html#a9fc56e8a4c02e45355b28387b6f4f8d7">header</a>.<a class="code" href="group___p_t_p___a_p_i.html#a65f738413281757f52f57111a065bc6a">control_field</a> = PTP_CTRL_FIELD_MANAGEMENT;</div><div class="line"></div><div class="line">    <span class="comment">/* Fill in the required fields for the management message. */</span></div><div class="line">    memcpy(message.management.target_clock_id, g_target_clock_id, <span class="keyword">sizeof</span>(g_target_clock_id));</div><div class="line">    message.management.target_port_id         = 1;</div><div class="line">    message.management.starting_boundary_hops = 1;</div><div class="line">    message.management.boundary_hops          = 1;</div><div class="line">    message.management.action                 = PTP_MANAGEMENT_ACTION_GET;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Fill in TLV data (Note that TLV data is big endian).</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * Type (Management)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    p_tlv_data[0] = 0;</div><div class="line">    p_tlv_data[1] = PTP_TLV_TYPE_MANAGEMENT;</div><div class="line"></div><div class="line">    <span class="comment">/* Length */</span></div><div class="line">    p_tlv_data[2] = 0;</div><div class="line">    p_tlv_data[3] = 2;</div><div class="line"></div><div class="line">    <span class="comment">/* Management ID (Clock Description) */</span></div><div class="line">    p_tlv_data[4] = 0;</div><div class="line">    p_tlv_data[5] = PTP_TLV_MANAGEMENT_ID_CLOCK_DESCRIPTION;</div><div class="line"></div><div class="line">    <span class="comment">/* Send the message. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___p_t_p.html#gad4c9e431f1209bb087dd3f6c7233c89a">R_PTP_MessageSend</a>(&amp;g_ptp_ctrl, &amp;message, p_tlv_data, <span class="keyword">sizeof</span>(p_tlv_data));</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    uint32_t timeout = EXAMPLE_TIMEOUT;</div><div class="line">    <span class="keywordflow">while</span> (0U == g_transmit_complete &amp;&amp; --timeout)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___b_s_p___m_c_u.html#gaf3219448adfd1531cf69f68697ab184b">R_BSP_SoftwareDelay</a>(1U, <a class="code" href="group___b_s_p___m_c_u.html#ggafd98e2a6f080d6a52a3ef72e3d731b2baa0312618f2508347a9a815b5887c12ae">BSP_DELAY_UNITS_MICROSECONDS</a>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Callback called whenever a PTP event occurs. */</span></div><div class="line"><span class="keywordtype">void</span> g_ptp_send_message_callback_example (<a class="code" href="group___p_t_p___a_p_i.html#structptp__callback__args__t">ptp_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">switch</span> (p_args-&gt;<a class="code" href="group___p_t_p___a_p_i.html#a85b99f7657cc3c6be615f6aab23a990a">event</a>)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___p_t_p___a_p_i.html#ggabed0a6a111a82eb8e8eb55254e1f3c0caf2bfc28f06fd82fe3a549fbae72e8768">PTP_EVENT_MESSAGE_TRANSMIT_COMPLETE</a>:</div><div class="line">        {</div><div class="line">            g_transmit_complete = 1U;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___p_t_p___a_p_i.html#ggabed0a6a111a82eb8e8eb55254e1f3c0ca46c6365f5cd17178f8ff8ca96d32aae2">PTP_EVENT_MESSAGE_RECEIVED</a>:</div><div class="line">        {</div><div class="line">            <span class="keywordflow">switch</span> (p_args-&gt;<a class="code" href="group___p_t_p___a_p_i.html#a223a52551c562f3b009301aed9805a39">p_message</a>-&gt;<a class="code" href="group___p_t_p___a_p_i.html#a9fc56e8a4c02e45355b28387b6f4f8d7">header</a>.<a class="code" href="group___p_t_p___a_p_i.html#aec1dad61d1dcce0e13690e7f3c70615b">message_type</a>)</div><div class="line">            {</div><div class="line">                <span class="keywordflow">case</span> <a class="code" href="group___p_t_p___a_p_i.html#ggad488af97304ef1466637952ecb35ea37a0666dd235df49faca6c7ea25a31d6107">PTP_MESSAGE_TYPE_MANAGEMENT</a>:</div><div class="line">                {</div><div class="line">                    <span class="comment">/* Handle the response message. */</span></div><div class="line">                    <span class="keywordflow">break</span>;</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="keywordflow">default</span>:</div><div class="line">                {</div><div class="line">                    <span class="keywordflow">break</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">        {</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structptp__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_t_p.html#structptp__instance__ctrl__t">ptp_instance_ctrl_t</a></td></tr>
<tr class="separator:structptp__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structptp__instance__ctrl__t" id="structptp__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structptp__instance__ctrl__t">&#9670;&nbsp;</a></span>ptp_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ptp_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>PTP instance control block. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a887ba47a5209723358ae5e33b2541b4c"></a>uint32_t</td>
<td class="fieldname">
open</td>
<td class="fielddoc">
Marks if the instance has been opened. </td></tr>
<tr><td class="fieldtype">
<a id="afc356026feab13691b95166b9be3b9fd"></a>uint32_t</td>
<td class="fieldname">
tx_buffer_write_index</td>
<td class="fielddoc">
Index into the descriptor list to write the next packet. </td></tr>
<tr><td class="fieldtype">
<a id="ac54d6ef05896599db1ef950c81ca1a5a"></a>uint32_t</td>
<td class="fieldname">
tx_buffer_complete_index</td>
<td class="fielddoc">
Index into the descriptor list of the last transmitted packet. </td></tr>
<tr><td class="fieldtype">
<a id="a30001220545b6112fea862527e336145"></a>uint32_t</td>
<td class="fieldname">
rx_buffer_index</td>
<td class="fielddoc">
Index into the descriptor of the last received packet. </td></tr>
<tr><td class="fieldtype">
<a id="aee4fd9d2ae92742f1642004ac15233db"></a>uint32_t</td>
<td class="fieldname">
tslatr</td>
<td class="fielddoc">
Keep track of whether tslatr was set. </td></tr>
<tr><td class="fieldtype">
<a id="ac599121c060dde0eaade0ab09ef8ad96"></a><a class="el" href="group___p_t_p___a_p_i.html#structptp__cfg__t">ptp_cfg_t</a> const  *</td>
<td class="fieldname">
p_cfg</td>
<td class="fielddoc">
Pointer to the configuration structure. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gac64c5e4a41f886f32a2396020e6e9669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac64c5e4a41f886f32a2396020e6e9669">&#9670;&nbsp;</a></span>R_PTP_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PTP_Open </td>
          <td>(</td>
          <td class="paramtype">ptp_ctrl_t *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_t_p___a_p_i.html#structptp__cfg__t">ptp_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function initializes PTP. Implements <a class="el" href="group___p_t_p___a_p_i.html#ab5c5a3285336842f7c44a8e8954a6382">ptp_api_t::open</a>.</p>
<p>This function performs the following tasks:</p><ul>
<li>Performs parameter checking and processes error conditions.</li>
<li>Configures the peripheral registers acording to the configuration.</li>
<li>Initialize the control structure for use in other <a class="el" href="group___p_t_p___a_p_i.html">PTP Interface</a> functions.</li>
</ul>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The instance has been successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Instance was already initialized. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The EDMAC instance was not opened correctly. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An invalid argument was given in the configuration structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1cf674cbb8cafcd8a090608167b20271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cf674cbb8cafcd8a090608167b20271">&#9670;&nbsp;</a></span>R_PTP_MacAddrSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PTP_MacAddrSet </td>
          <td>(</td>
          <td class="paramtype">ptp_ctrl_t *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *const&#160;</td>
          <td class="paramname"><em>p_mac_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the MAC address for the PTP instance. Implements <a class="el" href="group___p_t_p___a_p_i.html#a807b189c7987b1f2d972f4f1fb5af55b">ptp_api_t::macAddrSet</a>. </p><dl class="section note"><dt>Note</dt><dd>This function may only be called while the PTP instance is in <a class="el" href="group___p_t_p___a_p_i.html#gga5093799b09bcf8a2ec5865d38f1c46a1aad9f871bd628bc6d5610e8f3545ec84e">ptp_port_state_t::PTP_PORT_STATE_DISABLE</a>.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The MAC address has been set. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An argument was NULL </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>The instance is not in the correct state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1147acf7f5f8b34247f6e2fda64fd794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1147acf7f5f8b34247f6e2fda64fd794">&#9670;&nbsp;</a></span>R_PTP_IpAddrSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PTP_IpAddrSet </td>
          <td>(</td>
          <td class="paramtype">ptp_ctrl_t *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ip_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the IP address for the PTP instance. Implements <a class="el" href="group___p_t_p___a_p_i.html#ad5f07a92c3563dd682ee13f548f2bb76">ptp_api_t::ipAddrSet</a>. </p><dl class="section note"><dt>Note</dt><dd>This function may only be called while the PTP instance is in <a class="el" href="group___p_t_p___a_p_i.html#gga5093799b09bcf8a2ec5865d38f1c46a1aad9f871bd628bc6d5610e8f3545ec84e">ptp_port_state_t::PTP_PORT_STATE_DISABLE</a>.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The IP address has been set. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An argument was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>The configured <a class="el" href="group___p_t_p___a_p_i.html#a8dabf3b79220d66d3951bc4fc42ad40d" title="Frame format used to transport PTP messages. ">ptp_synfp_cfg_t::frame_format</a> is not configured to use IP packets, or the instance is not in the correct state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadd493ac1a0bb441a875b8f4cbcb48689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd493ac1a0bb441a875b8f4cbcb48689">&#9670;&nbsp;</a></span>R_PTP_LocalClockIdSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PTP_LocalClockIdSet </td>
          <td>(</td>
          <td class="paramtype">ptp_ctrl_t *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *const&#160;</td>
          <td class="paramname"><em>p_clock_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the local clock ID for the PTP instance. Implements <a class="el" href="group___p_t_p___a_p_i.html#a06e922d35f8c477b1d929a1847d2d273">ptp_api_t::localClockIdSet</a>. </p><dl class="section note"><dt>Note</dt><dd>This function may only be called while the PTP instance is in <a class="el" href="group___p_t_p___a_p_i.html#gga5093799b09bcf8a2ec5865d38f1c46a1aad9f871bd628bc6d5610e8f3545ec84e">ptp_port_state_t::PTP_PORT_STATE_DISABLE</a>. </dd>
<dd>
Typically the clock ID is derived from the MAC address (E.g. {b1,b2,b3,0xFF,0xFE,b4,b5,b6}).</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The local clock ID has been set. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An argument was NULL </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>The instance is not in the correct state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf8a649eb2aed004ccf17135f527e9503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8a649eb2aed004ccf17135f527e9503">&#9670;&nbsp;</a></span>R_PTP_MasterClockIdSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PTP_MasterClockIdSet </td>
          <td>(</td>
          <td class="paramtype">ptp_ctrl_t *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *const&#160;</td>
          <td class="paramname"><em>p_clock_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the master clock ID and port ID that the local clock will synchronize with. Implements <a class="el" href="group___p_t_p___a_p_i.html#a412c4ca0c0f16a2c447bac098cd07184">ptp_api_t::masterClockIdSet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The master clock ID and port ID have been set. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An argument was NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadb66200ebc5d880fb8b3bef9b091734c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb66200ebc5d880fb8b3bef9b091734c">&#9670;&nbsp;</a></span>R_PTP_MessageFlagsSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PTP_MessageFlagsSet </td>
          <td>(</td>
          <td class="paramtype">ptp_ctrl_t *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_t_p___a_p_i.html#gad488af97304ef1466637952ecb35ea37">ptp_message_type_t</a>&#160;</td>
          <td class="paramname"><em>message_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_t_p___a_p_i.html#structptp__message__flags__t">ptp_message_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the flags field for the given message type. Implements <a class="el" href="group___p_t_p___a_p_i.html#abe50284d5ff38e62e2702c135f0674d2">ptp_api_t::messageFlagsSet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The master clock ID and port ID have been set. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An argument was NULL or invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae7c3176ad9d2b8fe00fda18d2faeac01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7c3176ad9d2b8fe00fda18d2faeac01">&#9670;&nbsp;</a></span>R_PTP_CurrentUtcOffsetSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PTP_CurrentUtcOffsetSet </td>
          <td>(</td>
          <td class="paramtype">ptp_ctrl_t *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the currentUtcOffset value in announce messages. <a class="el" href="group___p_t_p___a_p_i.html#ac56ac84b683491b29b92e5fd33e3c70e">ptp_api_t::currentUtcOffsetSet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The currentUtcOffset has been updated. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An argument was NULL or invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae0850f602bdcc31584f8fd8652ad8dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0850f602bdcc31584f8fd8652ad8dc9">&#9670;&nbsp;</a></span>R_PTP_PortStateSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PTP_PortStateSet </td>
          <td>(</td>
          <td class="paramtype">ptp_ctrl_t *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function changes the current state of the PTP instance. Implements <a class="el" href="group___p_t_p___a_p_i.html#a55d6e455b502644258e4bfb55152dea1">ptp_api_t::portStateSet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The instance will transition to the new state. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An argument was NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad4c9e431f1209bb087dd3f6c7233c89a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4c9e431f1209bb087dd3f6c7233c89a">&#9670;&nbsp;</a></span>R_PTP_MessageSend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PTP_MessageSend </td>
          <td>(</td>
          <td class="paramtype">ptp_ctrl_t *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_t_p___a_p_i.html#structptp__message__t">ptp_message_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *const&#160;</td>
          <td class="paramname"><em>p_tlv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tlv_data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sends a PTP message. <a class="el" href="group___p_t_p___a_p_i.html#a3e765c401379982e08ef2c5786343280">ptp_api_t::messageSend</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The packet has been written to the transmit descriptor. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An argument was NULL or invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_ETHER_ERROR_TRANSMIT_BUFFER_FULL</td><td>There is no space for the packet in the transmit queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6ce3801ef62ff464667916864e1f3e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ce3801ef62ff464667916864e1f3e1a">&#9670;&nbsp;</a></span>R_PTP_LocalClockValueSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PTP_LocalClockValueSet </td>
          <td>(</td>
          <td class="paramtype">ptp_ctrl_t *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_t_p___a_p_i.html#structptp__time__t">ptp_time_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the local clock value. Implements <a class="el" href="group___p_t_p___a_p_i.html#a98d7e44f46454c96d43831ee7e66455e">ptp_api_t::localClockValueSet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The local clock value has been set. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An argument was NULL or invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacea3b3940af3df1f91101e722f26d6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacea3b3940af3df1f91101e722f26d6ef">&#9670;&nbsp;</a></span>R_PTP_LocalClockValueGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PTP_LocalClockValueGet </td>
          <td>(</td>
          <td class="paramtype">ptp_ctrl_t *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_t_p___a_p_i.html#structptp__time__t">ptp_time_t</a> *const&#160;</td>
          <td class="paramname"><em>p_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets the local clock value. Implements <a class="el" href="group___p_t_p___a_p_i.html#a72ba77657f891c2253678b87526cb206">ptp_api_t::localClockValueGet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The local clock value has been written in p_time. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An argument was NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga805458fe513b8ad84e56ef4bc6b9efe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga805458fe513b8ad84e56ef4bc6b9efe3">&#9670;&nbsp;</a></span>R_PTP_PulseTimerCommonConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PTP_PulseTimerCommonConfig </td>
          <td>(</td>
          <td class="paramtype">ptp_ctrl_t *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_t_p___a_p_i.html#structptp__pulse__timer__common__cfg__t">ptp_pulse_timer_common_cfg_t</a> *const&#160;</td>
          <td class="paramname"><em>p_timer_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function configures IPLS IRQ settings that are common to all pulse timer channels. Implements <a class="el" href="group___p_t_p___a_p_i.html#a3a4f87618ed1e25abe7d61a569d7dac3">ptp_api_t::pulseTimerCommonConfig</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The pulse timer has been enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An argument was NULL or invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadf42f6597cf6da5dd7f6cdf180826ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf42f6597cf6da5dd7f6cdf180826ede">&#9670;&nbsp;</a></span>R_PTP_PulseTimerEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PTP_PulseTimerEnable </td>
          <td>(</td>
          <td class="paramtype">ptp_ctrl_t *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_t_p___a_p_i.html#structptp__pulse__timer__cfg__t">ptp_pulse_timer_cfg_t</a> *const&#160;</td>
          <td class="paramname"><em>p_timer_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function enables a pulse timer channel. Implements <a class="el" href="group___p_t_p___a_p_i.html#a28a8fdf928bb7595d3f5b131bdfe1d8d">ptp_api_t::pulseTimerEnable</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The pulse timer has been enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An argument was NULL or invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga449c98ce945e5d8821fa74c89b8dfb75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga449c98ce945e5d8821fa74c89b8dfb75">&#9670;&nbsp;</a></span>R_PTP_PulseTimerDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PTP_PulseTimerDisable </td>
          <td>(</td>
          <td class="paramtype">ptp_ctrl_t *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function disables a pulse timer channel. Implements <a class="el" href="group___p_t_p___a_p_i.html#a1f6219692e39e4fdda71100ab92dba9e">ptp_api_t::pulseTimerDisable</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The pulse timer has been disabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An argument was NULL or invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafa87719b0a35125a830b14b03831e157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa87719b0a35125a830b14b03831e157">&#9670;&nbsp;</a></span>R_PTP_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PTP_Close </td>
          <td>(</td>
          <td class="paramtype">ptp_ctrl_t *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable the PTP instance. Implements <a class="el" href="group___p_t_p___a_p_i.html#affa30a9c253e0a32d42e35a90fddc1e8">ptp_api_t::close</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The pulse timer has been disabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The instance has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An argument was NULL or invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7c12489999f0c1913362ef2369bc3765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c12489999f0c1913362ef2369bc3765">&#9670;&nbsp;</a></span>R_PTP_BestMasterClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PTP_BestMasterClock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_t_p___a_p_i.html#structptp__message__t">ptp_message_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_announce1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_t_p___a_p_i.html#structptp__message__t">ptp_message_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_announce2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *const&#160;</td>
          <td class="paramname"><em>p_comparison</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function compares two clocks to determine which one is the better master clock.</p>
<p>p_comparison:</p><ul>
<li>Set to -1 if p_announce1 defines the best master clock.</li>
<li>Set to 1 if p_announce2 defines the best master clock.</li>
<li>Set to 0 if p_announce1 and p_announce2 define the same clock.</li>
</ul>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The valid result has been written to p_use_announce_clock. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An argument was NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v4.2.0 User's Manual Copyright  (2022) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
