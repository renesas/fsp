<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: Audio Playback PWM (rm_audio_playback_pwm)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
    $(document).ready(function() {
        $("tr.tree_lvl_1").nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
		$("tr.tree_lvl_1").data("expanded","0");
		$("tr.tree_lvl_2").data("expanded","0");
		$("tr.tree_lvl_3").data("expanded","0");
		$("tr.tree_lvl_4").data("expanded","0");
		$("tr.tree_lvl_5").data("expanded","0");
        $("tr.tree_lvl_1").click(function() {
		    var lvl_1_is_open = $(this).data("expanded");
		    if (lvl_1_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2, tr.tree_lvl_1_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_2").click(function() {
		    var lvl_2_is_open = $(this).data("expanded");
		    if (lvl_2_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3, tr.tree_lvl_2_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_3").click(function() {
		    var lvl_3_is_open = $(this).data("expanded");
		    if (lvl_3_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_3_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_4").click(function() {
		    var lvl_4_is_open = $(this).data("expanded");
		    if (lvl_4_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5, tr.tree_lvl_4_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_5").click(function() {
		    var lvl_5_is_open = $(this).data("expanded");
		    if (lvl_5_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4_item,tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
     });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v6.2.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">

    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text">
      </span>
      <span class="right">
          &nbsp;
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___r_m___a_u_d_i_o___p_l_a_y_b_a_c_k___p_w_m.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body.
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len));
            }
          }
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element.
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<div class="title">Audio Playback PWM (rm_audio_playback_pwm)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___a_u_d_i_o___m_o_d_u_l_e_s.html">Audio</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5b7e43022164166bf513800a59f525ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___a_u_d_i_o___p_l_a_y_b_a_c_k___p_w_m.html#ga5b7e43022164166bf513800a59f525ce">RM_AUDIO_PLAYBACK_PWM_Open</a> (<a class="el" href="group___a_u_d_i_o___p_l_a_y_b_a_c_k___a_p_i.html#gaedd9fa315a0afc1eb4d8ce56668acba8">audio_playback_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___a_u_d_i_o___p_l_a_y_b_a_c_k___a_p_i.html#structaudio__playback__cfg__t">audio_playback_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:ga5b7e43022164166bf513800a59f525ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac59d16a778f03d2bf4ec094f6fccc128"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___a_u_d_i_o___p_l_a_y_b_a_c_k___p_w_m.html#gac59d16a778f03d2bf4ec094f6fccc128">RM_AUDIO_PLAYBACK_PWM_Close</a> (<a class="el" href="group___a_u_d_i_o___p_l_a_y_b_a_c_k___a_p_i.html#gaedd9fa315a0afc1eb4d8ce56668acba8">audio_playback_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:gac59d16a778f03d2bf4ec094f6fccc128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b4c748d93d3a838d38bc33b5c123bd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___a_u_d_i_o___p_l_a_y_b_a_c_k___p_w_m.html#ga6b4c748d93d3a838d38bc33b5c123bd9">RM_AUDIO_PLAYBACK_PWM_Start</a> (<a class="el" href="group___a_u_d_i_o___p_l_a_y_b_a_c_k___a_p_i.html#gaedd9fa315a0afc1eb4d8ce56668acba8">audio_playback_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:ga6b4c748d93d3a838d38bc33b5c123bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85f49b31e593c483f72340d47fc318d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___a_u_d_i_o___p_l_a_y_b_a_c_k___p_w_m.html#ga85f49b31e593c483f72340d47fc318d6">RM_AUDIO_PLAYBACK_PWM_Stop</a> (<a class="el" href="group___a_u_d_i_o___p_l_a_y_b_a_c_k___a_p_i.html#gaedd9fa315a0afc1eb4d8ce56668acba8">audio_playback_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:ga85f49b31e593c483f72340d47fc318d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5835bf2ca45bb07f83a5cf01c5082a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___a_u_d_i_o___p_l_a_y_b_a_c_k___p_w_m.html#gaa5835bf2ca45bb07f83a5cf01c5082a0">RM_AUDIO_PLAYBACK_PWM_Play</a> (<a class="el" href="group___a_u_d_i_o___p_l_a_y_b_a_c_k___a_p_i.html#gaedd9fa315a0afc1eb4d8ce56668acba8">audio_playback_ctrl_t</a> *const p_api_ctrl, void const *const p_buffer, uint32_t length)</td></tr>
<tr class="separator:gaa5835bf2ca45bb07f83a5cf01c5082a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the Audio Playback middleware on RA MCUs. This module implements the <a class="el" href="group___a_u_d_i_o___p_l_a_y_b_a_c_k___a_p_i.html">AUDIO PLAYBACK Interface</a>. </p>
<h1><a class="anchor" id="rm-audio-playback-pwm-overview"></a>
Overview</h1>
<h2><a class="anchor" id="rm-audio-playback-pwm-features"></a>
Features</h2>
<p>The Audio Playback with PWM middleware is used to play audio streams at user selected playback rate using Pulse Width Modulation hardware on GPT or AGT timers. This module can play 16-bit or 32-bit(available on selected MCUs) uncompressed, unsigned PCM audio stream when AGT is selected as PWM interface, and can play 32-bit uncompressed, unsigned PCM audio stream when GPT is used as PWM interface. Note some MCUs have 16-bit GPT timers/channels. In this case audio stream still needs to be 32 bits because the duty cycle register is 32-bit - just the upper 16 bits are ignored. The application code is expected to convert the signed PCM data to unsigned PCM data and scale it with the playback rate before starting the playback.</p>
<h1><a class="anchor" id="rm-audio-playback-pwm-configuration"></a>
Configuration</h1>
<p><h2>Build Time Configurations for rm_audio_playback_pwm</h2>
The following build time configurations are defined in fsp_cfg/rm_audio_playback_pwm_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr class="tree_none">
<td>DMAC Support</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Select if DMAC will be used. </td></tr>
</table>
 <h2>Configurations for Audio &gt; Audio Playback PWM (rm_audio_playback_pwm)</h2>
This module can be added to the Stacks tab via New Stack &gt; Audio &gt; Audio Playback PWM (rm_audio_playback_pwm).<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> General  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Name</td><td>Name must be a valid C symbol</td><td>g_rm_audio_playback0 </td><td>Module name. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Playback Speed (Hz)</td><td>Must be an integer and greater than 0</td><td>44100 </td><td>Enter playback sample rate in Hz. </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Interrupts  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Callback</td><td>Name must be a valid C symbol</td><td>g_rm_audio_playback0_callback </td><td>A user callback function. If this callback function is provided, it is called from the interrupt service routine (ISR) each time the playback completes. </td></tr>
<tr class="tree_none">
<td>PWM Output Pin</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Pin A</li>
<li>
Pin B</li>
</ul>
</td><td>Pin A </td><td>Select which timer output pin should be used for audio output. </td></tr>
</table>
</p>
<p><a class="anchor" id="um_audio_playback_complete_event_notification"></a> </p>
<h2><a class="anchor" id="rm-audio-playback-pwm-clock-configuration"></a>
Clock Configuration</h2>
<p>The Audio Playback with PWM module does not require a specific clock configuration.</p>
<h2><a class="anchor" id="rm-audio-playback-pwm-pin-configuration"></a>
Pin Configuration</h2>
<p>Configure the PWM output pins for selected PWM HAL layer peripheral (AGT/GPT). One of the following pins needs to be selected and enabled as PWM output for selected channel n,</p>
<p>If GPT is used as PWM interface,</p><ul>
<li>GTIOCAn</li>
<li>GTIOCBn</li>
</ul>
<p>If AGT is used as PWM interface,</p><ul>
<li>AGTOAn</li>
<li>AGTOBn</li>
</ul>
<h1><a class="anchor" id="rm-audio-playback-pwm-usage_notes"></a>
Usage Notes</h1>
<h2>DMAC/DTC Integration</h2>
<p>DMAC/DTC is used as a lower level transfer instance with this module and is operated in Normal mode to transfer 16 bit or 32 bit data from the audio stream buffer to the PWM peripheral AGT or GPT respectively. Destination address for transfer instance needs to be the Duty Cycle setting register GTCCR for GPT as PWM driver or AGTMA/AGTCMB in case of AGT as PWM driver. The Audio Playback with PWM module internally configures 'Transfer Size' as 2 Bytes if AGT is used for PWM generation, otherwise it configures 'Transfer Size" as 4 Bytes if GPT or AGTW is used for PWM generation. Refer the hardware manual to check whether the MCU supports AGT or the AGTW peripheral.</p>
<h1><a class="anchor" id="rm-audio-playback-pwm-examples"></a>
Examples</h1>
<h2>Basic Example</h2>
<p>This is a basic example of minimal use of the RM_AUDIO_PLAYBACK_PWM in an application. This example shows how this driver can be used for playing a 16 bit uncompressed PCM audio from a single input buffer.</p>
<div class="fragment"><div class="line"></div><div class="line">int16_t play_buffer[AUDIO_EXAMPLE_LENGTH];</div><div class="line"></div><div class="line">uint32_t g_audio_callback_counter = 0;</div><div class="line"><span class="keywordtype">void</span> g_audio_example_counter_callback (<a class="code" href="group___a_u_d_i_o___p_l_a_y_b_a_c_k___a_p_i.html#structaudio__playback__callback__args__t">audio_playback_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___a_u_d_i_o___p_l_a_y_b_a_c_k___a_p_i.html#gga937592eccbaa6ebe521017d834580610a8b02a2a7d463c5ac93f9816ebd744551">AUDIO_PLAYBACK_EVENT_PLAYBACK_COMPLETE</a> == (p_args-&gt;<a class="code" href="group___a_u_d_i_o___p_l_a_y_b_a_c_k___a_p_i.html#a6b32c4b4f982473df1454a7f94e574ba">event</a>))</div><div class="line">    {</div><div class="line">        g_audio_callback_counter++;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the Audio Playback module for playing an audio stream. */</span></div><div class="line">    err = <a class="code" href="group___r_m___a_u_d_i_o___p_l_a_y_b_a_c_k___p_w_m.html#ga5b7e43022164166bf513800a59f525ce">RM_AUDIO_PLAYBACK_PWM_Open</a>(&amp;g_audio_playback_pwm_ctrl, &amp;g_audio_playback_pwm_cfg);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Set the 16 Bit PCM audio stream to play next */</span></div><div class="line">    err = <a class="code" href="group___r_m___a_u_d_i_o___p_l_a_y_b_a_c_k___p_w_m.html#gaa5835bf2ca45bb07f83a5cf01c5082a0">RM_AUDIO_PLAYBACK_PWM_Play</a>(&amp;g_audio_playback_pwm_ctrl, play_buffer, AUDIO_EXAMPLE_LENGTH);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Start to the play the selected audio stream*/</span></div><div class="line">    err = <a class="code" href="group___r_m___a_u_d_i_o___p_l_a_y_b_a_c_k___p_w_m.html#ga6b4c748d93d3a838d38bc33b5c123bd9">RM_AUDIO_PLAYBACK_PWM_Start</a>(&amp;g_audio_playback_pwm_ctrl);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Wait till the playback is completed */</span></div><div class="line">    <span class="keywordflow">while</span> (g_audio_callback_counter == 0)</div><div class="line">    {</div><div class="line">        ;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Stop playing. */</span></div><div class="line">    err = <a class="code" href="group___r_m___a_u_d_i_o___p_l_a_y_b_a_c_k___p_w_m.html#ga85f49b31e593c483f72340d47fc318d6">RM_AUDIO_PLAYBACK_PWM_Stop</a>(&amp;g_audio_playback_pwm_ctrl);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Streaming Example</h2>
<p>This is an example of using Audio Playback module to play audio stream. This application uses a double buffer to store PCM sine wave data. It starts playing in the main loop, then loads the next buffer if it is ready in the callback. If the next buffer is not ready, a flag is set in the callback so the application knows to restart playing in the main loop. This example also demonstrates conversion of signed PCM format data to unsigned PWM format data along with scaling the data samples for optimum PWM wave generation.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define AUDIO_PLAYBACK_PWM_STREAMING_EXAMPLE_AUDIO_SAMPLING_FREQUENCY_HZ    (22050U)</span></div><div class="line"><span class="preprocessor">#define AUDIO_PLAYBACK_PWM_STREAMING_EXAMPLE_PERIOD_VALUE_AT_22050HZ        (0x11B7U)</span></div><div class="line"><span class="preprocessor">#define AUDIO_PLAYBACK_PWM_STREAMING_EXAMPLE_SAMPLES_PER_CHUNK              (1024U)</span></div><div class="line"><span class="preprocessor">#define AUDIO_PLAYBACK_PWM_STREAMING_EXAMPLE_TONE_FREQUENCY_HZ              (800U)</span></div><div class="line"><span class="preprocessor">#define AUDIO_PLAYBACK_PWM_EXAMPLE_SAMPLES_TO_TRANSFER                      (1024U)</span></div><div class="line"><span class="preprocessor">#define AUDIO_PLAYBACK_PWM_EXAMPLE_CONVERT_TO_PWM_SAMPLES                   (32768U)</span></div><div class="line"><span class="preprocessor">#define AUDIO_PLAYBACK_PWM_STREAMING_EXAMPLE_DATA_BIT_SIZE                  (16U)</span></div><div class="line"></div><div class="line">int16_t       g_stream_src[2][AUDIO_PLAYBACK_PWM_EXAMPLE_SAMPLES_TO_TRANSFER];</div><div class="line">q15_t         g_pwm_sample[2][AUDIO_PLAYBACK_PWM_EXAMPLE_SAMPLES_TO_TRANSFER];</div><div class="line">q15_t         g_pwm_scaled_sample[2][AUDIO_PLAYBACK_PWM_EXAMPLE_SAMPLES_TO_TRANSFER];</div><div class="line">uint32_t      g_buffer_index           = 0;</div><div class="line"><span class="keyword">volatile</span> <span class="keywordtype">bool</span> g_send_data_in_main_loop = <span class="keyword">true</span>;</div><div class="line"><span class="keyword">volatile</span> <span class="keywordtype">bool</span> g_data_ready             = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="comment">/* Example callback called when Audio Playback is ready for more data. */</span></div><div class="line"><span class="keywordtype">void</span> rm_audio_playback_example_callback (<a class="code" href="group___a_u_d_i_o___p_l_a_y_b_a_c_k___a_p_i.html#structaudio__playback__callback__args__t">audio_playback_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="comment">/* Start playing next stream if data is ready. */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___a_u_d_i_o___p_l_a_y_b_a_c_k___a_p_i.html#gga937592eccbaa6ebe521017d834580610a8b02a2a7d463c5ac93f9816ebd744551">AUDIO_PLAYBACK_EVENT_PLAYBACK_COMPLETE</a> == (p_args-&gt;<a class="code" href="group___a_u_d_i_o___p_l_a_y_b_a_c_k___a_p_i.html#a6b32c4b4f982473df1454a7f94e574ba">event</a>))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (g_data_ready)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Reload data and handle errors. */</span></div><div class="line">            rm_audio_playback_example_play();</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            <span class="comment">/* Data was not ready yet, send it in the main loop. */</span></div><div class="line">            g_send_data_in_main_loop = <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Load the next stream and check for error condition. */</span></div><div class="line"><span class="keywordtype">void</span> rm_audio_playback_example_play (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Set the playback stream */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err;</div><div class="line">    err =</div><div class="line">        <a class="code" href="group___r_m___a_u_d_i_o___p_l_a_y_b_a_c_k___p_w_m.html#gaa5835bf2ca45bb07f83a5cf01c5082a0">RM_AUDIO_PLAYBACK_PWM_Play</a>(&amp;g_audio_playback_pwm_ctrl, (int16_t *) &amp;g_pwm_scaled_sample[g_buffer_index][0],</div><div class="line">                                   (AUDIO_PLAYBACK_PWM_STREAMING_EXAMPLE_SAMPLES_PER_CHUNK * <span class="keyword">sizeof</span>(int16_t)));</div><div class="line">    <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Switch the buffer after data is sent. */</span></div><div class="line">        g_buffer_index = !g_buffer_index;</div><div class="line"></div><div class="line">        <span class="comment">/* Allow loop to calculate next buffer. */</span></div><div class="line">        g_data_ready = <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* The</span></div><div class="line"><span class="comment">         * application must wait until the audio playback is completed. In this example, the</span></div><div class="line"><span class="comment">         * callback sets data or resets the flag g_send_data_in_main_loop. */</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Calculate samples. This example is just a sine wave. For this type of data, it would be better to calculate</span></div><div class="line"><span class="comment"> * one period and loop it. This example should be updated for the audio data used by the application. */</span></div><div class="line"><span class="keywordtype">void</span> rm_audio_playback_example_calculate_samples (uint32_t buffer_index)</div><div class="line">{</div><div class="line">    <span class="keyword">static</span> uint32_t t = 0U;</div><div class="line"></div><div class="line">    <span class="comment">/* Create a sine wave. Using formula sample = sin(2 * pi * tone_frequency * t / sampling_frequency) */</span></div><div class="line">    uint32_t freq = AUDIO_PLAYBACK_PWM_STREAMING_EXAMPLE_TONE_FREQUENCY_HZ;</div><div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; AUDIO_PLAYBACK_PWM_STREAMING_EXAMPLE_SAMPLES_PER_CHUNK; i += 1)</div><div class="line">    {</div><div class="line">        <span class="keywordtype">float</span> input = (((float) (freq * t)) * (<span class="keywordtype">float</span>) M_TWOPI) /</div><div class="line">                      AUDIO_PLAYBACK_PWM_STREAMING_EXAMPLE_AUDIO_SAMPLING_FREQUENCY_HZ;</div><div class="line">        t++;</div><div class="line"></div><div class="line">        <span class="comment">/* Store sample. */</span></div><div class="line">        int16_t sample = (int16_t) ((INT16_MAX * sinf(input)));</div><div class="line">        g_stream_src[buffer_index][i] = sample;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Convert signed PCM data to unsigned PCM data as PWM needs unsigned input. */</span></div><div class="line">    arm_offset_q15(&amp;g_stream_src[buffer_index][0],</div><div class="line">                   (q15_t) (INT16_MAX + 1),</div><div class="line">                   &amp;g_pwm_sample[buffer_index][0],</div><div class="line">                   AUDIO_PLAYBACK_PWM_STREAMING_EXAMPLE_SAMPLES_PER_CHUNK);</div><div class="line"></div><div class="line">    <span class="comment">/* Scale the data by the selected period for the timer (calculated for equivalent playback rate) */</span></div><div class="line">    arm_scale_q15(&amp;g_pwm_sample[buffer_index][0],</div><div class="line">                  AUDIO_PLAYBACK_PWM_STREAMING_EXAMPLE_PERIOD_VALUE_AT_22050HZ,</div><div class="line">                  AUDIO_PLAYBACK_PWM_STREAMING_EXAMPLE_DATA_BIT_SIZE,</div><div class="line">                  &amp;g_pwm_scaled_sample[buffer_index][0],</div><div class="line">                  AUDIO_PLAYBACK_PWM_STREAMING_EXAMPLE_SAMPLES_PER_CHUNK);</div><div class="line"></div><div class="line">    <span class="comment">/* Data is ready to be sent in the interrupt. */</span></div><div class="line">    g_data_ready = <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> rm_audio_playback_streaming_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the module.</span></div><div class="line"><span class="comment">     * Configure the following pins in the pin configurator for PWM output:</span></div><div class="line"><span class="comment">     *    - If the GPT timer is used for generation of PWM waves configure GTIOCAn or GTIOCBn pin and enable the output</span></div><div class="line"><span class="comment">     *      to these pins through the GPT module properties for desired channel n.</span></div><div class="line"><span class="comment">     *    - Otherwise, if AGT is used for generation of PWM waves configure AGTOAn or AGTOBn pin and enable the output to</span></div><div class="line"><span class="comment">     *      to these pins through the AGT module properties for desired channel n.</span></div><div class="line"><span class="comment">     * Configure the DMAC/DTC destination address as following:</span></div><div class="line"><span class="comment">     *    - If the GPT timer is used for generation of PWM waves, configure DMAC/DTC destination address to the address of</span></div><div class="line"><span class="comment">     *      GTCCRC register (&amp;R_GPTn-&gt;GTCCR[2]) if PWM output pin is GTIOCA otherwise configure to the address of GTCCRD</span></div><div class="line"><span class="comment">     *      register (&amp;R_GPTn-&gt;GTCCR[3]) if PWM output pin is GTIOCB for desired GPT channel n.</span></div><div class="line"><span class="comment">     *    - If the AGT timer is used for generation of PWM waves, configure DMAC/DTC destination address as the address of</span></div><div class="line"><span class="comment">     *      AGTCMA register (&amp;R_AGTn-&gt;AGTCMA) if PWM output pin is AGTOA otherwise the address of AGTCMB register</span></div><div class="line"><span class="comment">     *      (&amp;R_AGTn-&gt;AGTCMB) if the PWM output pin is AGTOB for desired AGT channel n.</span></div><div class="line"><span class="comment">     * Configure the DMAC/DTC transfer size as 4 Bytes if PWM interface is GPT timer otherwise configure transfer size as 2 Bytes if</span></div><div class="line"><span class="comment">     * PWM interface is AGT timer. */</span></div><div class="line">    err = <a class="code" href="group___r_m___a_u_d_i_o___p_l_a_y_b_a_c_k___p_w_m.html#ga5b7e43022164166bf513800a59f525ce">RM_AUDIO_PLAYBACK_PWM_Open</a>(&amp;g_audio_playback_pwm_ctrl, &amp;g_audio_playback_pwm_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Start timer and transfer modules. */</span></div><div class="line">    err = <a class="code" href="group___r_m___a_u_d_i_o___p_l_a_y_b_a_c_k___p_w_m.html#ga6b4c748d93d3a838d38bc33b5c123bd9">RM_AUDIO_PLAYBACK_PWM_Start</a>(&amp;g_audio_playback_pwm_ctrl);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Prepare data in a buffer that is not currently used for transmission. */</span></div><div class="line">        rm_audio_playback_example_calculate_samples(g_buffer_index);</div><div class="line"></div><div class="line">        <span class="comment">/* Send data in main loop the first time, and if it was not ready in the interrupt. */</span></div><div class="line">        <span class="keywordflow">if</span> (g_send_data_in_main_loop)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Clear flag. */</span></div><div class="line">            g_send_data_in_main_loop = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            <span class="comment">/* Reload data and handle errors. */</span></div><div class="line">            rm_audio_playback_example_play();</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* If the next buffer is ready, wait for the data to be sent in the interrupt. */</span></div><div class="line">        <span class="keywordflow">while</span> (g_data_ready)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Do nothing. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structaudio__playback__pwm__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___a_u_d_i_o___p_l_a_y_b_a_c_k___p_w_m.html#structaudio__playback__pwm__instance__ctrl__t">audio_playback_pwm_instance_ctrl_t</a></td></tr>
<tr class="separator:structaudio__playback__pwm__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structaudio__playback__pwm__instance__ctrl__t" id="structaudio__playback__pwm__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structaudio__playback__pwm__instance__ctrl__t">&#9670;&nbsp;</a></span>audio_playback_pwm_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct audio_playback_pwm_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>AUDIO_PLAYBACK_PWM instance control block. DO NOT MODIFY. Initialization occurs when <a class="el" href="group___r_m___a_u_d_i_o___p_l_a_y_b_a_c_k___p_w_m.html#ga5b7e43022164166bf513800a59f525ce">RM_AUDIO_PLAYBACK_PWM_Open()</a> is called. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a36e60dda6d25ed6ad7ecb4a1239f39d0"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___a_u_d_i_o___p_l_a_y_b_a_c_k___p_w_m.html#a36e60dda6d25ed6ad7ecb4a1239f39d0">p_callback</a> )(<a class="el" href="group___a_u_d_i_o___p_l_a_y_b_a_c_k___a_p_i.html#structaudio__playback__callback__args__t">audio_playback_callback_args_t</a> *p_args)</td></tr>
<tr class="separator:a36e60dda6d25ed6ad7ecb4a1239f39d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de66771e8d0e1589420b0e21f507c78"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___a_u_d_i_o___p_l_a_y_b_a_c_k___p_w_m.html#a9de66771e8d0e1589420b0e21f507c78">p_context</a></td></tr>
<tr class="separator:a9de66771e8d0e1589420b0e21f507c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa0d7cdb4fe4fd916e0efede2d95832"><td class="memItemLeft" align="right" valign="top"><a id="abaa0d7cdb4fe4fd916e0efede2d95832"></a>
<a class="el" href="group___a_u_d_i_o___p_l_a_y_b_a_c_k___a_p_i.html#structaudio__playback__cfg__t">audio_playback_cfg_t</a> const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___a_u_d_i_o___p_l_a_y_b_a_c_k___p_w_m.html#abaa0d7cdb4fe4fd916e0efede2d95832">p_cfg</a></td></tr>
<tr class="memdesc:abaa0d7cdb4fe4fd916e0efede2d95832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the configuration structure. <br /></td></tr>
<tr class="separator:abaa0d7cdb4fe4fd916e0efede2d95832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7129cc96c6ecca272b57e693d2761fc"><td class="memItemLeft" align="right" valign="top"><a id="aa7129cc96c6ecca272b57e693d2761fc"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___a_u_d_i_o___p_l_a_y_b_a_c_k___p_w_m.html#aa7129cc96c6ecca272b57e693d2761fc">open</a></td></tr>
<tr class="memdesc:aa7129cc96c6ecca272b57e693d2761fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by driver to check if the control structure is valid. <br /></td></tr>
<tr class="separator:aa7129cc96c6ecca272b57e693d2761fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50079866bbdeb359437124d7ccf9fea0"><td class="memItemLeft" align="right" valign="top"><a id="a50079866bbdeb359437124d7ccf9fea0"></a>
<a class="el" href="group___t_i_m_e_r___a_p_i.html#structtimer__instance__t">timer_instance_t</a> const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___a_u_d_i_o___p_l_a_y_b_a_c_k___p_w_m.html#a50079866bbdeb359437124d7ccf9fea0">p_lower_lvl_timer</a></td></tr>
<tr class="memdesc:a50079866bbdeb359437124d7ccf9fea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer API used to generate sampling frequency and GPT/AGT API used to access PWM hardware. <br /></td></tr>
<tr class="separator:a50079866bbdeb359437124d7ccf9fea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1df966ae4c757d24672de8438efc175"><td class="memItemLeft" align="right" valign="top"><a id="ac1df966ae4c757d24672de8438efc175"></a>
<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__instance__t">transfer_instance_t</a> const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___a_u_d_i_o___p_l_a_y_b_a_c_k___p_w_m.html#ac1df966ae4c757d24672de8438efc175">p_lower_lvl_transfer</a></td></tr>
<tr class="memdesc:ac1df966ae4c757d24672de8438efc175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer API used to transfer data each sampling frequency. <br /></td></tr>
<tr class="separator:ac1df966ae4c757d24672de8438efc175"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a id="a36e60dda6d25ed6ad7ecb4a1239f39d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e60dda6d25ed6ad7ecb4a1239f39d0">&#9670;&nbsp;</a></span>p_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(*  audio_playback_pwm_instance_ctrl_t::p_callback) (<a class="el" href="group___a_u_d_i_o___p_l_a_y_b_a_c_k___a_p_i.html#structaudio__playback__callback__args__t">audio_playback_callback_args_t</a> *p_args)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback called when play is complete. </p>

</div>
</div>
<a id="a9de66771e8d0e1589420b0e21f507c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de66771e8d0e1589420b0e21f507c78">&#9670;&nbsp;</a></span>p_context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* audio_playback_pwm_instance_ctrl_t::p_context</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Placeholder for user data. Passed to the user callback in <a class="el" href="group___a_u_d_i_o___p_l_a_y_b_a_c_k___a_p_i.html#structaudio__playback__callback__args__t">audio_playback_callback_args_t</a>. </p>

</div>
</div>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga5b7e43022164166bf513800a59f525ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b7e43022164166bf513800a59f525ce">&#9670;&nbsp;</a></span>RM_AUDIO_PLAYBACK_PWM_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> RM_AUDIO_PLAYBACK_PWM_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_u_d_i_o___p_l_a_y_b_a_c_k___a_p_i.html#gaedd9fa315a0afc1eb4d8ce56668acba8">audio_playback_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_u_d_i_o___p_l_a_y_b_a_c_k___a_p_i.html#structaudio__playback__cfg__t">audio_playback_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens and configures the Audio Playback with PWM driver. Sets playback speed and transfer rate to read the audio buffer.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Initialize the Audio Playback module for playing an audio stream. */</span></div><div class="line">    err = <a class="code" href="group___r_m___a_u_d_i_o___p_l_a_y_b_a_c_k___p_w_m.html#ga5b7e43022164166bf513800a59f525ce">RM_AUDIO_PLAYBACK_PWM_Open</a>(&amp;g_audio_playback_pwm_ctrl, &amp;g_audio_playback_pwm_cfg);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Audio Playback module successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Module already open. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>One or more pointers point to NULL or callback is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac59d16a778f03d2bf4ec094f6fccc128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac59d16a778f03d2bf4ec094f6fccc128">&#9670;&nbsp;</a></span>RM_AUDIO_PLAYBACK_PWM_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> RM_AUDIO_PLAYBACK_PWM_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_u_d_i_o___p_l_a_y_b_a_c_k___a_p_i.html#gaedd9fa315a0afc1eb4d8ce56668acba8">audio_playback_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes the module driver. Enables module stop mode.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Module successfully closed. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer pointing to NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function will close all the lower level HAL drivers as well. </dd></dl>

</div>
</div>
<a id="ga6b4c748d93d3a838d38bc33b5c123bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b4c748d93d3a838d38bc33b5c123bd9">&#9670;&nbsp;</a></span>RM_AUDIO_PLAYBACK_PWM_Start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> RM_AUDIO_PLAYBACK_PWM_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_u_d_i_o___p_l_a_y_b_a_c_k___a_p_i.html#gaedd9fa315a0afc1eb4d8ce56668acba8">audio_playback_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start the PWM HAL driver (AGT or GPT) and timer HAL (AGT or GPT) drivers.</p>
<ul>
<li>Example: <div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Start to the play the selected audio stream*/</span></div><div class="line">    err = <a class="code" href="group___r_m___a_u_d_i_o___p_l_a_y_b_a_c_k___p_w_m.html#ga6b4c748d93d3a838d38bc33b5c123bd9">RM_AUDIO_PLAYBACK_PWM_Start</a>(&amp;g_audio_playback_pwm_ctrl);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Audio playback hardware started successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>The parameter p_ctrl is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver not open. This function calls<ul>
<li><a class="el" href="group___t_i_m_e_r___a_p_i.html#afcc7e85d01c3d7dc0c6e09954631f47f">timer_api_t::start</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="ga85f49b31e593c483f72340d47fc318d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85f49b31e593c483f72340d47fc318d6">&#9670;&nbsp;</a></span>RM_AUDIO_PLAYBACK_PWM_Stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> RM_AUDIO_PLAYBACK_PWM_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_u_d_i_o___p_l_a_y_b_a_c_k___a_p_i.html#gaedd9fa315a0afc1eb4d8ce56668acba8">audio_playback_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop the PWM HAL driver (AGT or GPT) and timer HAL driver (AGT or GPT).</p>
<ul>
<li>Example: <div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Stop playing. */</span></div><div class="line">    err = <a class="code" href="group___r_m___a_u_d_i_o___p_l_a_y_b_a_c_k___p_w_m.html#ga85f49b31e593c483f72340d47fc318d6">RM_AUDIO_PLAYBACK_PWM_Stop</a>(&amp;g_audio_playback_pwm_ctrl);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Audio playback hardware stopped successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>The parameter p_ctrl is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver not open. This function calls<ul>
<li><a class="el" href="group___t_i_m_e_r___a_p_i.html#aed0139dbf5102e39719ddbc51f16a21e">timer_api_t::stop</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="gaa5835bf2ca45bb07f83a5cf01c5082a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5835bf2ca45bb07f83a5cf01c5082a0">&#9670;&nbsp;</a></span>RM_AUDIO_PLAYBACK_PWM_Play()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> RM_AUDIO_PLAYBACK_PWM_Play </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_u_d_i_o___p_l_a_y_b_a_c_k___a_p_i.html#gaedd9fa315a0afc1eb4d8ce56668acba8">audio_playback_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>p_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Play a single audio buffer by input samples to the PWM HAL (AGT or GPT) at the sampling frequency configured by the timer.</p>
<ul>
<li>Example: <div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Set the 16 Bit PCM audio stream to play next */</span></div><div class="line">    err = <a class="code" href="group___r_m___a_u_d_i_o___p_l_a_y_b_a_c_k___p_w_m.html#gaa5835bf2ca45bb07f83a5cf01c5082a0">RM_AUDIO_PLAYBACK_PWM_Play</a>(&amp;g_audio_playback_pwm_ctrl, play_buffer, AUDIO_EXAMPLE_LENGTH);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Buffer playback began successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>The parameter p_ctrl or p_buffer is NULL or buffer length is greater than 0x10000. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver not open.. This function calls<ul>
<li><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a9c096c8d0e78dfbf8b3809a4598b8619">transfer_api_t::reset</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v6.2.0 User's Manual Copyright © (2025) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
