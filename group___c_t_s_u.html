<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: CTSU (r_ctsu)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
    $(document).ready(function() {
        $("tr.tree_lvl_1").nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
		$("tr.tree_lvl_1").data("expanded","0");
		$("tr.tree_lvl_2").data("expanded","0");
		$("tr.tree_lvl_3").data("expanded","0");
		$("tr.tree_lvl_4").data("expanded","0");
		$("tr.tree_lvl_5").data("expanded","0");
        $("tr.tree_lvl_1").click(function() {
		    var lvl_1_is_open = $(this).data("expanded");
		    if (lvl_1_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2, tr.tree_lvl_1_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_2").click(function() {
		    var lvl_2_is_open = $(this).data("expanded");
		    if (lvl_2_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3, tr.tree_lvl_2_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_3").click(function() {
		    var lvl_3_is_open = $(this).data("expanded");
		    if (lvl_3_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_3_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_4").click(function() {
		    var lvl_4_is_open = $(this).data("expanded");
		    if (lvl_4_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5, tr.tree_lvl_4_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_5").click(function() {
		    var lvl_5_is_open = $(this).data("expanded");
		    if (lvl_5_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4_item,tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
     });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v6.2.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">

    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text">
      </span>
      <span class="right">
          &nbsp;
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___c_t_s_u.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body.
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len));
            }
          }
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element.
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">CTSU (r_ctsu)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___c_a_p_t_o_u_c_h___m_o_d_u_l_e_s.html">CapTouch</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4e625d8c9f3b301a46913c5827732682"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a> (<a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const p_ctrl, <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="memdesc:ga4e625d8c9f3b301a46913c5827732682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens and configures the CTSU driver module. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#ae8f2c7b3cc9e33f0f790f76655d3d723">ctsu_api_t::open</a>.  <a href="#ga4e625d8c9f3b301a46913c5827732682">More...</a><br /></td></tr>
<tr class="separator:ga4e625d8c9f3b301a46913c5827732682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46cf185922bbca921cb92b4c18f62525"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a> (<a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="memdesc:ga46cf185922bbca921cb92b4c18f62525"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function should be called each time a periodic timer expires. If initial offset tuning is enabled, The first several calls are used to tuning for the sensors. Before starting the next scan, first get the data with <a class="el" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe" title="This function gets the sensor values as scanned by the CTSU. If initial offset tuning is enabled...">R_CTSU_DataGet()</a>. If a different control block scan should be run, check the scan is complete before executing. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#a1df87278ab5d47fdd093994f53de96a6">ctsu_api_t::scanStart</a>.  <a href="#ga46cf185922bbca921cb92b4c18f62525">More...</a><br /></td></tr>
<tr class="separator:ga46cf185922bbca921cb92b4c18f62525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cff42feeaa3d73216b73c313fb9a5fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a> (<a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const p_ctrl, uint16_t *p_data)</td></tr>
<tr class="memdesc:ga1cff42feeaa3d73216b73c313fb9a5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the sensor values as scanned by the CTSU. If initial offset tuning is enabled, The first several calls are used to tuning for the sensors. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#aadcc6930b4e9d0ad86b6f607e86c28f5">ctsu_api_t::dataGet</a>.  <a href="#ga1cff42feeaa3d73216b73c313fb9a5fe">More...</a><br /></td></tr>
<tr class="separator:ga1cff42feeaa3d73216b73c313fb9a5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eee44681ca5401e3b1c8e36db873681"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ga9eee44681ca5401e3b1c8e36db873681">R_CTSU_AutoJudgementDataGet</a> (<a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const p_ctrl, uint64_t *p_button_status)</td></tr>
<tr class="memdesc:ga9eee44681ca5401e3b1c8e36db873681"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the result of automatic judgement button. Call after the scan is completed. The result is 64-bit bitmaps and is stored in order of TS number for specified ctsu control. After the initial judgement, the baseline initialization bit is set and the automatic judgement threshold is set. This function is called only for automatic judgement. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#a39b1857983379004b97041a9462c07f0">ctsu_api_t::autoJudgementDataGet</a>.  <a href="#ga9eee44681ca5401e3b1c8e36db873681">More...</a><br /></td></tr>
<tr class="separator:ga9eee44681ca5401e3b1c8e36db873681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04263b8b45802780c9e072e19414ba7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ga04263b8b45802780c9e072e19414ba7e">R_CTSU_OffsetTuning</a> (<a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="memdesc:ga04263b8b45802780c9e072e19414ba7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tunes the offset register(SO). Call after the measurement is completed. If the return value is FSP_ERR_CTSU_INCOMPLETE_TUNING, tuning is not complete. Execute the measurement and this function call routine until the return value becomes FSP_SUCCESS. It is recommended to run this routine after <a class="el" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682" title="Opens and configures the CTSU driver module. Implements ctsu_api_t::open. ">R_CTSU_Open()</a>. It can be recalled and tuned again. When the automatic judgement is enabled, after the offset tuning is completed,the baseline initialization bit flag is set. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#a5c1e1ab640eec8358e7ef92de31fcdc8">ctsu_api_t::offsetTuning</a>.  <a href="#ga04263b8b45802780c9e072e19414ba7e">More...</a><br /></td></tr>
<tr class="separator:ga04263b8b45802780c9e072e19414ba7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac88d0518c996cb44643a82818b961485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#gac88d0518c996cb44643a82818b961485">R_CTSU_ScanStop</a> (<a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="memdesc:gac88d0518c996cb44643a82818b961485"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function scan stops the sensor as scanning by the CTSU. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#ac21a98eaa673d72b7da701ba90093f59">ctsu_api_t::scanStop</a>.  <a href="#gac88d0518c996cb44643a82818b961485">More...</a><br /></td></tr>
<tr class="separator:gac88d0518c996cb44643a82818b961485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76c89bb207dad2030b60fd71df7a717f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ga76c89bb207dad2030b60fd71df7a717f">R_CTSU_CallbackSet</a> (<a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const p_api_ctrl, void(*p_callback)(<a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__callback__args__t">ctsu_callback_args_t</a> *), void *const p_context, <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__callback__args__t">ctsu_callback_args_t</a> *const p_callback_memory)</td></tr>
<tr class="separator:ga76c89bb207dad2030b60fd71df7a717f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73b45020c568d57065c8a7adecaaeb4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ga73b45020c568d57065c8a7adecaaeb4c">R_CTSU_Close</a> (<a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="memdesc:ga73b45020c568d57065c8a7adecaaeb4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables specified CTSU control block. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#aeb44bb4a59bad9025f0897cee306a395">ctsu_api_t::close</a>.  <a href="#ga73b45020c568d57065c8a7adecaaeb4c">More...</a><br /></td></tr>
<tr class="separator:ga73b45020c568d57065c8a7adecaaeb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32a5f61231501fb64c85fa52791b0e79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ga32a5f61231501fb64c85fa52791b0e79">R_CTSU_SpecificDataGet</a> (<a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const p_ctrl, uint16_t *p_specific_data, <a class="el" href="group___c_t_s_u___a_p_i.html#ga1fe870ee0162807f8f9387749ba4e0a6">ctsu_specific_data_type_t</a> specific_data_type)</td></tr>
<tr class="memdesc:ga32a5f61231501fb64c85fa52791b0e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the sensor specific data values as scanned by the CTSU. Call this function after calling the <a class="el" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe" title="This function gets the sensor values as scanned by the CTSU. If initial offset tuning is enabled...">R_CTSU_DataGet()</a> function.  <a href="#ga32a5f61231501fb64c85fa52791b0e79">More...</a><br /></td></tr>
<tr class="separator:ga32a5f61231501fb64c85fa52791b0e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac51fca87e02d589bcdeb894b99f7a08e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#gac51fca87e02d589bcdeb894b99f7a08e">R_CTSU_DataInsert</a> (<a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const p_ctrl, uint16_t *p_insert_data)</td></tr>
<tr class="memdesc:gac51fca87e02d589bcdeb894b99f7a08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function inserts the value of the second argument as the measurement result value. Call this function after calling the <a class="el" href="group___c_t_s_u.html#gac51fca87e02d589bcdeb894b99f7a08e" title="This function inserts the value of the second argument as the measurement result value. Call this function after calling the R_CTSU_DataInsert() function. Implements ctsu_api_t::dataInsert. ">R_CTSU_DataInsert()</a> function. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#a84dfd5dd2ab6b16465cc5c06953c6a9f">ctsu_api_t::dataInsert</a>.  <a href="#gac51fca87e02d589bcdeb894b99f7a08e">More...</a><br /></td></tr>
<tr class="separator:gac51fca87e02d589bcdeb894b99f7a08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45103e8db4a16dfabf3a516ab2da9f26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ga45103e8db4a16dfabf3a516ab2da9f26">R_CTSU_Diagnosis</a> (<a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="memdesc:ga45103e8db4a16dfabf3a516ab2da9f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagnosis the CTSU peripheral. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#a42a81fef42f2bf61bde59cba4796cc0e">ctsu_api_t::diagnosis</a>.  <a href="#ga45103e8db4a16dfabf3a516ab2da9f26">More...</a><br /></td></tr>
<tr class="separator:ga45103e8db4a16dfabf3a516ab2da9f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This HAL driver supports the Capacitive Touch Sensing Unit (CTSU). It implements the <a class="el" href="group___c_t_s_u___a_p_i.html">CTSU Interface</a>. </p>
<h1><a class="anchor" id="r-ctsu-overview"></a>
Overview</h1>
<p>The capacitive touch sensing unit HAL driver (r_ctsu) provides an API to control the CTSU peripheral. This module performs capacitance measurement based on various settings defined by the configuration. This module is configured via the <a href="https://www.renesas.com/qe-capacitive-touch">QE for Capacitive Touch</a>.</p>
<h2><a class="anchor" id="r-ctsu-features"></a>
Features</h2>
<p><a class="anchor" id="um_ctsu_mutual"></a><a class="anchor" id="um_ctsu_multi_method"></a><a class="anchor" id="um_ctsu_mutual_jmm"></a><a class="anchor" id="um_ctsu_multi_method_jmm"></a></p><ul>
<li>Supports multiple scan modes<ul>
<li>Self-capacitance multi scan mode (CTSU2 support active shield)</li>
<li>Mutual-capacitance full scan mode</li>
<li>Mutual-capacitance parallel scan mode (CTSU2)</li>
<li>Current Measurement mode (CTSU2)</li>
<li>Diagnosis scan mode</li>
</ul>
</li>
<li>Scans may be started by software or an external trigger</li>
<li>Returns measured capacitance data on scan completion</li>
<li>Support DTC transfer of scanned data</li>
<li>Supports TrustZone</li>
<li>Corrects accuracy for temperature drift (CTSU2)</li>
</ul>
<h1><a class="anchor" id="r-ctsu-configuration"></a>
Configuration</h1>
<dl class="section note"><dt>Note</dt><dd><b>This module is configured via the <a href="https://www.renesas.com/qe-capacitive-touch">QE for Capacitive Touch</a>. For information on how to use the QE tool, once the tool is installed click Help -&gt; Help Contents in e&sup2; studio and search for "QE".</b></dd></dl>
<p><h2>Build Time Configurations for r_ctsu</h2>
The following build time configurations are defined in fsp_cfg/r_ctsu_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr class="tree_none">
<td>Support for using DTC</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Enable DTC support for the CTSU module. </td></tr>
<tr class="tree_none">
<td>Enable automatic judgment mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Enable or Disable automatic judgment mode. This feature is only for RA4L1 and RA0L1. </td></tr>
<tr class="tree_none">
<td>Interrupt priority level</td><td>MCU Specific Options</td><td></td><td>Priority level of all CTSU interrupt (CSTU_WR,CTSU_RD,CTSU_FN)  </td></tr>
</table>
 <h2>Configurations for CapTouch &gt; CTSU (r_ctsu)</h2>
This module can be added to the Stacks tab via New Stack &gt; CapTouch &gt; CTSU (r_ctsu). Non-secure callable guard functions can be generated for this module by right clicking the module in the RA Configuration tool and checking the "Non-secure Callable" box.<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Scan Start Trigger</td><td>MCU Specific Options</td><td></td><td>CTSU Scan Start Trigger Select </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-ctsu-interrupt-configuration"></a>
Interrupt Configuration</h2>
<p>The first <a class="el" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a> function call sets CTSU peripheral interrupts. The user should provide a callback function to be invoked at the end of the CTSU scan sequence. The callback argument will contain information about the scan status.</p>
<h2><a class="anchor" id="r-ctsu-clock-configuration"></a>
Clock Configuration</h2>
<p>The CTSU peripheral module uses PCLKB as its clock source. You can set the PCLKB frequency using the <b>Clocks</b> tab of the RA Configuration editor or by using the CGC Interface at run-time.</p>
<dl class="section note"><dt>Note</dt><dd>The CTSU Drive pulse will be calculated and set by the tooling depending on the selected transfer rate.</dd></dl>
<h2><a class="anchor" id="r-ctsu-pin-configuration"></a>
Pin Configuration</h2>
<p>The TSn pins are sensor pins for the CTSU.</p>
<p>The TSCAP pin is used for an internal low-pass filter and must be connected to an external decoupling capacitor.</p>
<h1><a class="anchor" id="r-ctsu-usage_notes"></a>
Usage Notes</h1>
<p>The CTSU module is a CTSU driver for the Touch module. The CTSU module assumes the access from the Touch middleware layer, and it is also accessible from an user application.<br />
 The CTSU peripheral installed on RA family has three versions: CTSU, CTSU2, and CTSU2SLa. Each MCU devices are equipped with the following version of CTSU peripherals. <br />
</p><ul>
<li>CTSU2SLa : RA4L1, RA0L1</li>
<li>CTSU2 : RA2E1, RA2L1</li>
<li>CTSU : RA2A1, RA4M1, RA4M2, RA4M3, RA4W1, RA6M1, RA6M2, RA6M3, RA6M4, RA6M5,</li>
</ul>
<p>CTSU, CTSU2 and CTSU2SLa are functionally different, so CTSU, CTSU2 and CTSU2SLa are described in this application note as below.<br />
 Common description for CTSU and CTSU2 -&gt; CTSU<br />
 Description only for CTSU -&gt; CTSU1<br />
 Description only for CTSU2 and CTSU2SLa -&gt; CTSU2<br />
 Description only for CTSU2SLa -&gt; CTSU2SLa<br />
 Without mention, it means the common description for CTSU, CTSU2 and CTSU2SLa.</p>
<h2>Functions</h2>
<p>The CTSU module supports the following functions.</p>
<h3>Touch judgement Type</h3>
<p>CTSU2 has two judgement type, which differ in processing and output data.<br />
 It is common to get three raw value for each element and calculate CCO correction, and then performs different processing.<br />
</p>
<p><br />
</p><ol type="1">
<li>Value Majority Mode(VMM)<br />
 Calculate three frequency correction value from three CCO correction values. Calculate the sum of the two closest values of the three frequency correction value. Outputs the moving average of this added value.<br />
</li>
<li>judgement Majority Mode (JMM)<br />
 This mode is supported from FSP V5.6.0 or later.<br />
 Outputs the moving average of three CCO correction values.<br />
 <br />
</li>
</ol>
<div class="image">
<img src="r_ctsu_JMM_vs_VMM.png" alt="r_ctsu_JMM_vs_VMM.png"/>
<div class="caption">
Data flow Comparison of JMM and VMM </div></div>
<p><br />
</p>
<h3>Measurements and Obtaining Data</h3>
<p>Measurements can be started by a software trigger or by an external event triggered by the Event Link Controller (ELC).<br />
 As the measurement process is carried out by the CTSU2 peripheral, it does not use up main processor processing time.<br />
 The CTSU module processes INTCTSUWR and INTCTSURD if generated during a measurement. The data transfer controller (DTC) can also be used for these processes.<br />
 When the measurement complete interrupt (INTCTSUFN) process is complete, the application is notified in a callback function. Make sure you obtain the measurement results before the next measurement is started as internal processes are also executed when a measurement is completed.<br />
 Start the measurement with API function <a class="el" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525" title="This function should be called each time a periodic timer expires. If initial offset tuning is enable...">R_CTSU_ScanStart()</a>.<br />
 Obtain the measurement results with API function <a class="el" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe" title="This function gets the sensor values as scanned by the CTSU. If initial offset tuning is enabled...">R_CTSU_DataGet()</a>. <br />
 The number of arrays in the second argument of <a class="el" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe" title="This function gets the sensor values as scanned by the CTSU. If initial offset tuning is enabled...">R_CTSU_DataGet()</a> is different between VMM and JMM.<br />
 VMM returns one measurement result for each element.<br />
 JMM returns three measurement results for each element.<br />
</p>
<h3>Sensor CCO Correction function</h3>
<p>The CTSU2 peripheral has a built-in correction circuit to handle the potential microvariations related to the manufacturing process of the sensor CCO MCU.<br />
 The module temporarily transitions to the correction process during initialization after power is turned on. In the correction process, the correction circuit is used to generate a correction coefficient (factor) to ensure accurate sensor measurement values.<br />
 When temperature correction is enabled, an external resistor connected to a TS terminal is used to periodically update the correction coefficient. By using an external resistor that is not dependent on temperature, you can even correct the temperature drift of the sensor CCO.</p>
<h3>Initial Offset Adjustment</h3>
<p>The CTSU2 peripheral was designed with a built-in offset current circuit in consideration of the amount of change in current due to touch. The offset current circuit cancels enough of the parasitic capacitance for it to fit within the sensor CCO dynamic range.<br />
 This module automatically adjusts the offset current setting. As the adjustment uses the normal measurement process, the combination of <a class="el" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525" title="This function should be called each time a periodic timer expires. If initial offset tuning is enable...">R_CTSU_ScanStart()</a> and <a class="el" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe" title="This function gets the sensor values as scanned by the CTSU. If initial offset tuning is enabled...">R_CTSU_DataGet()</a> or the combination of <a class="el" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525" title="This function should be called each time a periodic timer expires. If initial offset tuning is enable...">R_CTSU_ScanStart()</a> and <a class="el" href="group___c_t_s_u.html#ga04263b8b45802780c9e072e19414ba7e" title="This function tunes the offset register(SO). Call after the measurement is completed. If the return value is FSP_ERR_CTSU_INCOMPLETE_TUNING, tuning is not complete. Execute the measurement and this function call routine until the return value becomes FSP_SUCCESS. It is recommended to run this routine after R_CTSU_Open(). It can be recalled and tuned again. When the automatic judgement is enabled, after the offset tuning is completed,the baseline initialization bit flag is set. Implements ctsu_api_t::offsetTuning. ">R_CTSU_OffsetTuning()</a> must be repeated several times after startup. Because the <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__element__cfg__t">ctsu_element_cfg_t</a> member “so” is the starting point for adjustments, you can set the appropriate value for “so” in order to reduce the number of times the two functions must be run to complete the adjustment. Normally, the value used for “so” is a value adjusted by QE for Capacitive Touch.<br />
 <a class="el" href="group___c_t_s_u.html#ga04263b8b45802780c9e072e19414ba7e" title="This function tunes the offset register(SO). Call after the measurement is completed. If the return value is FSP_ERR_CTSU_INCOMPLETE_TUNING, tuning is not complete. Execute the measurement and this function call routine until the return value becomes FSP_SUCCESS. It is recommended to run this routine after R_CTSU_Open(). It can be recalled and tuned again. When the automatic judgement is enabled, after the offset tuning is completed,the baseline initialization bit flag is set. Implements ctsu_api_t::offsetTuning. ">R_CTSU_OffsetTuning()</a> was added in FSP 3.8.0. This API can also be used for initial offset adjustment, and offset adjustment can be performed again at any time. See example code of <a class="el" href="group___c_t_s_u.html#ga04263b8b45802780c9e072e19414ba7e" title="This function tunes the offset register(SO). Call after the measurement is completed. If the return value is FSP_ERR_CTSU_INCOMPLETE_TUNING, tuning is not complete. Execute the measurement and this function call routine until the return value becomes FSP_SUCCESS. It is recommended to run this routine after R_CTSU_Open(). It can be recalled and tuned again. When the automatic judgement is enabled, after the offset tuning is completed,the baseline initialization bit flag is set. Implements ctsu_api_t::offsetTuning. ">R_CTSU_OffsetTuning()</a> for details.<br />
</p>
<table class="doxtable">
<tr>
<th>Mode</th><th>CTSU1 target value</th><th>CTSU2 target value  </th></tr>
<tr>
<td>Self-capacitance</td><td>15360 (37.5%)</td><td>11520 (37.5%) </td></tr>
<tr>
<td>Self-capacitance using active shield</td><td>-</td><td>4608 (15%) </td></tr>
<tr>
<td>Mutual-capacitance</td><td>10240 (25%)</td><td>7680 (25%) </td></tr>
</table>
<p>The percentage is based on 100% being the maximum input current applied to the CCO.<br />
 CTSU1: 100% is the measured value 40960 when the measurement time is 526us(base time).<br />
 CTSU2: 100% is the measured value 30720 when the measurement time is 256us(base time).<br />
 When the measurement time is changed, the target value is adjusted by the ratio with the base time.<br />
</p>
<p>Example of target value in combination of CTSUSNUM and CTSUSDPA.<br />
 CTSU1 (CTSU clock = 32MHz, Self-capacitance mode)</p>
<table class="doxtable">
<tr>
<th>Target value</th><th>CTSUSNUM</th><th>CTSUSDPA</th><th>Measurement time  </th></tr>
<tr>
<td>15360</td><td>0x3</td><td>0x7</td><td>526usec </td></tr>
<tr>
<td>30720</td><td>0x7</td><td>0x7</td><td>1052usec </td></tr>
<tr>
<td>30720</td><td>0x3</td><td>0xF</td><td>1052usec </td></tr>
<tr>
<td>7680</td><td>0x1</td><td>0x7</td><td>263usec </td></tr>
<tr>
<td>7680</td><td>0x3</td><td>0x3</td><td>263usec </td></tr>
</table>
<p>The measurement time changes depending on the combination of CTSUSNUM and CTSUSDPA.<br />
 When changing CTSUPRRATIO and CTSUPRMODE from the recommended values, follow the Hardware Manual for the measurement time.</p>
<p>CTSU2 (Self-capacitance mode)</p>
<table class="doxtable">
<tr>
<th>Target value</th><th>Target value (multi frequency)</th><th>CTSUSNUM</th><th>Measurement time  </th></tr>
<tr>
<td>5760</td><td>11520 (128us + 128us)</td><td>0x7</td><td>128usec </td></tr>
<tr>
<td>11520</td><td>23040 (256us + 256us) </td><td>0xF</td><td>256usec </td></tr>
<tr>
<td>2880</td><td>5460 (64us + 64us)</td><td>0x3</td><td>64usec </td></tr>
</table>
<p>The measurement time changes depending on CTSUSNUM. If STCLK cannot be set to 0.5MHz, it will not support the table above. Regarding STCLK, refer to the hardware manual.<br />
</p>
<h3>Random Pulse Frequency Measurement (CTSU1)</h3>
<p>The CTSU1 peripheral measures at one drive frequency.<br />
 The drive frequency determines the amperage to the electrode and generally uses the value tuned with QE for Capacitive Touch.<br />
 The drive frequency is calculated as below.<br />
 It is determined by PCLK frequency input to CTSU, CTSU Count Source Select bit(CTSUCLK), and CTSU Sensor Drive pulse Division Control bit(CTSUSDPA). For example, If it is set PCLK =32MHz, CTSUCLK = PLCK/2, and CTSUSDPA = 1/16, then drive frequency is 0.5MHz. CTSUSDPA can change for each TS port.</p>
<div class="image">
<img src="r_ctsu_Drive_Frequency_Settings.png" alt="r_ctsu_Drive_Frequency_Settings.png"/>
<div class="caption">
Drive Frequency Settings</div></div>
<p> The actual drive pulse is phase-shifted and frequency-spread with respect to the clock based on the drive frequency as a measure against external environmental noise. This module is fixed at initialization and sets the following.<br />
 CTSUSOFF = 0,CTSUSSMOD = 0,CTSUSSCNT = 3</p>
<h3>Multi-frequency Measurements (CTSU2)</h3>
<p>The CTSU2 peripheral can measure in one of four drive frequencies to avoid synchronous noise.<br />
 With the default settings, the module takes measurements at three different frequencies. This data are called raw data. And calculate CCO correction. This data are called CCO correction data.<br />
 In VMM, After standardizing the results obtained at the three frequencies in accordance with the first frequency reference value, the measured value is determined based on majority in a process referred to as “normalization.” <br />
 The three values standardized to the first frequency reference value are called frequency correction data.<br />
 You can get the three correction data with <a class="el" href="group___c_t_s_u.html#ga32a5f61231501fb64c85fa52791b0e79" title="This function gets the sensor specific data values as scanned by the CTSU. Call this function after c...">R_CTSU_SpecificDataGet()</a>.<br />
 In VMM, three raw data, CCO correction data, and frequency correction data can be obtained with <a class="el" href="group___c_t_s_u.html#ga32a5f61231501fb64c85fa52791b0e79" title="This function gets the sensor specific data values as scanned by the CTSU. Call this function after c...">R_CTSU_SpecificDataGet()</a>.<br />
 In JMM, three raw data and three CCO correction data can be obtained with <a class="el" href="group___c_t_s_u.html#ga32a5f61231501fb64c85fa52791b0e79" title="This function gets the sensor specific data values as scanned by the CTSU. Call this function after c...">R_CTSU_SpecificDataGet()</a>.</p>
<div class="image">
<img src="r_ctsu_Multi-Frequency_Mesurements.png" alt="r_ctsu_Multi-Frequency_Mesurements.png"/>
<div class="caption">
Multi-frequency Measurements</div></div>
<p> Drive frequency is determined based on the config settings. The module sets registers according to the config settings, and sets the three drive frequencies.<br />
 Drive frequency is calculated in the following equation:<br />
 (PCLKB frequency / CLK / STCLK) x SUMULTIn / 2 / SDPA : n = 0, 1, 2<br />
 The figure below shows the settings for generating a 2MHz drive frequency when the PCLKB frequency is 32 MHz. SDPA can be set for each touch interface configuration.</p>
<div class="image">
<img src="r_ctsu_Drive_Frequency_Settings_ctsu2.png" alt="r_ctsu_Drive_Frequency_Settings_ctsu2.png"/>
<div class="caption">
Drive Frequency Settings</div></div>
 <h3>Shield Function(CTSU2)</h3>
<p>The CTSU2 peripheral has a built-in function that outputs a shield signal in phase with the drive pulse from the shield terminal and the non-measurement terminal in order to shield against external influences while suppressing any increase in parasitic capacitance. This function can only be used during self-capacitance measurements.<br />
 This module allows the user to set a shield for each touch interface configuration. <br />
 For example, for the electrode configuration shown in , the members of <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a> should be set as follows. Other members have been omitted for the example. <br />
 .txvsel = CTSU_TXVSEL_INTERNAL_POWER,<br />
 .txvsel2 = CTSU_TXVSEL_MODE,<br />
 .md = CTSU_MODE_SELF_MULTI_SCAN,<br />
 .posel = CTSU_POSEL_SAME_PULSE,<br />
 .ctsuchac0 = 0x0F,<br />
 .ctsuchtrc0 = 0x08,</p>
<div class="image">
<img src="r_ctsu_Shield_Electrode_Structure.png" alt="r_ctsu_Shield_Electrode_Structure.png"/>
<div class="caption">
Example of Shield Electrode Structure</div></div>
 <h3>Measurement Error Message</h3>
<p>When the CTSU2 peripheral detects an abnormal measurement, it sets the status register bit to 1.<br />
 In the measurement complete interrupt process, the module reads ICOMP1, ICOMP0, and SENSOVF of the status register and notifies the results in the callback function. The status register is reset after the contents are read. For more details on abnormal measurements, refer to “member event” in the <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__callback__args__t">ctsu_callback_args_t</a> callback function argument.</p>
<h3>Moving Average</h3>
<p>This function calculates the moving average of the measured results. <br />
 Set the number of times the moving average should be calculated in the config settings.</p>
<h3>Diagnosis Function</h3>
<p>The CTSU peripheral has a built-in function that diagnoses its own inner circuit. This diagnosis function provides the API for diagnosing the inner circuit.<br />
 The diagnostic requirements are different for CTSU1 and CTSU2 providing 5 types of diagnosis for CTSU1 and 9 types for CTSU2.<br />
 The diagnosis function is executed by calling the API function. This is executed independently from the other measurements and does not affect them. <br />
 To enable the diagnosis function, set CTSU_CFG_DIAG_SUPPORT_ENABLE to 1.<br />
 For CTSU1, a 27pF condenser should be connected externally.<br />
 For CTSU2, Diagnosis function uses the ADC module.<br />
 If an error occurs in the ADC module used for Diagnosis mode, return FSP_ERR_ABORTED as the return value of <a class="el" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe" title="This function gets the sensor values as scanned by the CTSU. If initial offset tuning is enabled...">R_CTSU_DataGet()</a>.<br />
 If an ADC error is returned, exit the function so as not to measure or close the ADC.<br />
 See ADC (r_adc) for ADC module errors. <br />
 Please pay particular attention to the following three points.<br />
</p><ol type="1">
<li>Be sure to measure the ADC module when using the Diagnosis mode function of the CTSU module. Therefore, in order for the user to use it with Dignosis, please close the user's ADC. After closing, please use the Diagnosis mode function of the CTSU module.</li>
<li>When creating an application with RTOS, please be careful about the scheduling of the CTSU module's Diagnosis mode function task and the user's ADC task.</li>
<li>If FSP_ERR_ABORTED occurs, please call the user's ADC again when using the user's ADC.</li>
</ol>
<h3>MEC Function (CTSU2SLa)</h3>
<p>The CTSU2SLa peripheral has MEC (Multiple Electrode Connection) function that connects multiple electrodes and measures them as a single electrode. This feature is only available in self capacitance mode.<br />
 This is an example when using three electrodes. In normal times, normal measurement is performed, and 3 channels are measured to get each measured value. In power saving, MEC measurement is performed, and one channel is measured by combining three channels to acquire one measured value.<br />
 The figure below shows a compare of time of normal measurement and MEC measurement. Since multi channels are measured at the same time, the measurement time is shortened.<br />
</p>
<div class="image">
<img src="r_ctsu_Compare_Normal_measure_vs_MEC_measure.png" alt="r_ctsu_Compare_Normal_measure_vs_MEC_measure.png"/>
<div class="caption">
Comparison of time between normal measurement and MEC measurement</div></div>
<p> To enable the code for the MEC feature, set CTSU_CFG_MULTIPLE_ELECTRODE_CONNECTION_ENABLE to 1.<br />
 When using MEC, create a touch interface configuration different from the normal touch interface configuration for the same TS. <br />
 The following settings are required for the touch interface configuration for MEC measurement.<br />
 To enable MEC for touch interface configurations by setting tsod in <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a> to 1.<br />
 Set mec_ts of <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a> to one of the TS numbers to be measured.<br />
 If you want to use the shield function at the same time, set the TS number of the shield terminal in mec_shield_ts of <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a>.<br />
 In this case, only one TS can be used as a shield terminal. Set num_rx of <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a> to 1. <br />
 For example, in the case of the electrode configuration shown below, set the members of <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a> as shown below. Other members are omitted here. <br />
 .tsod = 1,<br />
 .mec_ts = 0,<br />
 .mec_shield_ts = 3,<br />
 .num_rx = 1,<br />
</p>
<div class="image">
<img src="r_ctsu_MEC_Shield_electrode.png" alt="r_ctsu_MEC_Shield_electrode.png"/>
<div class="caption">
Example of MEC and shield electrode configuration</div></div>
 <h3>Automatic CCO Correction (CTSU2SLa)</h3>
<p>CTSU2SL peripheral has an automatic correction that correct the sensor CCO by hardware. Refer to Sensor CCO Correction function for more information on sensor CCO correction.<br />
 CTSU2SL peripheral processes the correction calculation. CCO correction data can be calculated without using the correction calculation processing of the software.<br />
 The processing time of the main processor is not consumed.<br />
</p>
<p>Set CTSU_CFG_AUTO_CORRECTION_ENABLE to 1 to enable this feature.</p>
<h3>Automatic Frequency Correction (CTSU2SLa)</h3>
<p>CTSU2SLa peripheral has an automatic frequency correction that correct the calculation by hardware.<br />
 CTSU2SLa peripheral processes the correction calculation. Frequency correction data can be calculated without using the correction calculation processing of the software. <br />
 The processing time of the main processor is not consumed.<br />
</p>
<p>Set CTSU_CFG_AUTO_MULTI_CLOCK_CORRECTION_ENABLE to 1 to enable this feature.</p>
<h3>Automatic Judgement (CTSU2SLa)</h3>
<p>CTSU2SLa peripheral has an automatic judgement that judges the touch of a button by hardware.<br />
 CTSU2SLa peripheral processes the touch judgement of the button. The processing time of the main processor is not consumed.<br />
 Measurements and Judgements can be initiated either by software triggers or external events triggered by the Event Link Controller (ELC). <br />
 Please use the API function <a class="el" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525" title="This function should be called each time a periodic timer expires. If initial offset tuning is enable...">R_CTSU_ScanStart()</a>.<br />
 This module processes INTCTSUWR and INTCTSURD generated during measurement. Since DTC is used for these processes, DTC is required.<br />
</p>
<p>A callback function notifies the application when the processing of INTCTSUFN is completed. Get the judgement result before the next measurement. <br />
 Please use the API function R_CTSU_AutoJudgeDataGet().<br />
 Select either JMM or VMM as the majority voting method. Below is an example of the <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a> member settings for JMM. For VMM, set “jc” to 0 and “majirimd” to 1.<br />
 .tlot = 2, // Non-touch judgement continuous count : 3 times<br />
 .thot = 2, // Touch judgement continuous count : 3 times<br />
 .jc = 1, // Judgement by two frequency<br />
 .ajmmat = 2, // Moving average : 22times<br />
 .ajbmat = 7, // Baseline average count : 27+1times<br />
 .majirimd = 0, // JMM<br />
 .mtucfen = 1, // Mutual-capacitance<br />
 .ajfen = 1, // Enable automatic judgement<br />
</p>
<p>Set “CTSU_CFG_AUTO_JUDGE_ENABLE = 1” to enable the automatic judgement. In this case, set “CTSU_CFG_AUTO_CORRECTION_ENABLE = 1” to enable the automatic CCO correction function as well. <br />
 For VMM, set “CTSU_CFG_AUTO_MULTI_CLOCK_CORRECTION_ENABLE = 1” to enable the automatic frequency correction function as well.<br />
</p>
<p>The following (a) to (e) describe the automatic judgement and its setting. In the case of JMM, (a) ~ (e) settings are set for each multi-frequency measurement.</p><ul>
<li>(a) Measurement mode <br />
 Select self-capacitance or mutual-capacitance with “mtucfen” of <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__auto__button__cfg__t">ctsu_auto_button_cfg_t</a>. Set the self-capacitance to 0. Set the mutual-capacitance to 1.<br />
</li>
<li>(b) Baseline<br />
 Set the baseline from the measurement result in the non-touch state. After completing the initial offset adjustment with R_CTSU_OffsetTuning (), the baseline is initially set (set BLINI bit) when R_CTSU_ScanStart () is called for the first time. <br />
 After that, when R_CTSU_AutoJudgementDataGet () is called, the baseline initialization is canceled (clear BLINI bit) and the baseline update process is started.<br />
 The baseline is updated every set number of measurements to follow changes in the surrounding environment.<br />
 If “non-touch” state continues for the set number of measurements, the baseline is updated to the average value. When judgement result is “touch”, the number of counts is cleared.<br />
 Set the number of measurements (baseline update interval) with “ajbmat” of <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a>. Common to all buttons in the touch interface configuration. <br />
 Adjusts the ability to follow changes in the surrounding environment.<br />
</li>
<li>(c) Threshold<br />
 judgement is made using a threshold with an arbitrary offset from the baseline. The threshold is set by adding hysteresis.<br />
 Chattering is prevented by giving hysteresis to the transition from “touch” to “non-touch”. Increasing the hysteresis value is more effective in preventing chattering, but be aware that it will be more difficult to transition from “touch” to “non-touch”.<br />
 Set the threshold and hysteresis for each button with threshold and hysteresis of <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__auto__button__cfg__t">ctsu_auto_button_cfg_t</a>.<br />
 This module calculates the upper threshold and the lower threshold from these and sets them in the CTSUAJTHR register.<br />
 The figure below shows the self-capacitance judgement. Since the electrode capacitance of the self-capacitance button increases when touched, it is judged “touch” when the upper threshold is exceeded.<br />
</li>
</ul>
<div class="image">
<img src="r_ctsu_self_capacitance_judgement.png" alt="r_ctsu_self_capacitance_judgement.png"/>
<div class="caption">
Self-capacitance judgement</div></div>
<p> The figure below shows the mutual-capacitance judgement. Since the mutual capacitance button reduces the capacitance between electrodes when touched, it is judged as "touch" when the lower threshold is exceeded.</p>
<div class="image">
<img src="r_ctsu_mutual_capacitance_judgement.png" alt="r_ctsu_mutual_capacitance_judgement.png"/>
<div class="caption">
Mutual-capacitance judgement</div></div>
<ul>
<li>(d) The number of consecutive “non-touch” and “touch” detections<br />
 This is a filter function to judge "touch" or "non-touch" when "touch" or "non-touch" state continues for a certain number of times.<br />
 Set the number of times with “tlot” and “thot” of <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a>. Common to all buttons in the touch interface configuration.<br />
 Increasing the number of consecutive times will be more effective against chattering, but be aware that the reaction speed will decrease.<br />
</li>
<li>(e) Moving average<br />
 With the automatic judgement function, Set the number of moving averages with “ajmmat” of ctsu_cfg_t.Common to all buttons in the touch interface configuration.<br />
 The figure below shows the button judgement operation described above.</li>
</ul>
<div class="image">
<img src="r_ctsu_Button_Touch_Determination.png" alt="r_ctsu_Button_Touch_Determination.png"/>
<div class="caption">
Button judgement</div></div>
 <h2>Measurement Mode</h2>
<p>This module supports all three modes offered by the CTSU2 peripheral: self-capacitance, mutual-capacitance, and current measurement modes. The temperature correction mode is also offered as a mode for updating the correction coefficient.</p>
<h3>Self-capacitance Mode</h3>
<p>The self-capacitance mode is used to measure the capacitance of each terminal (TS).<br />
 The CTSU2 peripheral measures the terminals in ascending order according to the TS numbers, then stores the data. For example, even if you want to use TS5, TS8, TS2, TS3 and TS6 in your application in that order, they will still be measured and stored in the order of TS2, TS3, TS5, TS6, and TS8. Therefore, you will need to reference buffer indexes [2], [4], [0], [1], and [3].<br />
 VMM returns one measurement result for each element.<br />
 JMM returns three measurement results for each element.<br />
</p>
<p>[CTSU1]<br />
 In default settings, the measurement period for each TS is wait-time plus approximately 526us.</p>
<div class="image">
<img src="r_ctsu_Self_capacitance_Measurement_Period.png" alt="r_ctsu_Self_capacitance_Measurement_Period.png"/>
<div class="caption">
Self-capacitance Measurement Period (CTSU1)</div></div>
<p> [CTSU2]<br />
 In default settings, the measurement period for each TS is approximately 576us.<br />
</p>
<div class="image">
<img src="r_ctsu_Self_capacitance_Measurement_Period_ctsu2.png" alt="r_ctsu_Self_capacitance_Measurement_Period_ctsu2.png"/>
<div class="caption">
Self-capacitance Measurement Period (CTSU2)</div></div>
 <h3>Mutual-Capacitance Mode</h3>
<p>The mutual-capacitance mode is used to measure the capacitance generated between the receive TS (Rx) and transmit TS (Tx), and therefore requires at least two terminals.<br />
 The CTSU2 peripheral measures all specified combinations of Rx and Tx. For example, when Rx is TS1 and TS3, and Tx is TS2, TS7 and TS4, the combinations are measured in the following order and the data is stored.<br />
 TS3-TS2, TS3-TS4, TS3-TS7, TS10-TS2, TS10-TS4, TS10-TS7<br />
 To measure the mutual-capacitance generated between electrodes, the CTSU2 peripheral performs the measurement process on the same electrode twice. <br />
 The mutual-capacitance is obtained by inverting the phase relationship of the pulse output and switched capacitor in the primary and secondary measurements, and calculating the difference between the two measurements. This module does not calculate the difference, but outputs both primary and secondary measured result.<br />
 VMM returns two measurement results(one primary and one secondary) for each element.<br />
 JMM returns six measurement results(three primary and three secondary) for each element.<br />
 [CTSU1]<br />
 In default settings, the measurement period for each TS is twice of wait-time plus approximately 526us.<br />
 [CTSU2]<br />
 In default settings, the measurement period for each TS is approximately 1152us.<br />
</p>
<div class="image">
<img src="r_ctsu_Mutual_capacitance_Measurement_Period.png" alt="r_ctsu_Mutual_capacitance_Measurement_Period.png"/>
<div class="caption">
Mutual-capacitance Measurement Period</div></div>
 <h3>Mutual-capacitance parallel scan mode(CTSU2)</h3>
<p>This mode provides fast measurement time by parallel scanning the RX lines with a CFC circuit. Operation is otherwise identical to normal CTSU mutual scanning.<br />
</p><ul>
<li>Scan Order<ul>
<li>The hardware scans all RX pins simultaneously for each TX pin.</li>
<li>For example, if sensors TS10, TS11, and TS03 are specified as RX sensors, and sensors TS02, TS07, and TS04 are specified as TX sensors, the hardware will scan them in the following sensor-pair order:<br />
 TS02-(TS03, TS10, TS11), TS04-(TS03, TS10, TS11), TS07-(TS03, TS10, TS11)</li>
</ul>
</li>
<li>Element<ul>
<li>An element refers to the index of a sensor-pair within the scan order. Using the previous example, TS07-TS10 is element 7.</li>
</ul>
</li>
<li>Scan Time<ul>
<li>Because the RX lines are scanned in parallel, CFC mutual-capacitance scan is the same amount of times faster than a basic mutual matrix scan as the number of RX lines. In other words, on a matrix with N receive lines, CFC mutual scanning is N times faster than basic mutual scanning. Set CTSU_MODE_MUTUAL_CFC_SCAN to "md" of <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a>.<br />
 Also, add the number of matrix used for this measurement to CTSU_CFG_NUM_MUTUAL_ELEMENTS. In addition, set the number of CTSU_CFG_NUM_CFC and CTSU_CFG_NUM_CFC_TX.<br />
 For details, refer to the configuration and sample application output by QE for Capacitive Touch.</li>
</ul>
</li>
</ul>
<h3>Current Measurement Mode(CTSU2)</h3>
<p>The current measurement mode is used to measure the minute current input to the TS terminal. The order of measurement and data storage is the same as that of the self-capacitance mode. As this does not involve the switched capacitor operation, the measurement is only performed once. The measurement period for one TS under default settings is approximately 256us. The current measurement mode requires a longer stable wait time than the other modes, so the SST is set to 63.</p>
<div class="image">
<img src="r_ctsu_Current_Measurement_Period.png" alt="r_ctsu_Current_Measurement_Period.png"/>
<div class="caption">
Current Measurement Period</div></div>
 <h3>Temperature Correction Mode(CTSU2)</h3>
<p>The temperature correction mode is used to periodically update the correction coefficient using an external resistor connected to a TS terminal. This involves three processes as described below. Also refer to the timing chart in Figure of Temperature Correction Measurement Timing Chart.<br />
</p><ol type="1">
<li>Measure the correction circuit. One set comprises twelve measurements. <br />
</li>
<li>Measure the current when TSCAP voltage is applied to the external resistor to create a correction coefficient based on an external resistor that does not depend on temperature. Execute the next measurement after the previous measurement set is completed (as described in step 1).</li>
<li>Flow offset current to the external resistor and measure the voltage with the ADC. This will adjust the RTRIM register and handle the temperature drift of the internal reference resistor. In the config settings, set the number of times step 2 should be executed before carrying out this measurement.</li>
</ol>
<div class="image">
<img src="r_ctsu_Temperature_Correction_Measurement_Period.png" alt="r_ctsu_Temperature_Correction_Measurement_Period.png"/>
<div class="caption">
Temperature Correction Measurement Timing Chart</div></div>
<p> Temperature correction uses the ADC module.<br />
 If an error occurs in the ADC module used for temperature correction, return FSP_ERR_ABORTED as the return value of <a class="el" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe" title="This function gets the sensor values as scanned by the CTSU. If initial offset tuning is enabled...">R_CTSU_DataGet()</a>.<br />
 If an ADC error is returned, exit the function so as not to measure or close the ADC.<br />
 See ADC (r_adc) for ADC module errors. <br />
 Please pay articular attention to the following three points.<br />
</p><ol type="1">
<li>When using the temperature correction of the CTSU module, be sure to measure the ADC module. Therefore, please close the user's ADC for use in temperature correction. After closing, please use temperature correction of CTSU module.</li>
<li>When creating an RTOS, please be careful about the scheduling of the CTSU module's temperature correction task and the user's ADC task when creating an application.</li>
<li>If FSP_ERR_ABORTED occurs, please call the user's ADC again when using the user's ADC.</li>
</ol>
<h3>Diagnosis Mode</h3>
<p>The diagnosis mode is a mode in which various internal measurement values are scanned by using this diagnosis function <a class="el" href="group___c_t_s_u.html#ga45103e8db4a16dfabf3a516ab2da9f26" title="Diagnosis the CTSU peripheral. Implements ctsu_api_t::diagnosis. ">R_CTSU_Diagnosis()</a>.</p>
<h2>Measurement Timing</h2>
<p>Measurements are initiated by a software trigger or an external event which is triggered by the Event Link Controller (ELC).<br />
 The most common method is using a timer to carry out periodic measurements. Make sure to set the timer interval to allow the measurement and internal value update processes to complete before the next measurement period. The measurement period differs according to touch interface configuration and measurement mode.<br />
 The execution timing of software triggers and external triggers differ slightly. <br />
 Since a software trigger sets the start flag after setting the touch interface configuration with <a class="el" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525" title="This function should be called each time a periodic timer expires. If initial offset tuning is enable...">R_CTSU_ScanStart()</a>, there is a slight delay after the timer event occurrence. However, as the delay is much smaller than the measurement period, a software trigger is recommended for most instances as it is easy to set. <br />
 An external trigger is recommended for applications in which this slight delay is not acceptable or that require low-power consumption operations. When using an external trigger with multiple touch interface configurations, use <a class="el" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525" title="This function should be called each time a periodic timer expires. If initial offset tuning is enable...">R_CTSU_ScanStart()</a> to set another touch interface configuration after one measurement is completed.</p>
<h2>TrustZone Support</h2>
<p>In r_ctsu and rm_touch module, Non-Secure Callable Guard Functions are only generated from QE for Capacitive Touch. QE can be used for tuning in secure or flat project, but not in non-secure project. If you want to use in non-secure project, copy the output file from secure or flat project. Refer to QE Help for more information.</p>
<h2>Data flow</h2>
<p>The flow of storing data in RAM is as follows.<br />
</p>
<p>(CTSU1)<br />
</p><ol type="1">
<li>Read registers and stored in RAM as raw data.</li>
<li>ICO correction calculation of raw data and stored in RAM as correction data.</li>
<li>The correction data is calculated by moving average and stored in RAM as measurement results.</li>
</ol>
<p>(CTSU2 VMM)<br />
</p><ol type="1">
<li>Reads a register and stores raw data measured at three different frequencies in RAM.</li>
<li>Calculate CCO correction from three raw data and stored three CCO correction values in RAM.</li>
<li>Calculate three frequency correction values from three CCO correction values.</li>
<li>Three frequency correction data are calculated by majority decision and moving average, and stored in RAM as measurement results.</li>
</ol>
<p>(CTSU2 JMM)<br />
</p><ol type="1">
<li>Reads a register and stores raw data measured at three different frequencies in RAM.</li>
<li>Calculate CCO correction from three raw data and stored three CCO correction values in RAM.</li>
<li>Three CCO correction data is calculated by moving average and stored three measurement results in RAM.</li>
</ol>
<h2>Add user's filter</h2>
<p>There are two ways to add the user's filter.</p><ol type="1">
<li>Instead of filter calculation of <a class="el" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe" title="This function gets the sensor values as scanned by the CTSU. If initial offset tuning is enabled...">R_CTSU_DataGet()</a>, perform user filter calculation and use <a class="el" href="group___c_t_s_u.html#gac51fca87e02d589bcdeb894b99f7a08e" title="This function inserts the value of the second argument as the measurement result value. Call this function after calling the R_CTSU_DataInsert() function. Implements ctsu_api_t::dataInsert. ">R_CTSU_DataInsert()</a> to input user filter calculation result.<br />
 <a class="el" href="group___c_t_s_u.html#gac51fca87e02d589bcdeb894b99f7a08e" title="This function inserts the value of the second argument as the measurement result value. Call this function after calling the R_CTSU_DataInsert() function. Implements ctsu_api_t::dataInsert. ">R_CTSU_DataInsert()</a><br />
 In VMM, the second argument p_insert_data stores one data for each element.<br />
 In JMM, the second argument p_insert_data stores three data for each element.<br />
</li>
<li>Using the correction data obtained by <a class="el" href="group___c_t_s_u.html#ga32a5f61231501fb64c85fa52791b0e79" title="This function gets the sensor specific data values as scanned by the CTSU. Call this function after c...">R_CTSU_SpecificDataGet()</a>, instead of majority decision calculation and filter calculation of <a class="el" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe" title="This function gets the sensor values as scanned by the CTSU. If initial offset tuning is enabled...">R_CTSU_DataGet()</a>, perform user majority decision calculation &amp; filter calculation and use <a class="el" href="group___c_t_s_u.html#gac51fca87e02d589bcdeb894b99f7a08e" title="This function inserts the value of the second argument as the measurement result value. Call this function after calling the R_CTSU_DataInsert() function. Implements ctsu_api_t::dataInsert. ">R_CTSU_DataInsert()</a> to input user majority decision calculation &amp; filter calculation result.<br />
</li>
</ol>
<p>Please check example.<br />
 <a href="#Users-filter">User's filter additional Example</a></p>
<h2>Limitations</h2>
<p>Developers should be aware of the following limitations when using CTSU with FSP : <br />
</p><ul>
<li>CTSU doesn't support Diagnosis for CTSU2SLa.</li>
</ul>
<h1><a class="anchor" id="r-ctsu-examples"></a>
Examples</h1>
<h2>Basic Example</h2>
<p>This is a basic example of minimal use of the CTSU in an application.</p>
<div class="fragment"><div class="line"><span class="keyword">volatile</span> <span class="keywordtype">bool</span> g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> ctsu_callback (<a class="code" href="group___c_t_s_u___a_p_i.html#structctsu__callback__args__t">ctsu_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___c_t_s_u___a_p_i.html#ggaf6b0abb6cb3e6996d8435268d5e7c9cfa110041f0d6a2dcfeac8b0d2ba3d2318b">CTSU_EVENT_SCAN_COMPLETE</a> == p_args-&gt;<a class="code" href="group___c_t_s_u___a_p_i.html#a40ee54221ab1d85ee5d2ce7a5cdd289a">event</a>)</div><div class="line">    {</div><div class="line">        g_scan_flag = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> ctsu_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line">    uint16_t  data[CTSU_CFG_NUM_SELF_ELEMENTS];</div><div class="line"></div><div class="line">    err = <a class="code" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a>(&amp;g_ctsu_ctrl, &amp;g_ctsu_cfg);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a>(&amp;g_ctsu_ctrl, data);</div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Application specific data processing. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Multi-configuration Example</h2>
<p>This is a optional example of using both Self-capacitance and Mutual-capacitance configurations in the same project.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ctsu_optional_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line">    uint16_t  data[CTSU_CFG_NUM_SELF_ELEMENTS + (CTSU_CFG_NUM_MUTUAL_ELEMENTS * 2)];</div><div class="line"></div><div class="line">    err = <a class="code" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a>(&amp;g_ctsu_ctrl, &amp;g_ctsu_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">    err = <a class="code" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a>(&amp;g_ctsu_ctrl_mutual, &amp;g_ctsu_cfg_mutual);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl_mutual);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a>(&amp;g_ctsu_ctrl, data);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Application specific data processing. */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a>(&amp;g_ctsu_ctrl_mutual, data);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Application specific data processing. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Offset Adjustment Example</h2>
<p>This is an example of offset adjustment using <a class="el" href="group___c_t_s_u.html#ga04263b8b45802780c9e072e19414ba7e" title="This function tunes the offset register(SO). Call after the measurement is completed. If the return value is FSP_ERR_CTSU_INCOMPLETE_TUNING, tuning is not complete. Execute the measurement and this function call routine until the return value becomes FSP_SUCCESS. It is recommended to run this routine after R_CTSU_Open(). It can be recalled and tuned again. When the automatic judgement is enabled, after the offset tuning is completed,the baseline initialization bit flag is set. Implements ctsu_api_t::offsetTuning. ">R_CTSU_OffsetTuning()</a>.<br />
 After completing R_CTSU_Open (), perform initial offset adjustment.<br />
 Offset adjustment is performed again when the parasitic capacitance changes significantly due to changes in the surrounding environment and the count value becomes an abnormal value.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ctsu_offsettuning_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line">    uint16_t  data[CTSU_CFG_NUM_SELF_ELEMENTS];</div><div class="line"></div><div class="line">    err = <a class="code" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a>(&amp;g_ctsu_ctrl, &amp;g_ctsu_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Initial offset tuning */</span></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga04263b8b45802780c9e072e19414ba7e">R_CTSU_OffsetTuning</a>(&amp;g_ctsu_ctrl);</div><div class="line">    } <span class="keywordflow">while</span> (FSP_SUCCESS != err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a>(&amp;g_ctsu_ctrl, data);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Re-offset tuning is performed when the parasitic capacitance changes significantly due   */</span></div><div class="line">            <span class="comment">/* to changes in the surrounding environment and the count value becomes an abnormal value. */</span></div><div class="line">            <span class="comment">/*                                                                                          */</span></div><div class="line">            <span class="comment">/* if (abnormal value detection conditions)                                                 */</span></div><div class="line">            <span class="comment">/* {                                                                                        */</span></div><div class="line">            <span class="comment">/* Re-offset tuning */</span></div><div class="line">            <span class="keywordflow">do</span></div><div class="line">            {</div><div class="line">                <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">                <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">                {</div><div class="line">                    <span class="comment">/* Wait for scan end callback */</span></div><div class="line">                }</div><div class="line"></div><div class="line">                g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                err = <a class="code" href="group___c_t_s_u.html#ga04263b8b45802780c9e072e19414ba7e">R_CTSU_OffsetTuning</a>(&amp;g_ctsu_ctrl);</div><div class="line">            } <span class="keywordflow">while</span> (FSP_SUCCESS != err);</div><div class="line"></div><div class="line">            <span class="comment">/* }                                                                                        */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Diagnosis function Example</h2>
<p>This is a Diagnosis function example of using the configuration in the basic example.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ctsu_diag_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line">    uint16_t  data[CTSU_CFG_NUM_SELF_ELEMENTS];</div><div class="line">    uint16_t  dummy;</div><div class="line"></div><div class="line">    <a class="code" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a>(&amp;g_ctsu_ctrl, &amp;g_ctsu_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">    <a class="code" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a>(&amp;g_ctsu_ctrl_diagnosis, &amp;g_ctsu_cfg_diagnosis);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a>(&amp;g_ctsu_ctrl, data);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">        <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl_diagnosis);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a>(&amp;g_ctsu_ctrl_diagnosis, &amp;dummy);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">        {</div><div class="line">            err = <a class="code" href="group___c_t_s_u.html#ga45103e8db4a16dfabf3a516ab2da9f26">R_CTSU_Diagnosis</a>(&amp;g_ctsu_ctrl_diagnosis);</div><div class="line">            assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">            {</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p> <a class="anchor" id="Users-filter"></a></p>
<h2>User's filter additional Example</h2>
<p>This is a user's filter additiional example of using the configuration in the basic example.<br />
 To perform user's filter calculation, change the num_moving_average of the element in the target <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a> to 1. <br />
</p>
<p>Perform user filter calculation and use <a class="el" href="group___c_t_s_u.html#gac51fca87e02d589bcdeb894b99f7a08e" title="This function inserts the value of the second argument as the measurement result value. Call this function after calling the R_CTSU_DataInsert() function. Implements ctsu_api_t::dataInsert. ">R_CTSU_DataInsert()</a> to input user filter calculation result. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> ctsu_user_filter_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line">    uint16_t  data[CTSU_CFG_NUM_SELF_ELEMENTS];</div><div class="line">    uint16_t  filter_data[CTSU_CFG_NUM_SELF_ELEMENTS];</div><div class="line"></div><div class="line">    <span class="comment">/* If you want to make a touch judgment, call RM_TOUCH_Open()instead of the following. */</span></div><div class="line">    err = <a class="code" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a>(&amp;g_ctsu_ctrl, &amp;g_ctsu_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* If you want to make a touch judgment, call RM_TOUCH_ScanStart()instead of the following. */</span></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a>(&amp;g_ctsu_ctrl, data);</div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">        {</div><div class="line">            <span class="comment">/* User original function. */</span></div><div class="line">            ctsu_user_filter(data, filter_data);</div><div class="line"></div><div class="line">            err = <a class="code" href="group___c_t_s_u.html#gac51fca87e02d589bcdeb894b99f7a08e">R_CTSU_DataInsert</a>(&amp;g_ctsu_ctrl, filter_data);</div><div class="line"></div><div class="line">            assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">            <span class="comment">/* Call RM_TOUCH_DataGet() to make a touch decision. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p> Using the correction data obtained by <a class="el" href="group___c_t_s_u.html#ga32a5f61231501fb64c85fa52791b0e79" title="This function gets the sensor specific data values as scanned by the CTSU. Call this function after c...">R_CTSU_SpecificDataGet()</a>. Perform user majority decision calculation &amp; filter calculation and use <a class="el" href="group___c_t_s_u.html#gac51fca87e02d589bcdeb894b99f7a08e" title="This function inserts the value of the second argument as the measurement result value. Call this function after calling the R_CTSU_DataInsert() function. Implements ctsu_api_t::dataInsert. ">R_CTSU_DataInsert()</a> to input user majority decision calculation &amp; filter calculation result. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> ctsu_user_majority_decition_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line">    uint16_t  data[CTSU_CFG_NUM_SELF_ELEMENTS];</div><div class="line">    uint16_t  corr_data[CTSU_CFG_NUM_SELF_ELEMENTS * CTSU_CFG_NUM_SUMULTI];</div><div class="line">    uint16_t  filter_data[CTSU_CFG_NUM_SELF_ELEMENTS];</div><div class="line"></div><div class="line">    <span class="comment">/* If you want to make a touch judgment, call RM_TOUCH_Open()instead of the following. */</span></div><div class="line">    err = <a class="code" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a>(&amp;g_ctsu_ctrl, &amp;g_ctsu_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* If you want to make a touch judgment, call RM_TOUCH_ScanStart()instead of the following. */</span></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a>(&amp;g_ctsu_ctrl, data);</div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">        {</div><div class="line">            err = <a class="code" href="group___c_t_s_u.html#ga32a5f61231501fb64c85fa52791b0e79">R_CTSU_SpecificDataGet</a>(&amp;g_ctsu_ctrl, corr_data, CTSU_SPECIFIC_CORRECTION_DATA);</div><div class="line"></div><div class="line">            assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">            <span class="comment">/* User original function */</span></div><div class="line">            ctsu_user_filter(corr_data, filter_data);</div><div class="line"></div><div class="line">            err = <a class="code" href="group___c_t_s_u.html#gac51fca87e02d589bcdeb894b99f7a08e">R_CTSU_DataInsert</a>(&amp;g_ctsu_ctrl, filter_data);</div><div class="line">            assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">            <span class="comment">/* Call RM_TOUCH_DataGet() to make a touch decision. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structctsu__ctsuwr__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#structctsu__ctsuwr__t">ctsu_ctsuwr_t</a></td></tr>
<tr class="separator:structctsu__ctsuwr__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structctsu__self__buf__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#structctsu__self__buf__t">ctsu_self_buf_t</a></td></tr>
<tr class="separator:structctsu__self__buf__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structctsu__mutual__buf__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#structctsu__mutual__buf__t">ctsu_mutual_buf_t</a></td></tr>
<tr class="separator:structctsu__mutual__buf__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structctsu__correction__info__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#structctsu__correction__info__t">ctsu_correction_info_t</a></td></tr>
<tr class="separator:structctsu__correction__info__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structctsu__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#structctsu__instance__ctrl__t">ctsu_instance_ctrl_t</a></td></tr>
<tr class="separator:structctsu__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga9be3b4466784415a4193f9584362c2ce"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ga9be3b4466784415a4193f9584362c2ce">ctsu_state_t</a> </td></tr>
<tr class="separator:ga9be3b4466784415a4193f9584362c2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3fb0beb148069bb590287ed34771117"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#gae3fb0beb148069bb590287ed34771117">ctsu_tuning_t</a> </td></tr>
<tr class="separator:gae3fb0beb148069bb590287ed34771117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7a98cce83446a25cc6d9fae6fa1296d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#gad7a98cce83446a25cc6d9fae6fa1296d">ctsu_correction_status_t</a> </td></tr>
<tr class="separator:gad7a98cce83446a25cc6d9fae6fa1296d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07d91c963664201accc65a9d45fb817a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ga07d91c963664201accc65a9d45fb817a">ctsu_range_t</a> </td></tr>
<tr class="separator:ga07d91c963664201accc65a9d45fb817a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structctsu__ctsuwr__t" id="structctsu__ctsuwr__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structctsu__ctsuwr__t">&#9670;&nbsp;</a></span>ctsu_ctsuwr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ctsu_ctsuwr_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>CTSUWR write register value </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ac0528bef59c8c84d71b8f14ec06e63ef"></a>uint16_t</td>
<td class="fieldname">
ctsussc</td>
<td class="fielddoc">
Copy from (ssdiv &lt;&lt; 8) by Open API. </td></tr>
<tr><td class="fieldtype">
<a id="aaf34d3ace08918bb6475ec3d1c552ef7"></a>uint16_t</td>
<td class="fieldname">
ctsuso0</td>
<td class="fielddoc">
Copy from ((snum &lt;&lt; 10) | so) by Open API. </td></tr>
<tr><td class="fieldtype">
<a id="a7c9679ecf1fe0a5990b0876148ef95b9"></a>uint16_t</td>
<td class="fieldname">
ctsuso1</td>
<td class="fielddoc">
Copy from (sdpa &lt;&lt; 8) by Open API. ICOG and RICOA is set recommend value. </td></tr>
</table>

</div>
</div>
<a name="structctsu__self__buf__t" id="structctsu__self__buf__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structctsu__self__buf__t">&#9670;&nbsp;</a></span>ctsu_self_buf_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ctsu_self_buf_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Scan buffer data formats (Self) </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a6861f106e35481e78f023371e8a0a119"></a>uint16_t</td>
<td class="fieldname">
sen</td>
<td class="fielddoc">
Sensor counter data. </td></tr>
<tr><td class="fieldtype">
<a id="adc438e4276c0d59b50aed4803e7abfe7"></a>uint16_t</td>
<td class="fieldname">
ref</td>
<td class="fielddoc">
Reference counter data (Not used) </td></tr>
</table>

</div>
</div>
<a name="structctsu__mutual__buf__t" id="structctsu__mutual__buf__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structctsu__mutual__buf__t">&#9670;&nbsp;</a></span>ctsu_mutual_buf_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ctsu_mutual_buf_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Scan buffer data formats (Mutual) </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a8173a36e5f8828115784966f8166b688"></a>uint16_t</td>
<td class="fieldname">
pri_sen</td>
<td class="fielddoc">
Primary sensor data. </td></tr>
<tr><td class="fieldtype">
<a id="a8181f53939fa39f21dfe1bade4ecfb3d"></a>uint16_t</td>
<td class="fieldname">
pri_ref</td>
<td class="fielddoc">
Primary reference data (Not used) </td></tr>
<tr><td class="fieldtype">
<a id="a1dfbcd55fcbb9e5f84715ce6e6044ba6"></a>uint16_t</td>
<td class="fieldname">
snd_sen</td>
<td class="fielddoc">
Secondary sensor data. </td></tr>
<tr><td class="fieldtype">
<a id="af11629c8645bed6f08a9dacdbd9c6bef"></a>uint16_t</td>
<td class="fieldname">
snd_ref</td>
<td class="fielddoc">
Secondary reference data (Not used) </td></tr>
</table>

</div>
</div>
<a name="structctsu__correction__info__t" id="structctsu__correction__info__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structctsu__correction__info__t">&#9670;&nbsp;</a></span>ctsu_correction_info_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ctsu_correction_info_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Correction information </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="aeea8e0424a7e537c771aa5605e234999"></a><a class="el" href="group___c_t_s_u.html#gad7a98cce83446a25cc6d9fae6fa1296d">ctsu_correction_status_t</a></td>
<td class="fieldname">
status</td>
<td class="fielddoc">
Correction status. </td></tr>
<tr><td class="fieldtype">
<a id="a93c9375ac0095e5fe3fcdbafb75bac27"></a><a class="el" href="group___c_t_s_u.html#structctsu__ctsuwr__t">ctsu_ctsuwr_t</a></td>
<td class="fieldname">
ctsuwr</td>
<td class="fielddoc">
Correction scan parameter. </td></tr>
<tr><td class="fieldtype">
<a id="a9e6bd5681dc890925212b5e8c6992a81"></a>volatile <a class="el" href="group___c_t_s_u.html#structctsu__self__buf__t">ctsu_self_buf_t</a></td>
<td class="fieldname">
scanbuf</td>
<td class="fielddoc">
Correction scan buffer. </td></tr>
<tr><td class="fieldtype">
<a id="a796450ff9edaa0c22480df1a792578e2"></a>uint8_t</td>
<td class="fieldname">
calculation_error</td>
<td class="fielddoc">
Overflow or underflow in correction calclation. </td></tr>
<tr><td class="fieldtype">
<a id="ab57b6901038712e64335413e1410cd38"></a>uint16_t</td>
<td class="fieldname">
first_val</td>
<td class="fielddoc">
1st correction value </td></tr>
<tr><td class="fieldtype">
<a id="adf7029351b6a5a1783d9cdfdf84fc2e7"></a>uint16_t</td>
<td class="fieldname">
second_val</td>
<td class="fielddoc">
2nd correction value </td></tr>
<tr><td class="fieldtype">
<a id="acfe4f4937e286f12ce9ab99644d7c9b4"></a>uint32_t</td>
<td class="fieldname">
first_coefficient</td>
<td class="fielddoc">
1st correction coefficient </td></tr>
<tr><td class="fieldtype">
<a id="a9d61017a601220935fdd8b2802d28911"></a>uint32_t</td>
<td class="fieldname">
second_coefficient</td>
<td class="fielddoc">
2nd correction coefficient </td></tr>
<tr><td class="fieldtype">
<a id="a057c864fef470eed9c0fba106ccf7c88"></a>uint32_t</td>
<td class="fieldname">
ctsu_clock</td>
<td class="fielddoc">
CTSU clock [MHz]. </td></tr>
</table>

</div>
</div>
<a name="structctsu__instance__ctrl__t" id="structctsu__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structctsu__instance__ctrl__t">&#9670;&nbsp;</a></span>ctsu_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ctsu_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>CTSU private control block. DO NOT MODIFY. Initialization occurs when <a class="el" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682" title="Opens and configures the CTSU driver module. Implements ctsu_api_t::open. ">R_CTSU_Open()</a> is called. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a257eb16ff64e017d0a67a0a3384fdbf7"><td class="memItemLeft" align="right" valign="top"><a id="a257eb16ff64e017d0a67a0a3384fdbf7"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a257eb16ff64e017d0a67a0a3384fdbf7">open</a></td></tr>
<tr class="memdesc:a257eb16ff64e017d0a67a0a3384fdbf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not driver is open. <br /></td></tr>
<tr class="separator:a257eb16ff64e017d0a67a0a3384fdbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee16466f6ce29f3141a0413c1f30cfa8"><td class="memItemLeft" align="right" valign="top"><a id="aee16466f6ce29f3141a0413c1f30cfa8"></a>
volatile <a class="el" href="group___c_t_s_u.html#ga9be3b4466784415a4193f9584362c2ce">ctsu_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#aee16466f6ce29f3141a0413c1f30cfa8">state</a></td></tr>
<tr class="memdesc:aee16466f6ce29f3141a0413c1f30cfa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTSU run state. <br /></td></tr>
<tr class="separator:aee16466f6ce29f3141a0413c1f30cfa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0bb3177ec0e2650163c3c37160da7b"><td class="memItemLeft" align="right" valign="top"><a id="a7d0bb3177ec0e2650163c3c37160da7b"></a>
<a class="el" href="group___c_t_s_u___a_p_i.html#ga63a1fbd0c7d4ac971d07d40f7f92dfad">ctsu_cap_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a7d0bb3177ec0e2650163c3c37160da7b">cap</a></td></tr>
<tr class="memdesc:a7d0bb3177ec0e2650163c3c37160da7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTSU Scan Start Trigger Select. <br /></td></tr>
<tr class="separator:a7d0bb3177ec0e2650163c3c37160da7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6ced83cd472d23e2912f32d555f538"><td class="memItemLeft" align="right" valign="top"><a id="a3f6ced83cd472d23e2912f32d555f538"></a>
<a class="el" href="group___c_t_s_u___a_p_i.html#ga3bb35bd3c3041f0a80dceac7c1590d06">ctsu_md_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a3f6ced83cd472d23e2912f32d555f538">md</a></td></tr>
<tr class="memdesc:a3f6ced83cd472d23e2912f32d555f538"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTSU Measurement Mode Select(copy to cfg) <br /></td></tr>
<tr class="separator:a3f6ced83cd472d23e2912f32d555f538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200d61ec88212741eda11efdf320dcf2"><td class="memItemLeft" align="right" valign="top"><a id="a200d61ec88212741eda11efdf320dcf2"></a>
<a class="el" href="group___c_t_s_u.html#gae3fb0beb148069bb590287ed34771117">ctsu_tuning_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a200d61ec88212741eda11efdf320dcf2">tuning</a></td></tr>
<tr class="memdesc:a200d61ec88212741eda11efdf320dcf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTSU Initial offset tuning status. <br /></td></tr>
<tr class="separator:a200d61ec88212741eda11efdf320dcf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a41db2c42e9d1e46a7547d803b8296"><td class="memItemLeft" align="right" valign="top"><a id="a67a41db2c42e9d1e46a7547d803b8296"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a67a41db2c42e9d1e46a7547d803b8296">num_elements</a></td></tr>
<tr class="memdesc:a67a41db2c42e9d1e46a7547d803b8296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements to scan. <br /></td></tr>
<tr class="separator:a67a41db2c42e9d1e46a7547d803b8296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f07e521837e8b03d7b2e3b93c9161a5"><td class="memItemLeft" align="right" valign="top"><a id="a2f07e521837e8b03d7b2e3b93c9161a5"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a2f07e521837e8b03d7b2e3b93c9161a5">wr_index</a></td></tr>
<tr class="memdesc:a2f07e521837e8b03d7b2e3b93c9161a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Word index into ctsuwr register array. <br /></td></tr>
<tr class="separator:a2f07e521837e8b03d7b2e3b93c9161a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab422bfa8a5f8e1c9e56866c44c440f75"><td class="memItemLeft" align="right" valign="top"><a id="ab422bfa8a5f8e1c9e56866c44c440f75"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ab422bfa8a5f8e1c9e56866c44c440f75">rd_index</a></td></tr>
<tr class="memdesc:ab422bfa8a5f8e1c9e56866c44c440f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Word index into scan data buffer. <br /></td></tr>
<tr class="separator:ab422bfa8a5f8e1c9e56866c44c440f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d51d2cc89379ed752a6823fc2487603"><td class="memItemLeft" align="right" valign="top"><a id="a7d51d2cc89379ed752a6823fc2487603"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a7d51d2cc89379ed752a6823fc2487603">p_element_complete_flag</a></td></tr>
<tr class="memdesc:a7d51d2cc89379ed752a6823fc2487603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to complete flag of each element. g_ctsu_element_complete_flag[] is set by Open API. <br /></td></tr>
<tr class="separator:a7d51d2cc89379ed752a6823fc2487603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527001bce3114395980eb1ab84990d39"><td class="memItemLeft" align="right" valign="top"><a id="a527001bce3114395980eb1ab84990d39"></a>
int32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a527001bce3114395980eb1ab84990d39">p_tuning_diff</a></td></tr>
<tr class="memdesc:a527001bce3114395980eb1ab84990d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to difference from base value of each element. g_ctsu_tuning_diff[] is set by Open API. <br /></td></tr>
<tr class="separator:a527001bce3114395980eb1ab84990d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfb1f17208413aec59916e5c0d030c2"><td class="memItemLeft" align="right" valign="top"><a id="aadfb1f17208413aec59916e5c0d030c2"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#aadfb1f17208413aec59916e5c0d030c2">average</a></td></tr>
<tr class="memdesc:aadfb1f17208413aec59916e5c0d030c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTSU Moving average counter. <br /></td></tr>
<tr class="separator:aadfb1f17208413aec59916e5c0d030c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf1fa1d2eae6508aeb04433bd02be27"><td class="memItemLeft" align="right" valign="top"><a id="aaaf1fa1d2eae6508aeb04433bd02be27"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#aaaf1fa1d2eae6508aeb04433bd02be27">num_moving_average</a></td></tr>
<tr class="memdesc:aaaf1fa1d2eae6508aeb04433bd02be27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from config by Open API. <br /></td></tr>
<tr class="separator:aaaf1fa1d2eae6508aeb04433bd02be27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83665cf5d96629fb4907ca79b605b25b"><td class="memItemLeft" align="right" valign="top"><a id="a83665cf5d96629fb4907ca79b605b25b"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a83665cf5d96629fb4907ca79b605b25b">ctsucr1</a></td></tr>
<tr class="memdesc:a83665cf5d96629fb4907ca79b605b25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from (atune1 &lt;&lt; 3, md &lt;&lt; 6) by Open API. CLK, ATUNE0, CSW, and PON is set by HAL driver. <br /></td></tr>
<tr class="separator:a83665cf5d96629fb4907ca79b605b25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf778904b1ccf46e5ce7fa6d1ec7c5f"><td class="memItemLeft" align="right" valign="top"><a id="a1cf778904b1ccf46e5ce7fa6d1ec7c5f"></a>
<a class="el" href="group___c_t_s_u.html#structctsu__ctsuwr__t">ctsu_ctsuwr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a1cf778904b1ccf46e5ce7fa6d1ec7c5f">p_ctsuwr</a></td></tr>
<tr class="memdesc:a1cf778904b1ccf46e5ce7fa6d1ec7c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTSUWR write register value. g_ctsu_ctsuwr[] is set by Open API. <br /></td></tr>
<tr class="separator:a1cf778904b1ccf46e5ce7fa6d1ec7c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5911fb602e5ca9a55b2e3eb30ec3676"><td class="memItemLeft" align="right" valign="top"><a id="ab5911fb602e5ca9a55b2e3eb30ec3676"></a>
<a class="el" href="group___c_t_s_u.html#structctsu__self__buf__t">ctsu_self_buf_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ab5911fb602e5ca9a55b2e3eb30ec3676">p_self_raw</a></td></tr>
<tr class="memdesc:ab5911fb602e5ca9a55b2e3eb30ec3676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Self raw data. g_ctsu_self_raw[] is set by Open API. <br /></td></tr>
<tr class="separator:ab5911fb602e5ca9a55b2e3eb30ec3676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73d7040b3e53d964cfff2b45645830f"><td class="memItemLeft" align="right" valign="top"><a id="ad73d7040b3e53d964cfff2b45645830f"></a>
uint16_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ad73d7040b3e53d964cfff2b45645830f">p_self_corr</a></td></tr>
<tr class="memdesc:ad73d7040b3e53d964cfff2b45645830f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Self correction data. g_ctsu_self_corr[] is set by Open API. <br /></td></tr>
<tr class="separator:ad73d7040b3e53d964cfff2b45645830f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a1faa58d668db18aebde68a775bc66"><td class="memItemLeft" align="right" valign="top"><a id="a32a1faa58d668db18aebde68a775bc66"></a>
uint16_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a32a1faa58d668db18aebde68a775bc66">p_self_mfc</a></td></tr>
<tr class="memdesc:a32a1faa58d668db18aebde68a775bc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Self multi frequency correction data. g_ctsu_self_mfc[] is set by Open API. <br /></td></tr>
<tr class="separator:a32a1faa58d668db18aebde68a775bc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7116340712c5298c263e68d79501c18"><td class="memItemLeft" align="right" valign="top"><a id="ad7116340712c5298c263e68d79501c18"></a>
ctsu_data_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ad7116340712c5298c263e68d79501c18">p_self_data</a></td></tr>
<tr class="memdesc:ad7116340712c5298c263e68d79501c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Self moving average data. g_ctsu_self_data[] is set by Open API. <br /></td></tr>
<tr class="separator:ad7116340712c5298c263e68d79501c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f26ec90784dcf867d1fc63f5a0de0ff"><td class="memItemLeft" align="right" valign="top"><a id="a9f26ec90784dcf867d1fc63f5a0de0ff"></a>
<a class="el" href="group___c_t_s_u.html#structctsu__mutual__buf__t">ctsu_mutual_buf_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a9f26ec90784dcf867d1fc63f5a0de0ff">p_mutual_raw</a></td></tr>
<tr class="memdesc:a9f26ec90784dcf867d1fc63f5a0de0ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Mutual raw data. g_ctsu_mutual_raw[] is set by Open API. <br /></td></tr>
<tr class="separator:a9f26ec90784dcf867d1fc63f5a0de0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb8ffd54dae5cba1a29a00352ccc5ae"><td class="memItemLeft" align="right" valign="top"><a id="afcb8ffd54dae5cba1a29a00352ccc5ae"></a>
uint16_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#afcb8ffd54dae5cba1a29a00352ccc5ae">p_mutual_pri_corr</a></td></tr>
<tr class="memdesc:afcb8ffd54dae5cba1a29a00352ccc5ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Mutual primary correction data. g_ctsu_self_corr[] is set by Open API. <br /></td></tr>
<tr class="separator:afcb8ffd54dae5cba1a29a00352ccc5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2dec9c9c789594d001129914f9eec4"><td class="memItemLeft" align="right" valign="top"><a id="abe2dec9c9c789594d001129914f9eec4"></a>
uint16_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#abe2dec9c9c789594d001129914f9eec4">p_mutual_snd_corr</a></td></tr>
<tr class="memdesc:abe2dec9c9c789594d001129914f9eec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Mutual secondary correction data. g_ctsu_self_corr[] is set by Open API. <br /></td></tr>
<tr class="separator:abe2dec9c9c789594d001129914f9eec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd39f557d83829d35bc9da9be9ecf0c"><td class="memItemLeft" align="right" valign="top"><a id="a4fd39f557d83829d35bc9da9be9ecf0c"></a>
uint16_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a4fd39f557d83829d35bc9da9be9ecf0c">p_mutual_pri_mfc</a></td></tr>
<tr class="memdesc:a4fd39f557d83829d35bc9da9be9ecf0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Mutual primary multi frequency correction data. g_ctsu_pri_mutual_mfc[] is set by Open API. <br /></td></tr>
<tr class="separator:a4fd39f557d83829d35bc9da9be9ecf0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967f79f83a71d79c6484e1e14013d314"><td class="memItemLeft" align="right" valign="top"><a id="a967f79f83a71d79c6484e1e14013d314"></a>
uint16_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a967f79f83a71d79c6484e1e14013d314">p_mutual_snd_mfc</a></td></tr>
<tr class="memdesc:a967f79f83a71d79c6484e1e14013d314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Mutual primary multi frequency correction data. g_ctsu_pri_mutual_mfc[] is set by Open API. <br /></td></tr>
<tr class="separator:a967f79f83a71d79c6484e1e14013d314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aad65a11ef585b3bcab18a55c4ba510"><td class="memItemLeft" align="right" valign="top"><a id="a6aad65a11ef585b3bcab18a55c4ba510"></a>
ctsu_data_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a6aad65a11ef585b3bcab18a55c4ba510">p_mutual_pri_data</a></td></tr>
<tr class="memdesc:a6aad65a11ef585b3bcab18a55c4ba510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Mutual primary moving average data. g_ctsu_mutual_pri_data[] is set by Open API. <br /></td></tr>
<tr class="separator:a6aad65a11ef585b3bcab18a55c4ba510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55eb5ebc39d80cb27fea70777719fd71"><td class="memItemLeft" align="right" valign="top"><a id="a55eb5ebc39d80cb27fea70777719fd71"></a>
ctsu_data_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a55eb5ebc39d80cb27fea70777719fd71">p_mutual_snd_data</a></td></tr>
<tr class="memdesc:a55eb5ebc39d80cb27fea70777719fd71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Mutual secondary moving average data. g_ctsu_mutual_snd_data[] is set by Open API. <br /></td></tr>
<tr class="separator:a55eb5ebc39d80cb27fea70777719fd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae291493dd7e994e95df48d4dbc2162af"><td class="memItemLeft" align="right" valign="top"><a id="ae291493dd7e994e95df48d4dbc2162af"></a>
<a class="el" href="group___c_t_s_u.html#structctsu__correction__info__t">ctsu_correction_info_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ae291493dd7e994e95df48d4dbc2162af">p_correction_info</a></td></tr>
<tr class="memdesc:ae291493dd7e994e95df48d4dbc2162af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to correction info. <br /></td></tr>
<tr class="separator:ae291493dd7e994e95df48d4dbc2162af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765f9f63a90651b81ef4e040174d6524"><td class="memItemLeft" align="right" valign="top"><a id="a765f9f63a90651b81ef4e040174d6524"></a>
<a class="el" href="group___c_t_s_u___a_p_i.html#gaeab653b25bda70d84f951b2b683be1f3">ctsu_txvsel_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a765f9f63a90651b81ef4e040174d6524">txvsel</a></td></tr>
<tr class="memdesc:a765f9f63a90651b81ef4e040174d6524"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTSU Transmission Power Supply Select. <br /></td></tr>
<tr class="separator:a765f9f63a90651b81ef4e040174d6524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdcf0132ae02d8766945124ec684d51"><td class="memItemLeft" align="right" valign="top"><a id="a6bdcf0132ae02d8766945124ec684d51"></a>
<a class="el" href="group___c_t_s_u___a_p_i.html#ga45fc452df9c8843a08fd3d6028869589">ctsu_txvsel2_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a6bdcf0132ae02d8766945124ec684d51">txvsel2</a></td></tr>
<tr class="memdesc:a6bdcf0132ae02d8766945124ec684d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTSU Transmission Power Supply Select 2 (CTSU2 Only) <br /></td></tr>
<tr class="separator:a6bdcf0132ae02d8766945124ec684d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf87f8171b60105a0b83bf96cca8e88"><td class="memItemLeft" align="right" valign="top"><a id="a8bf87f8171b60105a0b83bf96cca8e88"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a8bf87f8171b60105a0b83bf96cca8e88">ctsuchac0</a></td></tr>
<tr class="memdesc:a8bf87f8171b60105a0b83bf96cca8e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">TS00-TS07 enable mask. <br /></td></tr>
<tr class="separator:a8bf87f8171b60105a0b83bf96cca8e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46593770d2cdf8e60a897b29948003d7"><td class="memItemLeft" align="right" valign="top"><a id="a46593770d2cdf8e60a897b29948003d7"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a46593770d2cdf8e60a897b29948003d7">ctsuchac1</a></td></tr>
<tr class="memdesc:a46593770d2cdf8e60a897b29948003d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">TS08-TS15 enable mask. <br /></td></tr>
<tr class="separator:a46593770d2cdf8e60a897b29948003d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ceed5d626de1856b1ab03f9922fbb43"><td class="memItemLeft" align="right" valign="top"><a id="a8ceed5d626de1856b1ab03f9922fbb43"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a8ceed5d626de1856b1ab03f9922fbb43">ctsuchac2</a></td></tr>
<tr class="memdesc:a8ceed5d626de1856b1ab03f9922fbb43"><td class="mdescLeft">&#160;</td><td class="mdescRight">TS16-TS23 enable mask. <br /></td></tr>
<tr class="separator:a8ceed5d626de1856b1ab03f9922fbb43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398a5c185b148c524fbe262a376ea407"><td class="memItemLeft" align="right" valign="top"><a id="a398a5c185b148c524fbe262a376ea407"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a398a5c185b148c524fbe262a376ea407">ctsuchac3</a></td></tr>
<tr class="memdesc:a398a5c185b148c524fbe262a376ea407"><td class="mdescLeft">&#160;</td><td class="mdescRight">TS24-TS31 enable mask. <br /></td></tr>
<tr class="separator:a398a5c185b148c524fbe262a376ea407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5cd003eb417279858d83ce2a7bb49a"><td class="memItemLeft" align="right" valign="top"><a id="aae5cd003eb417279858d83ce2a7bb49a"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#aae5cd003eb417279858d83ce2a7bb49a">ctsuchac4</a></td></tr>
<tr class="memdesc:aae5cd003eb417279858d83ce2a7bb49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">TS32-TS39 enable mask. <br /></td></tr>
<tr class="separator:aae5cd003eb417279858d83ce2a7bb49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d5921c5d2fdc2e1f79e454e4bbbcca"><td class="memItemLeft" align="right" valign="top"><a id="a75d5921c5d2fdc2e1f79e454e4bbbcca"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a75d5921c5d2fdc2e1f79e454e4bbbcca">ctsuchtrc0</a></td></tr>
<tr class="memdesc:a75d5921c5d2fdc2e1f79e454e4bbbcca"><td class="mdescLeft">&#160;</td><td class="mdescRight">TS00-TS07 mutual-tx mask. <br /></td></tr>
<tr class="separator:a75d5921c5d2fdc2e1f79e454e4bbbcca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c863a9abfe9b16f77e82d40551d3aad"><td class="memItemLeft" align="right" valign="top"><a id="a0c863a9abfe9b16f77e82d40551d3aad"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a0c863a9abfe9b16f77e82d40551d3aad">ctsuchtrc1</a></td></tr>
<tr class="memdesc:a0c863a9abfe9b16f77e82d40551d3aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">TS08-TS15 mutual-tx mask. <br /></td></tr>
<tr class="separator:a0c863a9abfe9b16f77e82d40551d3aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795d748497ebde08d6016241ee45bef1"><td class="memItemLeft" align="right" valign="top"><a id="a795d748497ebde08d6016241ee45bef1"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a795d748497ebde08d6016241ee45bef1">ctsuchtrc2</a></td></tr>
<tr class="memdesc:a795d748497ebde08d6016241ee45bef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">TS16-TS23 mutual-tx mask. <br /></td></tr>
<tr class="separator:a795d748497ebde08d6016241ee45bef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0116e443faacf66ecf90a11c965f993"><td class="memItemLeft" align="right" valign="top"><a id="ae0116e443faacf66ecf90a11c965f993"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ae0116e443faacf66ecf90a11c965f993">ctsuchtrc3</a></td></tr>
<tr class="memdesc:ae0116e443faacf66ecf90a11c965f993"><td class="mdescLeft">&#160;</td><td class="mdescRight">TS24-TS31 mutual-tx mask. <br /></td></tr>
<tr class="separator:ae0116e443faacf66ecf90a11c965f993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af172abd0b31fa569830a3865f6853828"><td class="memItemLeft" align="right" valign="top"><a id="af172abd0b31fa569830a3865f6853828"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#af172abd0b31fa569830a3865f6853828">ctsuchtrc4</a></td></tr>
<tr class="memdesc:af172abd0b31fa569830a3865f6853828"><td class="mdescLeft">&#160;</td><td class="mdescRight">TS32-TS39 mutual-tx mask. <br /></td></tr>
<tr class="separator:af172abd0b31fa569830a3865f6853828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5618040797bc7f6b553122113748ab"><td class="memItemLeft" align="right" valign="top"><a id="a6c5618040797bc7f6b553122113748ab"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a6c5618040797bc7f6b553122113748ab">self_elem_index</a></td></tr>
<tr class="memdesc:a6c5618040797bc7f6b553122113748ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">self element index number for Current instance. <br /></td></tr>
<tr class="separator:a6c5618040797bc7f6b553122113748ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7409d810c8ac53b0182c1314207b21"><td class="memItemLeft" align="right" valign="top"><a id="adc7409d810c8ac53b0182c1314207b21"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#adc7409d810c8ac53b0182c1314207b21">mutual_elem_index</a></td></tr>
<tr class="memdesc:adc7409d810c8ac53b0182c1314207b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">mutual element index number for Current instance. <br /></td></tr>
<tr class="separator:adc7409d810c8ac53b0182c1314207b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd8b32a8bc2496d2605463945a87169"><td class="memItemLeft" align="right" valign="top"><a id="a0bd8b32a8bc2496d2605463945a87169"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a0bd8b32a8bc2496d2605463945a87169">ctsu_elem_index</a></td></tr>
<tr class="memdesc:a0bd8b32a8bc2496d2605463945a87169"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTSU element index number for Current instance. <br /></td></tr>
<tr class="separator:a0bd8b32a8bc2496d2605463945a87169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538262fc400f4a0095f2cd60ebb710a6"><td class="memItemLeft" align="right" valign="top"><a id="a538262fc400f4a0095f2cd60ebb710a6"></a>
<a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a> const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a538262fc400f4a0095f2cd60ebb710a6">p_ctsu_cfg</a></td></tr>
<tr class="memdesc:a538262fc400f4a0095f2cd60ebb710a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to initial configurations. <br /></td></tr>
<tr class="separator:a538262fc400f4a0095f2cd60ebb710a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a790f4de7d688d9a9f448a810be05f"><td class="memItemLeft" align="right" valign="top"><a id="aa4a790f4de7d688d9a9f448a810be05f"></a>
IRQn_Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#aa4a790f4de7d688d9a9f448a810be05f">write_irq</a></td></tr>
<tr class="memdesc:aa4a790f4de7d688d9a9f448a810be05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from config by Open API. CTSU_CTSUWR interrupt vector. <br /></td></tr>
<tr class="separator:aa4a790f4de7d688d9a9f448a810be05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422889992dd929096784b65c29c8780b"><td class="memItemLeft" align="right" valign="top"><a id="a422889992dd929096784b65c29c8780b"></a>
IRQn_Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a422889992dd929096784b65c29c8780b">read_irq</a></td></tr>
<tr class="memdesc:a422889992dd929096784b65c29c8780b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from config by Open API. CTSU_CTSURD interrupt vector. <br /></td></tr>
<tr class="separator:a422889992dd929096784b65c29c8780b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139bed35e18c276442ed790e2f49ad92"><td class="memItemLeft" align="right" valign="top"><a id="a139bed35e18c276442ed790e2f49ad92"></a>
IRQn_Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a139bed35e18c276442ed790e2f49ad92">end_irq</a></td></tr>
<tr class="memdesc:a139bed35e18c276442ed790e2f49ad92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from config by Open API. CTSU_CTSUFN interrupt vector. <br /></td></tr>
<tr class="separator:a139bed35e18c276442ed790e2f49ad92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c65e56730176fb25ab76ddb33b772ee"><td class="memItemLeft" align="right" valign="top"><a id="a0c65e56730176fb25ab76ddb33b772ee"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a0c65e56730176fb25ab76ddb33b772ee">p_callback</a> )(<a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__callback__args__t">ctsu_callback_args_t</a> *)</td></tr>
<tr class="memdesc:a0c65e56730176fb25ab76ddb33b772ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback provided when a CTSUFN occurs. <br /></td></tr>
<tr class="separator:a0c65e56730176fb25ab76ddb33b772ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f6a8656c90a6efeb22d35da9f07952"><td class="memItemLeft" align="right" valign="top"><a id="a16f6a8656c90a6efeb22d35da9f07952"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a16f6a8656c90a6efeb22d35da9f07952">interrupt_reverse_flag</a></td></tr>
<tr class="memdesc:a16f6a8656c90a6efeb22d35da9f07952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag in which read interrupt and end interrupt are reversed. <br /></td></tr>
<tr class="separator:a16f6a8656c90a6efeb22d35da9f07952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8feceb5a0f8f20795459c94d0c18bd5"><td class="memItemLeft" align="right" valign="top"><a id="aa8feceb5a0f8f20795459c94d0c18bd5"></a>
<a class="el" href="group___c_t_s_u___a_p_i.html#gaf6b0abb6cb3e6996d8435268d5e7c9cf">ctsu_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#aa8feceb5a0f8f20795459c94d0c18bd5">error_status</a></td></tr>
<tr class="memdesc:aa8feceb5a0f8f20795459c94d0c18bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">error status variable to send to QE for serial tuning. <br /></td></tr>
<tr class="separator:aa8feceb5a0f8f20795459c94d0c18bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042150cc9f3c41639dcd6bb989e6ba1e"><td class="memItemLeft" align="right" valign="top"><a id="a042150cc9f3c41639dcd6bb989e6ba1e"></a>
<a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__callback__args__t">ctsu_callback_args_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a042150cc9f3c41639dcd6bb989e6ba1e">p_callback_memory</a></td></tr>
<tr class="memdesc:a042150cc9f3c41639dcd6bb989e6ba1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to non-secure memory that can be used to pass arguments to a callback in non-secure memory. <br /></td></tr>
<tr class="separator:a042150cc9f3c41639dcd6bb989e6ba1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c5187fdb59151e9bebdac0c9beaf72"><td class="memItemLeft" align="right" valign="top"><a id="aa9c5187fdb59151e9bebdac0c9beaf72"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#aa9c5187fdb59151e9bebdac0c9beaf72">p_context</a></td></tr>
<tr class="memdesc:aa9c5187fdb59151e9bebdac0c9beaf72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placeholder for user data. <br /></td></tr>
<tr class="separator:aa9c5187fdb59151e9bebdac0c9beaf72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9630297d507bbd5d4f7ed56588d560ac"><td class="memItemLeft" align="right" valign="top"><a id="a9630297d507bbd5d4f7ed56588d560ac"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a9630297d507bbd5d4f7ed56588d560ac">serial_tuning_enable</a></td></tr>
<tr class="memdesc:a9630297d507bbd5d4f7ed56588d560ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag of serial tuning status. <br /></td></tr>
<tr class="separator:a9630297d507bbd5d4f7ed56588d560ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af566fb688739a5c442320bbb50ddf86a"><td class="memItemLeft" align="right" valign="top"><a id="af566fb688739a5c442320bbb50ddf86a"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#af566fb688739a5c442320bbb50ddf86a">serial_tuning_mutual_cnt</a></td></tr>
<tr class="memdesc:af566fb688739a5c442320bbb50ddf86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Word index into ctsuwr register array. <br /></td></tr>
<tr class="separator:af566fb688739a5c442320bbb50ddf86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd86e4b99d5cd0930a61d55cac6780a0"><td class="memItemLeft" align="right" valign="top"><a id="afd86e4b99d5cd0930a61d55cac6780a0"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#afd86e4b99d5cd0930a61d55cac6780a0">tuning_self_target_value</a></td></tr>
<tr class="memdesc:afd86e4b99d5cd0930a61d55cac6780a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Target self value for initial offset tuning. <br /></td></tr>
<tr class="separator:afd86e4b99d5cd0930a61d55cac6780a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b867400f41d3ae2908d179cde0ac61"><td class="memItemLeft" align="right" valign="top"><a id="a80b867400f41d3ae2908d179cde0ac61"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a80b867400f41d3ae2908d179cde0ac61">tuning_mutual_target_value</a></td></tr>
<tr class="memdesc:a80b867400f41d3ae2908d179cde0ac61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Target mutual value for initial offset tuning. <br /></td></tr>
<tr class="separator:a80b867400f41d3ae2908d179cde0ac61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe18f2b91b6b21dcb0ede9bfa16f0ed3"><td class="memItemLeft" align="right" valign="top"><a id="abe18f2b91b6b21dcb0ede9bfa16f0ed3"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#abe18f2b91b6b21dcb0ede9bfa16f0ed3">tsod</a></td></tr>
<tr class="memdesc:abe18f2b91b6b21dcb0ede9bfa16f0ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from tsod by Open API. <br /></td></tr>
<tr class="separator:abe18f2b91b6b21dcb0ede9bfa16f0ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752379baf0205504e215cb1024a83a59"><td class="memItemLeft" align="right" valign="top"><a id="a752379baf0205504e215cb1024a83a59"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a752379baf0205504e215cb1024a83a59">mec_ts</a></td></tr>
<tr class="memdesc:a752379baf0205504e215cb1024a83a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from mec_ts by Open API. <br /></td></tr>
<tr class="separator:a752379baf0205504e215cb1024a83a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee8bdbc6d0ef9412daf6bdd7aa7df71"><td class="memItemLeft" align="right" valign="top"><a id="acee8bdbc6d0ef9412daf6bdd7aa7df71"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#acee8bdbc6d0ef9412daf6bdd7aa7df71">mec_shield_ts</a></td></tr>
<tr class="memdesc:acee8bdbc6d0ef9412daf6bdd7aa7df71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from mec_shield_ts by Open API. <br /></td></tr>
<tr class="separator:acee8bdbc6d0ef9412daf6bdd7aa7df71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga9be3b4466784415a4193f9584362c2ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9be3b4466784415a4193f9584362c2ce">&#9670;&nbsp;</a></span>ctsu_state_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_t_s_u.html#ga9be3b4466784415a4193f9584362c2ce">ctsu_state_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CTSU run state </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9be3b4466784415a4193f9584362c2cea728f7cac2f957376ddfdcb0a9bc7eb24"></a>CTSU_STATE_INIT&#160;</td><td class="fielddoc"><p>Not open. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9be3b4466784415a4193f9584362c2cead492927de253bafe181a3430d1ed6759"></a>CTSU_STATE_IDLE&#160;</td><td class="fielddoc"><p>Opened. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9be3b4466784415a4193f9584362c2ceaf35310abebbd7594def0fd113abc9009"></a>CTSU_STATE_SCANNING&#160;</td><td class="fielddoc"><p>Scanning now. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9be3b4466784415a4193f9584362c2ceaf5bf0b9c2914f02bc13287aaf25193a7"></a>CTSU_STATE_SCANNED&#160;</td><td class="fielddoc"><p>Scan end. </p>
</td></tr>
</table>

</div>
</div>
<a id="gae3fb0beb148069bb590287ed34771117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3fb0beb148069bb590287ed34771117">&#9670;&nbsp;</a></span>ctsu_tuning_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_t_s_u.html#gae3fb0beb148069bb590287ed34771117">ctsu_tuning_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CTSU Initial offset tuning status </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae3fb0beb148069bb590287ed34771117ac5b463f4f8d75c188535febbb8f3265b"></a>CTSU_TUNING_INCOMPLETE&#160;</td><td class="fielddoc"><p>Initial offset tuning incomplete. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae3fb0beb148069bb590287ed34771117ac3e474244bf3dfaeaf0d6f418d87cadd"></a>CTSU_TUNING_COMPLETE&#160;</td><td class="fielddoc"><p>Initial offset tuning complete. </p>
</td></tr>
</table>

</div>
</div>
<a id="gad7a98cce83446a25cc6d9fae6fa1296d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7a98cce83446a25cc6d9fae6fa1296d">&#9670;&nbsp;</a></span>ctsu_correction_status_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_t_s_u.html#gad7a98cce83446a25cc6d9fae6fa1296d">ctsu_correction_status_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CTSU Correction status </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad7a98cce83446a25cc6d9fae6fa1296da544177e8ae7de2375f436f67d8f0fe85"></a>CTSU_CORRECTION_INIT&#160;</td><td class="fielddoc"><p>Correction initial status. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7a98cce83446a25cc6d9fae6fa1296da226216e141c9645a7b026e71552fff8b"></a>CTSU_CORRECTION_RUN&#160;</td><td class="fielddoc"><p>Correction scan running. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7a98cce83446a25cc6d9fae6fa1296da547ad26a74b30f6abc040e88ca531b1d"></a>CTSU_CORRECTION_COMPLETE&#160;</td><td class="fielddoc"><p>Correction complete. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7a98cce83446a25cc6d9fae6fa1296da9ca74c2bfb3ebcc87035a6c9eec1b12f"></a>CTSU_CORRECTION_ERROR&#160;</td><td class="fielddoc"><p>Correction error. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga07d91c963664201accc65a9d45fb817a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07d91c963664201accc65a9d45fb817a">&#9670;&nbsp;</a></span>ctsu_range_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_t_s_u.html#ga07d91c963664201accc65a9d45fb817a">ctsu_range_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CTSU range definition </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga07d91c963664201accc65a9d45fb817aa18e0227acbd85f4a0e698e66e10ff399"></a>CTSU_RANGE_20UA&#160;</td><td class="fielddoc"><p>20uA mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga07d91c963664201accc65a9d45fb817aa8f4c9333b63b727e17dbe5cb1bba2b5d"></a>CTSU_RANGE_40UA&#160;</td><td class="fielddoc"><p>40uA mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga07d91c963664201accc65a9d45fb817aabe7fe0af42bd5680a187198d0a940b65"></a>CTSU_RANGE_80UA&#160;</td><td class="fielddoc"><p>80uA mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga07d91c963664201accc65a9d45fb817aa245c0b1c0e2c81523be95944d61438ea"></a>CTSU_RANGE_160UA&#160;</td><td class="fielddoc"><p>160uA mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga07d91c963664201accc65a9d45fb817aa7c1c26d795d57571c5b9441ea18f626d"></a>CTSU_RANGE_NUM&#160;</td><td class="fielddoc"><p>number of range </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga4e625d8c9f3b301a46913c5827732682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e625d8c9f3b301a46913c5827732682">&#9670;&nbsp;</a></span>R_CTSU_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_CTSU_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens and configures the CTSU driver module. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#ae8f2c7b3cc9e33f0f790f76655d3d723">ctsu_api_t::open</a>. </p>
<p>Example: </p><div class="fragment"><div class="line">    err = <a class="code" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a>(&amp;g_ctsu_ctrl, &amp;g_ctsu_cfg);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>CTSU successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer, or one or more configuration options is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Module is already open. This module can only be opened once. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ARGUMENT</td><td>Configuration parameter error.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>In the first Open, measurement for correction works, and it takes several tens of milliseconds.</li>
<li>When the touch interface configuration is diagnosis mode, execute the <a class="el" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682" title="Opens and configures the CTSU driver module. Implements ctsu_api_t::open. ">R_CTSU_Open()</a> of the other touch interface configuration first. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga46cf185922bbca921cb92b4c18f62525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46cf185922bbca921cb92b4c18f62525">&#9670;&nbsp;</a></span>R_CTSU_ScanStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_CTSU_ScanStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function should be called each time a periodic timer expires. If initial offset tuning is enabled, The first several calls are used to tuning for the sensors. Before starting the next scan, first get the data with <a class="el" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe" title="This function gets the sensor values as scanned by the CTSU. If initial offset tuning is enabled...">R_CTSU_DataGet()</a>. If a different control block scan should be run, check the scan is complete before executing. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#a1df87278ab5d47fdd093994f53de96a6">ctsu_api_t::scanStart</a>. </p>
<p>Example: </p><div class="fragment"><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a>(&amp;g_ctsu_ctrl, data);</div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Application specific data processing. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>CTSU successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_SCANNING</td><td>Scanning this instance or other. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_NOT_GET_DATA</td><td>The previous data has not been retrieved by DataGet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1cff42feeaa3d73216b73c313fb9a5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cff42feeaa3d73216b73c313fb9a5fe">&#9670;&nbsp;</a></span>R_CTSU_DataGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_CTSU_DataGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>p_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the sensor values as scanned by the CTSU. If initial offset tuning is enabled, The first several calls are used to tuning for the sensors. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#aadcc6930b4e9d0ad86b6f607e86c28f5">ctsu_api_t::dataGet</a>. </p>
<p>Example: </p><div class="fragment"><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a>(&amp;g_ctsu_ctrl, data);</div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Application specific data processing. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>CTSU successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_SCANNING</td><td>Scanning this instance. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_INCOMPLETE_TUNING</td><td>Incomplete initial offset tuning. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_NOT_YET</td><td>Diagnosis of data collected no yet. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>The mode of automatic judgement on is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_ABORTED</td><td>Operate error of Diagnosis ADC data collection ,since ADC use other </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9eee44681ca5401e3b1c8e36db873681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9eee44681ca5401e3b1c8e36db873681">&#9670;&nbsp;</a></span>R_CTSU_AutoJudgementDataGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_CTSU_AutoJudgementDataGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>p_button_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the result of automatic judgement button. Call after the scan is completed. The result is 64-bit bitmaps and is stored in order of TS number for specified ctsu control. After the initial judgement, the baseline initialization bit is set and the automatic judgement threshold is set. This function is called only for automatic judgement. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#a39b1857983379004b97041a9462c07f0">ctsu_api_t::autoJudgementDataGet</a>. </p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Main loop */</span></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga9eee44681ca5401e3b1c8e36db873681">R_CTSU_AutoJudgementDataGet</a>(&amp;g_ctsu_ctrl, &amp;button_status);</div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Application specific data processing. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>CTSU successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_SCANNING</td><td>Scanning this instance. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>The mode of automatic judgement off is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga04263b8b45802780c9e072e19414ba7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04263b8b45802780c9e072e19414ba7e">&#9670;&nbsp;</a></span>R_CTSU_OffsetTuning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_CTSU_OffsetTuning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tunes the offset register(SO). Call after the measurement is completed. If the return value is FSP_ERR_CTSU_INCOMPLETE_TUNING, tuning is not complete. Execute the measurement and this function call routine until the return value becomes FSP_SUCCESS. It is recommended to run this routine after <a class="el" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682" title="Opens and configures the CTSU driver module. Implements ctsu_api_t::open. ">R_CTSU_Open()</a>. It can be recalled and tuned again. When the automatic judgement is enabled, after the offset tuning is completed,the baseline initialization bit flag is set. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#a5c1e1ab640eec8358e7ef92de31fcdc8">ctsu_api_t::offsetTuning</a>. </p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Initial offset tuning */</span></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga04263b8b45802780c9e072e19414ba7e">R_CTSU_OffsetTuning</a>(&amp;g_ctsu_ctrl);</div><div class="line">    } <span class="keywordflow">while</span> (FSP_SUCCESS != err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a>(&amp;g_ctsu_ctrl, data);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Re-offset tuning is performed when the parasitic capacitance changes significantly due   */</span></div><div class="line">            <span class="comment">/* to changes in the surrounding environment and the count value becomes an abnormal value. */</span></div><div class="line">            <span class="comment">/*                                                                                          */</span></div><div class="line">            <span class="comment">/* if (abnormal value detection conditions)                                                 */</span></div><div class="line">            <span class="comment">/* {                                                                                        */</span></div><div class="line">            <span class="comment">/* Re-offset tuning */</span></div><div class="line">            <span class="keywordflow">do</span></div><div class="line">            {</div><div class="line">                <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">                <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">                {</div><div class="line">                    <span class="comment">/* Wait for scan end callback */</span></div><div class="line">                }</div><div class="line"></div><div class="line">                g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                err = <a class="code" href="group___c_t_s_u.html#ga04263b8b45802780c9e072e19414ba7e">R_CTSU_OffsetTuning</a>(&amp;g_ctsu_ctrl);</div><div class="line">            } <span class="keywordflow">while</span> (FSP_SUCCESS != err);</div><div class="line"></div><div class="line">            <span class="comment">/* }                                                                                        */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>CTSU successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_SCANNING</td><td>Scanning this instance. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_INCOMPLETE_TUNING</td><td>Incomplete initial offset tuning. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac88d0518c996cb44643a82818b961485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac88d0518c996cb44643a82818b961485">&#9670;&nbsp;</a></span>R_CTSU_ScanStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_CTSU_ScanStop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function scan stops the sensor as scanning by the CTSU. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#ac21a98eaa673d72b7da701ba90093f59">ctsu_api_t::scanStop</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>CTSU successfully scan stop. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga76c89bb207dad2030b60fd71df7a717f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76c89bb207dad2030b60fd71df7a717f">&#9670;&nbsp;</a></span>R_CTSU_CallbackSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_CTSU_CallbackSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__callback__args__t">ctsu_callback_args_t</a> *)&#160;</td>
          <td class="paramname"><em>p_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>p_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__callback__args__t">ctsu_callback_args_t</a> *const&#160;</td>
          <td class="paramname"><em>p_callback_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the user callback and has option of providing memory for callback structure. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#a95464ec2211af496368b86116be8991a">ctsu_api_t::callbackSet</a></p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Callback updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_NO_CALLBACK_MEMORY</td><td>p_callback is non-secure and p_callback_memory is either secure or NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga73b45020c568d57065c8a7adecaaeb4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73b45020c568d57065c8a7adecaaeb4c">&#9670;&nbsp;</a></span>R_CTSU_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_CTSU_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables specified CTSU control block. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#aeb44bb4a59bad9025f0897cee306a395">ctsu_api_t::close</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>CTSU successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga32a5f61231501fb64c85fa52791b0e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32a5f61231501fb64c85fa52791b0e79">&#9670;&nbsp;</a></span>R_CTSU_SpecificDataGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_CTSU_SpecificDataGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>p_specific_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#ga1fe870ee0162807f8f9387749ba4e0a6">ctsu_specific_data_type_t</a>&#160;</td>
          <td class="paramname"><em>specific_data_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the sensor specific data values as scanned by the CTSU. Call this function after calling the <a class="el" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe" title="This function gets the sensor values as scanned by the CTSU. If initial offset tuning is enabled...">R_CTSU_DataGet()</a> function. </p>
<p>By setting the third argument to CTSU_SPECIFIC_RAW_DATA, RAW data can be output from the second argument.</p>
<p>By setting the third argument to CTSU_SPECIFIC_CCO_CORRECTION_DATA, the cco corrected data can be output from the second argument.</p>
<p>By setting the third argument to CTSU_SPECIFIC_CORRECTION_DATA, the frequency corrected data can be output from the second argument.</p>
<p>By setting the third argument to CTSU_SPECIFIC_SELECTED_FREQ, Get bitmap of the frequency values used in majority decision from the second argument.(CTSU2 Only) The bitmap is shown as follows.</p>
<table class="doxtable">
<tr>
<th>2bit </th><th>1bit </th><th>0bit  </th></tr>
<tr>
<td>3rd frequency value </td><td>2nd frequency value </td><td>1st frequency value </td></tr>
</table>
<p>Implements <a class="el" href="group___c_t_s_u___a_p_i.html#adf2f74b741c739e9e21b1ce544292872">ctsu_api_t::specificDataGet</a>.</p>
<p>Example: </p><div class="fragment"><div class="line">            err = <a class="code" href="group___c_t_s_u.html#ga32a5f61231501fb64c85fa52791b0e79">R_CTSU_SpecificDataGet</a>(&amp;g_ctsu_ctrl, corr_data, CTSU_SPECIFIC_CORRECTION_DATA);</div><div class="line"></div></div><!-- fragment --><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>CTSU successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_SCANNING</td><td>Scanning this instance. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_INCOMPLETE_TUNING</td><td>Incomplete initial offset tuning. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_ENABLED</td><td>CTSU_SPECIFIC_SELECTED_FREQ is not enabled in CTSU1.(CTSU2 Only) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac51fca87e02d589bcdeb894b99f7a08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac51fca87e02d589bcdeb894b99f7a08e">&#9670;&nbsp;</a></span>R_CTSU_DataInsert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_CTSU_DataInsert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>p_insert_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function inserts the value of the second argument as the measurement result value. Call this function after calling the <a class="el" href="group___c_t_s_u.html#gac51fca87e02d589bcdeb894b99f7a08e" title="This function inserts the value of the second argument as the measurement result value. Call this function after calling the R_CTSU_DataInsert() function. Implements ctsu_api_t::dataInsert. ">R_CTSU_DataInsert()</a> function. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#a84dfd5dd2ab6b16465cc5c06953c6a9f">ctsu_api_t::dataInsert</a>. </p>
<p>Example: </p><div class="fragment"><div class="line">            err = <a class="code" href="group___c_t_s_u.html#gac51fca87e02d589bcdeb894b99f7a08e">R_CTSU_DataInsert</a>(&amp;g_ctsu_ctrl, filter_data);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>CTSU successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_SCANNING</td><td>Scanning this instance. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_INCOMPLETE_TUNING</td><td>Incomplete initial offset tuning. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga45103e8db4a16dfabf3a516ab2da9f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45103e8db4a16dfabf3a516ab2da9f26">&#9670;&nbsp;</a></span>R_CTSU_Diagnosis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_CTSU_Diagnosis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Diagnosis the CTSU peripheral. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#a42a81fef42f2bf61bde59cba4796cc0e">ctsu_api_t::diagnosis</a>. </p>
<p>Example: </p><div class="fragment"><div class="line">            err = <a class="code" href="group___c_t_s_u.html#ga45103e8db4a16dfabf3a516ab2da9f26">R_CTSU_Diagnosis</a>(&amp;g_ctsu_ctrl_diagnosis);</div><div class="line">            assert(FSP_SUCCESS == err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>CTSU successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_NOT_GET_DATA</td><td>The previous data has not been retrieved by DataGet. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_LDO_OVER_VOLTAGE</td><td>Diagnosis of LDO over voltage failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_CCO_HIGH</td><td>Diagnosis of CCO into 19.2uA failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_CCO_LOW</td><td>Diagnosis of CCO into 2.4uA failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_SSCG</td><td>Diagnosis of SSCG frequency failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_DAC</td><td>Diagnosis of non-touch count value failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_OUTPUT_VOLTAGE</td><td>Diagnosis of LDO output voltage failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_OVER_VOLTAGE</td><td>Diagnosis of over voltage detection circuit failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_OVER_CURRENT</td><td>Diagnosis of over current detection circuit failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_LOAD_RESISTANCE</td><td>Diagnosis of LDO internal resistance value failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_CURRENT_SOURCE</td><td>Diagnosis of LDO internal resistance value failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_SENSCLK_GAIN</td><td>Diagnosis of SENSCLK frequency gain failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_SUCLK_GAIN</td><td>Diagnosis of SUCLK frequency gain failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_CLOCK_RECOVERY</td><td>Diagnosis of SUCLK clock recovery function failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_CFC_GAIN</td><td>Diagnosis of CFC oscillator gain failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v6.2.0 User's Manual Copyright © (2025) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
