<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: CTSU (r_ctsu)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v4.2.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">
 
    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text"> 
      </span>
      <span class="right">
          &nbsp; 
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___c_t_s_u.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() { 
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body. 
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works 
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len)); 
            }
          } 
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }    
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element. 
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;  
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">CTSU (r_ctsu)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___c_a_p_t_o_u_c_h___m_o_d_u_l_e_s.html">CapTouch</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4e625d8c9f3b301a46913c5827732682"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a> (<a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const p_ctrl, <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="memdesc:ga4e625d8c9f3b301a46913c5827732682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens and configures the CTSU driver module. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#ae8f2c7b3cc9e33f0f790f76655d3d723">ctsu_api_t::open</a>.  <a href="#ga4e625d8c9f3b301a46913c5827732682">More...</a><br /></td></tr>
<tr class="separator:ga4e625d8c9f3b301a46913c5827732682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46cf185922bbca921cb92b4c18f62525"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a> (<a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="memdesc:ga46cf185922bbca921cb92b4c18f62525"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function should be called each time a periodic timer expires. If initial offset tuning is enabled, The first several calls are used to tuning for the sensors. Before starting the next scan, first get the data with <a class="el" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe" title="This function gets the sensor values as scanned by the CTSU. If initial offset tuning is enabled...">R_CTSU_DataGet()</a>. If a different control block scan should be run, check the scan is complete before executing. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#a1df87278ab5d47fdd093994f53de96a6">ctsu_api_t::scanStart</a>.  <a href="#ga46cf185922bbca921cb92b4c18f62525">More...</a><br /></td></tr>
<tr class="separator:ga46cf185922bbca921cb92b4c18f62525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cff42feeaa3d73216b73c313fb9a5fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a> (<a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const p_ctrl, uint16_t *p_data)</td></tr>
<tr class="memdesc:ga1cff42feeaa3d73216b73c313fb9a5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the sensor values as scanned by the CTSU. If initial offset tuning is enabled, The first several calls are used to tuning for the sensors. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#aadcc6930b4e9d0ad86b6f607e86c28f5">ctsu_api_t::dataGet</a>.  <a href="#ga1cff42feeaa3d73216b73c313fb9a5fe">More...</a><br /></td></tr>
<tr class="separator:ga1cff42feeaa3d73216b73c313fb9a5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04263b8b45802780c9e072e19414ba7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ga04263b8b45802780c9e072e19414ba7e">R_CTSU_OffsetTuning</a> (<a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="memdesc:ga04263b8b45802780c9e072e19414ba7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tunes the offset register(SO). Call after the measurement is completed. If the return value is FSP_ERR_CTSU_INCOMPLETE_TUNING, tuning is not complete. Execute the measurement and this function call routine until the return value becomes FSP_SUCCESS. It is recommended to run this routine after <a class="el" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682" title="Opens and configures the CTSU driver module. Implements ctsu_api_t::open. ">R_CTSU_Open()</a>. It can be recalled and tuned again. When the automatic judgement is enabled, after the offset tuning is completed,the baseline initialization bit flag is set. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#a5c1e1ab640eec8358e7ef92de31fcdc8">ctsu_api_t::offsetTuning</a>.  <a href="#ga04263b8b45802780c9e072e19414ba7e">More...</a><br /></td></tr>
<tr class="separator:ga04263b8b45802780c9e072e19414ba7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac88d0518c996cb44643a82818b961485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#gac88d0518c996cb44643a82818b961485">R_CTSU_ScanStop</a> (<a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="memdesc:gac88d0518c996cb44643a82818b961485"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function scan stops the sensor as scanning by the CTSU. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#ac21a98eaa673d72b7da701ba90093f59">ctsu_api_t::scanStop</a>.  <a href="#gac88d0518c996cb44643a82818b961485">More...</a><br /></td></tr>
<tr class="separator:gac88d0518c996cb44643a82818b961485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c966546f3774ce2228739a5ffc0ac19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ga3c966546f3774ce2228739a5ffc0ac19">R_CTSU_CallbackSet</a> (<a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const p_api_ctrl, void(*p_callback)(<a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__callback__args__t">ctsu_callback_args_t</a> *), void const *const p_context, <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__callback__args__t">ctsu_callback_args_t</a> *const p_callback_memory)</td></tr>
<tr class="separator:ga3c966546f3774ce2228739a5ffc0ac19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73b45020c568d57065c8a7adecaaeb4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ga73b45020c568d57065c8a7adecaaeb4c">R_CTSU_Close</a> (<a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="memdesc:ga73b45020c568d57065c8a7adecaaeb4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables specified CTSU control block. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#aeb44bb4a59bad9025f0897cee306a395">ctsu_api_t::close</a>.  <a href="#ga73b45020c568d57065c8a7adecaaeb4c">More...</a><br /></td></tr>
<tr class="separator:ga73b45020c568d57065c8a7adecaaeb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32a5f61231501fb64c85fa52791b0e79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ga32a5f61231501fb64c85fa52791b0e79">R_CTSU_SpecificDataGet</a> (<a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const p_ctrl, uint16_t *p_specific_data, <a class="el" href="group___c_t_s_u___a_p_i.html#ga1fe870ee0162807f8f9387749ba4e0a6">ctsu_specific_data_type_t</a> specific_data_type)</td></tr>
<tr class="memdesc:ga32a5f61231501fb64c85fa52791b0e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the sensor specific data values as scanned by the CTSU. Call this function after calling the <a class="el" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe" title="This function gets the sensor values as scanned by the CTSU. If initial offset tuning is enabled...">R_CTSU_DataGet()</a> function.  <a href="#ga32a5f61231501fb64c85fa52791b0e79">More...</a><br /></td></tr>
<tr class="separator:ga32a5f61231501fb64c85fa52791b0e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac51fca87e02d589bcdeb894b99f7a08e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#gac51fca87e02d589bcdeb894b99f7a08e">R_CTSU_DataInsert</a> (<a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const p_ctrl, uint16_t *p_insert_data)</td></tr>
<tr class="memdesc:gac51fca87e02d589bcdeb894b99f7a08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function inserts the value of the second argument as the measurement result value. Call this function after calling the <a class="el" href="group___c_t_s_u.html#gac51fca87e02d589bcdeb894b99f7a08e" title="This function inserts the value of the second argument as the measurement result value. Call this function after calling the R_CTSU_DataInsert() function. Implements ctsu_api_t::dataInsert. ">R_CTSU_DataInsert()</a> function. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#a84dfd5dd2ab6b16465cc5c06953c6a9f">ctsu_api_t::dataInsert</a>.  <a href="#gac51fca87e02d589bcdeb894b99f7a08e">More...</a><br /></td></tr>
<tr class="separator:gac51fca87e02d589bcdeb894b99f7a08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45103e8db4a16dfabf3a516ab2da9f26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ga45103e8db4a16dfabf3a516ab2da9f26">R_CTSU_Diagnosis</a> (<a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="memdesc:ga45103e8db4a16dfabf3a516ab2da9f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagnosis the CTSU peripheral. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#a42a81fef42f2bf61bde59cba4796cc0e">ctsu_api_t::diagnosis</a>.  <a href="#ga45103e8db4a16dfabf3a516ab2da9f26">More...</a><br /></td></tr>
<tr class="separator:ga45103e8db4a16dfabf3a516ab2da9f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This HAL driver supports the Capacitive Touch Sensing Unit (CTSU). It implements the <a class="el" href="group___c_t_s_u___a_p_i.html">CTSU Interface</a>. </p>
<h1><a class="anchor" id="r-ctsu-overview"></a>
Overview</h1>
<p>The capacitive touch sensing unit HAL driver (r_ctsu) provides an API to control the CTSU peripheral. This module performs capacitance measurement based on various settings defined by the configuration. This module is configured via the <a href="https://www.renesas.com/qe-capacitive-touch">QE for Capacitive Touch</a>.</p>
<h2><a class="anchor" id="r-ctsu-features"></a>
Features</h2>
<p><a class="anchor" id="um_ctsu_mutual"></a><a class="anchor" id="um_ctsu_multi_method"></a></p><ul>
<li>Supports multiple scan modes<ul>
<li>Self-capacitance multi scan mode (CTSU2 support active shield)</li>
<li>Mutual-capacitance full scan mode</li>
<li>Mutual-capacitance parallel scan mode (CTSU2)</li>
<li>Current Measurement mode (CTSU2)</li>
<li>Diagnosis scan mode</li>
</ul>
</li>
<li>Scans may be started by software or an external trigger</li>
<li>Returns measured capacitance data on scan completion</li>
<li>Support DTC transfer of scanned data</li>
<li>Supports TrustZone</li>
<li>Corrects accuracy for temperature drift (CTSU2)</li>
</ul>
<h1><a class="anchor" id="r-ctsu-configuration"></a>
Configuration</h1>
<dl class="section note"><dt>Note</dt><dd><b>This module is configured via the <a href="https://www.renesas.com/qe-capacitive-touch">QE for Capacitive Touch</a>. For information on how to use the QE tool, once the tool is installed click Help -&gt; Help Contents in e2 studio and search for "QE".</b></dd></dl>
<p><h2>Build Time Configurations for r_ctsu</h2>
The following build time configurations are defined in fsp_cfg/r_ctsu_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr>
<td>Support for using DTC</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Enable DTC support for the CTSU module. </td></tr>
<tr>
<td>Interrupt priority level</td><td>MCU Specific Options</td><td></td><td>Priority level of all CTSU interrupt (CSTU_WR,CTSU_RD,CTSU_FN)  </td></tr>
</table>
 <h2>Configurations for CapTouch &gt; CTSU (r_ctsu)</h2>
This module can be added to the Stacks tab via New Stack &gt; CapTouch &gt; CTSU (r_ctsu). Non-secure callable guard functions can be generated for this module by right clicking the module in the RA Configuration tool and checking the "Non-secure Callable" box.<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Scan Start Trigger</td><td>MCU Specific Options</td><td></td><td>CTSU Scan Start Trigger Select </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-ctsu-interrupt-configuration"></a>
Interrupt Configuration</h2>
<p>The first <a class="el" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a> function call sets CTSU peripheral interrupts. The user should provide a callback function to be invoked at the end of the CTSU scan sequence. The callback argument will contain information about the scan status.</p>
<h2><a class="anchor" id="r-ctsu-clock-configuration"></a>
Clock Configuration</h2>
<p>The CTSU peripheral module uses PCLKB as its clock source. You can set the PCLKB frequency using the <b>Clocks</b> tab of the RA Configuration editor or by using the CGC Interface at run-time.</p>
<dl class="section note"><dt>Note</dt><dd>The CTSU Drive pulse will be calculated and set by the tooling depending on the selected transfer rate.</dd></dl>
<h2><a class="anchor" id="r-ctsu-pin-configuration"></a>
Pin Configuration</h2>
<p>The TSn pins are sensor pins for the CTSU.</p>
<p>The TSCAP pin is used for an internal low-pass filter and must be connected to an external decoupling capacitor.</p>
<h1><a class="anchor" id="r-ctsu-usage_notes"></a>
Usage Notes</h1>
<p>The CTSU module is a CTSU driver for the Touch module. The CTSU module assumes the access from the Touch middleware layer, and it is also accessible from an user application.<br />
 CTSU and CTSU2 are functionally different, so CTSU and CTSU2 are described in this application note as below.<br />
 Common description for CTSU and CTSU2 -&gt; CTSU<br />
 Description only for CTSU -&gt; CTSU1<br />
 Description only for CTSU2 -&gt; CTSU2<br />
 Without mention, it means the common description for CTSU and CTSU2.</p>
<h2>Functions</h2>
<p>The CTSU module supports the following functions.</p>
<h3>Measurements and Obtaining Data</h3>
<p>Measurements can be started by a software trigger or by an external event triggered by the Event Link Controller (ELC).<br />
 As the measurement process is carried out by the CTSU2 peripheral, it does not use up main processor processing time.<br />
 The CTSU module processes INTCTSUWR and INTCTSURD if generated during a measurement. The data transfer controller (DTC) can also be used for these processes.<br />
 When the measurement complete interrupt (INTCTSUFN) process is complete, the application is notified in a callback function. Make sure you obtain the measurement results before the next measurement is started as internal processes are also executed when a measurement is completed.<br />
 Start the measurement with API function <a class="el" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525" title="This function should be called each time a periodic timer expires. If initial offset tuning is enable...">R_CTSU_ScanStart()</a>.<br />
 Obtain the measurement results with API function <a class="el" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe" title="This function gets the sensor values as scanned by the CTSU. If initial offset tuning is enabled...">R_CTSU_DataGet()</a>.</p>
<h3>Sensor ICO Correction function</h3>
<p>The CTSU2 peripheral has a built-in correction circuit to handle the potential microvariations related to the manufacturing process of the sensor ICO MCU.<br />
 The module temporarily transitions to the correction process during initialization after power is turned on. In the correction process, the correction circuit is used to generate a correction coefficient (factor) to ensure accurate sensor measurement values.<br />
 When temperature correction is enabled, an external resistor connected to a TS terminal is used to periodically update the correction coefficient. By using an external resistor that is not dependent on temperature, you can even correct the temperature drift of the sensor ICO.</p>
<h3>Initial Offset Adjustment</h3>
<p>The CTSU2 peripheral was designed with a built-in offset current circuit in consideration of the amount of change in current due to touch. The offset current circuit cancels enough of the parasitic capacitance for it to fit within the sensor ICO dynamic range.<br />
 This module automatically adjusts the offset current setting. As the adjustment uses the normal measurement process, the combination of <a class="el" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525" title="This function should be called each time a periodic timer expires. If initial offset tuning is enable...">R_CTSU_ScanStart()</a> and <a class="el" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe" title="This function gets the sensor values as scanned by the CTSU. If initial offset tuning is enabled...">R_CTSU_DataGet()</a> or the combination of <a class="el" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525" title="This function should be called each time a periodic timer expires. If initial offset tuning is enable...">R_CTSU_ScanStart()</a> and <a class="el" href="group___c_t_s_u.html#ga04263b8b45802780c9e072e19414ba7e" title="This function tunes the offset register(SO). Call after the measurement is completed. If the return value is FSP_ERR_CTSU_INCOMPLETE_TUNING, tuning is not complete. Execute the measurement and this function call routine until the return value becomes FSP_SUCCESS. It is recommended to run this routine after R_CTSU_Open(). It can be recalled and tuned again. When the automatic judgement is enabled, after the offset tuning is completed,the baseline initialization bit flag is set. Implements ctsu_api_t::offsetTuning. ">R_CTSU_OffsetTuning()</a> must be repeated several times after startup. Because the <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__element__cfg__t">ctsu_element_cfg_t</a> member “so” is the starting point for adjustments, you can set the appropriate value for “so” in order to reduce the number of times the two functions must be run to complete the adjustment. Normally, the value used for “so” is a value adjusted by QE for Capacitive Touch.<br />
 <a class="el" href="group___c_t_s_u.html#ga04263b8b45802780c9e072e19414ba7e" title="This function tunes the offset register(SO). Call after the measurement is completed. If the return value is FSP_ERR_CTSU_INCOMPLETE_TUNING, tuning is not complete. Execute the measurement and this function call routine until the return value becomes FSP_SUCCESS. It is recommended to run this routine after R_CTSU_Open(). It can be recalled and tuned again. When the automatic judgement is enabled, after the offset tuning is completed,the baseline initialization bit flag is set. Implements ctsu_api_t::offsetTuning. ">R_CTSU_OffsetTuning()</a> was added in FSP 3.8.0. This API can also be used for initial offset adjustment, and offset adjustment can be performed again at any time. See example code of <a class="el" href="group___c_t_s_u.html#ga04263b8b45802780c9e072e19414ba7e" title="This function tunes the offset register(SO). Call after the measurement is completed. If the return value is FSP_ERR_CTSU_INCOMPLETE_TUNING, tuning is not complete. Execute the measurement and this function call routine until the return value becomes FSP_SUCCESS. It is recommended to run this routine after R_CTSU_Open(). It can be recalled and tuned again. When the automatic judgement is enabled, after the offset tuning is completed,the baseline initialization bit flag is set. Implements ctsu_api_t::offsetTuning. ">R_CTSU_OffsetTuning()</a> for details.<br />
</p>
<table class="doxtable">
<tr>
<th>Mode</th><th>Default target value  </th></tr>
<tr>
<td>Self-capacitance</td><td>15360 (37.5%) </td></tr>
<tr>
<td>Self-capacitance using active shield</td><td>6144 (15%) </td></tr>
<tr>
<td>Mutual-capacitance</td><td>10240 (20%) </td></tr>
</table>
<p>The percentage is for the CCO's input limit. 100% is the measured value 40960.<br />
 The default target value is based on 526us(CTSU1) or 256us(CTSU2).<br />
 When the measurement time is changed, the target value is adjusted by the ratio with the base time.<br />
</p>
<p>Example of target value in combination of CTSUSNUM and CTSUSDPA.<br />
 CTSU1 (CTSU clock = 32MHz, Self-capacitance mode)</p>
<table class="doxtable">
<tr>
<th>Target value</th><th>CTSUSNUM</th><th>CTSUSDPA</th><th>Measurement time  </th></tr>
<tr>
<td>15360</td><td>0x3</td><td>0x7</td><td>526usec </td></tr>
<tr>
<td>30720</td><td>0x7</td><td>0x7</td><td>1052usec </td></tr>
<tr>
<td>30720</td><td>0x3</td><td>0xF</td><td>1052usec </td></tr>
<tr>
<td>7680</td><td>0x1</td><td>0x7</td><td>263usec </td></tr>
<tr>
<td>7680</td><td>0x3</td><td>0x3</td><td>263usec </td></tr>
</table>
<p>The measurement time changes depending on the combination of CTSUSNUM and CTSUSDPA.<br />
 In the above table, CTSUPRRTIO is the recommended value of 3, and CSTUPRMODE is the recommended value of 2.<br />
 When changing CTSUPRRATIO and CTSUPRMODE from the recommended values, follow the Hardware Manual for the measurement time.</p>
<p>CTSU2 (Self-capacitance mode)</p>
<table class="doxtable">
<tr>
<th>Target value</th><th>Target value (multi frequency)</th><th>CTSUSNUM</th><th>Measurement time  </th></tr>
<tr>
<td>7680</td><td>15360 (128us + 128us)</td><td>0x7</td><td>128usec </td></tr>
<tr>
<td>15360</td><td>30720 (256us + 256us) </td><td>0xF</td><td>256usec </td></tr>
<tr>
<td>3840</td><td>7680 (64us + 64us)</td><td>0x3</td><td>64usec </td></tr>
</table>
<p>The measurement time changes depending on CTSUSNUM.<br />
 If STCLK cannot be set to 0.5MHz, it will not support the table above.<br />
 When setting STCLK to other than 0.5MHz because the CTSU clock is not an integer, follow the hardware manual for the measurement time.</p>
<h3>Random Pulse Frequency Measurement (CTSU1)</h3>
<p>The CTSU1 peripheral measures at one drive frequency.<br />
 The drive frequency determines the amperage to the electrode and generally uses the value tuned with QE for Capacitive Touch.<br />
 The drive frequency is calculated as below.<br />
 It is determined by PCLK frequency input to CTSU, CTSU Count Source Select bit(CTSUCLK), and CTSU Sensor Drive pulse Division Control bit(CTSUSDPA). For example, If it is set PCLK =32MHz, CTSUCLK = PLCK/2, and CTSUSDPA = 1/16, then drive frequency is 0.5MHz. CTSUSDPA can change for each TS port.</p>
<div class="image">
<img src="r_ctsu_Drive_Frequency_Settings.png" alt="r_ctsu_Drive_Frequency_Settings.png"/>
<div class="caption">
Drive Frequency Settings</div></div>
<p> The actual drive pulse is phase-shifted and frequency-spread with respect to the clock based on the drive frequency as a measure against external environmental noise. This module is fixed at initialization and sets the following.<br />
 CTSUSOFF = 0,CTSUSSMOD = 0,CTSUSSCNT = 3</p>
<h3>Multi-frequency Measurements (CTSU2)</h3>
<p>The CTSU2 peripheral can measure in one of four drive frequencies to avoid synchronous noise.<br />
 With the default settings, the module takes measurements at three different frequencies. After standardizing the results obtained at the three frequencies in accordance with the first frequency reference value, the measured value is determined based on majority in a process referred to as “normalization.” <br />
 The three values standardized to the first frequency reference value are called correction data.<br />
 You can get the three correction data with <a class="el" href="group___c_t_s_u.html#ga32a5f61231501fb64c85fa52791b0e79" title="This function gets the sensor specific data values as scanned by the CTSU. Call this function after c...">R_CTSU_SpecificDataGet()</a>.</p>
<div class="image">
<img src="r_ctsu_Multi-Frequency_Mesurements.png" alt="r_ctsu_Multi-Frequency_Mesurements.png"/>
<div class="caption">
Multi-frequency Measurements</div></div>
<p> Drive frequency is determined based on the config settings. The module sets registers according to the config settings, and sets the three drive frequencies.<br />
 Drive frequency is calculated in the following equation:<br />
 (PCLKB frequency / CLK / STCLK) x SUMULTIn / 2 / SDPA : n = 0, 1, 2<br />
 The figure below shows the settings for generating a 2MHz drive frequency when the PCLKB frequency is 32 MHz. SDPA can be set for each touch interface configuration.</p>
<div class="image">
<img src="r_ctsu_Drive_Frequency_Settings_ctsu2.png" alt="r_ctsu_Drive_Frequency_Settings_ctsu2.png"/>
<div class="caption">
Drive Frequency Settings</div></div>
 <h3>Shield Function(CTSU2)</h3>
<p>The CTSU2 peripheral has a built-in function that outputs a shield signal in phase with the drive pulse from the shield terminal and the non-measurement terminal in order to shield against external influences while suppressing any increase in parasitic capacitance. This function can only be used during self-capacitance measurements.<br />
 This module allows the user to set a shield for each touch interface configuration. <br />
 For example, for the electrode configuration shown in , the members of <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a> should be set as follows. Other members have been omitted for the example. <br />
 .txvsel = CTSU_TXVSEL_INTERNAL_POWER,<br />
 .txvsel2 = CTSU_TXVSEL_MODE,<br />
 .md = CTSU_MODE_SELF_MULTI_SCAN,<br />
 .posel = CTSU_POSEL_SAME_PULSE,<br />
 .ctsuchac0 = 0x0F,<br />
 .ctsuchtrc0 = 0x08,</p>
<div class="image">
<img src="r_ctsu_Shield_Electrode_Structure.png" alt="r_ctsu_Shield_Electrode_Structure.png"/>
<div class="caption">
Example of Shield Electrode Structure</div></div>
 <h3>Measurement Error Message</h3>
<p>When the CTSU2 peripheral detects an abnormal measurement, it sets the status register bit to 1.<br />
 In the measurement complete interrupt process, the module reads ICOMP1, ICOMP0, and SENSOVF of the status register and notifies the results in the callback function. The status register is reset after the contents are read. For more details on abnormal measurements, refer to “member event” in the <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__callback__args__t">ctsu_callback_args_t</a> callback function argument.</p>
<h3>Moving Average</h3>
<p>This function calculates the moving average of the measured results. <br />
 Set the number of times the moving average should be calculated in the config settings.</p>
<h3>Diagnosis Function</h3>
<p>The CTSU peripheral has a built-in function that diagnoses its own inner circuit. This diagnosis function provides the API for diagnosing the inner circuit.<br />
 The diagnostic requirements are different for CTSU1 and CTSU2 providing 5 types of diagnosis for CTSU1 and 9 types for CTSU2.<br />
 The diagnosis function is executed by calling the API function. This is executed independently from the other measurements and does not affect them. <br />
 To enable the diagnosis function, set CTSU_CFG_DIAG_SUPPORT_ENABLE to 1.<br />
 For CTSU1, a 27pF condenser should be connected externally.<br />
 For CTSU2, Diagnosis function uses the ADC module.<br />
 If an error occurs in the ADC module used for Diagnosis mode, return FSP_ERR_ABORTED as the return value of <a class="el" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe" title="This function gets the sensor values as scanned by the CTSU. If initial offset tuning is enabled...">R_CTSU_DataGet()</a>.<br />
 If an ADC error is returned, exit the function so as not to measure or close the ADC.<br />
 See ADC (r_adc) for ADC module errors. <br />
 Please pay particular attention to the following three points.<br />
</p><ol type="1">
<li>Be sure to measure the ADC module when using the Diagnosis mode function of the CTSU module. Therefore, in order for the user to use it with Dignosis, please close the user's ADC. After closing, please use the Diagnosis mode function of the CTSU module.</li>
<li>When creating an application with RTOS, please be careful about the scheduling of the CTSU module's Diagnosis mode function task and the user's ADC task.</li>
<li>If FSP_ERR_ABORTED occurs, please call the user's ADC again when using the user's ADC.</li>
</ol>
<h2>Measurement Mode</h2>
<p>This module supports all three modes offered by the CTSU2 peripheral: self-capacitance, mutual-capacitance, and current measurement modes. The temperature correction mode is also offered as a mode for updating the correction coefficient.</p>
<h3>Self-capacitance Mode</h3>
<p>The self-capacitance mode is used to measure the capacitance of each terminal (TS).<br />
 The CTSU2 peripheral measures the terminals in ascending order according to the TS numbers, then stores the data. For example, even if you want to use TS5, TS8, TS2, TS3 and TS6 in your application in that order, they will still be measured and stored in the order of TS2, TS3, TS5, TS6, and TS8. Therefore, you will need to reference buffer indexes [2], [4], [0], [1], and [3].<br />
</p>
<p>[CTSU1]<br />
 In default settings, the measurement period for each TS is wait-time plus approximately 526us.</p>
<div class="image">
<img src="r_ctsu_Self_capacitance_Measurement_Period.png" alt="r_ctsu_Self_capacitance_Measurement_Period.png"/>
<div class="caption">
Self-capacitance Measurement Period (CTSU1)</div></div>
<p> [CTSU2]<br />
 In default settings, the measurement period for each TS is approximately 576us.<br />
</p>
<div class="image">
<img src="r_ctsu_Self_capacitance_Measurement_Period_ctsu2.png" alt="r_ctsu_Self_capacitance_Measurement_Period_ctsu2.png"/>
<div class="caption">
Self-capacitance Measurement Period (CTSU2)</div></div>
 <h3>Mutual-Capacitance Mode</h3>
<p>The mutual-capacitance mode is used to measure the capacitance generated between the receive TS (Rx) and transmit TS (Tx), and therefore requires at least two terminals.<br />
 The CTSU2 peripheral measures all specified combinations of Rx and Tx. For example, when Rx is TS1 and TS3, and Tx is TS2, TS7 and TS4, the combinations are measured in the following order and the data is stored.<br />
 TS3-TS2, TS3-TS4, TS3-TS7, TS10-TS2, TS10-TS4, TS10-TS7<br />
 To measure the mutual-capacitance generated between electrodes, the CTSU2 peripheral performs the measurement process on the same electrode twice. <br />
 The mutual-capacitance is obtained by inverting the phase relationship of the pulse output and switched capacitor in the primary and secondary measurements, and calculating the difference between the two measurements. This module does not calculate the difference, but outputs the secondary measured result.<br />
 [CTSU1]<br />
 In default settings, the measurement period for each TS is twice of wait-time plus approximately 526us.<br />
 [CTSU2]<br />
 In default settings, the measurement period for each TS is approximately 1152us.<br />
</p>
<div class="image">
<img src="r_ctsu_Mutual_capacitance_Measurement_Period.png" alt="r_ctsu_Mutual_capacitance_Measurement_Period.png"/>
<div class="caption">
Mutual-capacitance Measurement Period</div></div>
 <h3>Mutual-capacitance parallel scan mode(CTSU2)</h3>
<p>This mode provides fast measurement time by parallel scanning the RX lines with a CFC circuit. Operation is otherwise identical to normal CTSU mutual scanning.<br />
</p><ul>
<li>Scan Order<ul>
<li>The hardware scans all RX pins simultaneously for each TX pin.</li>
<li>For example, if sensors TS10, TS11, and TS03 are specified as RX sensors, and sensors TS02, TS07, and TS04 are specified as TX sensors, the hardware will scan them in the following sensor-pair order:<br />
 TS02-(TS03, TS10, TS11), TS04-(TS03, TS10, TS11), TS07-(TS03, TS10, TS11)</li>
</ul>
</li>
<li>Element<ul>
<li>An element refers to the index of a sensor-pair within the scan order. Using the previous example, TS07-TS10 is element 7.</li>
</ul>
</li>
<li>Scan Time<ul>
<li>Because the RX lines are scanned in parallel, CFC mutual-capacitance scan is the same amount of times faster than a basic mutual matrix scan as the number of RX lines. In other words, on a matrix with N receive lines, CFC mutual scanning is N times faster than basic mutual scanning. Set CTSU_MODE_MUTUAL_CFC_SCAN to "md" of <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a>.<br />
 Also, add the number of matrix used for this measurement to CTSU_CFG_NUM_MUTUAL_ELEMENTS. In addition, set the number of CTSU_CFG_NUM_CFC and CTSU_CFG_NUM_CFC_TX.<br />
 For details, refer to the configuration and sample application output by QE for Capacitive Touch.</li>
</ul>
</li>
</ul>
<h3>Current Measurement Mode(CTSU2)</h3>
<p>The current measurement mode is used to measure the minute current input to the TS terminal. The order of measurement and data storage is the same as that of the self-capacitance mode. As this does not involve the switched capacitor operation, the measurement is only performed once. The measurement period for one TS under default settings is approximately 256us. The current measurement mode requires a longer stable wait time than the other modes, so the SST is set to 63.</p>
<div class="image">
<img src="r_ctsu_Current_Measurement_Period.png" alt="r_ctsu_Current_Measurement_Period.png"/>
<div class="caption">
Current Measurement Period</div></div>
 <h3>Temperature Correction Mode(CTSU2)</h3>
<p>The temperature correction mode is used to periodically update the correction coefficient using an external resistor connected to a TS terminal. This involves three processes as described below. Also refer to the timing chart in Figure of Temperature Correction Measurement Timing Chart.<br />
</p><ol type="1">
<li>Measure the correction circuit. One set comprises twelve measurements. <br />
</li>
<li>Measure the current when TSCAP voltage is applied to the external resistor to create a correction coefficient based on an external resistor that does not depend on temperature. Execute the next measurement after the previous measurement set is completed (as described in step 1).</li>
<li>Flow offset current to the external resistor and measure the voltage with the ADC. This will adjust the RTRIM register and handle the temperature drift of the internal reference resistor. In the config settings, set the number of times step 2 should be executed before carrying out this measurement.</li>
</ol>
<div class="image">
<img src="r_ctsu_Temperature_Correction_Measurement_Period.png" alt="r_ctsu_Temperature_Correction_Measurement_Period.png"/>
<div class="caption">
Temperature Correction Measurement Timing Chart</div></div>
<p> Temperature correction uses the ADC module.<br />
 If an error occurs in the ADC module used for temperature correction, return FSP_ERR_ABORTED as the return value of <a class="el" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe" title="This function gets the sensor values as scanned by the CTSU. If initial offset tuning is enabled...">R_CTSU_DataGet()</a>.<br />
 If an ADC error is returned, exit the function so as not to measure or close the ADC.<br />
 See ADC (r_adc) for ADC module errors. <br />
 Please pay articular attention to the following three points.<br />
</p><ol type="1">
<li>When using the temperature correction of the CTSU module, be sure to measure the ADC module. Therefore, please close the user's ADC for use in temperature correction. After closing, please use temperature correction of CTSU module.</li>
<li>When creating an RTOS, please be careful about the scheduling of the CTSU module's temperature correction task and the user's ADC task when creating an application.</li>
<li>If FSP_ERR_ABORTED occurs, please call the user's ADC again when using the user's ADC.</li>
</ol>
<h3>Diagnosis Mode</h3>
<p>The diagnosis mode is a mode in which various internal measurement values are scanned by using this diagnosis function <a class="el" href="group___c_t_s_u.html#ga45103e8db4a16dfabf3a516ab2da9f26" title="Diagnosis the CTSU peripheral. Implements ctsu_api_t::diagnosis. ">R_CTSU_Diagnosis()</a>.</p>
<h2>Measurement Timing</h2>
<p>Measurements are initiated by a software trigger or an external event which is triggered by the Event Link Controller (ELC).<br />
 The most common method is using a timer to carry out periodic measurements. Make sure to set the timer interval to allow the measurement and internal value update processes to complete before the next measurement period. The measurement period differs according to touch interface configuration and measurement mode.<br />
 The execution timing of software triggers and external triggers differ slightly. <br />
 Since a software trigger sets the start flag after setting the touch interface configuration with <a class="el" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525" title="This function should be called each time a periodic timer expires. If initial offset tuning is enable...">R_CTSU_ScanStart()</a>, there is a slight delay after the timer event occurrence. However, as the delay is much smaller than the measurement period, a software trigger is recommended for most instances as it is easy to set. <br />
 An external trigger is recommended for applications in which this slight delay is not acceptable or that require low-power consumption operations. When using an external trigger with multiple touch interface configurations, use <a class="el" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525" title="This function should be called each time a periodic timer expires. If initial offset tuning is enable...">R_CTSU_ScanStart()</a> to set another touch interface configuration after one measurement is completed.</p>
<h2>TrustZone Support</h2>
<p>In r_ctsu and rm_touch module, Non-Secure Callable Guard Functions are only generated from QE for Capacitive Touch. QE can be used for tuning in secure or flat project, but not in non-secure project. If you want to use in non-secure project, copy the output file from secure or flat project. Refer to QE Help for more information.</p>
<h2>Data flow</h2>
<p>The flow of storing data in RAM is as follows.<br />
</p>
<p>(CTSU1)<br />
</p><ol type="1">
<li>Read registers and stored in RAM as raw data.</li>
<li>ICO correction calculation of raw data and stored in RAM as correction data.</li>
<li>The correction data is calculated by moving average and stored in RAM as measurement results.</li>
</ol>
<p>(CTSU2)<br />
</p><ol type="1">
<li>Reads a register and stores raw data measured at three different frequencies in RAM.</li>
<li>Three raw data is ICO-corrected, standardized to the fitst frequency reference value, and stored in RAM as three correction data.</li>
<li>Three correction data are calculated by majority decision and moving average, and stored in RAM as measurement results.</li>
</ol>
<h2>Add user's filter</h2>
<p>There are two ways to add the user's filter.</p><ol type="1">
<li>Instead of filter calculation of <a class="el" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe" title="This function gets the sensor values as scanned by the CTSU. If initial offset tuning is enabled...">R_CTSU_DataGet()</a>, perform user filter calculation and use <a class="el" href="group___c_t_s_u.html#gac51fca87e02d589bcdeb894b99f7a08e" title="This function inserts the value of the second argument as the measurement result value. Call this function after calling the R_CTSU_DataInsert() function. Implements ctsu_api_t::dataInsert. ">R_CTSU_DataInsert()</a> to input user filter calculation result.</li>
<li>Using the correction data obtained by <a class="el" href="group___c_t_s_u.html#ga32a5f61231501fb64c85fa52791b0e79" title="This function gets the sensor specific data values as scanned by the CTSU. Call this function after c...">R_CTSU_SpecificDataGet()</a>, instead of majority decision calculation and filter calculation of <a class="el" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe" title="This function gets the sensor values as scanned by the CTSU. If initial offset tuning is enabled...">R_CTSU_DataGet()</a>, perform user majority decision calculation &amp; filter calculation and use <a class="el" href="group___c_t_s_u.html#gac51fca87e02d589bcdeb894b99f7a08e" title="This function inserts the value of the second argument as the measurement result value. Call this function after calling the R_CTSU_DataInsert() function. Implements ctsu_api_t::dataInsert. ">R_CTSU_DataInsert()</a> to input user majority decision calculation &amp; filter calculation result.</li>
</ol>
<p>Please check example.<br />
 <a href="#Users-filter">User's filter additional Example</a></p>
<h1><a class="anchor" id="r-ctsu-examples"></a>
Examples</h1>
<h2>Basic Example</h2>
<p>This is a basic example of minimal use of the CTSU in an application.</p>
<div class="fragment"><div class="line"><span class="keyword">volatile</span> <span class="keywordtype">bool</span> g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> ctsu_callback (<a class="code" href="group___c_t_s_u___a_p_i.html#structctsu__callback__args__t">ctsu_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___c_t_s_u___a_p_i.html#ggaf6b0abb6cb3e6996d8435268d5e7c9cfa110041f0d6a2dcfeac8b0d2ba3d2318b">CTSU_EVENT_SCAN_COMPLETE</a> == p_args-&gt;<a class="code" href="group___c_t_s_u___a_p_i.html#a40ee54221ab1d85ee5d2ce7a5cdd289a">event</a>)</div><div class="line">    {</div><div class="line">        g_scan_flag = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> ctsu_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line">    uint16_t  data[CTSU_CFG_NUM_SELF_ELEMENTS];</div><div class="line"></div><div class="line">    err = <a class="code" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a>(&amp;g_ctsu_ctrl, &amp;g_ctsu_cfg);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a>(&amp;g_ctsu_ctrl, data);</div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Application specific data processing. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Multi-configuration Example</h2>
<p>This is a optional example of using both Self-capacitance and Mutual-capacitance configurations in the same project.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ctsu_optional_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line">    uint16_t  data[CTSU_CFG_NUM_SELF_ELEMENTS + (CTSU_CFG_NUM_MUTUAL_ELEMENTS * 2)];</div><div class="line"></div><div class="line">    err = <a class="code" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a>(&amp;g_ctsu_ctrl, &amp;g_ctsu_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">    err = <a class="code" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a>(&amp;g_ctsu_ctrl_mutual, &amp;g_ctsu_cfg_mutual);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl_mutual);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a>(&amp;g_ctsu_ctrl, data);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Application specific data processing. */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a>(&amp;g_ctsu_ctrl_mutual, data);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Application specific data processing. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Offset Adjustment Example</h2>
<p>This is an example of offset adjustment using <a class="el" href="group___c_t_s_u.html#ga04263b8b45802780c9e072e19414ba7e" title="This function tunes the offset register(SO). Call after the measurement is completed. If the return value is FSP_ERR_CTSU_INCOMPLETE_TUNING, tuning is not complete. Execute the measurement and this function call routine until the return value becomes FSP_SUCCESS. It is recommended to run this routine after R_CTSU_Open(). It can be recalled and tuned again. When the automatic judgement is enabled, after the offset tuning is completed,the baseline initialization bit flag is set. Implements ctsu_api_t::offsetTuning. ">R_CTSU_OffsetTuning()</a>.<br />
 After completing R_CTSU_Open (), perform initial offset adjustment.<br />
 Offset adjustment is performed again when the parasitic capacitance changes significantly due to changes in the surrounding environment and the count value becomes an abnormal value.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ctsu_offsettuning_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line">    uint16_t  data[CTSU_CFG_NUM_SELF_ELEMENTS];</div><div class="line"></div><div class="line">    err = <a class="code" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a>(&amp;g_ctsu_ctrl, &amp;g_ctsu_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Initial offset tuning */</span></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga04263b8b45802780c9e072e19414ba7e">R_CTSU_OffsetTuning</a>(&amp;g_ctsu_ctrl);</div><div class="line">    } <span class="keywordflow">while</span> (FSP_SUCCESS != err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a>(&amp;g_ctsu_ctrl, data);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Re-offset tuning is performed when the parasitic capacitance changes significantly due   */</span></div><div class="line">            <span class="comment">/* to changes in the surrounding environment and the count value becomes an abnormal value. */</span></div><div class="line">            <span class="comment">/*                                                                                          */</span></div><div class="line">            <span class="comment">/* if (abnormal value detection conditions)                                                 */</span></div><div class="line">            <span class="comment">/* {                                                                                        */</span></div><div class="line">            <span class="comment">/* Re-offset tuning */</span></div><div class="line">            <span class="keywordflow">do</span></div><div class="line">            {</div><div class="line">                <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">                <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">                {</div><div class="line">                    <span class="comment">/* Wait for scan end callback */</span></div><div class="line">                }</div><div class="line"></div><div class="line">                g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                err = <a class="code" href="group___c_t_s_u.html#ga04263b8b45802780c9e072e19414ba7e">R_CTSU_OffsetTuning</a>(&amp;g_ctsu_ctrl);</div><div class="line">            } <span class="keywordflow">while</span> (FSP_SUCCESS != err);</div><div class="line"></div><div class="line">            <span class="comment">/* }                                                                                        */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Diagnosis function Example</h2>
<p>This is a Diagnosis function example of using the configuration in the basic example.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ctsu_diag_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line">    uint16_t  data[CTSU_CFG_NUM_SELF_ELEMENTS];</div><div class="line">    uint16_t  dummy;</div><div class="line"></div><div class="line">    <a class="code" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a>(&amp;g_ctsu_ctrl, &amp;g_ctsu_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">    <a class="code" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a>(&amp;g_ctsu_ctrl_diagnosis, &amp;g_ctsu_cfg_diagnosis);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a>(&amp;g_ctsu_ctrl, data);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">        <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl_diagnosis);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a>(&amp;g_ctsu_ctrl_diagnosis, &amp;dummy);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">        {</div><div class="line">            err = <a class="code" href="group___c_t_s_u.html#ga45103e8db4a16dfabf3a516ab2da9f26">R_CTSU_Diagnosis</a>(&amp;g_ctsu_ctrl_diagnosis);</div><div class="line">            assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">            {</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p> <a class="anchor" id="Users-filter"></a></p>
<h2>User's filter additional Example</h2>
<p>This is a user's filter additiional example of using the configuration in the basic example.<br />
 To perform user's filter calculation, change the num_moving_average of the element in the target <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a> to 1. <br />
</p>
<p>Perform user filter calculation and use <a class="el" href="group___c_t_s_u.html#gac51fca87e02d589bcdeb894b99f7a08e" title="This function inserts the value of the second argument as the measurement result value. Call this function after calling the R_CTSU_DataInsert() function. Implements ctsu_api_t::dataInsert. ">R_CTSU_DataInsert()</a> to input user filter calculation result. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> ctsu_user_filter_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line">    uint16_t  data[CTSU_CFG_NUM_SELF_ELEMENTS];</div><div class="line">    uint16_t  filter_data[CTSU_CFG_NUM_SELF_ELEMENTS];</div><div class="line"></div><div class="line">    <span class="comment">/* If you want to make a touch judgment, call RM_TOUCH_Open()instead of the following. */</span></div><div class="line">    err = <a class="code" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a>(&amp;g_ctsu_ctrl, &amp;g_ctsu_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* If you want to make a touch judgment, call RM_TOUCH_ScanStart()instead of the following. */</span></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a>(&amp;g_ctsu_ctrl, data);</div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">        {</div><div class="line">            <span class="comment">/* User original function. */</span></div><div class="line">            ctsu_user_filter(data, filter_data);</div><div class="line"></div><div class="line">            err = <a class="code" href="group___c_t_s_u.html#gac51fca87e02d589bcdeb894b99f7a08e">R_CTSU_DataInsert</a>(&amp;g_ctsu_ctrl, filter_data);</div><div class="line"></div><div class="line">            assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">            <span class="comment">/* Call RM_TOUCH_DataGet() to make a touch decision. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p> Using the correction data obtained by <a class="el" href="group___c_t_s_u.html#ga32a5f61231501fb64c85fa52791b0e79" title="This function gets the sensor specific data values as scanned by the CTSU. Call this function after c...">R_CTSU_SpecificDataGet()</a>. Perform user majority decision calculation &amp; filter calculation and use <a class="el" href="group___c_t_s_u.html#gac51fca87e02d589bcdeb894b99f7a08e" title="This function inserts the value of the second argument as the measurement result value. Call this function after calling the R_CTSU_DataInsert() function. Implements ctsu_api_t::dataInsert. ">R_CTSU_DataInsert()</a> to input user majority decision calculation &amp; filter calculation result. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> ctsu_user_majority_decition_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line">    uint16_t  data[CTSU_CFG_NUM_SELF_ELEMENTS];</div><div class="line">    uint16_t  corr_data[CTSU_CFG_NUM_SELF_ELEMENTS * CTSU_CFG_NUM_SUMULTI];</div><div class="line">    uint16_t  filter_data[CTSU_CFG_NUM_SELF_ELEMENTS];</div><div class="line"></div><div class="line">    <span class="comment">/* If you want to make a touch judgment, call RM_TOUCH_Open()instead of the following. */</span></div><div class="line">    err = <a class="code" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a>(&amp;g_ctsu_ctrl, &amp;g_ctsu_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* If you want to make a touch judgment, call RM_TOUCH_ScanStart()instead of the following. */</span></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a>(&amp;g_ctsu_ctrl, data);</div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">        {</div><div class="line">            err = <a class="code" href="group___c_t_s_u.html#ga32a5f61231501fb64c85fa52791b0e79">R_CTSU_SpecificDataGet</a>(&amp;g_ctsu_ctrl, corr_data, CTSU_SPECIFIC_CORRECTION_DATA);</div><div class="line"></div><div class="line">            assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">            <span class="comment">/* User original function */</span></div><div class="line">            ctsu_user_filter(corr_data, filter_data);</div><div class="line"></div><div class="line">            err = <a class="code" href="group___c_t_s_u.html#gac51fca87e02d589bcdeb894b99f7a08e">R_CTSU_DataInsert</a>(&amp;g_ctsu_ctrl, filter_data);</div><div class="line">            assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">            <span class="comment">/* Call RM_TOUCH_DataGet() to make a touch decision. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structctsu__ctsuwr__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#structctsu__ctsuwr__t">ctsu_ctsuwr_t</a></td></tr>
<tr class="separator:structctsu__ctsuwr__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structctsu__self__buf__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#structctsu__self__buf__t">ctsu_self_buf_t</a></td></tr>
<tr class="separator:structctsu__self__buf__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structctsu__mutual__buf__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#structctsu__mutual__buf__t">ctsu_mutual_buf_t</a></td></tr>
<tr class="separator:structctsu__mutual__buf__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structctsu__correction__info__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#structctsu__correction__info__t">ctsu_correction_info_t</a></td></tr>
<tr class="separator:structctsu__correction__info__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structctsu__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#structctsu__instance__ctrl__t">ctsu_instance_ctrl_t</a></td></tr>
<tr class="separator:structctsu__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga9be3b4466784415a4193f9584362c2ce"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ga9be3b4466784415a4193f9584362c2ce">ctsu_state_t</a> </td></tr>
<tr class="separator:ga9be3b4466784415a4193f9584362c2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3fb0beb148069bb590287ed34771117"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#gae3fb0beb148069bb590287ed34771117">ctsu_tuning_t</a> </td></tr>
<tr class="separator:gae3fb0beb148069bb590287ed34771117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7a98cce83446a25cc6d9fae6fa1296d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#gad7a98cce83446a25cc6d9fae6fa1296d">ctsu_correction_status_t</a> </td></tr>
<tr class="separator:gad7a98cce83446a25cc6d9fae6fa1296d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07d91c963664201accc65a9d45fb817a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ga07d91c963664201accc65a9d45fb817a">ctsu_range_t</a> </td></tr>
<tr class="separator:ga07d91c963664201accc65a9d45fb817a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structctsu__ctsuwr__t" id="structctsu__ctsuwr__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structctsu__ctsuwr__t">&#9670;&nbsp;</a></span>ctsu_ctsuwr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ctsu_ctsuwr_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>CTSUWR write register value </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ac0528bef59c8c84d71b8f14ec06e63ef"></a>uint16_t</td>
<td class="fieldname">
ctsussc</td>
<td class="fielddoc">
Copy from (ssdiv &lt;&lt; 8) by Open API. </td></tr>
<tr><td class="fieldtype">
<a id="aaf34d3ace08918bb6475ec3d1c552ef7"></a>uint16_t</td>
<td class="fieldname">
ctsuso0</td>
<td class="fielddoc">
Copy from ((snum &lt;&lt; 10) | so) by Open API. </td></tr>
<tr><td class="fieldtype">
<a id="a7c9679ecf1fe0a5990b0876148ef95b9"></a>uint16_t</td>
<td class="fieldname">
ctsuso1</td>
<td class="fielddoc">
Copy from (sdpa &lt;&lt; 8) by Open API. ICOG and RICOA is set recommend value. </td></tr>
</table>

</div>
</div>
<a name="structctsu__self__buf__t" id="structctsu__self__buf__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structctsu__self__buf__t">&#9670;&nbsp;</a></span>ctsu_self_buf_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ctsu_self_buf_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Scan buffer data formats (Self) </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a6861f106e35481e78f023371e8a0a119"></a>uint16_t</td>
<td class="fieldname">
sen</td>
<td class="fielddoc">
Sensor counter data. </td></tr>
<tr><td class="fieldtype">
<a id="adc438e4276c0d59b50aed4803e7abfe7"></a>uint16_t</td>
<td class="fieldname">
ref</td>
<td class="fielddoc">
Reference counter data (Not used) </td></tr>
</table>

</div>
</div>
<a name="structctsu__mutual__buf__t" id="structctsu__mutual__buf__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structctsu__mutual__buf__t">&#9670;&nbsp;</a></span>ctsu_mutual_buf_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ctsu_mutual_buf_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Scan buffer data formats (Mutual) </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a8173a36e5f8828115784966f8166b688"></a>uint16_t</td>
<td class="fieldname">
pri_sen</td>
<td class="fielddoc">
Primary sensor data. </td></tr>
<tr><td class="fieldtype">
<a id="a8181f53939fa39f21dfe1bade4ecfb3d"></a>uint16_t</td>
<td class="fieldname">
pri_ref</td>
<td class="fielddoc">
Primary reference data (Not used) </td></tr>
<tr><td class="fieldtype">
<a id="a1dfbcd55fcbb9e5f84715ce6e6044ba6"></a>uint16_t</td>
<td class="fieldname">
snd_sen</td>
<td class="fielddoc">
Secondary sensor data. </td></tr>
<tr><td class="fieldtype">
<a id="af11629c8645bed6f08a9dacdbd9c6bef"></a>uint16_t</td>
<td class="fieldname">
snd_ref</td>
<td class="fielddoc">
Secondary reference data (Not used) </td></tr>
</table>

</div>
</div>
<a name="structctsu__correction__info__t" id="structctsu__correction__info__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structctsu__correction__info__t">&#9670;&nbsp;</a></span>ctsu_correction_info_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ctsu_correction_info_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Correction information </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="aeea8e0424a7e537c771aa5605e234999"></a><a class="el" href="group___c_t_s_u.html#gad7a98cce83446a25cc6d9fae6fa1296d">ctsu_correction_status_t</a></td>
<td class="fieldname">
status</td>
<td class="fielddoc">
Correction status. </td></tr>
<tr><td class="fieldtype">
<a id="a93c9375ac0095e5fe3fcdbafb75bac27"></a><a class="el" href="group___c_t_s_u.html#structctsu__ctsuwr__t">ctsu_ctsuwr_t</a></td>
<td class="fieldname">
ctsuwr</td>
<td class="fielddoc">
Correction scan parameter. </td></tr>
<tr><td class="fieldtype">
<a id="a9e6bd5681dc890925212b5e8c6992a81"></a>volatile <a class="el" href="group___c_t_s_u.html#structctsu__self__buf__t">ctsu_self_buf_t</a></td>
<td class="fieldname">
scanbuf</td>
<td class="fielddoc">
Correction scan buffer. </td></tr>
<tr><td class="fieldtype">
<a id="ab57b6901038712e64335413e1410cd38"></a>uint16_t</td>
<td class="fieldname">
first_val</td>
<td class="fielddoc">
1st correction value </td></tr>
<tr><td class="fieldtype">
<a id="adf7029351b6a5a1783d9cdfdf84fc2e7"></a>uint16_t</td>
<td class="fieldname">
second_val</td>
<td class="fielddoc">
2nd correction value </td></tr>
<tr><td class="fieldtype">
<a id="acfe4f4937e286f12ce9ab99644d7c9b4"></a>uint32_t</td>
<td class="fieldname">
first_coefficient</td>
<td class="fielddoc">
1st correction coefficient </td></tr>
<tr><td class="fieldtype">
<a id="a9d61017a601220935fdd8b2802d28911"></a>uint32_t</td>
<td class="fieldname">
second_coefficient</td>
<td class="fielddoc">
2nd correction coefficient </td></tr>
<tr><td class="fieldtype">
<a id="a057c864fef470eed9c0fba106ccf7c88"></a>uint32_t</td>
<td class="fieldname">
ctsu_clock</td>
<td class="fielddoc">
CTSU clock [MHz]. </td></tr>
</table>

</div>
</div>
<a name="structctsu__instance__ctrl__t" id="structctsu__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structctsu__instance__ctrl__t">&#9670;&nbsp;</a></span>ctsu_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ctsu_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>CTSU private control block. DO NOT MODIFY. Initialization occurs when <a class="el" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682" title="Opens and configures the CTSU driver module. Implements ctsu_api_t::open. ">R_CTSU_Open()</a> is called. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a257eb16ff64e017d0a67a0a3384fdbf7"><td class="memItemLeft" align="right" valign="top"><a id="a257eb16ff64e017d0a67a0a3384fdbf7"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a257eb16ff64e017d0a67a0a3384fdbf7">open</a></td></tr>
<tr class="memdesc:a257eb16ff64e017d0a67a0a3384fdbf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not driver is open. <br /></td></tr>
<tr class="separator:a257eb16ff64e017d0a67a0a3384fdbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee16466f6ce29f3141a0413c1f30cfa8"><td class="memItemLeft" align="right" valign="top"><a id="aee16466f6ce29f3141a0413c1f30cfa8"></a>
volatile <a class="el" href="group___c_t_s_u.html#ga9be3b4466784415a4193f9584362c2ce">ctsu_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#aee16466f6ce29f3141a0413c1f30cfa8">state</a></td></tr>
<tr class="memdesc:aee16466f6ce29f3141a0413c1f30cfa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTSU run state. <br /></td></tr>
<tr class="separator:aee16466f6ce29f3141a0413c1f30cfa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0bb3177ec0e2650163c3c37160da7b"><td class="memItemLeft" align="right" valign="top"><a id="a7d0bb3177ec0e2650163c3c37160da7b"></a>
<a class="el" href="group___c_t_s_u___a_p_i.html#ga63a1fbd0c7d4ac971d07d40f7f92dfad">ctsu_cap_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a7d0bb3177ec0e2650163c3c37160da7b">cap</a></td></tr>
<tr class="memdesc:a7d0bb3177ec0e2650163c3c37160da7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTSU Scan Start Trigger Select. <br /></td></tr>
<tr class="separator:a7d0bb3177ec0e2650163c3c37160da7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6ced83cd472d23e2912f32d555f538"><td class="memItemLeft" align="right" valign="top"><a id="a3f6ced83cd472d23e2912f32d555f538"></a>
<a class="el" href="group___c_t_s_u___a_p_i.html#ga3bb35bd3c3041f0a80dceac7c1590d06">ctsu_md_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a3f6ced83cd472d23e2912f32d555f538">md</a></td></tr>
<tr class="memdesc:a3f6ced83cd472d23e2912f32d555f538"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTSU Measurement Mode Select(copy to cfg) <br /></td></tr>
<tr class="separator:a3f6ced83cd472d23e2912f32d555f538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200d61ec88212741eda11efdf320dcf2"><td class="memItemLeft" align="right" valign="top"><a id="a200d61ec88212741eda11efdf320dcf2"></a>
<a class="el" href="group___c_t_s_u.html#gae3fb0beb148069bb590287ed34771117">ctsu_tuning_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a200d61ec88212741eda11efdf320dcf2">tuning</a></td></tr>
<tr class="memdesc:a200d61ec88212741eda11efdf320dcf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTSU Initial offset tuning status. <br /></td></tr>
<tr class="separator:a200d61ec88212741eda11efdf320dcf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a41db2c42e9d1e46a7547d803b8296"><td class="memItemLeft" align="right" valign="top"><a id="a67a41db2c42e9d1e46a7547d803b8296"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a67a41db2c42e9d1e46a7547d803b8296">num_elements</a></td></tr>
<tr class="memdesc:a67a41db2c42e9d1e46a7547d803b8296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements to scan. <br /></td></tr>
<tr class="separator:a67a41db2c42e9d1e46a7547d803b8296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f07e521837e8b03d7b2e3b93c9161a5"><td class="memItemLeft" align="right" valign="top"><a id="a2f07e521837e8b03d7b2e3b93c9161a5"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a2f07e521837e8b03d7b2e3b93c9161a5">wr_index</a></td></tr>
<tr class="memdesc:a2f07e521837e8b03d7b2e3b93c9161a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Word index into ctsuwr register array. <br /></td></tr>
<tr class="separator:a2f07e521837e8b03d7b2e3b93c9161a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab422bfa8a5f8e1c9e56866c44c440f75"><td class="memItemLeft" align="right" valign="top"><a id="ab422bfa8a5f8e1c9e56866c44c440f75"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ab422bfa8a5f8e1c9e56866c44c440f75">rd_index</a></td></tr>
<tr class="memdesc:ab422bfa8a5f8e1c9e56866c44c440f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Word index into scan data buffer. <br /></td></tr>
<tr class="separator:ab422bfa8a5f8e1c9e56866c44c440f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d51d2cc89379ed752a6823fc2487603"><td class="memItemLeft" align="right" valign="top"><a id="a7d51d2cc89379ed752a6823fc2487603"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a7d51d2cc89379ed752a6823fc2487603">p_element_complete_flag</a></td></tr>
<tr class="memdesc:a7d51d2cc89379ed752a6823fc2487603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to complete flag of each element. g_ctsu_element_complete_flag[] is set by Open API. <br /></td></tr>
<tr class="separator:a7d51d2cc89379ed752a6823fc2487603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527001bce3114395980eb1ab84990d39"><td class="memItemLeft" align="right" valign="top"><a id="a527001bce3114395980eb1ab84990d39"></a>
int32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a527001bce3114395980eb1ab84990d39">p_tuning_diff</a></td></tr>
<tr class="memdesc:a527001bce3114395980eb1ab84990d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to difference from base value of each element. g_ctsu_tuning_diff[] is set by Open API. <br /></td></tr>
<tr class="separator:a527001bce3114395980eb1ab84990d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfb1f17208413aec59916e5c0d030c2"><td class="memItemLeft" align="right" valign="top"><a id="aadfb1f17208413aec59916e5c0d030c2"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#aadfb1f17208413aec59916e5c0d030c2">average</a></td></tr>
<tr class="memdesc:aadfb1f17208413aec59916e5c0d030c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTSU Moving average counter. <br /></td></tr>
<tr class="separator:aadfb1f17208413aec59916e5c0d030c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf1fa1d2eae6508aeb04433bd02be27"><td class="memItemLeft" align="right" valign="top"><a id="aaaf1fa1d2eae6508aeb04433bd02be27"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#aaaf1fa1d2eae6508aeb04433bd02be27">num_moving_average</a></td></tr>
<tr class="memdesc:aaaf1fa1d2eae6508aeb04433bd02be27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from config by Open API. <br /></td></tr>
<tr class="separator:aaaf1fa1d2eae6508aeb04433bd02be27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83665cf5d96629fb4907ca79b605b25b"><td class="memItemLeft" align="right" valign="top"><a id="a83665cf5d96629fb4907ca79b605b25b"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a83665cf5d96629fb4907ca79b605b25b">ctsucr1</a></td></tr>
<tr class="memdesc:a83665cf5d96629fb4907ca79b605b25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from (atune1 &lt;&lt; 3, md &lt;&lt; 6) by Open API. CLK, ATUNE0, CSW, and PON is set by HAL driver. <br /></td></tr>
<tr class="separator:a83665cf5d96629fb4907ca79b605b25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf778904b1ccf46e5ce7fa6d1ec7c5f"><td class="memItemLeft" align="right" valign="top"><a id="a1cf778904b1ccf46e5ce7fa6d1ec7c5f"></a>
<a class="el" href="group___c_t_s_u.html#structctsu__ctsuwr__t">ctsu_ctsuwr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a1cf778904b1ccf46e5ce7fa6d1ec7c5f">p_ctsuwr</a></td></tr>
<tr class="memdesc:a1cf778904b1ccf46e5ce7fa6d1ec7c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTSUWR write register value. g_ctsu_ctsuwr[] is set by Open API. <br /></td></tr>
<tr class="separator:a1cf778904b1ccf46e5ce7fa6d1ec7c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5911fb602e5ca9a55b2e3eb30ec3676"><td class="memItemLeft" align="right" valign="top"><a id="ab5911fb602e5ca9a55b2e3eb30ec3676"></a>
<a class="el" href="group___c_t_s_u.html#structctsu__self__buf__t">ctsu_self_buf_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ab5911fb602e5ca9a55b2e3eb30ec3676">p_self_raw</a></td></tr>
<tr class="memdesc:ab5911fb602e5ca9a55b2e3eb30ec3676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Self raw data. g_ctsu_self_raw[] is set by Open API. <br /></td></tr>
<tr class="separator:ab5911fb602e5ca9a55b2e3eb30ec3676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73d7040b3e53d964cfff2b45645830f"><td class="memItemLeft" align="right" valign="top"><a id="ad73d7040b3e53d964cfff2b45645830f"></a>
uint16_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ad73d7040b3e53d964cfff2b45645830f">p_self_corr</a></td></tr>
<tr class="memdesc:ad73d7040b3e53d964cfff2b45645830f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Self correction data. g_ctsu_self_corr[] is set by Open API. <br /></td></tr>
<tr class="separator:ad73d7040b3e53d964cfff2b45645830f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9d2ea0f565cf340e5735b1c86309fe"><td class="memItemLeft" align="right" valign="top"><a id="a7d9d2ea0f565cf340e5735b1c86309fe"></a>
uint16_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a7d9d2ea0f565cf340e5735b1c86309fe">p_self_data</a></td></tr>
<tr class="memdesc:a7d9d2ea0f565cf340e5735b1c86309fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Self moving average data. g_ctsu_self_data[] is set by Open API. <br /></td></tr>
<tr class="separator:a7d9d2ea0f565cf340e5735b1c86309fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f26ec90784dcf867d1fc63f5a0de0ff"><td class="memItemLeft" align="right" valign="top"><a id="a9f26ec90784dcf867d1fc63f5a0de0ff"></a>
<a class="el" href="group___c_t_s_u.html#structctsu__mutual__buf__t">ctsu_mutual_buf_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a9f26ec90784dcf867d1fc63f5a0de0ff">p_mutual_raw</a></td></tr>
<tr class="memdesc:a9f26ec90784dcf867d1fc63f5a0de0ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Mutual raw data. g_ctsu_mutual_raw[] is set by Open API. <br /></td></tr>
<tr class="separator:a9f26ec90784dcf867d1fc63f5a0de0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb8ffd54dae5cba1a29a00352ccc5ae"><td class="memItemLeft" align="right" valign="top"><a id="afcb8ffd54dae5cba1a29a00352ccc5ae"></a>
uint16_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#afcb8ffd54dae5cba1a29a00352ccc5ae">p_mutual_pri_corr</a></td></tr>
<tr class="memdesc:afcb8ffd54dae5cba1a29a00352ccc5ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Mutual primary correction data. g_ctsu_self_corr[] is set by Open API. <br /></td></tr>
<tr class="separator:afcb8ffd54dae5cba1a29a00352ccc5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2dec9c9c789594d001129914f9eec4"><td class="memItemLeft" align="right" valign="top"><a id="abe2dec9c9c789594d001129914f9eec4"></a>
uint16_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#abe2dec9c9c789594d001129914f9eec4">p_mutual_snd_corr</a></td></tr>
<tr class="memdesc:abe2dec9c9c789594d001129914f9eec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Mutual secondary correction data. g_ctsu_self_corr[] is set by Open API. <br /></td></tr>
<tr class="separator:abe2dec9c9c789594d001129914f9eec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0664d7b0f274da19339d9de7b4c161d1"><td class="memItemLeft" align="right" valign="top"><a id="a0664d7b0f274da19339d9de7b4c161d1"></a>
uint16_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a0664d7b0f274da19339d9de7b4c161d1">p_mutual_pri_data</a></td></tr>
<tr class="memdesc:a0664d7b0f274da19339d9de7b4c161d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Mutual primary moving average data. g_ctsu_mutual_pri_data[] is set by Open API. <br /></td></tr>
<tr class="separator:a0664d7b0f274da19339d9de7b4c161d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621ad282765bd1f41e88b497a82e4fab"><td class="memItemLeft" align="right" valign="top"><a id="a621ad282765bd1f41e88b497a82e4fab"></a>
uint16_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a621ad282765bd1f41e88b497a82e4fab">p_mutual_snd_data</a></td></tr>
<tr class="memdesc:a621ad282765bd1f41e88b497a82e4fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Mutual secondary moving average data. g_ctsu_mutual_snd_data[] is set by Open API. <br /></td></tr>
<tr class="separator:a621ad282765bd1f41e88b497a82e4fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae291493dd7e994e95df48d4dbc2162af"><td class="memItemLeft" align="right" valign="top"><a id="ae291493dd7e994e95df48d4dbc2162af"></a>
<a class="el" href="group___c_t_s_u.html#structctsu__correction__info__t">ctsu_correction_info_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ae291493dd7e994e95df48d4dbc2162af">p_correction_info</a></td></tr>
<tr class="memdesc:ae291493dd7e994e95df48d4dbc2162af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to correction info. <br /></td></tr>
<tr class="separator:ae291493dd7e994e95df48d4dbc2162af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765f9f63a90651b81ef4e040174d6524"><td class="memItemLeft" align="right" valign="top"><a id="a765f9f63a90651b81ef4e040174d6524"></a>
<a class="el" href="group___c_t_s_u___a_p_i.html#gaeab653b25bda70d84f951b2b683be1f3">ctsu_txvsel_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a765f9f63a90651b81ef4e040174d6524">txvsel</a></td></tr>
<tr class="memdesc:a765f9f63a90651b81ef4e040174d6524"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTSU Transmission Power Supply Select. <br /></td></tr>
<tr class="separator:a765f9f63a90651b81ef4e040174d6524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdcf0132ae02d8766945124ec684d51"><td class="memItemLeft" align="right" valign="top"><a id="a6bdcf0132ae02d8766945124ec684d51"></a>
<a class="el" href="group___c_t_s_u___a_p_i.html#ga45fc452df9c8843a08fd3d6028869589">ctsu_txvsel2_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a6bdcf0132ae02d8766945124ec684d51">txvsel2</a></td></tr>
<tr class="memdesc:a6bdcf0132ae02d8766945124ec684d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTSU Transmission Power Supply Select 2 (CTSU2 Only) <br /></td></tr>
<tr class="separator:a6bdcf0132ae02d8766945124ec684d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf87f8171b60105a0b83bf96cca8e88"><td class="memItemLeft" align="right" valign="top"><a id="a8bf87f8171b60105a0b83bf96cca8e88"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a8bf87f8171b60105a0b83bf96cca8e88">ctsuchac0</a></td></tr>
<tr class="memdesc:a8bf87f8171b60105a0b83bf96cca8e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">TS00-TS07 enable mask. <br /></td></tr>
<tr class="separator:a8bf87f8171b60105a0b83bf96cca8e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46593770d2cdf8e60a897b29948003d7"><td class="memItemLeft" align="right" valign="top"><a id="a46593770d2cdf8e60a897b29948003d7"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a46593770d2cdf8e60a897b29948003d7">ctsuchac1</a></td></tr>
<tr class="memdesc:a46593770d2cdf8e60a897b29948003d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">TS08-TS15 enable mask. <br /></td></tr>
<tr class="separator:a46593770d2cdf8e60a897b29948003d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ceed5d626de1856b1ab03f9922fbb43"><td class="memItemLeft" align="right" valign="top"><a id="a8ceed5d626de1856b1ab03f9922fbb43"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a8ceed5d626de1856b1ab03f9922fbb43">ctsuchac2</a></td></tr>
<tr class="memdesc:a8ceed5d626de1856b1ab03f9922fbb43"><td class="mdescLeft">&#160;</td><td class="mdescRight">TS16-TS23 enable mask. <br /></td></tr>
<tr class="separator:a8ceed5d626de1856b1ab03f9922fbb43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398a5c185b148c524fbe262a376ea407"><td class="memItemLeft" align="right" valign="top"><a id="a398a5c185b148c524fbe262a376ea407"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a398a5c185b148c524fbe262a376ea407">ctsuchac3</a></td></tr>
<tr class="memdesc:a398a5c185b148c524fbe262a376ea407"><td class="mdescLeft">&#160;</td><td class="mdescRight">TS24-TS31 enable mask. <br /></td></tr>
<tr class="separator:a398a5c185b148c524fbe262a376ea407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5cd003eb417279858d83ce2a7bb49a"><td class="memItemLeft" align="right" valign="top"><a id="aae5cd003eb417279858d83ce2a7bb49a"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#aae5cd003eb417279858d83ce2a7bb49a">ctsuchac4</a></td></tr>
<tr class="memdesc:aae5cd003eb417279858d83ce2a7bb49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">TS32-TS39 enable mask. <br /></td></tr>
<tr class="separator:aae5cd003eb417279858d83ce2a7bb49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d5921c5d2fdc2e1f79e454e4bbbcca"><td class="memItemLeft" align="right" valign="top"><a id="a75d5921c5d2fdc2e1f79e454e4bbbcca"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a75d5921c5d2fdc2e1f79e454e4bbbcca">ctsuchtrc0</a></td></tr>
<tr class="memdesc:a75d5921c5d2fdc2e1f79e454e4bbbcca"><td class="mdescLeft">&#160;</td><td class="mdescRight">TS00-TS07 mutual-tx mask. <br /></td></tr>
<tr class="separator:a75d5921c5d2fdc2e1f79e454e4bbbcca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c863a9abfe9b16f77e82d40551d3aad"><td class="memItemLeft" align="right" valign="top"><a id="a0c863a9abfe9b16f77e82d40551d3aad"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a0c863a9abfe9b16f77e82d40551d3aad">ctsuchtrc1</a></td></tr>
<tr class="memdesc:a0c863a9abfe9b16f77e82d40551d3aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">TS08-TS15 mutual-tx mask. <br /></td></tr>
<tr class="separator:a0c863a9abfe9b16f77e82d40551d3aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795d748497ebde08d6016241ee45bef1"><td class="memItemLeft" align="right" valign="top"><a id="a795d748497ebde08d6016241ee45bef1"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a795d748497ebde08d6016241ee45bef1">ctsuchtrc2</a></td></tr>
<tr class="memdesc:a795d748497ebde08d6016241ee45bef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">TS16-TS23 mutual-tx mask. <br /></td></tr>
<tr class="separator:a795d748497ebde08d6016241ee45bef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0116e443faacf66ecf90a11c965f993"><td class="memItemLeft" align="right" valign="top"><a id="ae0116e443faacf66ecf90a11c965f993"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ae0116e443faacf66ecf90a11c965f993">ctsuchtrc3</a></td></tr>
<tr class="memdesc:ae0116e443faacf66ecf90a11c965f993"><td class="mdescLeft">&#160;</td><td class="mdescRight">TS24-TS31 mutual-tx mask. <br /></td></tr>
<tr class="separator:ae0116e443faacf66ecf90a11c965f993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af172abd0b31fa569830a3865f6853828"><td class="memItemLeft" align="right" valign="top"><a id="af172abd0b31fa569830a3865f6853828"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#af172abd0b31fa569830a3865f6853828">ctsuchtrc4</a></td></tr>
<tr class="memdesc:af172abd0b31fa569830a3865f6853828"><td class="mdescLeft">&#160;</td><td class="mdescRight">TS32-TS39 mutual-tx mask. <br /></td></tr>
<tr class="separator:af172abd0b31fa569830a3865f6853828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5618040797bc7f6b553122113748ab"><td class="memItemLeft" align="right" valign="top"><a id="a6c5618040797bc7f6b553122113748ab"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a6c5618040797bc7f6b553122113748ab">self_elem_index</a></td></tr>
<tr class="memdesc:a6c5618040797bc7f6b553122113748ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">self element index number for Current instance. <br /></td></tr>
<tr class="separator:a6c5618040797bc7f6b553122113748ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7409d810c8ac53b0182c1314207b21"><td class="memItemLeft" align="right" valign="top"><a id="adc7409d810c8ac53b0182c1314207b21"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#adc7409d810c8ac53b0182c1314207b21">mutual_elem_index</a></td></tr>
<tr class="memdesc:adc7409d810c8ac53b0182c1314207b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">mutual element index number for Current instance. <br /></td></tr>
<tr class="separator:adc7409d810c8ac53b0182c1314207b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd8b32a8bc2496d2605463945a87169"><td class="memItemLeft" align="right" valign="top"><a id="a0bd8b32a8bc2496d2605463945a87169"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a0bd8b32a8bc2496d2605463945a87169">ctsu_elem_index</a></td></tr>
<tr class="memdesc:a0bd8b32a8bc2496d2605463945a87169"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTSU element index number for Current instance. <br /></td></tr>
<tr class="separator:a0bd8b32a8bc2496d2605463945a87169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538262fc400f4a0095f2cd60ebb710a6"><td class="memItemLeft" align="right" valign="top"><a id="a538262fc400f4a0095f2cd60ebb710a6"></a>
<a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a> const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a538262fc400f4a0095f2cd60ebb710a6">p_ctsu_cfg</a></td></tr>
<tr class="memdesc:a538262fc400f4a0095f2cd60ebb710a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to initial configurations. <br /></td></tr>
<tr class="separator:a538262fc400f4a0095f2cd60ebb710a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a790f4de7d688d9a9f448a810be05f"><td class="memItemLeft" align="right" valign="top"><a id="aa4a790f4de7d688d9a9f448a810be05f"></a>
IRQn_Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#aa4a790f4de7d688d9a9f448a810be05f">write_irq</a></td></tr>
<tr class="memdesc:aa4a790f4de7d688d9a9f448a810be05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from config by Open API. CTSU_CTSUWR interrupt vector. <br /></td></tr>
<tr class="separator:aa4a790f4de7d688d9a9f448a810be05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422889992dd929096784b65c29c8780b"><td class="memItemLeft" align="right" valign="top"><a id="a422889992dd929096784b65c29c8780b"></a>
IRQn_Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a422889992dd929096784b65c29c8780b">read_irq</a></td></tr>
<tr class="memdesc:a422889992dd929096784b65c29c8780b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from config by Open API. CTSU_CTSURD interrupt vector. <br /></td></tr>
<tr class="separator:a422889992dd929096784b65c29c8780b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139bed35e18c276442ed790e2f49ad92"><td class="memItemLeft" align="right" valign="top"><a id="a139bed35e18c276442ed790e2f49ad92"></a>
IRQn_Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a139bed35e18c276442ed790e2f49ad92">end_irq</a></td></tr>
<tr class="memdesc:a139bed35e18c276442ed790e2f49ad92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from config by Open API. CTSU_CTSUFN interrupt vector. <br /></td></tr>
<tr class="separator:a139bed35e18c276442ed790e2f49ad92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c65e56730176fb25ab76ddb33b772ee"><td class="memItemLeft" align="right" valign="top"><a id="a0c65e56730176fb25ab76ddb33b772ee"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a0c65e56730176fb25ab76ddb33b772ee">p_callback</a> )(<a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__callback__args__t">ctsu_callback_args_t</a> *)</td></tr>
<tr class="memdesc:a0c65e56730176fb25ab76ddb33b772ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback provided when a CTSUFN occurs. <br /></td></tr>
<tr class="separator:a0c65e56730176fb25ab76ddb33b772ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f6a8656c90a6efeb22d35da9f07952"><td class="memItemLeft" align="right" valign="top"><a id="a16f6a8656c90a6efeb22d35da9f07952"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a16f6a8656c90a6efeb22d35da9f07952">interrupt_reverse_flag</a></td></tr>
<tr class="memdesc:a16f6a8656c90a6efeb22d35da9f07952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag in which read interrupt and end interrupt are reversed. <br /></td></tr>
<tr class="separator:a16f6a8656c90a6efeb22d35da9f07952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8feceb5a0f8f20795459c94d0c18bd5"><td class="memItemLeft" align="right" valign="top"><a id="aa8feceb5a0f8f20795459c94d0c18bd5"></a>
<a class="el" href="group___c_t_s_u___a_p_i.html#gaf6b0abb6cb3e6996d8435268d5e7c9cf">ctsu_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#aa8feceb5a0f8f20795459c94d0c18bd5">error_status</a></td></tr>
<tr class="memdesc:aa8feceb5a0f8f20795459c94d0c18bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">error status variable to send to QE for serial tuning. <br /></td></tr>
<tr class="separator:aa8feceb5a0f8f20795459c94d0c18bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042150cc9f3c41639dcd6bb989e6ba1e"><td class="memItemLeft" align="right" valign="top"><a id="a042150cc9f3c41639dcd6bb989e6ba1e"></a>
<a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__callback__args__t">ctsu_callback_args_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a042150cc9f3c41639dcd6bb989e6ba1e">p_callback_memory</a></td></tr>
<tr class="memdesc:a042150cc9f3c41639dcd6bb989e6ba1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to non-secure memory that can be used to pass arguments to a callback in non-secure memory. <br /></td></tr>
<tr class="separator:a042150cc9f3c41639dcd6bb989e6ba1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3493d9a66a667f943638459c3ba5392"><td class="memItemLeft" align="right" valign="top"><a id="ac3493d9a66a667f943638459c3ba5392"></a>
void const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ac3493d9a66a667f943638459c3ba5392">p_context</a></td></tr>
<tr class="memdesc:ac3493d9a66a667f943638459c3ba5392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placeholder for user data. <br /></td></tr>
<tr class="separator:ac3493d9a66a667f943638459c3ba5392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9630297d507bbd5d4f7ed56588d560ac"><td class="memItemLeft" align="right" valign="top"><a id="a9630297d507bbd5d4f7ed56588d560ac"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a9630297d507bbd5d4f7ed56588d560ac">serial_tuning_enable</a></td></tr>
<tr class="memdesc:a9630297d507bbd5d4f7ed56588d560ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag of serial tuning status. <br /></td></tr>
<tr class="separator:a9630297d507bbd5d4f7ed56588d560ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af566fb688739a5c442320bbb50ddf86a"><td class="memItemLeft" align="right" valign="top"><a id="af566fb688739a5c442320bbb50ddf86a"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#af566fb688739a5c442320bbb50ddf86a">serial_tuning_mutual_cnt</a></td></tr>
<tr class="memdesc:af566fb688739a5c442320bbb50ddf86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Word index into ctsuwr register array. <br /></td></tr>
<tr class="separator:af566fb688739a5c442320bbb50ddf86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd86e4b99d5cd0930a61d55cac6780a0"><td class="memItemLeft" align="right" valign="top"><a id="afd86e4b99d5cd0930a61d55cac6780a0"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#afd86e4b99d5cd0930a61d55cac6780a0">tuning_self_target_value</a></td></tr>
<tr class="memdesc:afd86e4b99d5cd0930a61d55cac6780a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Target self value for initial offset tuning. <br /></td></tr>
<tr class="separator:afd86e4b99d5cd0930a61d55cac6780a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b867400f41d3ae2908d179cde0ac61"><td class="memItemLeft" align="right" valign="top"><a id="a80b867400f41d3ae2908d179cde0ac61"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a80b867400f41d3ae2908d179cde0ac61">tuning_mutual_target_value</a></td></tr>
<tr class="memdesc:a80b867400f41d3ae2908d179cde0ac61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Target mutual value for initial offset tuning. <br /></td></tr>
<tr class="separator:a80b867400f41d3ae2908d179cde0ac61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga9be3b4466784415a4193f9584362c2ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9be3b4466784415a4193f9584362c2ce">&#9670;&nbsp;</a></span>ctsu_state_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_t_s_u.html#ga9be3b4466784415a4193f9584362c2ce">ctsu_state_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CTSU run state </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9be3b4466784415a4193f9584362c2cea728f7cac2f957376ddfdcb0a9bc7eb24"></a>CTSU_STATE_INIT&#160;</td><td class="fielddoc"><p>Not open. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9be3b4466784415a4193f9584362c2cead492927de253bafe181a3430d1ed6759"></a>CTSU_STATE_IDLE&#160;</td><td class="fielddoc"><p>Opened. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9be3b4466784415a4193f9584362c2ceaf35310abebbd7594def0fd113abc9009"></a>CTSU_STATE_SCANNING&#160;</td><td class="fielddoc"><p>Scanning now. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9be3b4466784415a4193f9584362c2ceaf5bf0b9c2914f02bc13287aaf25193a7"></a>CTSU_STATE_SCANNED&#160;</td><td class="fielddoc"><p>Scan end. </p>
</td></tr>
</table>

</div>
</div>
<a id="gae3fb0beb148069bb590287ed34771117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3fb0beb148069bb590287ed34771117">&#9670;&nbsp;</a></span>ctsu_tuning_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_t_s_u.html#gae3fb0beb148069bb590287ed34771117">ctsu_tuning_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CTSU Initial offset tuning status </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae3fb0beb148069bb590287ed34771117ac5b463f4f8d75c188535febbb8f3265b"></a>CTSU_TUNING_INCOMPLETE&#160;</td><td class="fielddoc"><p>Initial offset tuning incomplete. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae3fb0beb148069bb590287ed34771117ac3e474244bf3dfaeaf0d6f418d87cadd"></a>CTSU_TUNING_COMPLETE&#160;</td><td class="fielddoc"><p>Initial offset tuning complete. </p>
</td></tr>
</table>

</div>
</div>
<a id="gad7a98cce83446a25cc6d9fae6fa1296d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7a98cce83446a25cc6d9fae6fa1296d">&#9670;&nbsp;</a></span>ctsu_correction_status_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_t_s_u.html#gad7a98cce83446a25cc6d9fae6fa1296d">ctsu_correction_status_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CTSU Correction status </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad7a98cce83446a25cc6d9fae6fa1296da544177e8ae7de2375f436f67d8f0fe85"></a>CTSU_CORRECTION_INIT&#160;</td><td class="fielddoc"><p>Correction initial status. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7a98cce83446a25cc6d9fae6fa1296da226216e141c9645a7b026e71552fff8b"></a>CTSU_CORRECTION_RUN&#160;</td><td class="fielddoc"><p>Correction scan running. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7a98cce83446a25cc6d9fae6fa1296da547ad26a74b30f6abc040e88ca531b1d"></a>CTSU_CORRECTION_COMPLETE&#160;</td><td class="fielddoc"><p>Correction complete. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7a98cce83446a25cc6d9fae6fa1296da9ca74c2bfb3ebcc87035a6c9eec1b12f"></a>CTSU_CORRECTION_ERROR&#160;</td><td class="fielddoc"><p>Correction error. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga07d91c963664201accc65a9d45fb817a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07d91c963664201accc65a9d45fb817a">&#9670;&nbsp;</a></span>ctsu_range_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_t_s_u.html#ga07d91c963664201accc65a9d45fb817a">ctsu_range_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CTSU range definition </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga07d91c963664201accc65a9d45fb817aa18e0227acbd85f4a0e698e66e10ff399"></a>CTSU_RANGE_20UA&#160;</td><td class="fielddoc"><p>20uA mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga07d91c963664201accc65a9d45fb817aa8f4c9333b63b727e17dbe5cb1bba2b5d"></a>CTSU_RANGE_40UA&#160;</td><td class="fielddoc"><p>40uA mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga07d91c963664201accc65a9d45fb817aabe7fe0af42bd5680a187198d0a940b65"></a>CTSU_RANGE_80UA&#160;</td><td class="fielddoc"><p>80uA mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga07d91c963664201accc65a9d45fb817aa245c0b1c0e2c81523be95944d61438ea"></a>CTSU_RANGE_160UA&#160;</td><td class="fielddoc"><p>160uA mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga07d91c963664201accc65a9d45fb817aa7c1c26d795d57571c5b9441ea18f626d"></a>CTSU_RANGE_NUM&#160;</td><td class="fielddoc"><p>number of range </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga4e625d8c9f3b301a46913c5827732682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e625d8c9f3b301a46913c5827732682">&#9670;&nbsp;</a></span>R_CTSU_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_CTSU_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens and configures the CTSU driver module. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#ae8f2c7b3cc9e33f0f790f76655d3d723">ctsu_api_t::open</a>. </p>
<p>Example: </p><div class="fragment"><div class="line">    err = <a class="code" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a>(&amp;g_ctsu_ctrl, &amp;g_ctsu_cfg);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>CTSU successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer, or one or more configuration options is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Module is already open. This module can only be opened once. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ARGUMENT</td><td>Configuration parameter error.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In the first Open, measurement for correction works, and it takes several tens of milliseconds. </dd></dl>

</div>
</div>
<a id="ga46cf185922bbca921cb92b4c18f62525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46cf185922bbca921cb92b4c18f62525">&#9670;&nbsp;</a></span>R_CTSU_ScanStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_CTSU_ScanStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function should be called each time a periodic timer expires. If initial offset tuning is enabled, The first several calls are used to tuning for the sensors. Before starting the next scan, first get the data with <a class="el" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe" title="This function gets the sensor values as scanned by the CTSU. If initial offset tuning is enabled...">R_CTSU_DataGet()</a>. If a different control block scan should be run, check the scan is complete before executing. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#a1df87278ab5d47fdd093994f53de96a6">ctsu_api_t::scanStart</a>. </p>
<p>Example: </p><div class="fragment"><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a>(&amp;g_ctsu_ctrl, data);</div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Application specific data processing. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>CTSU successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_SCANNING</td><td>Scanning this instance or other. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_NOT_GET_DATA</td><td>The previous data has not been retrieved by DataGet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1cff42feeaa3d73216b73c313fb9a5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cff42feeaa3d73216b73c313fb9a5fe">&#9670;&nbsp;</a></span>R_CTSU_DataGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_CTSU_DataGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>p_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the sensor values as scanned by the CTSU. If initial offset tuning is enabled, The first several calls are used to tuning for the sensors. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#aadcc6930b4e9d0ad86b6f607e86c28f5">ctsu_api_t::dataGet</a>. </p>
<p>Example: </p><div class="fragment"><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a>(&amp;g_ctsu_ctrl, data);</div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Application specific data processing. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>CTSU successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_SCANNING</td><td>Scanning this instance. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_INCOMPLETE_TUNING</td><td>Incomplete initial offset tuning. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_NOT_YET</td><td>Diagnosis of data collected no yet. </td></tr>
    <tr><td class="paramname">FSP_ERR_ABORTED</td><td>Operate error of Diagnosis ADC data collection ,since ADC use other </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga04263b8b45802780c9e072e19414ba7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04263b8b45802780c9e072e19414ba7e">&#9670;&nbsp;</a></span>R_CTSU_OffsetTuning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_CTSU_OffsetTuning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tunes the offset register(SO). Call after the measurement is completed. If the return value is FSP_ERR_CTSU_INCOMPLETE_TUNING, tuning is not complete. Execute the measurement and this function call routine until the return value becomes FSP_SUCCESS. It is recommended to run this routine after <a class="el" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682" title="Opens and configures the CTSU driver module. Implements ctsu_api_t::open. ">R_CTSU_Open()</a>. It can be recalled and tuned again. When the automatic judgement is enabled, after the offset tuning is completed,the baseline initialization bit flag is set. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#a5c1e1ab640eec8358e7ef92de31fcdc8">ctsu_api_t::offsetTuning</a>. </p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Initial offset tuning */</span></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga04263b8b45802780c9e072e19414ba7e">R_CTSU_OffsetTuning</a>(&amp;g_ctsu_ctrl);</div><div class="line">    } <span class="keywordflow">while</span> (FSP_SUCCESS != err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a>(&amp;g_ctsu_ctrl, data);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Re-offset tuning is performed when the parasitic capacitance changes significantly due   */</span></div><div class="line">            <span class="comment">/* to changes in the surrounding environment and the count value becomes an abnormal value. */</span></div><div class="line">            <span class="comment">/*                                                                                          */</span></div><div class="line">            <span class="comment">/* if (abnormal value detection conditions)                                                 */</span></div><div class="line">            <span class="comment">/* {                                                                                        */</span></div><div class="line">            <span class="comment">/* Re-offset tuning */</span></div><div class="line">            <span class="keywordflow">do</span></div><div class="line">            {</div><div class="line">                <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">                <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">                {</div><div class="line">                    <span class="comment">/* Wait for scan end callback */</span></div><div class="line">                }</div><div class="line"></div><div class="line">                g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                err = <a class="code" href="group___c_t_s_u.html#ga04263b8b45802780c9e072e19414ba7e">R_CTSU_OffsetTuning</a>(&amp;g_ctsu_ctrl);</div><div class="line">            } <span class="keywordflow">while</span> (FSP_SUCCESS != err);</div><div class="line"></div><div class="line">            <span class="comment">/* }                                                                                        */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>CTSU successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_SCANNING</td><td>Scanning this instance. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_INCOMPLETE_TUNING</td><td>Incomplete initial offset tuning. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac88d0518c996cb44643a82818b961485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac88d0518c996cb44643a82818b961485">&#9670;&nbsp;</a></span>R_CTSU_ScanStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_CTSU_ScanStop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function scan stops the sensor as scanning by the CTSU. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#ac21a98eaa673d72b7da701ba90093f59">ctsu_api_t::scanStop</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>CTSU successfully scan stop. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3c966546f3774ce2228739a5ffc0ac19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c966546f3774ce2228739a5ffc0ac19">&#9670;&nbsp;</a></span>R_CTSU_CallbackSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_CTSU_CallbackSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__callback__args__t">ctsu_callback_args_t</a> *)&#160;</td>
          <td class="paramname"><em>p_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>p_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__callback__args__t">ctsu_callback_args_t</a> *const&#160;</td>
          <td class="paramname"><em>p_callback_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the user callback and has option of providing memory for callback structure. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#adda480537f35733dbed856a30b89be50">ctsu_api_t::callbackSet</a></p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Callback updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_NO_CALLBACK_MEMORY</td><td>p_callback is non-secure and p_callback_memory is either secure or NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga73b45020c568d57065c8a7adecaaeb4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73b45020c568d57065c8a7adecaaeb4c">&#9670;&nbsp;</a></span>R_CTSU_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_CTSU_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables specified CTSU control block. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#aeb44bb4a59bad9025f0897cee306a395">ctsu_api_t::close</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>CTSU successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga32a5f61231501fb64c85fa52791b0e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32a5f61231501fb64c85fa52791b0e79">&#9670;&nbsp;</a></span>R_CTSU_SpecificDataGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_CTSU_SpecificDataGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>p_specific_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#ga1fe870ee0162807f8f9387749ba4e0a6">ctsu_specific_data_type_t</a>&#160;</td>
          <td class="paramname"><em>specific_data_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the sensor specific data values as scanned by the CTSU. Call this function after calling the <a class="el" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe" title="This function gets the sensor values as scanned by the CTSU. If initial offset tuning is enabled...">R_CTSU_DataGet()</a> function. </p>
<p>By setting the third argument to CTSU_SPECIFIC_RAW_DATA, RAW data can be output from the second argument.</p>
<p>By setting the third argument to CTSU_SPECIFIC_CORRECTION_DATA, the corrected data can be output from the second argument.</p>
<p>By setting the third argument to CTSU_SPECIFIC_SELECTED_DATA, Get bitmap of the frequency values used in majority decision from the second argument. The bitmap is shown as follows.</p>
<table class="doxtable">
<tr>
<th>2bit </th><th>1bit </th><th>0bit  </th></tr>
<tr>
<td>3rd frequency value </td><td>2nd frequency value </td><td>1st frequency value </td></tr>
</table>
<p>Implements <a class="el" href="group___c_t_s_u___a_p_i.html#adf2f74b741c739e9e21b1ce544292872">ctsu_api_t::specificDataGet</a>.</p>
<p>Example: </p><div class="fragment"><div class="line">            err = <a class="code" href="group___c_t_s_u.html#ga32a5f61231501fb64c85fa52791b0e79">R_CTSU_SpecificDataGet</a>(&amp;g_ctsu_ctrl, corr_data, CTSU_SPECIFIC_CORRECTION_DATA);</div><div class="line"></div></div><!-- fragment --><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>CTSU successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_SCANNING</td><td>Scanning this instance. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_INCOMPLETE_TUNING</td><td>Incomplete initial offset tuning. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_ENABLED</td><td>CTSU_SPECIFIC_SELECTED_FREQ is not enabled in CTSU1.(CTSU2 Only) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac51fca87e02d589bcdeb894b99f7a08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac51fca87e02d589bcdeb894b99f7a08e">&#9670;&nbsp;</a></span>R_CTSU_DataInsert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_CTSU_DataInsert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>p_insert_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function inserts the value of the second argument as the measurement result value. Call this function after calling the <a class="el" href="group___c_t_s_u.html#gac51fca87e02d589bcdeb894b99f7a08e" title="This function inserts the value of the second argument as the measurement result value. Call this function after calling the R_CTSU_DataInsert() function. Implements ctsu_api_t::dataInsert. ">R_CTSU_DataInsert()</a> function. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#a84dfd5dd2ab6b16465cc5c06953c6a9f">ctsu_api_t::dataInsert</a>. </p>
<p>Example: </p><div class="fragment"><div class="line">            err = <a class="code" href="group___c_t_s_u.html#gac51fca87e02d589bcdeb894b99f7a08e">R_CTSU_DataInsert</a>(&amp;g_ctsu_ctrl, filter_data);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>CTSU successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_SCANNING</td><td>Scanning this instance. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_INCOMPLETE_TUNING</td><td>Incomplete initial offset tuning. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga45103e8db4a16dfabf3a516ab2da9f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45103e8db4a16dfabf3a516ab2da9f26">&#9670;&nbsp;</a></span>R_CTSU_Diagnosis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_CTSU_Diagnosis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Diagnosis the CTSU peripheral. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#a42a81fef42f2bf61bde59cba4796cc0e">ctsu_api_t::diagnosis</a>. </p>
<p>Example: </p><div class="fragment"><div class="line">            err = <a class="code" href="group___c_t_s_u.html#ga45103e8db4a16dfabf3a516ab2da9f26">R_CTSU_Diagnosis</a>(&amp;g_ctsu_ctrl_diagnosis);</div><div class="line">            assert(FSP_SUCCESS == err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>CTSU successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_NOT_GET_DATA</td><td>The previous data has not been retrieved by DataGet. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_LDO_OVER_VOLTAGE</td><td>Diagnosis of LDO over voltage failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_CCO_HIGH</td><td>Diagnosis of CCO into 19.2uA failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_CCO_LOW</td><td>Diagnosis of CCO into 2.4uA failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_SSCG</td><td>Diagnosis of SSCG frequency failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_DAC</td><td>Diagnosis of non-touch count value failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_OUTPUT_VOLTAGE</td><td>Diagnosis of LDO output voltage failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_OVER_VOLTAGE</td><td>Diagnosis of over voltage detection circuit failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_OVER_CURRENT</td><td>Diagnosis of over current detection circuit failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_LOAD_RESISTANCE</td><td>Diagnosis of LDO internal resistance value failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_CURRENT_SOURCE</td><td>Diagnosis of LDO internal resistance value failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_SENSCLK_GAIN</td><td>Diagnosis of SENSCLK frequency gain failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_SUCLK_GAIN</td><td>Diagnosis of SUCLK frequency gain failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_CLOCK_RECOVERY</td><td>Diagnosis of SUCLK clock recovery function failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_CFC_GAIN</td><td>Diagnosis of CFC oscillator gain failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v4.2.0 User's Manual Copyright © (2022) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
