<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: Serial Communications Interface (SCI) I2C (r_sci_i2c)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v1.2.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___s_c_i___i2_c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<div class="title">Serial Communications Interface (SCI) I2C (r_sci_i2c)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga075bd36361ec44fc1dc964248db8c7ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_i___i2_c.html#ga075bd36361ec44fc1dc964248db8c7ff">R_SCI_I2C_VersionGet</a> (<a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#unionfsp__version__t">fsp_version_t</a> *const p_version)</td></tr>
<tr class="separator:ga075bd36361ec44fc1dc964248db8c7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddcd4299259f33f1586458c6f580ef4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_i___i2_c.html#gaddcd4299259f33f1586458c6f580ef4c">R_SCI_I2C_Open</a> (<a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga87f5194ba16044322815db81dc442138">i2c_master_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#structi2c__master__cfg__t">i2c_master_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:gaddcd4299259f33f1586458c6f580ef4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ce2bd61f5a153cd7957c4a1b1350df8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_i___i2_c.html#ga6ce2bd61f5a153cd7957c4a1b1350df8">R_SCI_I2C_Close</a> (<a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga87f5194ba16044322815db81dc442138">i2c_master_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:ga6ce2bd61f5a153cd7957c4a1b1350df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad044a875458d5878769a8f4b4b5e038f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_i___i2_c.html#gad044a875458d5878769a8f4b4b5e038f">R_SCI_I2C_Read</a> (<a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga87f5194ba16044322815db81dc442138">i2c_master_ctrl_t</a> *const p_api_ctrl, uint8_t *const p_dest, uint32_t const bytes, bool const restart)</td></tr>
<tr class="separator:gad044a875458d5878769a8f4b4b5e038f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bb2633c299214aa6c1779aa39d8df0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_i___i2_c.html#ga7bb2633c299214aa6c1779aa39d8df0c">R_SCI_I2C_Write</a> (<a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga87f5194ba16044322815db81dc442138">i2c_master_ctrl_t</a> *const p_api_ctrl, uint8_t *const p_src, uint32_t const bytes, bool const restart)</td></tr>
<tr class="separator:ga7bb2633c299214aa6c1779aa39d8df0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga417258e6c32f4000c95198a60f2a699d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_i___i2_c.html#ga417258e6c32f4000c95198a60f2a699d">R_SCI_I2C_Abort</a> (<a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga87f5194ba16044322815db81dc442138">i2c_master_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:ga417258e6c32f4000c95198a60f2a699d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafb153ace0acecf6d61037ed2113c6da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_i___i2_c.html#gaafb153ace0acecf6d61037ed2113c6da">R_SCI_I2C_SlaveAddressSet</a> (<a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga87f5194ba16044322815db81dc442138">i2c_master_ctrl_t</a> *const p_api_ctrl, uint32_t const slave, <a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga6203bcd8d8127b8fd442a2d33d112940">i2c_master_addr_mode_t</a> const addr_mode)</td></tr>
<tr class="separator:gaafb153ace0acecf6d61037ed2113c6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the SCI peripheral on RA MCUs. This module implements the <a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html">I2C Master Interface</a>. </p>
<h1><a class="anchor" id="r-sci_i2c-overview"></a>
Overview</h1>
<p>The Simple I2C master on SCI HAL module supports transactions with an I2C Slave device. Callbacks must be provided which would be invoked when a transmission or receive has been completed. The callback arguments will contain information about the transaction status, bytes transferred and a pointer to the user defined context.</p>
<h2><a class="anchor" id="r-sci_i2c-features"></a>
Features</h2>
<ul>
<li>Supports multiple transmission rates<ul>
<li><a class="anchor" id="um_i2c_master_standard_mode_clock_rate_configuration"></a>Standard Mode Support with up to 100 kHz transaction rate.</li>
<li><a class="anchor" id="um_i2c_master_fast_mode_clock_rate_configuration"></a>Fast Mode Support with up to 400 kHz transaction rate.</li>
</ul>
</li>
<li>SDA Delay in nanoseconds can be specified as a part of the configuration.</li>
<li><a class="anchor" id="um_i2c_master_read_from_slave_device"></a>I2C Master Read from a slave device.</li>
<li><a class="anchor" id="um_i2c_master_write_to_slave_device"></a>I2C Master Write to a slave device.</li>
<li><a class="anchor" id="um_i2c_master_abort_i2c_peripheral"></a>Abort any in-progress transactions.</li>
<li><a class="anchor" id="um_i2c_master_change_slave_address_at_run_time"></a>Set the address of the slave device.</li>
<li><a class="anchor" id="um_i2c_master_notify_generated_event_via_callback"></a>Non-blocking behavior is achieved by the use of callbacks.</li>
<li>Additional build-time features<ul>
<li><a class="anchor" id="um_i2c_master_optional_dtc_support_for_data_transfer"></a>Optional (build time) DTC support for read and write respectively.</li>
<li><a class="anchor" id="um_i2c_master_optional_10_bit_slave_addressing"></a>Optional (build time) support for 10-bit slave addressing.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="r-sci_i2c-configuration"></a>
Configuration</h1>
<p><h2>Build Time Configurations for r_sci_i2c</h2>
The following build time configurations are defined in fsp_cfg/r_sci_i2c_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr>
<td>DTC on Transmission and Reception</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>If enabled, DTC instances will be included in the build for both transmission and reception. </td></tr>
<tr>
<td>10-bit slave addressing</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>If enabled, the driver will support 10-bit slave addressing mode along with the default 7-bit slave addressing mode. </td></tr>
</table>
 <h2>Configurations for Driver &gt; Connectivity &gt; I2C Master Driver on r_sci_i2c</h2>
This module can be added to the Stacks tab via New Stack &gt; Driver &gt; Connectivity &gt; I2C Master Driver on r_sci_i2c:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Name</td><td>Name must be a valid C symbol</td><td>g_i2c0 </td><td>Module name. </td></tr>
<tr>
<td>Channel</td><td>Value must be an integer between 0 and 9</td><td>0 </td><td>Select the SCI channel. </td></tr>
<tr>
<td>Slave Address </td><td>Value must be a hex value</td><td>0x00 </td><td>Specify the slave address. </td></tr>
<tr>
<td>Address Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
7-Bit</li>
<li>
10-Bit</li>
</ul>
</td><td>7-Bit </td><td>Select the address mode. </td></tr>
<tr>
<td>Rate</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Standard</li>
<li>
Fast-mode</li>
</ul>
</td><td>Standard </td><td>Select the I2C data rate. </td></tr>
<tr>
<td>SDA Output Delay (nano seconds)</td><td>Must be a valid non-negative integer with maximum configurable value of 300</td><td>300 </td><td>Specify the SDA output delay in nanoseconds. </td></tr>
<tr>
<td>Noise filter setting</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Use clock signal divided by 1 with noise filter</li>
<li>
Use clock signal divided by 2 with noise filter</li>
<li>
Use clock signal divided by 4 with noise filter</li>
<li>
Use clock signal divided by 8 with noise filter</li>
</ul>
</td><td>Use clock signal divided by 1 with noise filter </td><td>Select the sampling clock for the digital noise filter </td></tr>
<tr>
<td>Bit Rate Modulation</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enable</li>
<li>
Disable</li>
</ul>
</td><td>Enable </td><td>Enabling bitrate modulation reduces the percent error of the actual bitrate with respect to the requested baud rate. It does this by modulating the number of cycles per clock output pulse, so the clock is no longer a square wave. </td></tr>
<tr>
<td>Callback</td><td>Name must be a valid C symbol</td><td>sci_i2c_master_callback </td><td>A user callback function can be provided. If this callback function is provided, it will be called from the interrupt service routine (ISR). </td></tr>
<tr>
<td>Interrupt Priority Level</td><td>MCU Specific Options</td><td></td><td>Select the interrupt priority level. This is set for TXI, RXI (if used), TEI interrupts. </td></tr>
<tr>
<td>RX Interrupt Priority Level [Only used when DTC is enabled]</td><td>MCU Specific Options</td><td></td><td>Select the interrupt priority level. This is set for RXI only when DTC is enabled. </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-sci_i2c-clock-configuration"></a>
Clock Configuration</h2>
<p>The SCI I2C peripheral module uses either PCLKA or PCLKB (depending on the MCU) as its clock source. The actual I2C transfer rate will be calculated and set by the tooling depending on the selected transfer rate and the SDA delay. If the PCLK is configured in such a manner that the selected internal rate cannot be achieved, an error will be returned.</p>
<h2><a class="anchor" id="r-sci_i2c-pin-configuration"></a>
Pin Configuration</h2>
<p>The SCI I2C peripheral module uses pins on the MCU to communicate to external devices. I/O pins must be selected and configured as required by the external device. An I2C channel would consist of two pins - SDA and SCL for data/address and clock respectively.</p>
<h1><a class="anchor" id="r-sci_i2c-usage_notes"></a>
Usage Notes</h1>
<h2><a class="anchor" id="r-sci_i2c-interrupt-configuration"></a>
Interrupt Configuration</h2>
<ul>
<li>Receive buffer full (RXI), transmit buffer empty (TXI) and transmit end (TEI) interrupts for the selected channel used must be enabled in the properties of the selected device.</li>
<li>Set equal priority levels for all the interrupts mentioned above. Setting the interrupts to different priority levels could result in improper operation.</li>
</ul>
<h2><a class="anchor" id="r-sci_i2c-rate_calculation"></a>
SCI I2C Master Rate Calculation</h2>
<ul>
<li>The RA Configuration editor calculates the internal baud-rate setting based on the configured transfer rate and SDA Delay. The closest possible baud-rate that can be achieved (less than or equal to the requested rate) at the current PCLK settings is calculated and used.</li>
<li>If a valid clock rate could not be calculated, an error is returned by the tool.</li>
</ul>
<h2><a class="anchor" id="r-sci_i2c-enabling-dtc"></a>
Enabling DTC with the SCI I2C</h2>
<ul>
<li>DTC transfer support is configurable and is disabled from the build by default. SCI I2C driver provides two DTC instances for transmission and reception respectively.</li>
<li>For further details on DTC please refer <a class="el" href="group___d_t_c.html">Data Transfer Controller (r_dtc)</a></li>
</ul>
<h2><a class="anchor" id="r-sci_i2c-multiple-devices-on-same-bus"></a>
Multiple Devices on the Bus</h2>
<ul>
<li>A single SCI I2C instance can be used to communicate with multiple slave devices on the same channel by using the SlaveAddressSet API.</li>
</ul>
<h2><a class="anchor" id="r-sci_i2c-restart"></a>
Restart</h2>
<ul>
<li>SCI I2C master can hold the the bus after an I2C transaction by issuing Restart. This will mimic a stop followed by start condition.</li>
</ul>
<h1><a class="anchor" id="r-sci_i2c-examples"></a>
Examples</h1>
<h2>Basic Example</h2>
<p>This is a basic example of minimal use of the r_sci_i2c in an application. This example shows how this driver can be used for basic read and write operations.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err;</div><div class="line">    uint32_t  i;</div><div class="line">    uint32_t  timeout_ms = I2C_TRANSACTION_BUSY_DELAY;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the IIC module */</span></div><div class="line">    err = <a class="code" href="group___s_c_i___i2_c.html#gaddcd4299259f33f1586458c6f580ef4c">R_SCI_I2C_Open</a>(&amp;g_i2c_device_ctrl_1, &amp;g_i2c_device_cfg_1);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    <span class="comment">/* Write some data to the transmit buffer */</span></div><div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; I2C_BUFFER_SIZE_BYTES; i++)</div><div class="line">    {</div><div class="line">        g_i2c_tx_buffer[i] = (uint8_t) i;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Send data to I2C slave */</span></div><div class="line">    g_i2c_callback_event = <a class="code" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#gga515f0c8b583f8851ce4d6474168769afa22226fd293eb8a7f80e4a80ca8699a4d">I2C_MASTER_EVENT_ABORTED</a>;</div><div class="line"></div><div class="line"></div><div class="line">    err = <a class="code" href="group___s_c_i___i2_c.html#ga7bb2633c299214aa6c1779aa39d8df0c">R_SCI_I2C_Write</a>(&amp;g_i2c_device_ctrl_1, &amp;g_i2c_tx_buffer[0], I2C_BUFFER_SIZE_BYTES, <span class="keyword">false</span>);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Since there is nothing else to do, block until Callback triggers*/</span></div><div class="line">    <span class="keywordflow">while</span> ((<a class="code" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#gga515f0c8b583f8851ce4d6474168769afa9273437457da4f6369e937d257c0211b">I2C_MASTER_EVENT_TX_COMPLETE</a> != g_i2c_callback_event) &amp;&amp; timeout_ms)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___b_s_p___m_c_u.html#gaf3219448adfd1531cf69f68697ab184b">R_BSP_SoftwareDelay</a>(1U, <a class="code" href="group___b_s_p___m_c_u.html#ggafd98e2a6f080d6a52a3ef72e3d731b2ba59fcc4e8d51046d4a1bd63c87ac64913">BSP_DELAY_UNITS_MILLISECONDS</a>);</div><div class="line">        timeout_ms--;;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#gga515f0c8b583f8851ce4d6474168769afa22226fd293eb8a7f80e4a80ca8699a4d">I2C_MASTER_EVENT_ABORTED</a> == g_i2c_callback_event)</div><div class="line">    {</div><div class="line">        __BKPT(0);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Read data back from the I2C slave */</span></div><div class="line">    g_i2c_callback_event = <a class="code" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#gga515f0c8b583f8851ce4d6474168769afa22226fd293eb8a7f80e4a80ca8699a4d">I2C_MASTER_EVENT_ABORTED</a>;</div><div class="line">    timeout_ms           = I2C_TRANSACTION_BUSY_DELAY;</div><div class="line"></div><div class="line"></div><div class="line">    err = <a class="code" href="group___s_c_i___i2_c.html#gad044a875458d5878769a8f4b4b5e038f">R_SCI_I2C_Read</a>(&amp;g_i2c_device_ctrl_1, &amp;g_i2c_rx_buffer[0], I2C_BUFFER_SIZE_BYTES, <span class="keyword">false</span>);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Since there is nothing else to do, block until Callback triggers*/</span></div><div class="line">    <span class="keywordflow">while</span> ((<a class="code" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#gga515f0c8b583f8851ce4d6474168769afa1b3d50a1a4fbf045307febd9eca1521a">I2C_MASTER_EVENT_RX_COMPLETE</a> != g_i2c_callback_event) &amp;&amp; timeout_ms)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___b_s_p___m_c_u.html#gaf3219448adfd1531cf69f68697ab184b">R_BSP_SoftwareDelay</a>(1U, <a class="code" href="group___b_s_p___m_c_u.html#ggafd98e2a6f080d6a52a3ef72e3d731b2ba59fcc4e8d51046d4a1bd63c87ac64913">BSP_DELAY_UNITS_MILLISECONDS</a>);</div><div class="line">        timeout_ms--;;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#gga515f0c8b583f8851ce4d6474168769afa22226fd293eb8a7f80e4a80ca8699a4d">I2C_MASTER_EVENT_ABORTED</a> == g_i2c_callback_event)</div><div class="line">    {</div><div class="line">        __BKPT(0);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Verify the read data */</span></div><div class="line">    <span class="keywordflow">if</span> (0U != memcmp(g_i2c_tx_buffer, g_i2c_rx_buffer, I2C_BUFFER_SIZE_BYTES))</div><div class="line">    {</div><div class="line">        __BKPT(0);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Multiple Slave devices on the same channel (bus)</h2>
<p>This example demonstrates how a single SCI I2C driver can be used to communicate with different slave devices which are on the same channel.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> single_channel_multi_slave (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err;</div><div class="line">    uint32_t  timeout_ms = I2C_TRANSACTION_BUSY_DELAY;</div><div class="line"></div><div class="line">    err = <a class="code" href="group___s_c_i___i2_c.html#gaddcd4299259f33f1586458c6f580ef4c">R_SCI_I2C_Open</a>(&amp;g_i2c_device_ctrl_2, &amp;g_i2c_device_cfg_2);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    <span class="comment">/* Clear the recieve buffer */</span></div><div class="line">    memset(g_i2c_rx_buffer, <span class="charliteral">&#39;0&#39;</span>, I2C_BUFFER_SIZE_BYTES);</div><div class="line"></div><div class="line">    <span class="comment">/* Read data from I2C slave */</span></div><div class="line">    g_i2c_callback_event = <a class="code" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#gga515f0c8b583f8851ce4d6474168769afa22226fd293eb8a7f80e4a80ca8699a4d">I2C_MASTER_EVENT_ABORTED</a>;</div><div class="line">    err = <a class="code" href="group___s_c_i___i2_c.html#gad044a875458d5878769a8f4b4b5e038f">R_SCI_I2C_Read</a>(&amp;g_i2c_device_ctrl_2, &amp;g_i2c_rx_buffer[0], I2C_BUFFER_SIZE_BYTES, <span class="keyword">false</span>);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> ((<a class="code" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#gga515f0c8b583f8851ce4d6474168769afa1b3d50a1a4fbf045307febd9eca1521a">I2C_MASTER_EVENT_RX_COMPLETE</a> != g_i2c_callback_event) &amp;&amp; timeout_ms)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___b_s_p___m_c_u.html#gaf3219448adfd1531cf69f68697ab184b">R_BSP_SoftwareDelay</a>(1U, <a class="code" href="group___b_s_p___m_c_u.html#ggafd98e2a6f080d6a52a3ef72e3d731b2ba59fcc4e8d51046d4a1bd63c87ac64913">BSP_DELAY_UNITS_MILLISECONDS</a>);</div><div class="line">        timeout_ms--;;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#gga515f0c8b583f8851ce4d6474168769afa22226fd293eb8a7f80e4a80ca8699a4d">I2C_MASTER_EVENT_ABORTED</a> == g_i2c_callback_event)</div><div class="line">    {</div><div class="line">        __BKPT(0);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Send data to I2C slave on the same channel */</span></div><div class="line">    err = <a class="code" href="group___s_c_i___i2_c.html#gaafb153ace0acecf6d61037ed2113c6da">R_SCI_I2C_SlaveAddressSet</a>(&amp;g_i2c_device_ctrl_2, I2C_SLAVE_DISPLAY_ADAPTER, <a class="code" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#gga6203bcd8d8127b8fd442a2d33d112940ab42fbd73d951db4694494c5acfa19dd8">I2C_MASTER_ADDR_MODE_7BIT</a>);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    g_i2c_tx_buffer[0]   = (uint8_t) I2C_EXAMPLE_DATA_1;</div><div class="line">    g_i2c_tx_buffer[1]   = (uint8_t) I2C_EXAMPLE_DATA_2;</div><div class="line">    g_i2c_callback_event = <a class="code" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#gga515f0c8b583f8851ce4d6474168769afa22226fd293eb8a7f80e4a80ca8699a4d">I2C_MASTER_EVENT_ABORTED</a>;</div><div class="line">    timeout_ms           = I2C_TRANSACTION_BUSY_DELAY;</div><div class="line">    err = <a class="code" href="group___s_c_i___i2_c.html#ga7bb2633c299214aa6c1779aa39d8df0c">R_SCI_I2C_Write</a>(&amp;g_i2c_device_ctrl_2, &amp;g_i2c_tx_buffer[0], 2U, <span class="keyword">false</span>);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> ((<a class="code" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#gga515f0c8b583f8851ce4d6474168769afa9273437457da4f6369e937d257c0211b">I2C_MASTER_EVENT_TX_COMPLETE</a> != g_i2c_callback_event) &amp;&amp; timeout_ms)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___b_s_p___m_c_u.html#gaf3219448adfd1531cf69f68697ab184b">R_BSP_SoftwareDelay</a>(1U, <a class="code" href="group___b_s_p___m_c_u.html#ggafd98e2a6f080d6a52a3ef72e3d731b2ba59fcc4e8d51046d4a1bd63c87ac64913">BSP_DELAY_UNITS_MILLISECONDS</a>);</div><div class="line">        timeout_ms--;;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#gga515f0c8b583f8851ce4d6474168769afa22226fd293eb8a7f80e4a80ca8699a4d">I2C_MASTER_EVENT_ABORTED</a> == g_i2c_callback_event)</div><div class="line">    {</div><div class="line">        __BKPT(0);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structsci__i2c__clock__settings__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_i___i2_c.html#structsci__i2c__clock__settings__t">sci_i2c_clock_settings_t</a></td></tr>
<tr class="separator:structsci__i2c__clock__settings__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsci__i2c__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_i___i2_c.html#structsci__i2c__instance__ctrl__t">sci_i2c_instance_ctrl_t</a></td></tr>
<tr class="separator:structsci__i2c__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsci__i2c__extended__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_i___i2_c.html#structsci__i2c__extended__cfg__t">sci_i2c_extended_cfg_t</a></td></tr>
<tr class="separator:structsci__i2c__extended__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structsci__i2c__clock__settings__t" id="structsci__i2c__clock__settings__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structsci__i2c__clock__settings__t">&#9670;&nbsp;</a></span>sci_i2c_clock_settings_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sci_i2c_clock_settings_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>I2C clock settings </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a880d8113fcc8b178207d73e61405d614"></a>bool</td>
<td class="fieldname">
bitrate_modulation</td>
<td class="fielddoc">
Bit-rate Modulation Function enable or disable. </td></tr>
<tr><td class="fieldtype">
<a id="a5aee024389304363d286ce4b8c82f0c7"></a>uint8_t</td>
<td class="fieldname">
brr_value</td>
<td class="fielddoc">
Bit rate register settings. </td></tr>
<tr><td class="fieldtype">
<a id="a0f00a71bedd128489acaf6ef050cbf64"></a>uint8_t</td>
<td class="fieldname">
clk_divisor_value</td>
<td class="fielddoc">
Clock Select settings. </td></tr>
<tr><td class="fieldtype">
<a id="a104f665a62ee531371d56b5d950fea36"></a>uint8_t</td>
<td class="fieldname">
mddr_value</td>
<td class="fielddoc">
Modulation Duty Register settings. </td></tr>
<tr><td class="fieldtype">
<a id="a3d2c9d58afec4a6a86a88a106280157b"></a>uint8_t</td>
<td class="fieldname">
cycles_value</td>
<td class="fielddoc">
SDA Delay Output Cycles Select. </td></tr>
<tr><td class="fieldtype">
<a id="ad7d5b1653f03ca2eb63692763fbe1493"></a>uint8_t</td>
<td class="fieldname">
snfr_value</td>
<td class="fielddoc">
Noise Filter Setting Register value. </td></tr>
</table>

</div>
</div>
<a name="structsci__i2c__instance__ctrl__t" id="structsci__i2c__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structsci__i2c__instance__ctrl__t">&#9670;&nbsp;</a></span>sci_i2c_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sci_i2c_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>I2C control structure. DO NOT INITIALIZE. </p>
</div>
</div>
</div>
<a name="structsci__i2c__extended__cfg__t" id="structsci__i2c__extended__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structsci__i2c__extended__cfg__t">&#9670;&nbsp;</a></span>sci_i2c_extended_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sci_i2c_extended_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>SCI I2C extended configuration </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a8695398d7f739c6335fed576df646973"></a><a class="el" href="group___s_c_i___i2_c.html#structsci__i2c__clock__settings__t">sci_i2c_clock_settings_t</a></td>
<td class="fieldname">
clock_settings</td>
<td class="fielddoc">
I2C Clock settings. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga075bd36361ec44fc1dc964248db8c7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga075bd36361ec44fc1dc964248db8c7ff">&#9670;&nbsp;</a></span>R_SCI_I2C_VersionGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SCI_I2C_VersionGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#unionfsp__version__t">fsp_version_t</a> *const&#160;</td>
          <td class="paramname"><em>p_version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets driver version based on compile time macros.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful version get. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>The parameter p_version is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaddcd4299259f33f1586458c6f580ef4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddcd4299259f33f1586458c6f580ef4c">&#9670;&nbsp;</a></span>R_SCI_I2C_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SCI_I2C_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga87f5194ba16044322815db81dc442138">i2c_master_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#structi2c__master__cfg__t">i2c_master_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens the I2C device.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Requested clock rate was set exactly. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Module is already open. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Parameter check failure due to one or more reasons below:<ol type="1">
<li>p_api_ctrl or p_cfg is NULL.</li>
<li>extended parameter is NULL.</li>
<li>Callback parameter is NULL.</li>
<li>Clock rate requested is greater than 400KHz</li>
<li>Invalid IRQ number assigned </li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6ce2bd61f5a153cd7957c4a1b1350df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ce2bd61f5a153cd7957c4a1b1350df8">&#9670;&nbsp;</a></span>R_SCI_I2C_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SCI_I2C_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga87f5194ba16044322815db81dc442138">i2c_master_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes the I2C device. Power down I2C peripheral.</p>
<p>This function will safely terminate any in-progress I2C transfer with the device. If a transfer is aborted, the user will be notified via callback with an abort event. Since the callback is optional, this function will also return a specific error code in this situation.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Device closed without issue. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>The parameter p_ctrl is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Device was not even opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad044a875458d5878769a8f4b4b5e038f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad044a875458d5878769a8f4b4b5e038f">&#9670;&nbsp;</a></span>R_SCI_I2C_Read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SCI_I2C_Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga87f5194ba16044322815db81dc442138">i2c_master_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>p_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>restart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a read from the I2C device. The caller will be notified when the operation has completed (successfully) by an I2C_MASTER_EVENT_RX_COMPLETE in the callback.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Function executed without issue. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>The parameter p_ctrl, p_dest is NULL, bytes is 0. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_SIZE</td><td>Provided number of bytes more than uint16_t size (65535) while DTC is used for data transfer. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Device was not even opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7bb2633c299214aa6c1779aa39d8df0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bb2633c299214aa6c1779aa39d8df0c">&#9670;&nbsp;</a></span>R_SCI_I2C_Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SCI_I2C_Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga87f5194ba16044322815db81dc442138">i2c_master_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>p_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>restart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a write to the I2C device.</p>
<p>This function will fail if there is already an in-progress I2C transfer on the associated channel. Otherwise, the I2C write operation will begin. When no callback is provided by the user, this function performs a blocking write. Otherwise, the write operation is non-blocking and the caller will be notified when the operation has finished by an I2C_EVENT_TX_COMPLETE in the callback.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Function executed without issue. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl, p_src is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_SIZE</td><td>Provided number of bytes more than uint16_t size (65535) while DTC is used for data transfer. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Device was not even opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga417258e6c32f4000c95198a60f2a699d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga417258e6c32f4000c95198a60f2a699d">&#9670;&nbsp;</a></span>R_SCI_I2C_Abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SCI_I2C_Abort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga87f5194ba16044322815db81dc442138">i2c_master_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Aborts any in-progress transfer and forces the I2C peripheral into a ready state.</p>
<p>This function will safely terminate any in-progress I2C transfer with the device. If a transfer is aborted, the user will be notified via callback with an abort event. Since the callback is optional, this function will also return a specific error code in this situation.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Transaction was aborted without issue. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Device was not even opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaafb153ace0acecf6d61037ed2113c6da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafb153ace0acecf6d61037ed2113c6da">&#9670;&nbsp;</a></span>R_SCI_I2C_SlaveAddressSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SCI_I2C_SlaveAddressSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga87f5194ba16044322815db81dc442138">i2c_master_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>slave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga6203bcd8d8127b8fd442a2d33d112940">i2c_master_addr_mode_t</a> const&#160;</td>
          <td class="paramname"><em>addr_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets address and addressing mode of the slave device.</p>
<p>This function is used to set the device address and addressing mode of the slave without reconfiguring the entire bus.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Address of the slave is set correctly. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl or address is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Device was not even opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>An I2C Transaction is in progress. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v1.2.0 User's Manual Copyright Â© (2020) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
