<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: Azure RTOS NetX Crypto HW Acceleration (rm_netx_secure_crypto)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
    $(document).ready(function() {
        $("tr.tree_lvl_1").nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
		$("tr.tree_lvl_1").data("expanded","0");
		$("tr.tree_lvl_2").data("expanded","0");
		$("tr.tree_lvl_3").data("expanded","0");
		$("tr.tree_lvl_4").data("expanded","0");
		$("tr.tree_lvl_5").data("expanded","0");
        $("tr.tree_lvl_1").click(function() {
		    var lvl_1_is_open = $(this).data("expanded");
		    if (lvl_1_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2, tr.tree_lvl_1_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_2").click(function() {
		    var lvl_2_is_open = $(this).data("expanded");
		    if (lvl_2_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3, tr.tree_lvl_2_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_3").click(function() {
		    var lvl_3_is_open = $(this).data("expanded");
		    if (lvl_3_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_3_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_4").click(function() {
		    var lvl_4_is_open = $(this).data("expanded");
		    if (lvl_4_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5, tr.tree_lvl_4_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_5").click(function() {
		    var lvl_5_is_open = $(this).data("expanded");
		    if (lvl_5_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4_item,tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
     });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v6.2.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">

    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text">
      </span>
      <span class="right">
          &nbsp;
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___r_m___n_e_t_x___s_e_c_u_r_e___c_r_y_p_t_o.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body.
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len));
            }
          }
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element.
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Azure RTOS NetX Crypto HW Acceleration (rm_netx_secure_crypto)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___s_e_c_u_r_i_t_y___m_o_d_u_l_e_s.html">Security</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Hardware acceleration for the Netx Crypto implementation of the Microsoft Azure RTOS NetX Crypto API. </p>
<h1><a class="anchor" id="rm-netx-secure-crypto-overview"></a>
Overview</h1>
<p>Please refer to the <a href="https://docs.microsoft.com/en-us/azure/rtos/netx/netx-crypto/chapter1">NetXDuo - NetX Crypto documentation</a> for further details.</p>
<h2>HW Overview</h2>
<table class="doxtable">
<tr>
<th>Crypto Peripheral version </th><th>Devices  </th></tr>
<tr>
<td>RSIP-E51A </td><td>RA8M1, RA8D1, RA8T1 </td></tr>
<tr>
<td>RSIP-E50D </td><td>RA8P1 </td></tr>
<tr>
<td>RSIP-E31A </td><td>RA4C1 </td></tr>
<tr>
<td>RSIP-E11A </td><td>RA4L1 </td></tr>
<tr>
<td>SCE9 </td><td>RA6M4, RA4M3, RA4M2, RA6M5 </td></tr>
<tr>
<td>SCE7 </td><td>RA6M3, RA6M2, RA6M1, RA6T1 </td></tr>
<tr>
<td>SCE5 </td><td>RA4W1, RA4M1 </td></tr>
<tr>
<td>SCE5B </td><td>RA6T2 </td></tr>
<tr>
<td>AES Engine </td><td>RA2A1, RA2E1, RA2E2, RA2L1 </td></tr>
<tr>
<td>AES Engine 2 </td><td>RA2A2 </td></tr>
<tr>
<td>TRNG </td><td>RA0E1, RA0E2, RA2L2, RA4E1, RA4E2, RA4T1, RA6E1, RA6E2, RA6T3, RA8E1, RA8E2 </td></tr>
</table>
<h2><a class="anchor" id="rm-netx-secure-crypto-features"></a>
Features</h2>
<table class="doxtable">
<tr>
<th></th><th></th><th>AES Engine </th><th>AES Engine 2 </th><th>SCE5 </th><th>SCE5_B </th><th>SCE7 </th><th>SCE9 </th><th>RSIP-E11A </th><th>RSIP-E31A </th><th>RSIP-E51A </th><th>RSIP-E50D  </th></tr>
<tr>
<td>TRNG </td><td></td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td></tr>
<tr>
<td>Hash </td><td>SHA224, SHA256 </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td></tr>
<tr>
<td></td><td>SHA384, SHA512 </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>Yes </td><td>Yes </td><td>Yes </td></tr>
<tr>
<td></td><td>SHA512/224, SHA512/256 </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>Yes </td><td>Yes </td><td>Yes </td></tr>
<tr>
<td>MAC </td><td>HMAC-SHA224, HMAC-SHA256 </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td></tr>
<tr>
<td></td><td>HMAC-SHA384, HMAC-SHA512 </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>Yes </td><td>Yes </td><td>Yes </td></tr>
<tr>
<td></td><td>HMAC-SHA512/224 </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>Yes </td><td>Yes </td><td>Yes </td></tr>
<tr>
<td></td><td>HMAC-SHA512/256 </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>Yes </td><td>Yes </td><td>Yes </td></tr>
<tr>
<td>AES </td><td>AES128-CBC, CTR </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td></tr>
<tr>
<td></td><td>AES128-GCM (1) </td><td>&ndash; </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>(2) </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td></tr>
<tr>
<td></td><td>AES128-CCM (1) </td><td>&ndash; </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td></tr>
<tr>
<td></td><td>AES192-CBC, CTR </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>Yes </td><td>Yes </td><td>&ndash; </td><td>&ndash; </td><td>Yes </td><td>Yes </td></tr>
<tr>
<td></td><td>AES192-GCM (1) </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>Yes </td><td>(2) </td><td>&ndash; </td><td>&ndash; </td><td>Yes </td><td>Yes </td></tr>
<tr>
<td></td><td>AES192-CCM (1) </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>Yes </td><td>Yes </td><td>&ndash; </td><td>&ndash; </td><td>Yes </td><td>Yes </td></tr>
<tr>
<td></td><td>AES256-CBC, CTR </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td></tr>
<tr>
<td></td><td>AES256-GCM (1) </td><td>&ndash; </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>(2) </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td></tr>
<tr>
<td></td><td>AES256-CCM (1) </td><td>&ndash; </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td></tr>
<tr>
<td>ECC </td><td>secp256r1 </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td></tr>
<tr>
<td></td><td>secp384r1 </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>Yes </td><td>Yes </td><td>&ndash; </td><td>Yes </td><td>Yes </td><td>Yes </td></tr>
<tr>
<td>RSA </td><td>RSA-1024 </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>Yes </td><td>&ndash; </td><td>&ndash; </td><td>Yes </td><td>Yes </td></tr>
<tr>
<td></td><td>RSA-2048 </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>Yes </td><td>Yes </td><td>&ndash; </td><td>&ndash; </td><td>Yes </td><td>Yes </td></tr>
<tr>
<td></td><td>RSA-3072 (3) </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>Yes </td><td>&ndash; </td><td>&ndash; </td><td>Yes </td><td>Yes </td></tr>
<tr>
<td></td><td>RSA-4096 (3) </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>&ndash; </td><td>Yes </td><td>&ndash; </td><td>&ndash; </td><td>Yes </td><td>Yes </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>Only block cipher unit is HW accelerated</li>
<li>Encrypt - Fully accelerated; Decrypt - Only GHASH and block cipher unit is HW accelerated</li>
<li>Signature verification only</li>
</ol>
</dd></dl>
<p><a class="anchor" id="um_crypto_sha256_hash_calculation"></a><a class="anchor" id="um_crypto_sha256_hash_multipart_calculation"></a><a class="anchor" id="um_crypto_sha256_hash_multipart_long_message_calculation"></a><a class="anchor" id="um_crypto_sha256_hash_read"></a><a class="anchor" id="um_crypto_sha224_hash_calculation"></a><a class="anchor" id="um_crypto_sha224_hash_multipart_calculation"></a><a class="anchor" id="um_crypto_sha224_hash_read"></a><a class="anchor" id="um_crypto_sha384_hash_multipart_calculation"></a><a class="anchor" id="um_crypto_sha384_hash_multipart_long_message_calculation"></a><a class="anchor" id="um_crypto_sha512_hash_multipart_calculation"></a><a class="anchor" id="um_crypto_sha512_hash_multipart_long_message_calculation"></a><a class="anchor" id="um_crypto_sha512_224_hash_multipart_calculation"></a><a class="anchor" id="um_crypto_sha512_224_hash_multipart_long_message_calculation"></a><a class="anchor" id="um_crypto_sha512_256_hash_multipart_calculation"></a><a class="anchor" id="um_crypto_sha512_256_hash_multipart_long_message_calculation"></a><a class="anchor" id="um_sha224_crypto_hmac"></a><a class="anchor" id="um_sha256_crypto_hmac"></a><a class="anchor" id="um_sha384_crypto_hmac"></a><a class="anchor" id="um_sha512_crypto_hmac"></a><a class="anchor" id="um_crypto_AES128_encryption_decryption"></a><a class="anchor" id="um_crypto_AES192_encryption_decryption"></a><a class="anchor" id="um_crypto_AES256_encryption_decryption"></a><a class="anchor" id="um_crypto_AES_cbc"></a><a class="anchor" id="um_crypto_AES_ctr"></a><a class="anchor" id="um_crypto_AES_gcm"></a><a class="anchor" id="um_crypto_AES_ccm"></a><a class="anchor" id="um_crypto_random_number_generation"></a><a class="anchor" id="um_crypto_ECC_ECDSA_384R1"></a><a class="anchor" id="um_crypto_ECC_ECDSA_256R1"></a><a class="anchor" id="um_crypto_ECC_ECDH_384R1"></a><a class="anchor" id="um_crypto_ECC_ECDH_256R1"></a><a class="anchor" id="um_crypto_RSA_2048_wrapped_key"></a><a class="anchor" id="um_crypto_RSA_1024"></a><a class="anchor" id="um_crypto_RSA_2048"></a><a class="anchor" id="um_crypto_RSA_3072"></a><a class="anchor" id="um_crypto_RSA_4096"></a><a class="anchor" id="um_crypto_RSA_PKCS1V15_sign_verify"></a>&#160;</p>
<h1><a class="anchor" id="rm-netx-secure-crypto-configuration"></a>
Configuration</h1>
<p><h2>Build Time Configurations for rm_netx_secure_crypto_sw_port</h2>
The following build time configurations are defined in fsp_cfg/middleware/rm_netx_secure_crypto_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Standalone Usage</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Use Standalone Crypto Only</li>
<li>
Use with TLS</li>
</ul>
</td><td>Use Standalone Crypto Only </td><td>Defines NX_CRYPTO_STANDALONE_ENABLE. </td></tr>
<tr class="tree_none">
<td>Maximum RSA Modulus size (bits)</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1024</li>
<li>
2048</li>
<li>
3072</li>
<li>
4096</li>
</ul>
</td><td>4096 </td><td></td></tr>
</table>
 <h2>Build Time Configurations for rm_netx_secure_crypto</h2>
The following build time configurations are defined in fsp_cfg/middleware/rm_netx_secure_crypto_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Hardware Acceleration  </td></tr>
<tr class="tree_lvl_2">
<td class="tree_lvl_2" colspan="4"><span class="chevron-collapsed"></span> Hardware Acceleration &gt; Hash  </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">SHA256/224</td><td>MCU Specific Options</td><td></td><td>Enables NETX_SECURE_CRYPTO_NX_CRYPTO_METHODS_SHA256_ALT. </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">SHA512/384</td><td>MCU Specific Options</td><td></td><td>Enables NETX_SECURE_CRYPTO_NX_CRYPTO_METHODS_SHA512_ALT. </td></tr>
<tr class="tree_lvl_2">
<td class="tree_lvl_2" colspan="4"><span class="chevron-collapsed"></span> Hardware Acceleration &gt; Cipher  </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">AES</td><td>MCU Specific Options</td><td></td><td>Enables NETX_SECURE_CRYPTO_NX_CRYPTO_METHODS_AES_ALT </td></tr>
<tr class="tree_lvl_2">
<td class="tree_lvl_2" colspan="4"><span class="chevron-collapsed"></span> Hardware Acceleration &gt; Public Key Cryptography (PKC)  </td></tr>
<tr class="tree_lvl_3">
<td class="tree_lvl_3" colspan="4"><span class="chevron-collapsed"></span> Hardware Acceleration &gt; Public Key Cryptography (PKC) &gt; ECC  </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">ECC</td><td>MCU Specific Options</td><td></td><td>Enables NETX_SECURE_CRYPTO_NX_CRYPTO_METHODS_ECC_ALT </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">ECDSA Scratch Buffer Size (Bytes)</td><td>Value must be a non-negative integer</td><td>3016 </td><td>Sets value of NX_CRYPTO_ECDSA_SCRATCH_BUFFER_SIZE </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">ECDH Scratch Buffer Size (Bytes)</td><td>Value must be a non-negative integer</td><td>2464 </td><td>Sets value of NX_CRYPTO_ECDH_SCRATCH_BUFFER_SIZE </td></tr>
<tr class="tree_lvl_3">
<td class="tree_lvl_3" colspan="4"><span class="chevron-collapsed"></span> Hardware Acceleration &gt; Public Key Cryptography (PKC) &gt; RSA  </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">RSA</td><td>MCU Specific Options</td><td></td><td>Enables/Disables RSA HW support </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">RSA 1024 (HW)</td><td>MCU Specific Options</td><td></td><td>Enables NETX_SECURE_CRYPTO_NX_CRYPTO_METHODS_RSA_1024_ALT to allow HW support </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">RSA 2048 (HW)</td><td>MCU Specific Options</td><td></td><td>Enables NETX_SECURE_CRYPTO_NX_CRYPTO_METHODS_RSA_2048_ALT to allow HW support </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">RSA 3072 Verify/Encryption (HW)</td><td>MCU Specific Options</td><td></td><td>Enables NETX_SECURE_CRYPTO_NX_CRYPTO_METHODS_RSA_3072_ALT to allow HW support </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">RSA 4096 Verify/Encryption (HW)</td><td>MCU Specific Options</td><td></td><td>Enables RSA NETX_SECURE_CRYPTO_NX_CRYPTO_METHODS_RSA_4096_ALT to allow HW support </td></tr>
<tr class="tree_lvl_3_item">
<td class="tree_lvl_3_cell">RSA Scratch Buffer Size (Bytes)</td><td>MCU Specific Options</td><td></td><td>Sets value of NX_CRYPTO_RSA_SCRATCH_BUFFER_SIZE </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">TRNG</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>Enables NETX_SECURE_CRYPTO_NX_CRYPTO_METHODS_TRNG_ALT. </td></tr>
<tr class="tree_none">
<td>Standalone Usage</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Use Standalone Crypto Only</li>
<li>
Use with TLS</li>
</ul>
</td><td>Use Standalone Crypto Only </td><td>Defines NX_CRYPTO_STANDALONE_ENABLE. </td></tr>
</table>
</p>
<h2><a class="anchor" id="rm-netx-secure-crypto-rng-configuration"></a>
Random Number Generator Configuration</h2>
<p>To enable hardware acceleration for the TRNG, the macro NETX_SECURE_CRYPTO_NX_CRYPTO_METHODS_TRNG_ALT must be defined in the configuration file. By default TRNG is enabled which can be disabled using the RA Configuration editor.</p>
<p>Once enabled 'rand' function will be mapped to HW TRNG; the 'srand' function is not supported, any calls to this function will have no effect. Functionality to re-seed the HW TRNG is not supported by the existing implementation.</p>
<p>If disabled, both 'rand' and 'srand' will be mapped to the C Standard Library. This would require setting up the heap as 'rand' implementation calls 'malloc'.</p>
<h2><a class="anchor" id="rm-netx-secure-crypto-sha-configuration"></a>
SHA Configuration</h2>
<p>To enable hardware acceleration for the SHA256/224 or SHA384/512 calculation, the macro NETX_SECURE_CRYPTO_NX_CRYPTO_METHODS_SHA256_ALT or NETX_SECURE_CRYPTO_NX_CRYPTO_METHODS_SHA512_ALT must be defined in the configuration file. By default SHA is enabled which can be disabled using the RA Configuration editor.</p>
<h2><a class="anchor" id="rm-netx-secure-crypto-aes-configuration"></a>
AES Configuration</h2>
<p>To enable hardware acceleration for the AES128/192/256 operation, the macro NETX_SECURE_CRYPTO_NX_CRYPTO_METHODS_AES_ALT must be defined in the configuration file. By default AES is enabled which can be disabled using the RA Configuration editor.</p>
<h2><a class="anchor" id="rm-netx-secure-crypto-ecc-configuration"></a>
ECC Configuration</h2>
<p>To enable hardware acceleration for the ECDSA and ECDH for curves SECP384R1 and SECP256R1, the macro NETX_SECURE_CRYPTO_NX_CRYPTO_METHODS_ECC_ALT must be defined in the configuration file. By default ECC operations are enabled which can be disabled using the RA Configuration editor.</p>
<h2><a class="anchor" id="rm-netx-secure-crypto-rsa-configuration"></a>
RSA Configuration</h2>
<p>To enable hardware acceleration for the RSA Encrypt/Decrypt (or Sign/Verify) operation(s), the macro(s) below must be must be defined in the configuration file: </p><table class="doxtable">
<tr>
<th>Configuration Macro </th><th>Feature / Operation  </th></tr>
<tr>
<td>NETX_SECURE_CRYPTO_NX_CRYPTO_METHODS_RSA_1024_ALT </td><td>Signature Generation / Signature Verification (Encryption / Decryption) </td></tr>
<tr>
<td>NETX_SECURE_CRYPTO_NX_CRYPTO_METHODS_RSA_2048_ALT </td><td>Signature Generation / Signature Verification (Encryption / Decryption) </td></tr>
<tr>
<td>NETX_SECURE_CRYPTO_NX_CRYPTO_METHODS_RSA_3072_ALT </td><td>Signature Verification (Encryption Only) </td></tr>
<tr>
<td>NETX_SECURE_CRYPTO_NX_CRYPTO_METHODS_RSA_4096_ALT </td><td>Signature Verification (Encryption Only) </td></tr>
</table>
<p>By default RSA 2048 is enabled which can be disabled using the RA Configuration editor.</p>
<p>RSA software implementation is completely disabled when any of the above macros are enabled.</p>
<h1><a class="anchor" id="rm-netx-secure-crypto-usage-notes"></a>
Usage Notes</h1>
<h2><a class="anchor" id="rm-netx-secure-crypto-memory-alignment"></a>
Memory Alignment</h2>
<p>Use 32bit aligned buffer pointers as arguments to APIs for best performance.</p>
<h2><a class="anchor" id="rm-netx-secure-crypto-hardware-init"></a>
Hardware Initialization</h2>
<p>_nx_crypto_initialize() must be invoked before using the NetX Crypto APIs to ensure that the SCE peripheral is initialized.</p>
<h2><a class="anchor" id="rm-netx-secure-crypto-memory-usage"></a>
Memory Usage</h2>
<p>Sufficient memory must be allocated to be used as 'crypto_metadata' for the chosen crypto operation(s). Refer <a href="https://docs.microsoft.com/en-us/azure/rtos/netx/netx-crypto/chapter4">Azure RTOS NetX Crypto API description</a> for recommended 'crypto_metadata_size' based on selected crypto operations. Sufficient amount of memory must be allocated for the thread stack to support low level crypto operations when using this module in the standalone mode or through NetX Secure (TLS). A minimum stack of 0x1000 is required to use ECC and RSA. This is either the main stack in a bare metal application or the specific thread stack for an RTOS based application.</p>
<h2><a class="anchor" id="rm-netx-secure-aes-usage"></a>
AES Usage</h2>
<h3><a class="anchor" id="rm-netx-secure-crypto-gcm-mode"></a>
GCM mode</h3>
<p>The first byte of the IV must indicate the length of the subsequent IV. For example if the IV is {0x00, 0x00, 0x00}, then the IV pointer passed to the _nx_crypto_method_aes_operation must store the IV as {0x03, 0x00, 0x00, 0x00}. Refer to the example code for actual usage.</p>
<h3><a class="anchor" id="rm-netx-secure-crypto-ctr-mode"></a>
CTR mode</h3>
<p>For CTR mode the IV pointer must be as defined in <a href="https://tools.ietf.org/html/rfc3686">Using Advanced Encryption Standard (AES) Counter Mode With IPsec Encapsulating Security Payload (ESP)</a> under 'Figure 2. Counter Block Format'. The IV must be 8 bytes in length. The Nonce field in the reference above must be 4 bytes and should be passed to _nx_crypto_method_aes_operation through the key pointer stored after the actual AES key. For Example, if the AES 128-bit Plain Key is {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} and the Nonce is {0x01, 0x07, 0xBD, 0xFD}, the key passed to the _nx_crypto_method_aes_operation during Encryption/Decryption should be set as {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0xBD, 0xFD}. This format would also be valid for Wrapped keys where the Nonce is appended at the end of the actual Wrapped key. Refer to the example code for actual usage.</p>
<p>The 'Block Counter' field in the above reference is fixed to {0x00, 0x00, 0x00, 0x01} at the beginning and increments internally after every subsequent AES block is processed. Test vectors that have the initial Block Counter not set to {0x00, 0x00, 0x00, 0x01} cannot be used in this implementation.</p>
<h2><a class="anchor" id="rm-netx-secure-ecc-usage"></a>
ECC Usage</h2>
<p>ECC operations include ECDH and ECDSA. As a part of ECDSA operation the input message can be hashed before signing or verification, or the message digest can be provided directly. ECC Scratch buffer size can be optionally reduced as supported ECC computations are now done by the HW. This is controlled by NX_CRYPTO_ECDSA_SCRATCH_BUFFER_SIZE and NX_CRYPTO_ECDH_SCRATCH_BUFFER_SIZE macros for ECDSA and ECDH respectively.</p>
<table class="doxtable">
<tr>
<th>Operation </th><th>Key Format  </th></tr>
<tr>
<td>ECDSA Signature </td><td>Plain private key; Wrapped private key </td></tr>
<tr>
<td>ECDSA Signature-Verify </td><td>Uncompressed public key </td></tr>
<tr>
<td>Key Generation using ECDSA operation API </td><td>Wrapped private key; Uncompressed public key </td></tr>
<tr>
<td>ECDH private key import </td><td>Plain private key; Wrapped private key (Allows for Uncompressed and Formatted public key) </td></tr>
<tr>
<td>ECDH public key export </td><td>Uncompressed public key </td></tr>
<tr>
<td>ECDH setup </td><td>Uncompressed public key </td></tr>
<tr>
<td>ECDH shared secret calculate </td><td>Uncompressed public key </td></tr>
<tr>
<td>Key Generation using ECDH operation API </td><td>Wrapped private key; Uncompressed public key </td></tr>
</table>
<p>Note:</p><ul>
<li>Uncompressed public key is of the form (0x04 || Qx || Qy). Refer Section 2.2. Subject Public Key under <a href="https://tools.ietf.org/html/rfc5480">RFC5480</a></li>
<li>Formatted public key is of the form (Key Info (4 bytes) || Qx || Qy || Key Info (16 bytes)). This is the key which is used internally by SCE peripheral.</li>
</ul>
<h2><a class="anchor" id="rm-netx-secure-rsa-usage"></a>
RSA Usage</h2>
<h3>Wrapped Key Usage</h3>
<p>To use the NetX Crypto stack with wrapped private keys (for signature generation/decryption), a dummy pointer (non-NULL) should be passed to the 'key' parameter during _nx_crypto_method_rsa_init API call. However, the 'key_size_in_bits' parameter should be equal to the intended RSA modulus length in bits. The actual wrapped key must be passed as the 'key' parameter to the _nx_crypto_method_rsa_operation API call with its length in bits passed through the 'key_size_in_bits' parameter.</p>
<p>For PKCS1V15 operation 'key' and 'key_size_in_bits' parameters of _nx_crypto_method_pkcs1_v1_5_init are unused. These can be passed as NULL and 0 respectively. The actual wrapped key must be passed as the 'key' parameter to the _nx_crypto_method_pkcs1_v1_5_operation API call and the intended modulus length in bits must be passed through the 'key_size_in_bits' parameter.</p>
<h3>Software Implementation</h3>
<p>The plaintext data passed in to the RSA encryption API must be 4-byte aligned. If it is not aligned then when the resultant encrypted data is decrypted using the decryption API, the unaligned data will be endian-swapped. For instance, if {0x01, 0x02,0x03, 0x04, 0x05} is passed as input data for encryption, when decrypted, the result will be {0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x05}. Note that this alignment of input data need not be taken care while using Hardware accelerated RSA.</p>
<h2>Limitations</h2>
<ul>
<li>Only little endian mode is supported.</li>
<li>RSA CRT keys are not supported.</li>
<li>ECJPAKE related operations are unsupported for NIST 224, 256 and 384 bit curves when HW ECC is eanbled.</li>
</ul>
<h1><a class="anchor" id="rm-netx-secure-crypto-examples"></a>
Examples</h1>
<h2>Initialization Example</h2>
<p>This example shows how to initialize the HW crypto engine. This step must be performed before any crypto algorithm is used.</p>
<div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Setup the platform; initialize the SCE and the TRNG */</span></div><div class="line">    err = nx_crypto_initialize();</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div></div><!-- fragment --><h2>Hash Example</h2>
<p>This is an example on calculating the SHA256 hash using the NetX Crypto API.</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> NX_CRYPTO_METHOD crypto_method_sha256;</div><div class="line"><span class="keyword">const</span> uint8_t           NIST_SHA256ShortMsgLen200[] =</div><div class="line">{</div><div class="line">    0x2e, 0x7e, 0xa8, 0x4d, 0xa4, 0xbc, 0x4d, 0x7c, 0xfb, 0x46, 0x3e, 0x3f, 0x2c, 0x86, 0x47, 0x05,</div><div class="line">    0x7a, 0xff, 0xf3, 0xfb, 0xec, 0xec, 0xa1, 0xd2, 00</div><div class="line">};</div><div class="line"><span class="keyword">const</span> uint8_t NIST_SHA256ShortMsgLen200_expected[] =</div><div class="line">{</div><div class="line">    0x76, 0xe3, 0xac, 0xbc, 0x71, 0x88, 0x36, 0xf2, 0xdf, 0x8a, 0xd2, 0xd0, 0xd2, 0xd7, 0x6f, 0x0c,</div><div class="line">    0xfa, 0x5f, 0xea, 0x09, 0x86, 0xbe, 0x91, 0x8f, 0x10, 0xbc, 0xee, 0x73, 0x0d, 0xf4, 0x41, 0xb9</div><div class="line">};</div><div class="line"><span class="keywordtype">void</span> netx_secure_crypto_sha256_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="keywordtype">size_t</span>   actual_hash_len = RM_NETX_SECURE_CRYPTO_EXAMPLE_SHA256_HASH_SIZE_BYTES;</div><div class="line">    uint8_t  actual_hash[RM_NETX_SECURE_CRYPTO_EXAMPLE_SHA256_HASH_SIZE_BYTES];</div><div class="line">    uint8_t  metadata[<span class="keyword">sizeof</span>(NX_CRYPTO_SHA256)];</div><div class="line">    uint32_t metadata_size = <span class="keyword">sizeof</span>(NX_CRYPTO_SHA256);</div><div class="line">    <span class="keywordtype">void</span>   * handler       = NX_CRYPTO_NULL;</div><div class="line">    uint32_t err           = NX_CRYPTO_SUCCESS;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Setup the platform; initialize the SCE and the TRNG */</span></div><div class="line">    err = nx_crypto_initialize();</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Nx Crypto SHA256 init */</span></div><div class="line">    err = _nx_crypto_method_sha256_init(&amp;crypto_method_sha256, NX_CRYPTO_NULL, 0, &amp;handler, metadata, metadata_size);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Nx Crypto SHA256 operation - NX_CRYPTO_HASH_INITIALIZE */</span></div><div class="line">    err = _nx_crypto_method_sha256_operation(NX_CRYPTO_HASH_INITIALIZE,</div><div class="line">                                             handler,</div><div class="line">                                             &amp;crypto_method_sha256,</div><div class="line">                                             NX_CRYPTO_NULL,</div><div class="line">                                             0,</div><div class="line">                                             NX_CRYPTO_NULL,</div><div class="line">                                             0,</div><div class="line">                                             NX_CRYPTO_NULL,</div><div class="line">                                             NX_CRYPTO_NULL,</div><div class="line">                                             0,</div><div class="line">                                             metadata,</div><div class="line">                                             metadata_size,</div><div class="line">                                             NX_CRYPTO_NULL,</div><div class="line">                                             NX_CRYPTO_NULL);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Nx Crypto SHA256 operation - NX_CRYPTO_HASH_UPDATE,</span></div><div class="line"><span class="comment">     * call this multiple times if needed to hash multiple data batches */</span></div><div class="line">    err =</div><div class="line">        _nx_crypto_method_sha256_operation(NX_CRYPTO_HASH_UPDATE,</div><div class="line">                                           handler,</div><div class="line">                                           &amp;crypto_method_sha256,</div><div class="line">                                           NX_CRYPTO_NULL,</div><div class="line">                                           0,</div><div class="line">                                           (uint8_t *) NIST_SHA256ShortMsgLen200,</div><div class="line">                                           <span class="keyword">sizeof</span>(NIST_SHA256ShortMsgLen200),</div><div class="line">                                           NX_CRYPTO_NULL,</div><div class="line">                                           NX_CRYPTO_NULL,</div><div class="line">                                           0,</div><div class="line">                                           metadata,</div><div class="line">                                           metadata_size,</div><div class="line">                                           NX_CRYPTO_NULL,</div><div class="line">                                           NX_CRYPTO_NULL);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Nx Crypto SHA256 operation - NX_CRYPTO_HASH_CALCULATE */</span></div><div class="line">    err = _nx_crypto_method_sha256_operation(NX_CRYPTO_HASH_CALCULATE,</div><div class="line">                                             handler,</div><div class="line">                                             &amp;crypto_method_sha256,</div><div class="line">                                             NX_CRYPTO_NULL,</div><div class="line">                                             0,</div><div class="line">                                             NX_CRYPTO_NULL,</div><div class="line">                                             0,</div><div class="line">                                             NX_CRYPTO_NULL,</div><div class="line">                                             (uint8_t *) actual_hash,</div><div class="line">                                             actual_hash_len,</div><div class="line">                                             metadata,</div><div class="line">                                             metadata_size,</div><div class="line">                                             NX_CRYPTO_NULL,</div><div class="line">                                             NX_CRYPTO_NULL);</div><div class="line"></div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Ensure generated SHA256 hash matches the expected digest */</span></div><div class="line">    err = (uint32_t) memcmp(&amp;actual_hash[0], &amp;NIST_SHA256ShortMsgLen200_expected[0], actual_hash_len);</div><div class="line">    assert(0 == err);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>AES Example</h2>
<p>This is an example on using the NetX Crypto API to encrypt and decrypt multi-block data. </p><h3>AES CBC Example</h3>
<div class="fragment"><div class="line"><span class="keyword">extern</span> NX_CRYPTO_METHOD crypto_method_aes_cbc_256;</div><div class="line"></div><div class="line"><span class="comment">/* fe8901fecd3ccd2ec5fdc7c7a0b50519c245b42d611a5ef9e90268d59f3edf33 */</span></div><div class="line"><span class="keyword">const</span> uint8_t NIST_AES256_CBC_key[] =</div><div class="line">{</div><div class="line">    0xfe, 0x89, 0x01, 0xfe, 0xcd, 0x3c, 0xcd, 0x2e, 0xc5, 0xfd, 0xc7, 0xc7, 0xa0, 0xb5, 0x05, 0x19,</div><div class="line">    0xc2, 0x45, 0xb4, 0x2d, 0x61, 0x1a, 0x5e, 0xf9, 0xe9, 0x02, 0x68, 0xd5, 0x9f, 0x3e, 0xdf, 0x33</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* 851e8764776e6796aab722dbb644ace8 */</span></div><div class="line"><span class="keyword">const</span> uint8_t NIST_AES256_CBC_iv[] =</div><div class="line">{</div><div class="line">    0xbd, 0x41, 0x6c, 0xb3, 0xb9, 0x89, 0x22, 0x28, 0xd8, 0xf1, 0xdf, 0x57, 0x56, 0x92, 0xe4, 0xd0</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* 6282b8c05c5c1530b97d4816ca434762 */</span></div><div class="line"><span class="keyword">const</span> uint8_t NIST_AES256_CBC_plaintext[] =</div><div class="line">{</div><div class="line">    0x8d, 0x3a, 0xa1, 0x96, 0xec, 0x3d, 0x7c, 0x9b, 0x5b, 0xb1, 0x22, 0xe7, 0xfe, 0x77, 0xfb, 0x12,</div><div class="line">    0x95, 0xa6, 0xda, 0x75, 0xab, 0xe5, 0xd3, 0xa5, 0x10, 0x19, 0x4d, 0x3a, 0x8a, 0x41, 0x57, 0xd5,</div><div class="line">    0xc8, 0x9d, 0x40, 0x61, 0x97, 0x16, 0x61, 0x98, 0x59, 0xda, 0x3e, 0xc9, 0xb2, 0x47, 0xce, 0xd9</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* 6acc04142e100a65f51b97adf5172c41 */</span></div><div class="line"><span class="keyword">const</span> uint8_t NIST_AES256_CBC_ciphertext[] =</div><div class="line">{</div><div class="line">    0x60, 0x8e, 0x82, 0xc7, 0xab, 0x04, 0x00, 0x7a, 0xdb, 0x22, 0xe3, 0x89, 0xa4, 0x47, 0x97, 0xfe,</div><div class="line">    0xd7, 0xde, 0x09, 0x0c, 0x8c, 0x03, 0xca, 0x8a, 0x2c, 0x5a, 0xcd, 0x9e, 0x84, 0xdf, 0x37, 0xfb,</div><div class="line">    0xc5, 0x8c, 0xe8, 0xed, 0xb2, 0x93, 0xe9, 0x8f, 0x02, 0xb6, 0x40, 0xd6, 0xd1, 0xd7, 0x24, 0x64</div><div class="line">};</div><div class="line"><span class="keywordtype">void</span> netx_secure_crypto_aes256cbc_multipart_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint8_t  metadata[<span class="keyword">sizeof</span>(NX_CRYPTO_AES)];</div><div class="line">    uint32_t metadata_size = <span class="keyword">sizeof</span>(NX_CRYPTO_AES);</div><div class="line">    <span class="keywordtype">void</span>   * handler       = NX_CRYPTO_NULL;</div><div class="line">    uint32_t err           = NX_CRYPTO_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* 3 AES Blocks */</span></div><div class="line">    uint8_t generated_ciphertext[3U * NX_CRYPTO_AES_BLOCK_SIZE] = {0};</div><div class="line">    uint8_t generated_plaintext[3U * NX_CRYPTO_AES_BLOCK_SIZE]  = {0};</div><div class="line"></div><div class="line">    <span class="comment">/* Setup the platform; initialize the SCE and the TRNG */</span></div><div class="line">    err = nx_crypto_initialize();</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    err =</div><div class="line">        _nx_crypto_method_aes_init(&amp;crypto_method_aes_cbc_256, (uint8_t *) NIST_AES256_CBC_key,</div><div class="line">                                   <span class="keyword">sizeof</span>(NIST_AES256_CBC_key) &lt;&lt; 3U, &amp;handler, metadata, metadata_size);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Encryption. */</span></div><div class="line">    err = _nx_crypto_method_aes_operation(NX_CRYPTO_ENCRYPT,</div><div class="line">                                          handler,</div><div class="line">                                          &amp;crypto_method_aes_cbc_256,</div><div class="line">                                          NULL,</div><div class="line">                                          0,</div><div class="line">                                          (uint8_t *) NIST_AES256_CBC_plaintext,</div><div class="line">                                          <span class="keyword">sizeof</span>(NIST_AES256_CBC_plaintext),</div><div class="line">                                          (uint8_t *) NIST_AES256_CBC_iv,</div><div class="line">                                          generated_ciphertext,</div><div class="line">                                          <span class="keyword">sizeof</span>(generated_ciphertext),</div><div class="line">                                          metadata,</div><div class="line">                                          metadata_size,</div><div class="line">                                          NX_CRYPTO_NULL,</div><div class="line">                                          NX_CRYPTO_NULL);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Verify generated ciphertext matches the expected ciphertext */</span></div><div class="line">    err = (uint32_t) memcmp(generated_ciphertext, NIST_AES256_CBC_ciphertext, <span class="keyword">sizeof</span>(generated_ciphertext));</div><div class="line">    assert(0 == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Decryption. */</span></div><div class="line">    err = _nx_crypto_method_aes_operation(NX_CRYPTO_DECRYPT,</div><div class="line">                                          handler,</div><div class="line">                                          &amp;crypto_method_aes_cbc_256,</div><div class="line">                                          NULL,</div><div class="line">                                          0,</div><div class="line">                                          (uint8_t *) NIST_AES256_CBC_ciphertext,</div><div class="line">                                          <span class="keyword">sizeof</span>(NIST_AES256_CBC_ciphertext),</div><div class="line">                                          (uint8_t *) NIST_AES256_CBC_iv,</div><div class="line">                                          generated_plaintext,</div><div class="line">                                          <span class="keyword">sizeof</span>(generated_plaintext),</div><div class="line">                                          metadata,</div><div class="line">                                          metadata_size,</div><div class="line">                                          NX_CRYPTO_NULL,</div><div class="line">                                          NX_CRYPTO_NULL);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Verify generated plaintext matches the input plaintext */</span></div><div class="line">    err = (uint32_t) memcmp(generated_plaintext, NIST_AES256_CBC_plaintext, <span class="keyword">sizeof</span>(generated_ciphertext));</div><div class="line">    assert(0 == err);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h3>AES GCM Example</h3>
<div class="fragment"><div class="line"><span class="keyword">extern</span> NX_CRYPTO_METHOD crypto_method_aes_128_gcm_16;</div><div class="line"></div><div class="line"><span class="comment">/* 83F9D97D4AB759FDDCC3EF54A0E2A8EC */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> uint8_t key_gcm_128[] =</div><div class="line">{</div><div class="line">    0x83, 0xF9, 0xD9, 0x7D, 0x4A, 0xB7, 0x59, 0xFD, 0xDC, 0xC3, 0xEF, 0x54, 0xA0, 0xE2, 0xA8, 0xEC</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* In case of IV the IV length must be the first byte followed by the actual IV.</span></div><div class="line"><span class="comment"> * In this example the IV length is 0x01 and the actual IV is 0xCF</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="comment">/* 01CF */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> uint8_t iv_gcm_128[] =</div><div class="line">{</div><div class="line">    0x01, 0xCF</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* 77E6329CF9424F71C808DF9170BFD298 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> uint8_t plain_gcm_128[] =</div><div class="line">{</div><div class="line">    0x77, 0xE6, 0x32, 0x9C, 0xF9, 0x42, 0x4F, 0x71, 0xC8, 0x08, 0xDF, 0x91, 0x70, 0xBF, 0xD2, 0x98</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* 6DD49EAEB4103DAC8F97E3234946DD2D */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> uint8_t aad_gcm_128[] =</div><div class="line">{</div><div class="line">    0x6D, 0xD4, 0x9E, 0xAE, 0xB4, 0x10, 0x3D, 0xAC, 0x8F, 0x97, 0xE3, 0x23, 0x49, 0x46, 0xDD, 0x2D</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* 50DE86A7A92A8A5EA33DB5696B96CD77AA181E84BC8B4BF5A68927C409D422CB */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> uint8_t secret_gcm_128[] =</div><div class="line">{</div><div class="line">    <span class="comment">/* Ciphertext */</span></div><div class="line">    0x50, 0xDE, 0x86, 0xA7, 0xA9, 0x2A, 0x8A, 0x5E, 0xA3, 0x3D, 0xB5, 0x69, 0x6B, 0x96, 0xCD, 0x77,</div><div class="line"></div><div class="line">    <span class="comment">/* Tag */</span></div><div class="line">    0xAA, 0x18, 0x1E, 0x84, 0xBC, 0x8B, 0x4B, 0xF5, 0xA6, 0x89, 0x27, 0xC4, 0x09, 0xD4, 0x22, 0xCB</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> netx_secure_crypto_aes128gcm_multipart_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint8_t  metadata[<span class="keyword">sizeof</span>(NX_CRYPTO_AES)];</div><div class="line">    uint32_t metadata_size = <span class="keyword">sizeof</span>(NX_CRYPTO_AES);</div><div class="line">    <span class="keywordtype">void</span>   * handler       = NX_CRYPTO_NULL;</div><div class="line">    uint32_t err           = NX_CRYPTO_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* 3 AES Blocks */</span></div><div class="line">    uint8_t generated_ciphertext[3U * NX_CRYPTO_AES_BLOCK_SIZE] = {0};</div><div class="line">    uint8_t generated_plaintext[3U * NX_CRYPTO_AES_BLOCK_SIZE]  = {0};</div><div class="line"></div><div class="line">    <span class="comment">/* Setup the platform; initialize the SCE and the TRNG */</span></div><div class="line">    err = nx_crypto_initialize();</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    err =</div><div class="line">        _nx_crypto_method_aes_init(&amp;crypto_method_aes_128_gcm_16,</div><div class="line">                                   (uint8_t *) key_gcm_128,</div><div class="line">                                   <span class="keyword">sizeof</span>(key_gcm_128) &lt;&lt; 3U,</div><div class="line">            &amp;handler,</div><div class="line">            metadata,</div><div class="line">            metadata_size);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Setup Additional Authentication Data */</span></div><div class="line">    err = _nx_crypto_method_aes_operation(NX_CRYPTO_SET_ADDITIONAL_DATA,</div><div class="line">                                          handler,</div><div class="line">                                          &amp;crypto_method_aes_128_gcm_16,</div><div class="line">                                          NULL,</div><div class="line">                                          0,</div><div class="line">                                          (uint8_t *) aad_gcm_128,</div><div class="line">                                          <span class="keyword">sizeof</span>(aad_gcm_128),</div><div class="line">                                          NULL,</div><div class="line">                                          NULL,</div><div class="line">                                          0,</div><div class="line">                                          metadata,</div><div class="line">                                          metadata_size,</div><div class="line">                                          NX_CRYPTO_NULL,</div><div class="line">                                          NX_CRYPTO_NULL);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Encryption. */</span></div><div class="line">    err = _nx_crypto_method_aes_operation(NX_CRYPTO_ENCRYPT,</div><div class="line">                                          handler,</div><div class="line">                                          &amp;crypto_method_aes_128_gcm_16,</div><div class="line">                                          NULL,</div><div class="line">                                          0,</div><div class="line">                                          (uint8_t *) plain_gcm_128,</div><div class="line">                                          <span class="keyword">sizeof</span>(plain_gcm_128),</div><div class="line">                                          (uint8_t *) iv_gcm_128,</div><div class="line">                                          generated_ciphertext,</div><div class="line">                                          <span class="keyword">sizeof</span>(generated_ciphertext),</div><div class="line">                                          metadata,</div><div class="line">                                          metadata_size,</div><div class="line">                                          NX_CRYPTO_NULL,</div><div class="line">                                          NX_CRYPTO_NULL);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* The 16 byte tag is appended to the generated ciphertext */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Verify generated tag matches the expected tag */</span></div><div class="line">    err = (uint32_t) memcmp(&amp;generated_ciphertext[<span class="keyword">sizeof</span>(plain_gcm_128)], &amp;secret_gcm_128[<span class="keyword">sizeof</span>(plain_gcm_128)], 16U);</div><div class="line">    assert(0 == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Verify generated ciphertext matches the expected ciphertext */</span></div><div class="line">    err = (uint32_t) memcmp(generated_ciphertext, secret_gcm_128, <span class="keyword">sizeof</span>(secret_gcm_128));</div><div class="line">    assert(0 == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Setup Additional Authentication Data */</span></div><div class="line">    err = _nx_crypto_method_aes_operation(NX_CRYPTO_SET_ADDITIONAL_DATA,</div><div class="line">                                          handler,</div><div class="line">                                          &amp;crypto_method_aes_128_gcm_16,</div><div class="line">                                          NULL,</div><div class="line">                                          0,</div><div class="line">                                          (uint8_t *) aad_gcm_128,</div><div class="line">                                          <span class="keyword">sizeof</span>(aad_gcm_128),</div><div class="line">                                          NULL,</div><div class="line">                                          NULL,</div><div class="line">                                          0,</div><div class="line">                                          metadata,</div><div class="line">                                          metadata_size,</div><div class="line">                                          NX_CRYPTO_NULL,</div><div class="line">                                          NX_CRYPTO_NULL);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Decryption. */</span></div><div class="line">    err = _nx_crypto_method_aes_operation(NX_CRYPTO_DECRYPT,</div><div class="line">                                          handler,</div><div class="line">                                          &amp;crypto_method_aes_128_gcm_16,</div><div class="line">                                          NULL,</div><div class="line">                                          0,</div><div class="line">                                          (uint8_t *) generated_ciphertext,</div><div class="line">                                          <span class="keyword">sizeof</span>(secret_gcm_128), <span class="comment">/* ciphertext size + tag size */</span></div><div class="line">                                          (uint8_t *) iv_gcm_128,</div><div class="line">                                          generated_plaintext,</div><div class="line">                                          <span class="keyword">sizeof</span>(generated_plaintext),</div><div class="line">                                          metadata,</div><div class="line">                                          metadata_size,</div><div class="line">                                          NX_CRYPTO_NULL,</div><div class="line">                                          NX_CRYPTO_NULL);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Verify generated plaintext matches the input plaintext */</span></div><div class="line">    err = (uint32_t) memcmp(generated_plaintext, plain_gcm_128, <span class="keyword">sizeof</span>(plain_gcm_128));</div><div class="line">    assert(0 == err);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h3>AES CTR Example</h3>
<div class="fragment"><div class="line"></div><div class="line">NX_CRYPTO_METHOD crypto_method_aes_ctr_256 =</div><div class="line">{</div><div class="line">    NX_CRYPTO_ENCRYPTION_AES_CTR,            <span class="comment">/* AES crypto algorithm                   */</span></div><div class="line">    NX_CRYPTO_AES_256_KEY_LEN_IN_BITS,       <span class="comment">/* Key size in bits                       */</span></div><div class="line">    NX_CRYPTO_AES_IV_LEN_IN_BITS,            <span class="comment">/* IV size in bits                        */</span></div><div class="line">    0,                                       <span class="comment">/* ICV size in bits, not used             */</span></div><div class="line">    (NX_CRYPTO_AES_BLOCK_SIZE_IN_BITS &gt;&gt; 3), <span class="comment">/* Block size in bytes                    */</span></div><div class="line">    <span class="keyword">sizeof</span>(NX_CRYPTO_AES),                   <span class="comment">/* Metadata size in bytes                 */</span></div><div class="line">    _nx_crypto_method_aes_init,              <span class="comment">/* AES-CBC initialization routine         */</span></div><div class="line">    _nx_crypto_method_aes_cleanup,           <span class="comment">/* AES-CBC cleanup routine                */</span></div><div class="line">    _nx_crypto_method_aes_ctr_operation      <span class="comment">/* AES-CBC operation                      */</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/*Note: For CTR, the key_ctr is the conjunction of key and nonce.  */</span></div><div class="line"><span class="comment">/* D0E78C4D0B30D33F5BF4A132B2F94A4A38963511A3904B117E35A37B5AAC8A193BF0D158 */</span></div><div class="line"><span class="keyword">const</span> uint8_t key_ctr_256[] =</div><div class="line">{</div><div class="line">    <span class="comment">/* AES Key */</span></div><div class="line">    0xD0, 0xE7, 0x8C, 0x4D, 0x0B, 0x30, 0xD3, 0x3F, 0x5B, 0xF4, 0xA1, 0x32, 0xB2, 0xF9, 0x4A, 0x4A,</div><div class="line">    0x38, 0x96, 0x35, 0x11, 0xA3, 0x90, 0x4B, 0x11, 0x7E, 0x35, 0xA3, 0x7B, 0x5A, 0xAC, 0x8A, 0x19,</div><div class="line"></div><div class="line">    <span class="comment">/* Nonce */</span></div><div class="line">    0x3B, 0xF0, 0xD1, 0x58,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* A1A31704C8B7E16C */</span></div><div class="line"><span class="keyword">const</span> uint8_t iv_ctr_256[] =</div><div class="line">{</div><div class="line">    0xA1, 0xA3, 0x17, 0x04, 0xC8, 0xB7, 0xE1, 0x6C,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* 981FA33222C5451017530155A4BF7F29 */</span></div><div class="line"><span class="keyword">const</span> uint8_t plain_ctr_256[] =</div><div class="line">{</div><div class="line">    0x98, 0x1F, 0xA3, 0x32, 0x22, 0xC5, 0x45, 0x10, 0x17, 0x53, 0x01, 0x55, 0xA4, 0xBF, 0x7F, 0x29,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* 643B91B4E541B20AAAEAB77F2D328566 */</span></div><div class="line"><span class="keyword">const</span> uint8_t secret_ctr_256[] =</div><div class="line">{</div><div class="line">    0x64, 0x3B, 0x91, 0xB4, 0xE5, 0x41, 0xB2, 0x0A, 0xAA, 0xEA, 0xB7, 0x7F, 0x2D, 0x32, 0x85, 0x66,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> netx_secure_crypto_aes256ctr_multipart_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint8_t  metadata[<span class="keyword">sizeof</span>(NX_CRYPTO_AES)];</div><div class="line">    uint32_t metadata_size = <span class="keyword">sizeof</span>(NX_CRYPTO_AES);</div><div class="line">    <span class="keywordtype">void</span>   * handler       = NX_CRYPTO_NULL;</div><div class="line">    uint32_t err           = NX_CRYPTO_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* 3 AES Blocks */</span></div><div class="line">    uint8_t generated_ciphertext[3U * NX_CRYPTO_AES_BLOCK_SIZE] = {0};</div><div class="line">    uint8_t generated_plaintext[3U * NX_CRYPTO_AES_BLOCK_SIZE]  = {0};</div><div class="line"></div><div class="line">    <span class="comment">/* Setup the platform; initialize the SCE and the TRNG */</span></div><div class="line">    err = nx_crypto_initialize();</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    err =</div><div class="line">        _nx_crypto_method_aes_init(&amp;crypto_method_aes_ctr_256,</div><div class="line">                                   (uint8_t *) key_ctr_256,</div><div class="line">                                   crypto_method_aes_ctr_256.nx_crypto_key_size_in_bits,</div><div class="line">                                   &amp;handler,</div><div class="line">                                   metadata,</div><div class="line">                                   metadata_size);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Encryption. */</span></div><div class="line">    err = _nx_crypto_method_aes_operation(NX_CRYPTO_ENCRYPT,</div><div class="line">                                          handler,</div><div class="line">                                          &amp;crypto_method_aes_ctr_256,</div><div class="line">                                          (uint8_t *) key_ctr_256,</div><div class="line">                                          crypto_method_aes_ctr_256.nx_crypto_key_size_in_bits,</div><div class="line">                                          (uint8_t *) plain_ctr_256,</div><div class="line">                                          <span class="keyword">sizeof</span>(plain_ctr_256),</div><div class="line">                                          (uint8_t *) iv_ctr_256,</div><div class="line">                                          generated_ciphertext,</div><div class="line">                                          <span class="keyword">sizeof</span>(generated_ciphertext),</div><div class="line">                                          metadata,</div><div class="line">                                          metadata_size,</div><div class="line">                                          NX_CRYPTO_NULL,</div><div class="line">                                          NX_CRYPTO_NULL);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Verify generated ciphertext matches the expected ciphertext */</span></div><div class="line">    err = (uint32_t) memcmp(generated_ciphertext, secret_ctr_256, <span class="keyword">sizeof</span>(secret_ctr_256));</div><div class="line">    assert(0 == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Decryption. */</span></div><div class="line">    err = _nx_crypto_method_aes_operation(NX_CRYPTO_DECRYPT,</div><div class="line">                                          handler,</div><div class="line">                                          &amp;crypto_method_aes_ctr_256,</div><div class="line">                                          (uint8_t *) key_ctr_256,</div><div class="line">                                          crypto_method_aes_ctr_256.nx_crypto_key_size_in_bits,</div><div class="line">                                          (uint8_t *) secret_ctr_256,</div><div class="line">                                          <span class="keyword">sizeof</span>(secret_ctr_256),</div><div class="line">                                          (uint8_t *) iv_ctr_256,</div><div class="line">                                          generated_plaintext,</div><div class="line">                                          <span class="keyword">sizeof</span>(generated_plaintext),</div><div class="line">                                          metadata,</div><div class="line">                                          metadata_size,</div><div class="line">                                          NX_CRYPTO_NULL,</div><div class="line">                                          NX_CRYPTO_NULL);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Verify generated plaintext matches the input plaintext */</span></div><div class="line">    err = (uint32_t) memcmp(generated_plaintext, plain_ctr_256, <span class="keyword">sizeof</span>(plain_ctr_256));</div><div class="line">    assert(0 == err);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>ECDSA Example</h2>
<p>This is an example on using the NetX Crypto API to sign and verify input message data. Based on the hash algorithm selected a digest is computed of the plain input message before sign/verify.</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> NX_CRYPTO_METHOD crypto_method_ecdsa;</div><div class="line"><span class="keyword">extern</span> NX_CRYPTO_METHOD crypto_method_ec_secp256;</div><div class="line"><span class="keyword">extern</span> NX_CRYPTO_METHOD crypto_method_sha256;</div><div class="line"></div><div class="line"><span class="keyword">const</span> uint8_t ECC_SECP256R1Keydata[] =</div><div class="line">{</div><div class="line">    0xf9, 0xa7, 0x68, 0x71, 0x24, 0x68, 0x9d, 0x32, 0x92, 0x6f, 0x1d, 0xfb, 0xbe, 0xf2, 0x61, 0x41, <span class="comment">// NOLINT(readability-magic-numbers)</span></div><div class="line">    0x07, 0x54, 0x0d, 0xb9, 0xa8, 0x8a, 0x8b, 0xc2, 0xd5, 0xe9, 0x38, 0x4b, 0xf9, 0xe5, 0x43, 0x5a  <span class="comment">// NOLINT(readability-magic-numbers)</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">const</span> uint8_t ECC_SECP256R1PublicKeydata[] =</div><div class="line">{</div><div class="line">    0x04,                                                                                           <span class="comment">/* ASN1 Constant */</span></div><div class="line">    0x5b, 0xba, 0xd4, 0x2e, 0xb5, 0xc1, 0x07, 0xf2, 0x0e, 0x01, 0x95, 0x42, 0x6e, 0x90, 0xb8, 0x4e, <span class="comment">// NOLINT(readability-magic-numbers)</span></div><div class="line">    0xe9, 0x5a, 0xa1, 0xe8, 0x4c, 0x6c, 0xa5, 0x32, 0x3c, 0xf3, 0x09, 0xf5, 0xff, 0x8b, 0x3d, 0x26, <span class="comment">// NOLINT(readability-magic-numbers)</span></div><div class="line">    0xb6, 0x88, 0xc1, 0xdb, 0x02, 0xaf, 0x4d, 0xa5, 0x0e, 0x73, 0x61, 0x96, 0xb3, 0x59, 0x95, 0x6f, <span class="comment">// NOLINT(readability-magic-numbers)</span></div><div class="line">    0x5e, 0xc9, 0xa1, 0xf9, 0xb7, 0xb3, 0xb6, 0xdf, 0x54, 0x82, 0x79, 0xe3, 0xb6, 0x4e, 0xac, 0xb6  <span class="comment">// NOLINT(readability-magic-numbers)</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">const</span> uint8_t ECC_SECP256R1Message[] = <span class="stringliteral">&quot;ASYMMETRIC_INPUT_FOR_SIGN......&quot;</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> netx_secure_crypto_ecdsa_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint8_t  metadata[<span class="keyword">sizeof</span>(NX_CRYPTO_ECDSA)];</div><div class="line">    uint32_t metadata_size = <span class="keyword">sizeof</span>(NX_CRYPTO_ECDSA);</div><div class="line">    <span class="keywordtype">void</span>   * handler       = NX_CRYPTO_NULL;</div><div class="line">    uint32_t err           = NX_CRYPTO_SUCCESS;</div><div class="line"></div><div class="line">    ULONG sig_length;</div><div class="line">    NX_CRYPTO_EXTENDED_OUTPUT extended_output;</div><div class="line"></div><div class="line">    uint8_t output[RM_NETX_SECURE_CRYPTO_EXAMPLE_OUTPUT_BUFFER_SIZE] = {0};</div><div class="line"></div><div class="line">    <span class="comment">/* Setup the platform; initialize the SCE and the TRNG */</span></div><div class="line">    err = nx_crypto_initialize();</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Call the crypto initialization function.  */</span></div><div class="line">    err = _nx_crypto_method_ecdsa_init(&amp;crypto_method_ecdsa, NX_CRYPTO_NULL, 0, &amp;handler, metadata, metadata_size);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Set hash method.  */</span></div><div class="line">    err = _nx_crypto_method_ecdsa_operation(NX_CRYPTO_HASH_METHOD_SET,</div><div class="line">                                            handler,</div><div class="line">                                            &amp;crypto_method_ecdsa,</div><div class="line">                                            NX_CRYPTO_NULL,</div><div class="line">                                            0,</div><div class="line">                                            (uint8_t *) &amp;crypto_method_sha256,</div><div class="line">                                            <span class="keyword">sizeof</span>(NX_CRYPTO_METHOD *),</div><div class="line">                                            NX_CRYPTO_NULL,</div><div class="line">                                            NX_CRYPTO_NULL,</div><div class="line">                                            0,</div><div class="line">                                            metadata,</div><div class="line">                                            metadata_size,</div><div class="line">                                            NX_CRYPTO_NULL,</div><div class="line">                                            NX_CRYPTO_NULL);</div><div class="line"></div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Set EC curve.  */</span></div><div class="line">    err =</div><div class="line">        _nx_crypto_method_ecdsa_operation(NX_CRYPTO_EC_CURVE_SET,</div><div class="line">                                          handler,</div><div class="line">                                          &amp;crypto_method_ecdsa,</div><div class="line">                                          NX_CRYPTO_NULL,</div><div class="line">                                          0,</div><div class="line">                                          (uint8_t *) &amp;crypto_method_ec_secp256,</div><div class="line">                                          <span class="keyword">sizeof</span>(NX_CRYPTO_METHOD *),</div><div class="line">                                          NX_CRYPTO_NULL,</div><div class="line">                                          NX_CRYPTO_NULL,</div><div class="line">                                          0,</div><div class="line">                                          metadata,</div><div class="line">                                          metadata_size,</div><div class="line">                                          NX_CRYPTO_NULL,</div><div class="line">                                          NX_CRYPTO_NULL);</div><div class="line"></div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    extended_output.nx_crypto_extended_output_data           = output;</div><div class="line">    extended_output.nx_crypto_extended_output_length_in_byte = <span class="keyword">sizeof</span>(output);</div><div class="line"></div><div class="line">    <span class="comment">/* Sign the hash data using ECDSA. */</span></div><div class="line">    err = _nx_crypto_method_ecdsa_operation(NX_CRYPTO_SIGNATURE_GENERATE,</div><div class="line">                                            handler,</div><div class="line">                                            &amp;crypto_method_ec_secp256,</div><div class="line">                                            (uint8_t *) ECC_SECP256R1Keydata,</div><div class="line">                                            <span class="keyword">sizeof</span>(ECC_SECP256R1Keydata) &lt;&lt; 3,</div><div class="line">                                            (uint8_t *) ECC_SECP256R1Message,</div><div class="line">        <span class="keyword">sizeof</span>(ECC_SECP256R1Message),</div><div class="line">        NX_CRYPTO_NULL,</div><div class="line">                                            (uint8_t *) &amp;extended_output,</div><div class="line">        <span class="keyword">sizeof</span>(extended_output),</div><div class="line">        metadata,</div><div class="line">        metadata_size,</div><div class="line">        NX_CRYPTO_NULL,</div><div class="line">        NX_CRYPTO_NULL);</div><div class="line"></div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    sig_length = extended_output.nx_crypto_extended_output_actual_size;</div><div class="line"></div><div class="line">    <span class="comment">/* Verify the generated signature. */</span></div><div class="line">    err = _nx_crypto_method_ecdsa_operation(NX_CRYPTO_SIGNATURE_VERIFY,</div><div class="line">                                            handler,</div><div class="line">                                            &amp;crypto_method_ec_secp256,</div><div class="line">                                            (uint8_t *) ECC_SECP256R1PublicKeydata,</div><div class="line">                                            <span class="keyword">sizeof</span>(ECC_SECP256R1PublicKeydata) &lt;&lt; 3,</div><div class="line">                                            (uint8_t *) ECC_SECP256R1Message,</div><div class="line">        <span class="keyword">sizeof</span>(ECC_SECP256R1Message),</div><div class="line">        NX_CRYPTO_NULL,</div><div class="line">        output,</div><div class="line">        sig_length,</div><div class="line">        metadata,</div><div class="line">        metadata_size,</div><div class="line">        NX_CRYPTO_NULL,</div><div class="line">        NX_CRYPTO_NULL);</div><div class="line"></div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>ECDH Example</h2>
<p>This is an example on using the NetX Crypto API to generate a shared secret using ECDH. A shared secret is computed using known public key (from peer) and generated private key. Another shared secret is computed using the generated public key and known private key (imported to mimic peer). Both the shared secrets are checked to be the same.</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> NX_CRYPTO_METHOD crypto_method_ecdh;</div><div class="line"></div><div class="line"><span class="comment">/*Private key 59137e38152350b195c9718d39673d519838055ad908dd4757152fd8255c09bf */</span></div><div class="line"><span class="keyword">const</span> uint8_t ECC_SECP256R1Keydata_ecdh[] =</div><div class="line">{</div><div class="line">    0x59, 0x13, 0x7e, 0x38, 0x15, 0x23, 0x50, 0xb1, 0x95, 0xc9, 0x71, 0x8d, 0x39, 0x67, 0x3d, 0x51, <span class="comment">// NOLINT(readability-magic-numbers)</span></div><div class="line">    0x98, 0x38, 0x05, 0x5a, 0xd9, 0x08, 0xdd, 0x47, 0x57, 0x15, 0x2f, 0xd8, 0x25, 0x5c, 0x09, 0xbf, <span class="comment">// NOLINT(readability-magic-numbers)</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/*Public key 4, a8c5fdce8b62c5ada598f141adb3b26cf254c280b2857a63d2ad783a73115f6b, 806e1aafec4af80a0d786b3de45375b517a7e5b51ffb2c356537c9e6ef227d4a*/</span></div><div class="line"><span class="keyword">const</span> uint8_t ECC_SECP256R1PublicKeydata_ecdh[] =</div><div class="line">{</div><div class="line">    0x04,</div><div class="line">    0xa8,0xc5, 0xfd, 0xce, 0x8b,  0x62, 0xc5, 0xad, 0xa5, 0x98, 0xf1, 0x41, 0xad, 0xb3, 0xb2, 0x6c, <span class="comment">// NOLINT(readability-magic-numbers)</span></div><div class="line">    0xf2,0x54, 0xc2, 0x80, 0xb2,  0x85, 0x7a, 0x63, 0xd2, 0xad, 0x78, 0x3a, 0x73, 0x11, 0x5f, 0x6b, <span class="comment">// NOLINT(readability-magic-numbers)</span></div><div class="line">    0x80,0x6e, 0x1a, 0xaf, 0xec,  0x4a, 0xf8, 0x0a, 0x0d, 0x78, 0x6b, 0x3d, 0xe4, 0x53, 0x75, 0xb5, <span class="comment">// NOLINT(readability-magic-numbers)</span></div><div class="line">    0x17,0xa7, 0xe5, 0xb5, 0x1f,  0xfb, 0x2c, 0x35, 0x65, 0x37, 0xc9, 0xe6, 0xef, 0x22, 0x7d, 0x4a, <span class="comment">// NOLINT(readability-magic-numbers)</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> netx_secure_crypto_ecdh_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint8_t  metadata[<span class="keyword">sizeof</span>(NX_CRYPTO_ECDH)];</div><div class="line">    uint32_t metadata_size = <span class="keyword">sizeof</span>(NX_CRYPTO_ECDH);</div><div class="line">    uint32_t err           = NX_CRYPTO_SUCCESS;</div><div class="line"></div><div class="line">    uint8_t  local_public_key[RM_NETX_SECURE_CRYPTO_EXAMPLE_OUTPUT_BUFFER_SIZE] = {0};</div><div class="line">    uint32_t local_public_key_len = 0;</div><div class="line"></div><div class="line">    uint8_t  shared_secret[RM_NETX_SECURE_CRYPTO_EXAMPLE_OUTPUT_BUFFER_SIZE] = {0};</div><div class="line">    uint32_t shared_secret_len = 0;</div><div class="line"></div><div class="line">    uint8_t output[RM_NETX_SECURE_CRYPTO_EXAMPLE_OUTPUT_BUFFER_SIZE] = {0};</div><div class="line"></div><div class="line">    NX_CRYPTO_EXTENDED_OUTPUT extended_output;</div><div class="line"></div><div class="line">    <span class="comment">/* Setup the platform; initialize the SCE and the TRNG */</span></div><div class="line">    err = nx_crypto_initialize();</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Call the crypto initialization function.  */</span></div><div class="line">    err = _nx_crypto_method_ecdh_init(&amp;crypto_method_ecdh, NX_CRYPTO_NULL, 0, NX_CRYPTO_NULL, metadata, metadata_size);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Set EC curve.  */</span></div><div class="line">    err = _nx_crypto_method_ecdh_operation(NX_CRYPTO_EC_CURVE_SET,</div><div class="line">                                           NX_CRYPTO_NULL,</div><div class="line">                                           &amp;crypto_method_ecdh,</div><div class="line">                                           NX_CRYPTO_NULL,</div><div class="line">                                           0,</div><div class="line">                                           (uint8_t *) &amp;crypto_method_ec_secp256,</div><div class="line">                                           <span class="keyword">sizeof</span>(NX_CRYPTO_METHOD *),</div><div class="line">                                           NX_CRYPTO_NULL,</div><div class="line">                                           NX_CRYPTO_NULL,</div><div class="line">                                           0,</div><div class="line">                                           metadata,</div><div class="line">                                           metadata_size,</div><div class="line">                                           NX_CRYPTO_NULL,</div><div class="line">                                           NX_CRYPTO_NULL);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Generate local public key. This will generate a key pair.</span></div><div class="line"><span class="comment">     * The private wrapped key will be held by the ecdh context and the public key (local_public_key)</span></div><div class="line"><span class="comment">     * will be returned for sharing with the peer.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    extended_output.nx_crypto_extended_output_data           = local_public_key;</div><div class="line">    extended_output.nx_crypto_extended_output_length_in_byte = <span class="keyword">sizeof</span>(local_public_key);</div><div class="line">    err = _nx_crypto_method_ecdh_operation(NX_CRYPTO_DH_SETUP,</div><div class="line">                                           NX_CRYPTO_NULL,</div><div class="line">                                           &amp;crypto_method_ecdh,</div><div class="line">                                           NX_CRYPTO_NULL,</div><div class="line">                                           0,</div><div class="line">                                           NX_CRYPTO_NULL,</div><div class="line">                                           0,</div><div class="line">                                           NX_CRYPTO_NULL,</div><div class="line">                                           (uint8_t *) &amp;extended_output,</div><div class="line">                                           <span class="keyword">sizeof</span>(extended_output),</div><div class="line">                                           metadata,</div><div class="line">                                           metadata_size,</div><div class="line">                                           NX_CRYPTO_NULL,</div><div class="line">                                           NX_CRYPTO_NULL);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    local_public_key_len = extended_output.nx_crypto_extended_output_actual_size;</div><div class="line"></div><div class="line">    <span class="comment">/* Calculate shared secret using the test (peer&#39;s) public key.  */</span></div><div class="line">    extended_output.nx_crypto_extended_output_data           = shared_secret;</div><div class="line">    extended_output.nx_crypto_extended_output_length_in_byte = <span class="keyword">sizeof</span>(shared_secret);</div><div class="line">    err = _nx_crypto_method_ecdh_operation(NX_CRYPTO_DH_CALCULATE,</div><div class="line">                                           NX_CRYPTO_NULL,</div><div class="line">                                           &amp;crypto_method_ecdh,</div><div class="line">                                           NX_CRYPTO_NULL,</div><div class="line">                                           0,</div><div class="line">                                           (uint8_t *) ECC_SECP256R1PublicKeydata_ecdh,</div><div class="line">                                           <span class="keyword">sizeof</span>(ECC_SECP256R1PublicKeydata_ecdh),</div><div class="line">                                           NX_CRYPTO_NULL,</div><div class="line">                                           (uint8_t *) &amp;extended_output,</div><div class="line">                                           <span class="keyword">sizeof</span>(extended_output),</div><div class="line">                                           metadata,</div><div class="line">                                           metadata_size,</div><div class="line">                                           NX_CRYPTO_NULL,</div><div class="line">                                           NX_CRYPTO_NULL);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    shared_secret_len = extended_output.nx_crypto_extended_output_actual_size;</div><div class="line"></div><div class="line">    err = _nx_crypto_method_ecdh_cleanup(metadata);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Verify. The below operations will be carried out by the peer.  */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Call the crypto initialization function.  */</span></div><div class="line">    err = _nx_crypto_method_ecdh_init(&amp;crypto_method_ecdh, NX_CRYPTO_NULL, 0, NX_CRYPTO_NULL, metadata, metadata_size);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Set EC curve.  */</span></div><div class="line">    err = _nx_crypto_method_ecdh_operation(NX_CRYPTO_EC_CURVE_SET,</div><div class="line">                                           NX_CRYPTO_NULL,</div><div class="line">                                           &amp;crypto_method_ecdh,</div><div class="line">                                           NX_CRYPTO_NULL,</div><div class="line">                                           0,</div><div class="line">                                           (uint8_t *) &amp;crypto_method_ec_secp256,</div><div class="line">                                           <span class="keyword">sizeof</span>(NX_CRYPTO_METHOD *),</div><div class="line">                                           NX_CRYPTO_NULL,</div><div class="line">                                           NX_CRYPTO_NULL,</div><div class="line">                                           0,</div><div class="line">                                           metadata,</div><div class="line">                                           metadata_size,</div><div class="line">                                           NX_CRYPTO_NULL,</div><div class="line">                                           NX_CRYPTO_NULL);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Import the test private key. The peer could generate its own key pair,</span></div><div class="line"><span class="comment">     * in this example a test private key is used for simplicity. */</span></div><div class="line">    err =</div><div class="line">        _nx_crypto_method_ecdh_operation(NX_CRYPTO_DH_KEY_PAIR_IMPORT,</div><div class="line">                                         NX_CRYPTO_NULL,</div><div class="line">                                         &amp;crypto_method_ecdh,</div><div class="line">                                         (uint8_t *) ECC_SECP256R1Keydata_ecdh,</div><div class="line">                                         (NX_CRYPTO_KEY_SIZE) (<span class="keyword">sizeof</span>(ECC_SECP256R1Keydata_ecdh) &lt;&lt; 3),</div><div class="line">                                         (uint8_t *) ECC_SECP256R1PublicKeydata_ecdh,</div><div class="line">                                         <span class="keyword">sizeof</span>(ECC_SECP256R1PublicKeydata_ecdh),</div><div class="line">                                         NX_CRYPTO_NULL,</div><div class="line">                                         NX_CRYPTO_NULL,</div><div class="line">                                         0,</div><div class="line">                                         metadata,</div><div class="line">                                         metadata_size,</div><div class="line">                                         NX_CRYPTO_NULL,</div><div class="line">                                         NX_CRYPTO_NULL);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Calculate the shared secret using the local public key generated above and shared with the peer.  */</span></div><div class="line">    extended_output.nx_crypto_extended_output_data           = output;</div><div class="line">    extended_output.nx_crypto_extended_output_length_in_byte = <span class="keyword">sizeof</span>(output);</div><div class="line">    err = _nx_crypto_method_ecdh_operation(NX_CRYPTO_DH_CALCULATE,</div><div class="line">                                           NX_CRYPTO_NULL,</div><div class="line">                                           &amp;crypto_method_ecdh,</div><div class="line">                                           NX_CRYPTO_NULL,</div><div class="line">                                           0,</div><div class="line">                                           local_public_key,</div><div class="line">                                           local_public_key_len,</div><div class="line">                                           NX_CRYPTO_NULL,</div><div class="line">                                           (uint8_t *) &amp;extended_output,</div><div class="line">                                           <span class="keyword">sizeof</span>(extended_output),</div><div class="line">                                           metadata,</div><div class="line">                                           metadata_size,</div><div class="line">                                           NX_CRYPTO_NULL,</div><div class="line">                                           NX_CRYPTO_NULL);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Validate the output. Both the parties must generate the same shared secret  */</span></div><div class="line">    err = (extended_output.nx_crypto_extended_output_actual_size != shared_secret_len);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    err = (uint32_t) memcmp(output, shared_secret, extended_output.nx_crypto_extended_output_actual_size);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>RSA Example</h2>
<p>This is an example on using the NetX Crypto API to encrypt and decrypt input message data.</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> NX_CRYPTO_METHOD crypto_method_rsa;</div><div class="line"></div><div class="line"><span class="comment">/* 00010001 */</span></div><div class="line"><span class="keyword">const</span> uint8_t public_e[] =</div><div class="line">{</div><div class="line">    0x00, 0x01, 0x00, 0x01,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* 13FF7429F8E851F1079CCFCE3B3CD8606ABA8607AD85CBB3057501EBD58811F3C04823171F192C048E1E883AF8CF958810151D3874AEDC8EC4F88D2065C581569F1E200852DD40B6DFD1652659085A9DD1D3B869EA3617D904D209DE156A60BA5929D02F16430273D10720C2F28D2B95684DCAA6B9F6A508EA2CBBC11B9F3F30D6201EA6CFFBBF1C44255CEC58EE70DBC872442BCCF115D8F743557B5DE5F42DDDA6CEAE7977793CC9D90ADFE65E520F5520B615CF3B8C2DC82D7AC75EDB1297CF38AB23A37EED18D4DD45D9AD051B26401BE86E8C8E53F9585A702D02F1B5BD65F6739DFA6BFFE560CA130B6F1D4779C556C06D9CD29FB72D8851904F9CDEE9 */</span></div><div class="line"><span class="keyword">const</span> uint8_t private_e_2048[] =</div><div class="line">{</div><div class="line">    0x13, 0xFF, 0x74, 0x29, 0xF8, 0xE8, 0x51, 0xF1, 0x07, 0x9C, 0xCF, 0xCE, 0x3B, 0x3C, 0xD8, 0x60,</div><div class="line">    0x6A, 0xBA, 0x86, 0x07, 0xAD, 0x85, 0xCB, 0xB3, 0x05, 0x75, 0x01, 0xEB, 0xD5, 0x88, 0x11, 0xF3,</div><div class="line">    0xC0, 0x48, 0x23, 0x17, 0x1F, 0x19, 0x2C, 0x04, 0x8E, 0x1E, 0x88, 0x3A, 0xF8, 0xCF, 0x95, 0x88,</div><div class="line">    0x10, 0x15, 0x1D, 0x38, 0x74, 0xAE, 0xDC, 0x8E, 0xC4, 0xF8, 0x8D, 0x20, 0x65, 0xC5, 0x81, 0x56,</div><div class="line">    0x9F, 0x1E, 0x20, 0x08, 0x52, 0xDD, 0x40, 0xB6, 0xDF, 0xD1, 0x65, 0x26, 0x59, 0x08, 0x5A, 0x9D,</div><div class="line">    0xD1, 0xD3, 0xB8, 0x69, 0xEA, 0x36, 0x17, 0xD9, 0x04, 0xD2, 0x09, 0xDE, 0x15, 0x6A, 0x60, 0xBA,</div><div class="line">    0x59, 0x29, 0xD0, 0x2F, 0x16, 0x43, 0x02, 0x73, 0xD1, 0x07, 0x20, 0xC2, 0xF2, 0x8D, 0x2B, 0x95,</div><div class="line">    0x68, 0x4D, 0xCA, 0xA6, 0xB9, 0xF6, 0xA5, 0x08, 0xEA, 0x2C, 0xBB, 0xC1, 0x1B, 0x9F, 0x3F, 0x30,</div><div class="line">    0xD6, 0x20, 0x1E, 0xA6, 0xCF, 0xFB, 0xBF, 0x1C, 0x44, 0x25, 0x5C, 0xEC, 0x58, 0xEE, 0x70, 0xDB,</div><div class="line">    0xC8, 0x72, 0x44, 0x2B, 0xCC, 0xF1, 0x15, 0xD8, 0xF7, 0x43, 0x55, 0x7B, 0x5D, 0xE5, 0xF4, 0x2D,</div><div class="line">    0xDD, 0xA6, 0xCE, 0xAE, 0x79, 0x77, 0x79, 0x3C, 0xC9, 0xD9, 0x0A, 0xDF, 0xE6, 0x5E, 0x52, 0x0F,</div><div class="line">    0x55, 0x20, 0xB6, 0x15, 0xCF, 0x3B, 0x8C, 0x2D, 0xC8, 0x2D, 0x7A, 0xC7, 0x5E, 0xDB, 0x12, 0x97,</div><div class="line">    0xCF, 0x38, 0xAB, 0x23, 0xA3, 0x7E, 0xED, 0x18, 0xD4, 0xDD, 0x45, 0xD9, 0xAD, 0x05, 0x1B, 0x26,</div><div class="line">    0x40, 0x1B, 0xE8, 0x6E, 0x8C, 0x8E, 0x53, 0xF9, 0x58, 0x5A, 0x70, 0x2D, 0x02, 0xF1, 0xB5, 0xBD,</div><div class="line">    0x65, 0xF6, 0x73, 0x9D, 0xFA, 0x6B, 0xFF, 0xE5, 0x60, 0xCA, 0x13, 0x0B, 0x6F, 0x1D, 0x47, 0x79,</div><div class="line">    0xC5, 0x56, 0xC0, 0x6D, 0x9C, 0xD2, 0x9F, 0xB7, 0x2D, 0x88, 0x51, 0x90, 0x4F, 0x9C, 0xDE, 0xE9,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* E0F5059966A8AEC4BF7CDAC8AE2430BDF61C54D09CAB9963CBF9A52AC641E384B6431D3B6A9D1811519A2904E1170A44446C80E7638A4AF2720A7654AB740D8A151FDD216F3D6933422FD9AC14AEDE9CCD021EA79E46925F4B18FD1AF2C0073CFC3A69AC71A2B3673D08136CDB01C379892601C7C857D68018DAE924CB8CD29377A14C752B92BAFF14C3A49725AE2FEFAAD4686D8A7D9F94EB11BF81E05BD5D2586526FB129E73539F9223D496B2ACA23CCACC34D5B18533BD0F5815A76F94F4F55D965FE61599B44BD8FBAD35F42B612A4C4F2765B2097A5C0090EA8166D9C6DA1E03B6119736B794600491C48433132D0F15D5DE3BB4270DF6BC9012B74931 */</span></div><div class="line"><span class="keyword">const</span> uint8_t m_2048[] =</div><div class="line">{</div><div class="line">    0xE0, 0xF5, 0x05, 0x99, 0x66, 0xA8, 0xAE, 0xC4, 0xBF, 0x7C, 0xDA, 0xC8, 0xAE, 0x24, 0x30, 0xBD,</div><div class="line">    0xF6, 0x1C, 0x54, 0xD0, 0x9C, 0xAB, 0x99, 0x63, 0xCB, 0xF9, 0xA5, 0x2A, 0xC6, 0x41, 0xE3, 0x84,</div><div class="line">    0xB6, 0x43, 0x1D, 0x3B, 0x6A, 0x9D, 0x18, 0x11, 0x51, 0x9A, 0x29, 0x04, 0xE1, 0x17, 0x0A, 0x44,</div><div class="line">    0x44, 0x6C, 0x80, 0xE7, 0x63, 0x8A, 0x4A, 0xF2, 0x72, 0x0A, 0x76, 0x54, 0xAB, 0x74, 0x0D, 0x8A,</div><div class="line">    0x15, 0x1F, 0xDD, 0x21, 0x6F, 0x3D, 0x69, 0x33, 0x42, 0x2F, 0xD9, 0xAC, 0x14, 0xAE, 0xDE, 0x9C,</div><div class="line">    0xCD, 0x02, 0x1E, 0xA7, 0x9E, 0x46, 0x92, 0x5F, 0x4B, 0x18, 0xFD, 0x1A, 0xF2, 0xC0, 0x07, 0x3C,</div><div class="line">    0xFC, 0x3A, 0x69, 0xAC, 0x71, 0xA2, 0xB3, 0x67, 0x3D, 0x08, 0x13, 0x6C, 0xDB, 0x01, 0xC3, 0x79,</div><div class="line">    0x89, 0x26, 0x01, 0xC7, 0xC8, 0x57, 0xD6, 0x80, 0x18, 0xDA, 0xE9, 0x24, 0xCB, 0x8C, 0xD2, 0x93,</div><div class="line">    0x77, 0xA1, 0x4C, 0x75, 0x2B, 0x92, 0xBA, 0xFF, 0x14, 0xC3, 0xA4, 0x97, 0x25, 0xAE, 0x2F, 0xEF,</div><div class="line">    0xAA, 0xD4, 0x68, 0x6D, 0x8A, 0x7D, 0x9F, 0x94, 0xEB, 0x11, 0xBF, 0x81, 0xE0, 0x5B, 0xD5, 0xD2,</div><div class="line">    0x58, 0x65, 0x26, 0xFB, 0x12, 0x9E, 0x73, 0x53, 0x9F, 0x92, 0x23, 0xD4, 0x96, 0xB2, 0xAC, 0xA2,</div><div class="line">    0x3C, 0xCA, 0xCC, 0x34, 0xD5, 0xB1, 0x85, 0x33, 0xBD, 0x0F, 0x58, 0x15, 0xA7, 0x6F, 0x94, 0xF4,</div><div class="line">    0xF5, 0x5D, 0x96, 0x5F, 0xE6, 0x15, 0x99, 0xB4, 0x4B, 0xD8, 0xFB, 0xAD, 0x35, 0xF4, 0x2B, 0x61,</div><div class="line">    0x2A, 0x4C, 0x4F, 0x27, 0x65, 0xB2, 0x09, 0x7A, 0x5C, 0x00, 0x90, 0xEA, 0x81, 0x66, 0xD9, 0xC6,</div><div class="line">    0xDA, 0x1E, 0x03, 0xB6, 0x11, 0x97, 0x36, 0xB7, 0x94, 0x60, 0x04, 0x91, 0xC4, 0x84, 0x33, 0x13,</div><div class="line">    0x2D, 0x0F, 0x15, 0xD5, 0xDE, 0x3B, 0xB4, 0x27, 0x0D, 0xF6, 0xBC, 0x90, 0x12, 0xB7, 0x49, 0x31,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* 551C2E268F7ED44D0E8B063F5B2B510CB809F53BD54E9956971E243B2363DA123C29AB4A009EDE1FCEC54625971A4E3490F3EA398BF7386AAC34720E43FB0C795445B520AEE4D7694EE1474F60F77E1B5F09FE2ED004333658D212122F040322D1564512A1540400F27E18049A762A5EDC9F072CA4F49F408252D42B31BC35523373740E90DDDA6A8CE7865EEB7C694A662C74412406AB190FE0435DA2551F0C24A48939DDA58A0239706D40B4977473689DC36CE5A4DF4EF892816CBDE2780D9389B7384674C93B1DDAF728F292B5671679FC7175AC0A3B2197B809E7CF410417010F3B1316D10D82466C62F3A01667B70A714E0499400E255D4C39EA7DE55C */</span></div><div class="line"><span class="keyword">const</span> uint8_t plain_2048[] =</div><div class="line">{</div><div class="line">    0x55, 0x1C, 0x2E, 0x26, 0x8F, 0x7E, 0xD4, 0x4D, 0x0E, 0x8B, 0x06, 0x3F, 0x5B, 0x2B, 0x51, 0x0C,</div><div class="line">    0xB8, 0x09, 0xF5, 0x3B, 0xD5, 0x4E, 0x99, 0x56, 0x97, 0x1E, 0x24, 0x3B, 0x23, 0x63, 0xDA, 0x12,</div><div class="line">    0x3C, 0x29, 0xAB, 0x4A, 0x00, 0x9E, 0xDE, 0x1F, 0xCE, 0xC5, 0x46, 0x25, 0x97, 0x1A, 0x4E, 0x34,</div><div class="line">    0x90, 0xF3, 0xEA, 0x39, 0x8B, 0xF7, 0x38, 0x6A, 0xAC, 0x34, 0x72, 0x0E, 0x43, 0xFB, 0x0C, 0x79,</div><div class="line">    0x54, 0x45, 0xB5, 0x20, 0xAE, 0xE4, 0xD7, 0x69, 0x4E, 0xE1, 0x47, 0x4F, 0x60, 0xF7, 0x7E, 0x1B,</div><div class="line">    0x5F, 0x09, 0xFE, 0x2E, 0xD0, 0x04, 0x33, 0x36, 0x58, 0xD2, 0x12, 0x12, 0x2F, 0x04, 0x03, 0x22,</div><div class="line">    0xD1, 0x56, 0x45, 0x12, 0xA1, 0x54, 0x04, 0x00, 0xF2, 0x7E, 0x18, 0x04, 0x9A, 0x76, 0x2A, 0x5E,</div><div class="line">    0xDC, 0x9F, 0x07, 0x2C, 0xA4, 0xF4, 0x9F, 0x40, 0x82, 0x52, 0xD4, 0x2B, 0x31, 0xBC, 0x35, 0x52,</div><div class="line">    0x33, 0x73, 0x74, 0x0E, 0x90, 0xDD, 0xDA, 0x6A, 0x8C, 0xE7, 0x86, 0x5E, 0xEB, 0x7C, 0x69, 0x4A,</div><div class="line">    0x66, 0x2C, 0x74, 0x41, 0x24, 0x06, 0xAB, 0x19, 0x0F, 0xE0, 0x43, 0x5D, 0xA2, 0x55, 0x1F, 0x0C,</div><div class="line">    0x24, 0xA4, 0x89, 0x39, 0xDD, 0xA5, 0x8A, 0x02, 0x39, 0x70, 0x6D, 0x40, 0xB4, 0x97, 0x74, 0x73,</div><div class="line">    0x68, 0x9D, 0xC3, 0x6C, 0xE5, 0xA4, 0xDF, 0x4E, 0xF8, 0x92, 0x81, 0x6C, 0xBD, 0xE2, 0x78, 0x0D,</div><div class="line">    0x93, 0x89, 0xB7, 0x38, 0x46, 0x74, 0xC9, 0x3B, 0x1D, 0xDA, 0xF7, 0x28, 0xF2, 0x92, 0xB5, 0x67,</div><div class="line">    0x16, 0x79, 0xFC, 0x71, 0x75, 0xAC, 0x0A, 0x3B, 0x21, 0x97, 0xB8, 0x09, 0xE7, 0xCF, 0x41, 0x04,</div><div class="line">    0x17, 0x01, 0x0F, 0x3B, 0x13, 0x16, 0xD1, 0x0D, 0x82, 0x46, 0x6C, 0x62, 0xF3, 0xA0, 0x16, 0x67,</div><div class="line">    0xB7, 0x0A, 0x71, 0x4E, 0x04, 0x99, 0x40, 0x0E, 0x25, 0x5D, 0x4C, 0x39, 0xEA, 0x7D, 0xE5, 0x5C,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* 10F904E071338569EC131401A7869F42F3BCAE252B5D3C8755FD24D47997A9CD4221D992B2871E05283B98841FC5C379C5D0E35B3938279B344299C3CF1566E0C994D0A9013AF64174F1379A4B5E4E9DE57491F3078F6D10011EA55535D0763E538662C9996F4FCF8B64A768685AA417ADB6978743D3D1F513CF143DD6D383AD6357728A88928D39E27EA4D0B2AF92FC7F63875F9D6A70FAE7993C1FF04DF9A2F99216874BC123D4B7DA7E7E8974CFC10ACF0C7BC8747526A8D16791F969082EA9B0C36D77B67C37B325682D74178E4234D52D5635273301A6CC35E315AE74D659B1433576DAAE6780FA39E0550D971F2CB5817CAAFC24B5220E21C8CEEE85DD */</span></div><div class="line"><span class="keyword">const</span> uint8_t secret_2048[] =</div><div class="line">{</div><div class="line">    0x10, 0xF9, 0x04, 0xE0, 0x71, 0x33, 0x85, 0x69, 0xEC, 0x13, 0x14, 0x01, 0xA7, 0x86, 0x9F, 0x42,</div><div class="line">    0xF3, 0xBC, 0xAE, 0x25, 0x2B, 0x5D, 0x3C, 0x87, 0x55, 0xFD, 0x24, 0xD4, 0x79, 0x97, 0xA9, 0xCD,</div><div class="line">    0x42, 0x21, 0xD9, 0x92, 0xB2, 0x87, 0x1E, 0x05, 0x28, 0x3B, 0x98, 0x84, 0x1F, 0xC5, 0xC3, 0x79,</div><div class="line">    0xC5, 0xD0, 0xE3, 0x5B, 0x39, 0x38, 0x27, 0x9B, 0x34, 0x42, 0x99, 0xC3, 0xCF, 0x15, 0x66, 0xE0,</div><div class="line">    0xC9, 0x94, 0xD0, 0xA9, 0x01, 0x3A, 0xF6, 0x41, 0x74, 0xF1, 0x37, 0x9A, 0x4B, 0x5E, 0x4E, 0x9D,</div><div class="line">    0xE5, 0x74, 0x91, 0xF3, 0x07, 0x8F, 0x6D, 0x10, 0x01, 0x1E, 0xA5, 0x55, 0x35, 0xD0, 0x76, 0x3E,</div><div class="line">    0x53, 0x86, 0x62, 0xC9, 0x99, 0x6F, 0x4F, 0xCF, 0x8B, 0x64, 0xA7, 0x68, 0x68, 0x5A, 0xA4, 0x17,</div><div class="line">    0xAD, 0xB6, 0x97, 0x87, 0x43, 0xD3, 0xD1, 0xF5, 0x13, 0xCF, 0x14, 0x3D, 0xD6, 0xD3, 0x83, 0xAD,</div><div class="line">    0x63, 0x57, 0x72, 0x8A, 0x88, 0x92, 0x8D, 0x39, 0xE2, 0x7E, 0xA4, 0xD0, 0xB2, 0xAF, 0x92, 0xFC,</div><div class="line">    0x7F, 0x63, 0x87, 0x5F, 0x9D, 0x6A, 0x70, 0xFA, 0xE7, 0x99, 0x3C, 0x1F, 0xF0, 0x4D, 0xF9, 0xA2,</div><div class="line">    0xF9, 0x92, 0x16, 0x87, 0x4B, 0xC1, 0x23, 0xD4, 0xB7, 0xDA, 0x7E, 0x7E, 0x89, 0x74, 0xCF, 0xC1,</div><div class="line">    0x0A, 0xCF, 0x0C, 0x7B, 0xC8, 0x74, 0x75, 0x26, 0xA8, 0xD1, 0x67, 0x91, 0xF9, 0x69, 0x08, 0x2E,</div><div class="line">    0xA9, 0xB0, 0xC3, 0x6D, 0x77, 0xB6, 0x7C, 0x37, 0xB3, 0x25, 0x68, 0x2D, 0x74, 0x17, 0x8E, 0x42,</div><div class="line">    0x34, 0xD5, 0x2D, 0x56, 0x35, 0x27, 0x33, 0x01, 0xA6, 0xCC, 0x35, 0xE3, 0x15, 0xAE, 0x74, 0xD6,</div><div class="line">    0x59, 0xB1, 0x43, 0x35, 0x76, 0xDA, 0xAE, 0x67, 0x80, 0xFA, 0x39, 0xE0, 0x55, 0x0D, 0x97, 0x1F,</div><div class="line">    0x2C, 0xB5, 0x81, 0x7C, 0xAA, 0xFC, 0x24, 0xB5, 0x22, 0x0E, 0x21, 0xC8, 0xCE, 0xEE, 0x85, 0xDD,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> netx_secure_crypto_rsa_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint8_t  metadata[<span class="keyword">sizeof</span>(NX_CRYPTO_RSA)];</div><div class="line">    uint32_t metadata_size = <span class="keyword">sizeof</span>(NX_CRYPTO_RSA);</div><div class="line">    uint32_t err           = NX_CRYPTO_SUCCESS;</div><div class="line">    <span class="keywordtype">void</span>   * handler       = NX_CRYPTO_NULL;</div><div class="line">    uint8_t  output[RM_NETX_SECURE_CRYPTO_EXAMPLE_OUTPUT_BUFFER_SIZE] = {0};</div><div class="line"></div><div class="line">    <span class="comment">/* Setup the platform; initialize the SCE and the TRNG */</span></div><div class="line">    err = nx_crypto_initialize();</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Encryption. */</span></div><div class="line">    err =</div><div class="line">        _nx_crypto_method_rsa_init(&amp;crypto_method_rsa,</div><div class="line">                                   (uint8_t *) m_2048,</div><div class="line">                                   RM_NETX_SECURE_CRYPTO_BYTES_TO_BITS(<span class="keyword">sizeof</span>(m_2048)),</div><div class="line">                                   &amp;handler,</div><div class="line">                                   metadata,</div><div class="line">                                   metadata_size);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line">    err = _nx_crypto_method_rsa_operation(NX_CRYPTO_ENCRYPT,</div><div class="line">                                          handler,</div><div class="line">                                          &amp;crypto_method_rsa,</div><div class="line">                                          (uint8_t *) public_e,</div><div class="line">                                          RM_NETX_SECURE_CRYPTO_BYTES_TO_BITS(<span class="keyword">sizeof</span>(public_e)),</div><div class="line">                                          (uint8_t *) plain_2048,</div><div class="line">                                          <span class="keyword">sizeof</span>(m_2048),</div><div class="line">                                          NX_CRYPTO_NULL,</div><div class="line">                                          output,</div><div class="line">                                          <span class="keyword">sizeof</span>(m_2048),</div><div class="line">                                          metadata,</div><div class="line">                                          metadata_size,</div><div class="line">                                          NX_CRYPTO_NULL,</div><div class="line">                                          NX_CRYPTO_NULL);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    err = (uint32_t) memcmp(output, secret_2048, <span class="keyword">sizeof</span>(m_2048));</div><div class="line">    assert(0 == err);</div><div class="line"></div><div class="line">    err = _nx_crypto_method_rsa_cleanup(metadata);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Decryption. */</span></div><div class="line">    memset(output, 0, <span class="keyword">sizeof</span>(output));</div><div class="line">    err =</div><div class="line">        _nx_crypto_method_rsa_init(&amp;crypto_method_rsa,</div><div class="line">                                   (uint8_t *) m_2048,</div><div class="line">                                   RM_NETX_SECURE_CRYPTO_BYTES_TO_BITS(<span class="keyword">sizeof</span>(m_2048)),</div><div class="line">                                   &amp;handler,</div><div class="line">                                   metadata,</div><div class="line">                                   metadata_size);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    err = _nx_crypto_method_rsa_operation(NX_CRYPTO_DECRYPT,</div><div class="line">                                          handler,</div><div class="line">                                          &amp;crypto_method_rsa,</div><div class="line">                                          (uint8_t *) private_e_2048,</div><div class="line">                                          RM_NETX_SECURE_CRYPTO_BYTES_TO_BITS(<span class="keyword">sizeof</span>(private_e_2048)),</div><div class="line">                                          (uint8_t *) secret_2048,</div><div class="line">                                          <span class="keyword">sizeof</span>(m_2048),</div><div class="line">                                          NX_CRYPTO_NULL,</div><div class="line">                                          output,</div><div class="line">                                          <span class="keyword">sizeof</span>(m_2048),</div><div class="line">                                          metadata,</div><div class="line">                                          metadata_size,</div><div class="line">                                          NX_CRYPTO_NULL,</div><div class="line">                                          NX_CRYPTO_NULL);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    err = (uint32_t) memcmp(output, plain_2048, <span class="keyword">sizeof</span>(m_2048));</div><div class="line">    assert(0 == err);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>RSA PKCS1V1.5 Example</h2>
<p>This is an example on using the NetX Crypto API to sign and verify input message data. The plain input message is PKCS1V1.5 encoded before signature generation.</p>
<p><a href="https://github.com/azure-rtos/netxduo/blob/master/crypto_libraries/src/nx_crypto_method_self_test_pkcs1.c">PKCS1V15 Example</a></p>
<h2>HMAC SHA256 Example</h2>
<p>This is an example on using the HMAC with SHA256 hash using the NetX Crypto API.</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> NX_CRYPTO_METHOD crypto_method_hmac_sha256;</div><div class="line"></div><div class="line"><span class="comment">/* C4DA057B81EA740B697FFE1B6EB8591356BA6D5EA7F1B96E4F048030449ACD64E4BB271CB4DCF94937E6 */</span></div><div class="line"><span class="keyword">const</span> uint8_t key_256[] =</div><div class="line">{</div><div class="line">    0xC4, 0xDA, 0x05, 0x7B, 0x81, 0xEA, 0x74, 0x0B, 0x69, 0x7F, 0xFE, 0x1B, 0x6E, 0xB8, 0x59, 0x13,</div><div class="line">    0x56, 0xBA, 0x6D, 0x5E, 0xA7, 0xF1, 0xB9, 0x6E, 0x4F, 0x04, 0x80, 0x30, 0x44, 0x9A, 0xCD, 0x64,</div><div class="line">    0xE4, 0xBB, 0x27, 0x1C, 0xB4, 0xDC, 0xF9, 0x49, 0x37, 0xE6,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* BDACB6555D294D3AFFC245520116062D98F88D64276BDA593492AE71CFE16E46CABC287CB00DF21D96066D5856C2224EEF609D4896302540078F3A0EE325F5337E */</span></div><div class="line"><span class="keyword">const</span> uint8_t plain_256[] =</div><div class="line">{</div><div class="line">    0xBD, 0xAC, 0xB6, 0x55, 0x5D, 0x29, 0x4D, 0x3A, 0xFF, 0xC2, 0x45, 0x52, 0x01, 0x16, 0x06, 0x2D,</div><div class="line">    0x98, 0xF8, 0x8D, 0x64, 0x27, 0x6B, 0xDA, 0x59, 0x34, 0x92, 0xAE, 0x71, 0xCF, 0xE1, 0x6E, 0x46,</div><div class="line">    0xCA, 0xBC, 0x28, 0x7C, 0xB0, 0x0D, 0xF2, 0x1D, 0x96, 0x06, 0x6D, 0x58, 0x56, 0xC2, 0x22, 0x4E,</div><div class="line">    0xEF, 0x60, 0x9D, 0x48, 0x96, 0x30, 0x25, 0x40, 0x07, 0x8F, 0x3A, 0x0E, 0xE3, 0x25, 0xF5, 0x33,</div><div class="line">    0x7E,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* 940F986AC891C9000B72EF0CEC69AB66AF002E3A34EB8A3A5F94484E45C0396C */</span></div><div class="line"><span class="keyword">const</span> uint8_t secret_256[] =</div><div class="line">{</div><div class="line">    0x94, 0x0F, 0x98, 0x6A, 0xC8, 0x91, 0xC9, 0x00, 0x0B, 0x72, 0xEF, 0x0C, 0xEC, 0x69, 0xAB, 0x66,</div><div class="line">    0xAF, 0x00, 0x2E, 0x3A, 0x34, 0xEB, 0x8A, 0x3A, 0x5F, 0x94, 0x48, 0x4E, 0x45, 0xC0, 0x39, 0x6C,</div><div class="line">};</div><div class="line"><span class="keywordtype">void</span> netx_secure_crypto_hmac_sha256_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint8_t  output[RM_NETX_SECURE_CRYPTO_EXAMPLE_SHA256_HASH_SIZE_BYTES] = {0};</div><div class="line">    uint8_t  metadata[<span class="keyword">sizeof</span>(NX_CRYPTO_SHA256_HMAC)] = {0};</div><div class="line">    uint32_t metadata_size = <span class="keyword">sizeof</span>(NX_CRYPTO_SHA256_HMAC);</div><div class="line">    <span class="keywordtype">void</span>   * handler       = NX_CRYPTO_NULL;</div><div class="line">    uint32_t err           = NX_CRYPTO_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Setup the platform; initialize the SCE and the TRNG */</span></div><div class="line">    err = nx_crypto_initialize();</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Nx Crypto HMAC-SHA256 init */</span></div><div class="line">    err = _nx_crypto_method_hmac_sha256_init(&amp;crypto_method_hmac_sha256,</div><div class="line">                                             (UCHAR *) key_256,</div><div class="line">                                             RM_NETX_SECURE_CRYPTO_BYTES_TO_BITS(<span class="keyword">sizeof</span>(key_256)),</div><div class="line">                                             &amp;handler,</div><div class="line">                                             metadata,</div><div class="line">                                             metadata_size);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Nx Crypto HMAC-SHA256 operation - NX_CRYPTO_HASH_INITIALIZE */</span></div><div class="line">    err =</div><div class="line">        _nx_crypto_method_hmac_sha256_operation(NX_CRYPTO_HASH_INITIALIZE,</div><div class="line">                                                handler,</div><div class="line">                                                &amp;crypto_method_hmac_sha256,</div><div class="line">                                                (UCHAR *) key_256,</div><div class="line">                                                RM_NETX_SECURE_CRYPTO_BYTES_TO_BITS(<span class="keyword">sizeof</span>(key_256)),</div><div class="line">                                                NX_CRYPTO_NULL,</div><div class="line">                                                0,</div><div class="line">                                                NX_CRYPTO_NULL,</div><div class="line">                                                NX_CRYPTO_NULL,</div><div class="line">                                                0,</div><div class="line">                                                metadata,</div><div class="line">                                                metadata_size,</div><div class="line">                                                NX_CRYPTO_NULL,</div><div class="line">                                                NX_CRYPTO_NULL);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Nx Crypto HMAC-SHA256 operation - NX_CRYPTO_HASH_UPDATE */</span></div><div class="line">    err = _nx_crypto_method_hmac_sha256_operation(NX_CRYPTO_HASH_UPDATE,</div><div class="line">                                                  handler,</div><div class="line">                                                  &amp;crypto_method_hmac_sha256,</div><div class="line">                                                  NX_CRYPTO_NULL,</div><div class="line">                                                  0,</div><div class="line">                                                  (UCHAR *) plain_256,</div><div class="line">                                                  <span class="keyword">sizeof</span>(plain_256),</div><div class="line">                                                  NX_CRYPTO_NULL,</div><div class="line">                                                  NX_CRYPTO_NULL,</div><div class="line">                                                  0,</div><div class="line">                                                  metadata,</div><div class="line">                                                  metadata_size,</div><div class="line">                                                  NX_CRYPTO_NULL,</div><div class="line">                                                  NX_CRYPTO_NULL);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Nx Crypto HMAC-SHA256 operation - NX_CRYPTO_HASH_CALCULATE */</span></div><div class="line">    err = _nx_crypto_method_hmac_sha256_operation(NX_CRYPTO_HASH_CALCULATE,</div><div class="line">                                                  handler,</div><div class="line">                                                  &amp;crypto_method_hmac_sha256,</div><div class="line">                                                  NX_CRYPTO_NULL,</div><div class="line">                                                  0,</div><div class="line">                                                  NX_CRYPTO_NULL,</div><div class="line">                                                  0,</div><div class="line">                                                  NX_CRYPTO_NULL,</div><div class="line">                                                  (UCHAR *) output,</div><div class="line">                                                  <span class="keyword">sizeof</span>(output),</div><div class="line">                                                  metadata,</div><div class="line">                                                  metadata_size,</div><div class="line">                                                  NX_CRYPTO_NULL,</div><div class="line">                                                  NX_CRYPTO_NULL);</div><div class="line">    assert(NX_CRYPTO_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Ensure generated HMAC-SHA256 mac matches the expected mac */</span></div><div class="line">    err = (uint32_t) memcmp(output, secret_256, <span class="keyword">sizeof</span>(secret_256));</div><div class="line">    assert(0 == err);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v6.2.0 User's Manual Copyright © (2025) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
