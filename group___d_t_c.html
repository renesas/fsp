<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: Transfer (r_dtc)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
    $(document).ready(function() {
        $("tr.tree_lvl_1").nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
		$("tr.tree_lvl_1").data("expanded","0");
		$("tr.tree_lvl_2").data("expanded","0");
		$("tr.tree_lvl_3").data("expanded","0");
		$("tr.tree_lvl_4").data("expanded","0");
		$("tr.tree_lvl_5").data("expanded","0");
        $("tr.tree_lvl_1").click(function() {
		    var lvl_1_is_open = $(this).data("expanded");
		    if (lvl_1_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2, tr.tree_lvl_1_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_2").click(function() {
		    var lvl_2_is_open = $(this).data("expanded");
		    if (lvl_2_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3, tr.tree_lvl_2_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_3").click(function() {
		    var lvl_3_is_open = $(this).data("expanded");
		    if (lvl_3_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_3_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_4").click(function() {
		    var lvl_4_is_open = $(this).data("expanded");
		    if (lvl_4_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5, tr.tree_lvl_4_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_5").click(function() {
		    var lvl_5_is_open = $(this).data("expanded");
		    if (lvl_5_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4_item,tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
     });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v6.0.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">

    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text">
      </span>
      <span class="right">
          &nbsp;
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___d_t_c.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body.
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len));
            }
          }
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element.
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle">
<div class="title">Transfer (r_dtc)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___t_r_a_n_s_f_e_r___m_o_d_u_l_e_s.html">Transfer</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad2bd9d74b22d0f3e109130385ac8904e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_t_c.html#gad2bd9d74b22d0f3e109130385ac8904e">R_DTC_Open</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__cfg__t">transfer_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:gad2bd9d74b22d0f3e109130385ac8904e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6aca711303eee5fbb414bb5134f7db7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_t_c.html#ga6aca711303eee5fbb414bb5134f7db7c">R_DTC_Reconfigure</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__info__t">transfer_info_t</a> *p_info)</td></tr>
<tr class="separator:ga6aca711303eee5fbb414bb5134f7db7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4276dd89f346eb7a5e3ec8e4c8fe99fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_t_c.html#ga4276dd89f346eb7a5e3ec8e4c8fe99fb">R_DTC_Reset</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_api_ctrl, void const *volatile p_src, void *volatile p_dest, uint16_t const num_transfers)</td></tr>
<tr class="separator:ga4276dd89f346eb7a5e3ec8e4c8fe99fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3f6630c2d03e702ecd46f830e62fa5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_t_c.html#gad3f6630c2d03e702ecd46f830e62fa5f">R_DTC_SoftwareStart</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga11917a0ab2cb8b878937c97691b07fd9">transfer_start_mode_t</a> mode)</td></tr>
<tr class="separator:gad3f6630c2d03e702ecd46f830e62fa5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cc47cdad4249f69488065b5e3b62363"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_t_c.html#ga9cc47cdad4249f69488065b5e3b62363">R_DTC_SoftwareStop</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:ga9cc47cdad4249f69488065b5e3b62363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09d7866bbd07c19c458a1d96a6013e49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_t_c.html#ga09d7866bbd07c19c458a1d96a6013e49">R_DTC_Enable</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:ga09d7866bbd07c19c458a1d96a6013e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfaa6458b92432fa53fc073f6e36cfd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_t_c.html#gacfaa6458b92432fa53fc073f6e36cfd1">R_DTC_Disable</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:gacfaa6458b92432fa53fc073f6e36cfd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9e2c3dc5b7271551b2cd470bfe0e000"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_t_c.html#gaa9e2c3dc5b7271551b2cd470bfe0e000">R_DTC_InfoGet</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__properties__t">transfer_properties_t</a> *const p_properties)</td></tr>
<tr class="separator:gaa9e2c3dc5b7271551b2cd470bfe0e000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f76bce1981837af6bc7e9dd20a036fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_t_c.html#ga7f76bce1981837af6bc7e9dd20a036fb">R_DTC_Reload</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_api_ctrl, void const *p_src, void *p_dest, uint32_t const num_transfers)</td></tr>
<tr class="separator:ga7f76bce1981837af6bc7e9dd20a036fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa41dac393e47b04b1c0f5431e82518dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_t_c.html#gaa41dac393e47b04b1c0f5431e82518dd">R_DTC_CallbackSet</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_api_ctrl, void(*p_callback)(<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__callback__args__t">transfer_callback_args_t</a> *), void *const p_context, <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__callback__args__t">transfer_callback_args_t</a> *const p_callback_memory)</td></tr>
<tr class="separator:gaa41dac393e47b04b1c0f5431e82518dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2139f7cdd0e8d8dcb0ce07b705ea1ef4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_t_c.html#ga2139f7cdd0e8d8dcb0ce07b705ea1ef4">R_DTC_Close</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:ga2139f7cdd0e8d8dcb0ce07b705ea1ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the DTC peripheral on RA MCUs. This module implements the <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html">Transfer Interface</a>. </p>
<h1><a class="anchor" id="r-dtc-overview"></a>
Overview</h1>
<p>The Data Transfer Controller (DTC) transfers data from one memory location to another without using the CPU.</p>
<p>The DTC uses a RAM based vector table. Each entry in the vector table corresponds to an entry in the ISR vector table. When the DTC is triggered by an interrupt, it reads the DTC vector table, fetches the transfer information, and then executes the transfer. After the transfer is executed, the DTC writes the updated transfer info back to the location pointed to by the DTC vector table.</p>
<h2><a class="anchor" id="r-dtc-features"></a>
Features</h2>
<ul>
<li>Supports multiple transfer modes<ul>
<li>Normal transfer</li>
<li>Repeat transfer</li>
<li>Block transfer</li>
</ul>
</li>
<li>Chain transfers<a class="anchor" id="um_dtc_chain_transfer"></a></li>
<li>Address increment, decrement or fixed modes<a class="anchor" id="um_transfer_address_inc_dec_fixed"></a></li>
<li>Can be triggered by any event that has reserved a slot in the interrupt vector table.<a class="anchor" id="um_transfer_multiple_open"></a><ul>
<li>Some exceptions apply, see the Event table in the Event Numbers section of the Interrupt Controller Unit chapter of the hardware manual</li>
</ul>
</li>
<li>Supports 1, 2, and 4 byte data units<a class="anchor" id="um_transfer_unit"></a> </li>
</ul>
<h1><a class="anchor" id="r-dtc-configuration"></a>
Configuration</h1>
<p><a class="anchor" id="um_transfer_normal_mode"></a><a class="anchor" id="um_transfer_repeat_mode"></a><a class="anchor" id="um_transfer_block_mode"></a><a class="anchor" id="um_dtc_interrupts"></a><a class="anchor" id="um_dtc_configure_vector_table"></a><a class="anchor" id="um_transfer_activation_source"></a><a class="anchor" id="um_transfer_block_repeat_area"></a><a class="anchor" id="um_transfer_repeat_area"></a> <h2>Build Time Configurations for r_dtc</h2>
The following build time configurations are defined in fsp_cfg/r_dtc_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr class="tree_none">
<td>Linker section to keep DTC vector table</td><td>Manual Entry</td><td>.fsp_dtc_vector_table </td><td>Section to place the DTC vector table. </td></tr>
</table>
 <h2>Configurations for Transfer &gt; Transfer (r_dtc)</h2>
This module can be added to the Stacks tab via New Stack &gt; Transfer &gt; Transfer (r_dtc).<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Name</td><td>Name must be a valid C symbol</td><td>g_transfer0 </td><td>Module name. </td></tr>
<tr class="tree_none">
<td>Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Normal</li>
<li>
Repeat</li>
<li>
Block</li>
</ul>
</td><td>Normal </td><td>Select the transfer mode.<br />
Normal: One transfer per activation, transfer ends after Number of Transfers.<br />
Repeat: One transfer per activation, Repeat Area address reset after Number of Transfers, transfer repeats until stopped.<br />
Block: Number of Blocks per activation, Repeat Area address reset after Number of Transfers, transfer ends after Number of Blocks. </td></tr>
<tr class="tree_none">
<td>Transfer Size</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1 Byte</li>
<li>
2 Bytes</li>
<li>
4 Bytes</li>
</ul>
</td><td>2 Bytes </td><td>Select the transfer size. </td></tr>
<tr class="tree_none">
<td>Destination Address Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Fixed</li>
<li>
Incremented</li>
<li>
Decremented</li>
</ul>
</td><td>Fixed </td><td>Select the address mode for the destination. </td></tr>
<tr class="tree_none">
<td>Source Address Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Fixed</li>
<li>
Incremented</li>
<li>
Decremented</li>
</ul>
</td><td>Fixed </td><td>Select the address mode for the source. </td></tr>
<tr class="tree_none">
<td>Repeat Area (Unused in Normal Mode)</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Destination</li>
<li>
Source</li>
</ul>
</td><td>Source </td><td>Select the repeat area. Either the source or destination address resets to its initial value after completing Number of Transfers in Repeat or Block mode. </td></tr>
<tr class="tree_none">
<td>Interrupt Frequency</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
After all transfers have completed</li>
<li>
After each transfer</li>
</ul>
</td><td>After all transfers have completed </td><td>Select to have interrupt after each transfer or after last transfer. </td></tr>
<tr class="tree_none">
<td>Number of Transfers</td><td>Value must be a non-negative integer</td><td>0 </td><td>Specify the number of transfers. </td></tr>
<tr class="tree_none">
<td>Number of Blocks (Valid only in Block Mode)</td><td>Must be a valid non-negative integer with a maximum configurable value of 65536. Applicable only in Block Mode.</td><td>0 </td><td>Specify the number of blocks to transfer in Block mode. </td></tr>
<tr class="tree_none">
<td>Number of Transfer Descriptors</td><td>Value must be a non-negative integer</td><td>1 </td><td>Specify the number of transfer descriptors. Users have to initialize descriptors if its value is greater than 1. </td></tr>
<tr class="tree_none">
<td>Activation Source</td><td>MCU Specific Options</td><td></td><td>Select the DTC transfer start event. </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-dtc-clock-configuration"></a>
Clock Configuration</h2>
<p>The DTC peripheral module uses ICLK as the clock source. The ICLK frequency is set by using the <b>Clocks</b> tab of the RA Configuration editor prior to a build or by using the CGC module at runtime.</p>
<h2><a class="anchor" id="r-dtc-pin-configuration"></a>
Pin Configuration</h2>
<p>This module does not use I/O pins.</p>
<h1><a class="anchor" id="r-dtc-usage_notes"></a>
Usage Notes</h1>
<h2>Source and Destination Configuration</h2>
<p><a class="el" href="group___d_t_c.html#ga4276dd89f346eb7a5e3ec8e4c8fe99fb">R_DTC_Reset()</a> API function should be called to set the Source and Destination address before starting the transfer operation.</p>
<h2>Transfer Modes</h2>
<p>The DTC Module supports three modes of operation.</p>
<ul>
<li><b>Normal Mode</b> - In normal mode, a single data unit is transferred every time an interrupt is received by the DTC. A data unit can be 1-byte, 2-bytes, or 4-bytes. The source and destination addresses can be fixed, increment or decrement to the next data unit after each transfer. A 16-bit counter (length) decrements after each transfer. When the counter reaches 0, transfers will no longer be triggered by the interrupt source and the CPU can be interrupted to signal that all transfers have finished.</li>
<li><b>Repeat Mode</b> - Repeat mode works the same way as normal mode, however the length is limited to an integer in the range[1,256]. When the tranfer counter reaches 0, the counter is reset to its configured value and the repeat area (source or destination address) resets to its starting address and transfers will still be triggered by the interrupt.</li>
<li><b>Block Mode</b> - In block mode, the amount of data units transferred by each interrupt can be set to an integer in the range [1,256]. The number of blocks to transfer can also be configured to a 16-bit number. After each block transfer the repeat area (source or destination address) will reset to the original address and the other address will be incremented or decremented to the next block.</li>
</ul>
<p><a class="anchor" id="um_transfer_max_length"></a></p><dl class="section note"><dt>Note</dt><dd>The source and destination address of the transfer must be aligned to the configured data unit.</dd></dl>
<h2>Chaining Transfers</h2>
<p>Multiple transfers can be configured for the same interrupt source by specifying an array of <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__info__t">transfer_info_t</a> structs instead of just passing a pointer to one. In this configuration, every <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__info__t">transfer_info_t</a> struct must be configured for a chain mode except for the last one. There are two types of chain mode; CHAIN_MODE_EACH and CHAIN_MODE_END. If a transfer is configured in CHAIN_MODE_EACH then it triggers the next transfer in the chain after it completes each transfer. If a transfer is configured in CHAIN_MODE_END then it triggers the next transfer in the chain after it completes its last transfer.</p>
<div class="image">
<object type="image/svg+xml" data="r_dtc_flowchart.svg">r_dtc_flowchart.svg</object>
<div class="caption">
DTC Transfer Flowchart</div></div>
 <h2>Selecting the DTC or DMAC</h2>
<p>The Transfer API is implemented by both DTC and the DMAC so that applications can switch between the DTC and the DMAC. When selecting between them, consider these factors:</p>
<table class="doxtable">
<tr>
<th></th><th>DTC </th><th>DMAC  </th></tr>
<tr>
<td>Repeat Mode </td><td><ul>
<li>
Repeats forever</li>
<li>
Max repeat size is 256 x 4 bytes</li>
</ul>
</td><td><ul>
<li>
Configurable number of repeats</li>
<li>
Max repeat size is 1024 x 4 bytes</li>
</ul>
</td></tr>
<tr>
<td>Block Mode </td><td><ul>
<li>
Max block size is 256 x 4 bytes</li>
</ul>
</td><td><ul>
<li>
Max block size is 1024 x 4 bytes</li>
</ul>
</td></tr>
<tr>
<td>Channels </td><td><ul>
<li>
One instance per interrupt</li>
</ul>
</td><td><ul>
<li>
MCU specific (8 channels or less)</li>
</ul>
</td></tr>
<tr>
<td>Chained Transfers </td><td><ul>
<li>
Supported</li>
</ul>
</td><td><ul>
<li>
Not Supported</li>
</ul>
</td></tr>
<tr>
<td>Software Trigger </td><td><ul>
<li>
Must use the software ELC event</li>
</ul>
</td><td><ul>
<li>
Has support for software trigger without using software ELC event</li>
<li>
Supports TRANSFER_START_MODE_SINGLE and TRANSFER_START_MODE_REPEAT</li>
</ul>
</td></tr>
<tr>
<td>Offset Address Mode </td><td><ul>
<li>
Not supported</li>
</ul>
</td><td><ul>
<li>
Supported</li>
</ul>
</td></tr>
</table>
<h3>Additional Considerations</h3>
<ul>
<li>The DTC requires a moderate amount of RAM (one <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__info__t">transfer_info_t</a> struct per open instance + DTC_VECTOR_TABLE_SIZE).</li>
<li>The DTC stores transfer information in RAM and writes back to RAM after each transfer whereas the DMAC stores all transfer information in registers.</li>
<li>When transfers are configured for more than one activation source, the DTC must fetch the transfer info from RAM on each interrupt. This can cause a higher latency between transfers.</li>
<li>The DTC interrupts the CPU using the activation source's IRQ. Each DMAC channel has its own IRQ.</li>
<li>The necessary alignment of the <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__info__t">transfer_info_t</a> structs depends on the underlying MCU. The <code>DTC_TRANSFER_INFO_ALIGNMENT</code> macro is supplied to align the structs as necessary.</li>
</ul>
<h3>Interrupts</h3>
<p>The DTC and DMAC interrupts behave differently. The DTC uses the configured event IRQ as the interrupt source whereas each DMAC channel has its own IRQ.</p>
<p>The transfer_info_t::irq setting also behaves a little differently depending on which mode is selected.</p>
<ul>
<li><b>Normal Mode</b></li>
</ul>
<table class="doxtable">
<tr>
<th></th><th>DTC </th><th>DMAC  </th></tr>
<tr>
<td>TRANSFER_IRQ_EACH </td><td>Interrupt after each transfer </td><td>N/A </td></tr>
<tr>
<td>TRANSFER_IRQ_END </td><td>Interrupt after last transfer </td><td>Interrupt after last transfer </td></tr>
</table>
<ul>
<li><b>Repeat Mode</b></li>
</ul>
<table class="doxtable">
<tr>
<th></th><th>DTC </th><th>DMAC  </th></tr>
<tr>
<td>TRANSFER_IRQ_EACH </td><td>Interrupt after each transfer </td><td>Interrupt after each repeat </td></tr>
<tr>
<td>TRANSFER_IRQ_END </td><td>Interrupt after each repeat </td><td>Interrupt after last transfer </td></tr>
</table>
<ul>
<li><b>Block Mode</b></li>
</ul>
<table class="doxtable">
<tr>
<th></th><th>DTC </th><th>DMAC  </th></tr>
<tr>
<td>TRANSFER_IRQ_EACH </td><td>Interrupt after each block </td><td>Interrupt after each block </td></tr>
<tr>
<td>TRANSFER_IRQ_END </td><td>Interrupt after last block </td><td>Interrupt after last block </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>DTC_VECTOR_TABLE_SIZE = (ICU_NVIC_IRQ_SOURCES x 4) Bytes</dd></dl>
<h2><a class="anchor" id="r-dtc-peripheral-interrupts"></a>
Peripheral Interrupts and DTC</h2>
<p>When an interrupt is configured to trigger DTC transfers, the peripheral ISR will trigger on the following conditions:</p>
<ul>
<li>Each transfer completed (transfer_info_t::irq = TRANSFER_IRQ_EACH)</li>
<li>Last transfer completed (transfer_info_t::irq = TRANSFER_IRQ_END)</li>
</ul>
<p>For example, if SCI1_RXI is configured to trigger DTC transfers and a SCI1_RXI event occurs, the interrupt will not fire until the DTC transfer is completed. If the DTC transfer_info_t::irq is configured to only interrupt on the last transfer, then no RXI interrupts will occur until the last transfer is completed.</p>
<dl class="section note"><dt>Note</dt><dd>1. The DTC activation source must be enabled in the NVIC in order to trigger DTC transfers (Modules that are designed to integrate the R_DTC module will automatically handle this). </dd>
<dd>
2. The DTC prioritizes activation sources by granting the smaller interrupt vector numbers higher priority. The priority of interrupts to the CPU is determined by the NVIC priority.</dd></dl>
<h2>Low Power Modes</h2>
<p>DTCST must be set to 0 before transitioning to any of the following:</p>
<ul>
<li>Module-stop state</li>
<li>Software Standby mode without Snooze mode transition</li>
<li>Deep Software Standby mode</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>1. R_LPM Module stops the DTC before entering deep software standby mode and software standby without snooze mode transition. </dd>
<dd>
2. For more information see 18.9 and 18.10 in the RA6M3 manual R01UH0886EJ0100.</dd></dl>
<h2><a class="anchor" id="r-dtc-limitations"></a>
Limitations</h2>
<p>Developers should be aware of the following limitations when using the DTC:</p>
<ul>
<li>If the DTC is configured to service many different activation sources, the system could run in to performance issues due to memory contention. To address this issue, it is recommended that the DTC vector table and transfer information be moved to their own dedicated memory area (Ex: SRAM0, SRAM1, SRAMHS). This allows memory accesses from different BUS Masters (CPU, DTC, DMAC, EDMAC and Graphics IPs) to occur in parallel.</li>
</ul>
<h1><a class="anchor" id="r-dtc-examples"></a>
Examples</h1>
<h2>Basic Example</h2>
<p>This is a basic example of minimal use of the DTC in an application.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> dtc_minimal_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line"></div><div class="line">    <span class="comment">/* Open the transfer instance with initial configuration. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___d_t_c.html#gad2bd9d74b22d0f3e109130385ac8904e">R_DTC_Open</a>(&amp;g_transfer_ctrl, &amp;g_transfer_cfg);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Enable the DTC to handle incoming transfer requests. */</span></div><div class="line">    err = <a class="code" href="group___d_t_c.html#ga09d7866bbd07c19c458a1d96a6013e49">R_DTC_Enable</a>(&amp;g_transfer_ctrl);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structdtc__extended__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_t_c.html#structdtc__extended__cfg__t">dtc_extended_cfg_t</a></td></tr>
<tr class="separator:structdtc__extended__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structdtc__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_t_c.html#structdtc__instance__ctrl__t">dtc_instance_ctrl_t</a></td></tr>
<tr class="separator:structdtc__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaefd0bae0ca748ccb6719ab0134d9d70b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_t_c.html#gaefd0bae0ca748ccb6719ab0134d9d70b">DTC_MAX_NORMAL_TRANSFER_LENGTH</a></td></tr>
<tr class="separator:gaefd0bae0ca748ccb6719ab0134d9d70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fd7d0141f9b7f10c39146c4b80242e7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_t_c.html#ga4fd7d0141f9b7f10c39146c4b80242e7">DTC_MAX_REPEAT_TRANSFER_LENGTH</a></td></tr>
<tr class="separator:ga4fd7d0141f9b7f10c39146c4b80242e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19425a6e2cc8c0080c61ff61f6ad9e29"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_t_c.html#ga19425a6e2cc8c0080c61ff61f6ad9e29">DTC_MAX_BLOCK_TRANSFER_LENGTH</a></td></tr>
<tr class="separator:ga19425a6e2cc8c0080c61ff61f6ad9e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ab61b801ce7972fdfc9c6f00da2df51"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_t_c.html#ga7ab61b801ce7972fdfc9c6f00da2df51">DTC_MAX_BLOCK_COUNT</a></td></tr>
<tr class="separator:ga7ab61b801ce7972fdfc9c6f00da2df51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga178f306c1911683915cea5c85c8868da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_t_c.html#ga178f306c1911683915cea5c85c8868da">DTC_TRANSFER_INFO_ALIGNMENT</a></td></tr>
<tr class="separator:ga178f306c1911683915cea5c85c8868da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structdtc__extended__cfg__t" id="structdtc__extended__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structdtc__extended__cfg__t">&#9670;&nbsp;</a></span>dtc_extended_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct dtc_extended_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>DTC transfer configuration extension. This extension is required. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a130274ec6e4da69b61d944502abd24ae"></a>IRQn_Type</td>
<td class="fieldname">
activation_source</td>
<td class="fielddoc">
<p>Select which IRQ will trigger the transfer. </p>
</td></tr>
</table>

</div>
</div>
<a name="structdtc__instance__ctrl__t" id="structdtc__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structdtc__instance__ctrl__t">&#9670;&nbsp;</a></span>dtc_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct dtc_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Control block used by driver. DO NOT INITIALIZE - this structure will be initialized in <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a84d48960cdfe867ef54fd4635a85ceeb">transfer_api_t::open</a>. </p>
</div>
</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaefd0bae0ca748ccb6719ab0134d9d70b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefd0bae0ca748ccb6719ab0134d9d70b">&#9670;&nbsp;</a></span>DTC_MAX_NORMAL_TRANSFER_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DTC_MAX_NORMAL_TRANSFER_LENGTH</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Max configurable number of transfers in NORMAL MODE </p>

</div>
</div>
<a id="ga4fd7d0141f9b7f10c39146c4b80242e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fd7d0141f9b7f10c39146c4b80242e7">&#9670;&nbsp;</a></span>DTC_MAX_REPEAT_TRANSFER_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DTC_MAX_REPEAT_TRANSFER_LENGTH</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Max number of transfers per repeat for REPEAT MODE </p>

</div>
</div>
<a id="ga19425a6e2cc8c0080c61ff61f6ad9e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19425a6e2cc8c0080c61ff61f6ad9e29">&#9670;&nbsp;</a></span>DTC_MAX_BLOCK_TRANSFER_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DTC_MAX_BLOCK_TRANSFER_LENGTH</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Max number of transfers per block in BLOCK MODE </p>

</div>
</div>
<a id="ga7ab61b801ce7972fdfc9c6f00da2df51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ab61b801ce7972fdfc9c6f00da2df51">&#9670;&nbsp;</a></span>DTC_MAX_BLOCK_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DTC_MAX_BLOCK_COUNT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Max configurable number of blocks to transfer in BLOCK MODE </p>

</div>
</div>
<a id="ga178f306c1911683915cea5c85c8868da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga178f306c1911683915cea5c85c8868da">&#9670;&nbsp;</a></span>DTC_TRANSFER_INFO_ALIGNMENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DTC_TRANSFER_INFO_ALIGNMENT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alignment required for <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__info__t">transfer_info_t</a> structures. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad2bd9d74b22d0f3e109130385ac8904e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2bd9d74b22d0f3e109130385ac8904e">&#9670;&nbsp;</a></span>R_DTC_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DTC_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__cfg__t">transfer_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure the vector table if it hasn't been configured, enable the Module and copy the pointer to the transfer info into the DTC vector table. Implements <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a84d48960cdfe867ef54fd4635a85ceeb">transfer_api_t::open</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Open the transfer instance with initial configuration. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___d_t_c.html#gad2bd9d74b22d0f3e109130385ac8904e">R_DTC_Open</a>(&amp;g_transfer_ctrl, &amp;g_transfer_cfg);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful open. Transfer transfer info pointer copied to DTC Vector table. Module started. DTC vector table configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input parameter is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Address Mode Offset is selected. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>The control structure is already opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>The index for this IRQ in the DTC vector table is already configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_IRQ_BSP_DISABLED</td><td>The IRQ associated with the activation source is not enabled in the BSP. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6aca711303eee5fbb414bb5134f7db7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6aca711303eee5fbb414bb5134f7db7c">&#9670;&nbsp;</a></span>R_DTC_Reconfigure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DTC_Reconfigure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__info__t">transfer_info_t</a> *&#160;</td>
          <td class="paramname"><em>p_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy pointer to transfer info into the DTC vector table and enable transfer in ICU. Implements <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a1e38b8ef4e4fa3e59efb257102e72b72">transfer_api_t::reconfigure</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Transfer is configured and will start when trigger occurs. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input parameter is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Handle is not initialized. Call R_DTC_Open to initialize the control block. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_ENABLED</td><td>Transfer source address is NULL or is not aligned correctly. Transfer destination address is NULL or is not aligned correctly.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>p_info must persist until all transfers are completed. </dd></dl>

</div>
</div>
<a id="ga4276dd89f346eb7a5e3ec8e4c8fe99fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4276dd89f346eb7a5e3ec8e4c8fe99fb">&#9670;&nbsp;</a></span>R_DTC_Reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DTC_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *volatile&#160;</td>
          <td class="paramname"><em>p_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *volatile&#160;</td>
          <td class="paramname"><em>p_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t const&#160;</td>
          <td class="paramname"><em>num_transfers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset transfer source, destination, and number of transfers. Implements <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a9c096c8d0e78dfbf8b3809a4598b8619">transfer_api_t::reset</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Transfer reset successfully (transfers are enabled). </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input parameter is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Handle is not initialized. Call R_DTC_Open to initialize the control block. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_ENABLED</td><td>Transfer source address is NULL or is not aligned correctly. Transfer destination address is NULL or is not aligned correctly. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad3f6630c2d03e702ecd46f830e62fa5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3f6630c2d03e702ecd46f830e62fa5f">&#9670;&nbsp;</a></span>R_DTC_SoftwareStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DTC_SoftwareStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga11917a0ab2cb8b878937c97691b07fd9">transfer_start_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Placeholder for unsupported softwareStart function. Implements <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a394ddea028013153254bafa12115dce2">transfer_api_t::softwareStart</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>DTC software start is not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9cc47cdad4249f69488065b5e3b62363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cc47cdad4249f69488065b5e3b62363">&#9670;&nbsp;</a></span>R_DTC_SoftwareStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DTC_SoftwareStop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Placeholder for unsupported softwareStop function. Implements <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a77207de2ae81eab58858fd28ae88df06">transfer_api_t::softwareStop</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>DTC software stop is not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga09d7866bbd07c19c458a1d96a6013e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09d7866bbd07c19c458a1d96a6013e49">&#9670;&nbsp;</a></span>R_DTC_Enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DTC_Enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable transfers on this activation source. Implements <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a7fd4d96709c77a309492d13fd43fd048">transfer_api_t::enable</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Enable the DTC to handle incoming transfer requests. */</span></div><div class="line">    err = <a class="code" href="group___d_t_c.html#ga09d7866bbd07c19c458a1d96a6013e49">R_DTC_Enable</a>(&amp;g_transfer_ctrl);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Transfers will be triggered by the activation source </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input parameter is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Address Mode Offset is selected. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Handle is not initialized. Call R_DTC_Open to initialize the control block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacfaa6458b92432fa53fc073f6e36cfd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfaa6458b92432fa53fc073f6e36cfd1">&#9670;&nbsp;</a></span>R_DTC_Disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DTC_Disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable transfer on this activation source. Implements <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a3188207ba386da0ec85946e134b4327a">transfer_api_t::disable</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Transfers will not occur on activation events. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Handle is not initialized. Call R_DTC_Open to initialize the control block. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input parameter is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa9e2c3dc5b7271551b2cd470bfe0e000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9e2c3dc5b7271551b2cd470bfe0e000">&#9670;&nbsp;</a></span>R_DTC_InfoGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DTC_InfoGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__properties__t">transfer_properties_t</a> *const&#160;</td>
          <td class="paramname"><em>p_properties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides information about this transfer. Implements <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ad18824ffdf72b5e6a0c588289620fc84">transfer_api_t::infoGet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>p_info updated with current instance information. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Handle is not initialized. Call R_DTC_Open to initialize the control block. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input parameter is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7f76bce1981837af6bc7e9dd20a036fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f76bce1981837af6bc7e9dd20a036fb">&#9670;&nbsp;</a></span>R_DTC_Reload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DTC_Reload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>p_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>num_transfers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>To update next transfer information without interruption during transfer.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>This feature is not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa41dac393e47b04b1c0f5431e82518dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa41dac393e47b04b1c0f5431e82518dd">&#9670;&nbsp;</a></span>R_DTC_CallbackSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DTC_CallbackSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__callback__args__t">transfer_callback_args_t</a> *)&#160;</td>
          <td class="paramname"><em>p_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>p_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__callback__args__t">transfer_callback_args_t</a> *const&#160;</td>
          <td class="paramname"><em>p_callback_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Placeholder for unsupported callbackset function. Implements <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ae27b0544680f6ef53822b37753f404cb">transfer_api_t::callbackSet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>DTC does not support direct callbacks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2139f7cdd0e8d8dcb0ce07b705ea1ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2139f7cdd0e8d8dcb0ce07b705ea1ef4">&#9670;&nbsp;</a></span>R_DTC_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DTC_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables DTC activation in the ICU, then clears transfer data from the DTC vector table. Implements <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ade5973e7a8e994f9146e0db84bee8bf4">transfer_api_t::close</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful close. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input parameter is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Handle is not initialized. Call R_DTC_Open to initialize the control block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v6.0.0 User's Manual Copyright  (2025) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
