<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: LevelX NOR Port (rm_levelx_nor_spi)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
    $(document).ready(function() {
        $("tr.tree_lvl_1").nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
		$("tr.tree_lvl_1").data("expanded","0");
		$("tr.tree_lvl_2").data("expanded","0");
		$("tr.tree_lvl_3").data("expanded","0");
		$("tr.tree_lvl_4").data("expanded","0");
		$("tr.tree_lvl_5").data("expanded","0");
        $("tr.tree_lvl_1").click(function() {
		    var lvl_1_is_open = $(this).data("expanded");
		    if (lvl_1_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2, tr.tree_lvl_1_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_2").click(function() {
		    var lvl_2_is_open = $(this).data("expanded");
		    if (lvl_2_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3, tr.tree_lvl_2_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_3").click(function() {
		    var lvl_3_is_open = $(this).data("expanded");
		    if (lvl_3_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_3_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_4").click(function() {
		    var lvl_4_is_open = $(this).data("expanded");
		    if (lvl_4_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5, tr.tree_lvl_4_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_5").click(function() {
		    var lvl_5_is_open = $(this).data("expanded");
		    if (lvl_5_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4_item,tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
     });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v6.2.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">

    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text">
      </span>
      <span class="right">
          &nbsp;
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body.
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len));
            }
          }
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element.
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">LevelX NOR Port (rm_levelx_nor_spi)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___s_t_o_r_a_g_e___m_o_d_u_l_e_s.html">Storage</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaef0eb4a11efcf102f39c399c288c5bf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#gaef0eb4a11efcf102f39c399c288c5bf7">RM_LEVELX_NOR_SPI_Open</a> (<a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#structrm__levelx__nor__spi__instance__ctrl__t">rm_levelx_nor_spi_instance_ctrl_t</a> *const p_ctrl, <a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#structrm__levelx__nor__spi__cfg__t">rm_levelx_nor_spi_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="memdesc:gaef0eb4a11efcf102f39c399c288c5bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes LevelX NOR SPI port read/write and control.  <a href="#gaef0eb4a11efcf102f39c399c288c5bf7">More...</a><br /></td></tr>
<tr class="separator:gaef0eb4a11efcf102f39c399c288c5bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18056338e334dcea8947d33ed1182a34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#ga18056338e334dcea8947d33ed1182a34">RM_LEVELX_NOR_SPI_Read</a> (<a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#structrm__levelx__nor__spi__instance__ctrl__t">rm_levelx_nor_spi_instance_ctrl_t</a> *const p_ctrl, ULONG *const p_flash_addr, ULONG *const p_dest, ULONG word_count)</td></tr>
<tr class="memdesc:ga18056338e334dcea8947d33ed1182a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">LevelX NOR driver "read sector" service.  <a href="#ga18056338e334dcea8947d33ed1182a34">More...</a><br /></td></tr>
<tr class="separator:ga18056338e334dcea8947d33ed1182a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab39574b2e0bf5fb608e78b06b1cef652"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#gab39574b2e0bf5fb608e78b06b1cef652">RM_LEVELX_NOR_SPI_Write</a> (<a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#structrm__levelx__nor__spi__instance__ctrl__t">rm_levelx_nor_spi_instance_ctrl_t</a> *const p_ctrl, ULONG *const p_flash_addr, ULONG *const p_src, ULONG word_count)</td></tr>
<tr class="memdesc:gab39574b2e0bf5fb608e78b06b1cef652"><td class="mdescLeft">&#160;</td><td class="mdescRight">LevelX NOR driver "write sector" service.  <a href="#gab39574b2e0bf5fb608e78b06b1cef652">More...</a><br /></td></tr>
<tr class="separator:gab39574b2e0bf5fb608e78b06b1cef652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76ecc63c9080d4cde63f24748172642e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#ga76ecc63c9080d4cde63f24748172642e">RM_LEVELX_NOR_SPI_BlockErase</a> (<a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#structrm__levelx__nor__spi__instance__ctrl__t">rm_levelx_nor_spi_instance_ctrl_t</a> *const p_ctrl, ULONG block, ULONG erase_count)</td></tr>
<tr class="memdesc:ga76ecc63c9080d4cde63f24748172642e"><td class="mdescLeft">&#160;</td><td class="mdescRight">LevelX NOR driver "block erase" service.  <a href="#ga76ecc63c9080d4cde63f24748172642e">More...</a><br /></td></tr>
<tr class="separator:ga76ecc63c9080d4cde63f24748172642e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53d112c770001682ff41534279304dae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#ga53d112c770001682ff41534279304dae">RM_LEVELX_NOR_SPI_BlockErasedVerify</a> (<a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#structrm__levelx__nor__spi__instance__ctrl__t">rm_levelx_nor_spi_instance_ctrl_t</a> *const p_ctrl, ULONG block)</td></tr>
<tr class="memdesc:ga53d112c770001682ff41534279304dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">LevelX NOR driver "block erased verify" service.  <a href="#ga53d112c770001682ff41534279304dae">More...</a><br /></td></tr>
<tr class="separator:ga53d112c770001682ff41534279304dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7118bff110a7f290102ff6e4f1c53ce4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#ga7118bff110a7f290102ff6e4f1c53ce4">RM_LEVELX_NOR_SPI_Close</a> (<a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#structrm__levelx__nor__spi__instance__ctrl__t">rm_levelx_nor_spi_instance_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="memdesc:ga7118bff110a7f290102ff6e4f1c53ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">LevelX NOR driver close service.  <a href="#ga7118bff110a7f290102ff6e4f1c53ce4">More...</a><br /></td></tr>
<tr class="separator:ga7118bff110a7f290102ff6e4f1c53ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Middleware for using Azure RTOS LevelX on NOR SPI memory. </p>
<h1><a class="anchor" id="rm-levelx-nor-spi-overview"></a>
Overview</h1>
<p>This module provides the hardware port layer for LevelX on NOR SPI flash memory. Setup for this module is done solely through calling LevelX APIs. Please refer to the LevelX API reference: <a href="https://docs.microsoft.com/en-us/azure/rtos/levelx/">https://docs.microsoft.com/en-us/azure/rtos/levelx/</a></p>
<h1><a class="anchor" id="rm-levelx-nor-spi-configurations"></a>
Configuration</h1>
<p><h2>Build Time Configurations for rm_levelx_nor_spi</h2>
The following build time configurations are defined in fsp_cfg/middleware/rm_levelx_nor_spi_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>Selects if code for parameter checking is to be included in the build. </td></tr>
<tr class="tree_none">
<td>Page Buffer Size (bytes)</td><td>Size should be greater than zero</td><td>256 </td><td>When direct read is enabled in LevelX a situation can occur where the driver has to write to SPI memory with the source locaiton also being within the SPI memory address range. In this situation the driver needs a buffer that is at least the same size as a page in order to temporarily store data to write out. </td></tr>
</table>
 <h2>Configurations for Storage &gt; LevelX NOR Port (rm_levelx_nor_spi)</h2>
<table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Name</td><td>Name must be a valid C symbol</td><td>g_rm_levelx_nor_spi0 </td><td>Module name. </td></tr>
<tr class="tree_none">
<td>Memory Start Address Offset (bytes)</td><td>Offset should be greater than or equal to zero</td><td>0 </td><td>Enter the starting offset to use in the SPI memory. The starting address for LevelX memory will be the SPI memory base address plus this offset. </td></tr>
<tr class="tree_none">
<td>Memory Size (bytes)</td><td>Size should be greater than zero</td><td>33554432 </td><td>Enter the size that the LevelX Memory should be. This can be smaller than the SPI memory size in order to use a subset of SPI memory. </td></tr>
<tr class="tree_none">
<td>Poll Status Count</td><td>Poll Status Count should be greater than or equal to zero</td><td>0xFFFFFFFF </td><td>Number of times to poll for operation complete status for blocking memory operations. </td></tr>
</table>
 <h2>Build Time Configurations for lx</h2>
The following build time configurations are defined in fsp_cfg/azure/lx/lx_user.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> NOR  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Direct Read</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (default)</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled (default) </td><td>When enabled, this option bypasses the NOR flash driver read routine in favor or reading the NOR memory directly, resulting in a significant performance increase. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Free Sector Data Verify</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled (default)</li>
</ul>
</td><td>Disabled (default) </td><td>When enabled, this causes the LevelX NOR instance open logic to verify free NOR sectors are all ones. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Extended Cache</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (default)</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled (default) </td><td>Enables the extended NOR cache. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Extended Cache Size</td><td>Manual Entry</td><td></td><td>If not set this value defaults to 8, which represents a maximum of 8 sectors that can be cached in a NOR instance. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Sector Mapping Cache Size</td><td>Value must be greater than or equal to 8 and a power of 2, or empty</td><td></td><td>If not set this value defaults to 16 and defines the logical sector mapping cache size. Large values improve performance, but cost memory. The minimum size is 8 and all values must be a power of 2. </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> NAND  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Sector Mapping Cache Size</td><td>Value must be greater than or equal to 8 and a power of 2, or empty</td><td></td><td>If not set this value defaults to 128 and defines the logical sector mapping cache size. Large values improve performance, but cost memory. The minimum size is 8 and all values must be a power of 2. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Flash Direct Mapping Cache</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled (default)</li>
</ul>
</td><td>Disabled (default) </td><td>When enabled, this creates a direct mapping cache, such that there are no cache misses. It also required that LX_NAND_SECTOR_MAPPING_CACHE_SIZE represents the exact number of total pages in your flash device. </td></tr>
<tr class="tree_none">
<td>Thread Safe</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled (default)</li>
</ul>
</td><td>Disabled (default) </td><td>When enabled, this makes LevelX thread-safe by using a ThreadX mutex object throughout the API. </td></tr>
<tr class="tree_none">
<td>Standalone Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled (default)</li>
</ul>
</td><td>Disabled (default) </td><td>When enabled, allows LevelX to be used in standalone mode (without Azure RTOS). </td></tr>
</table>
</p>
<h1><a class="anchor" id="rm-levelx-nor-spi-usage-notes"></a>
Usage Notes</h1>
<h2>Pending during Erase/Write</h2>
<p>The LevelX NOR SPI driver is blocking on all SPI operations and will poll device status for operation completion on Writes and Erases. A callback can be provided by the user to wait with an OS-specific thread wait in these instances.</p>
<h2>Closing the driver</h2>
<p>When lx_nor_flash_close is called to close the LevelX instance it does not call any services within the LevelX NOR SPI driver to close out the driver instance. The user should call the generated close function (i.e. g_rm_levelx_nor_spi0_close) in order to close out the driver instance.</p>
<h2>Erasing Flash Memory Prior to Usage</h2>
<p>The area of the flash memory being used for the LevelX instance should be erased using the lower level flash API prior to usage. Otherwise, LevelX API may fail on lx_nor_flash_open due to any areas in flash memory that have been written/set.</p>
<h1><a class="anchor" id="rm-levelx-nor-spi-examples"></a>
Examples</h1>
<h2>Basic Example</h2>
<p>This is a basic example of using the LevelX NOR SPI driver with the LevelX API in an application.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define RM_LEVELX_NOR_SPI_EXAMPLE_SECTOR_SIZE          (512)</span></div><div class="line"><span class="preprocessor">#define RM_LEVELX_NOR_SPI_EXAMPLE_BUFFER_FILL_VALUE    (0xA5)</span></div><div class="line"><span class="preprocessor">#define RM_LEVELX_NOR_SPI_EXAMPLE_SPI_SECTOR_SIZE      (4096)</span></div><div class="line"></div><div class="line"><span class="keyword">extern</span> <a class="code" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#structrm__levelx__nor__spi__instance__ctrl__t">rm_levelx_nor_spi_instance_ctrl_t</a> g_levelx_nor_spi0_ctrl;</div><div class="line"><span class="keyword">extern</span> <a class="code" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#structrm__levelx__nor__spi__cfg__t">rm_levelx_nor_spi_cfg_t</a>           g_levelx_nor_spi0_cfg;</div><div class="line"></div><div class="line"><span class="keyword">extern</span> LX_NOR_FLASH g_lx_nor_flash0;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> rm_levelx_nor_spi_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint8_t                read_buffer[RM_LEVELX_NOR_SPI_EXAMPLE_SECTOR_SIZE];</div><div class="line">    uint8_t                write_buffer[RM_LEVELX_NOR_SPI_EXAMPLE_SECTOR_SIZE];</div><div class="line">    <a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__instance__t">spi_flash_instance_t</a> * p_spi_flash_instance = (<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__instance__t">spi_flash_instance_t</a> *) g_levelx_nor_spi0_cfg.<a class="code" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#a7dcadbcfcfa10de3673c1c008e35bfc5">p_lower_lvl</a>;</div><div class="line">    <a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__status__t">spi_flash_status_t</a>     status;</div><div class="line"></div><div class="line">    memset(write_buffer, RM_LEVELX_NOR_SPI_EXAMPLE_BUFFER_FILL_VALUE, <span class="keyword">sizeof</span>(write_buffer));</div><div class="line"></div><div class="line">    <span class="comment">/* Erase flash prior to usage */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = p_spi_flash_instance-&gt;<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#aa393a0e23c69a916e8c30e9dc4e5513b">p_api</a>-&gt;<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a75a4468493abb92f6bf484ed93718f6f">open</a>(p_spi_flash_instance-&gt;<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ab7cca7ee8e821effe8d7e8902e6a7514">p_ctrl</a>, p_spi_flash_instance-&gt;<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a74f26946c33e77fda5b6e2d26b2c9fee">p_cfg</a>);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (uint32_t i = g_levelx_nor_spi0_cfg.<a class="code" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#a6d6dc54ab7b793bc4c241956cf743a2d">address_offset</a>;</div><div class="line">         i &lt; g_levelx_nor_spi0_cfg.<a class="code" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#a28e980602115f51ad7b912d79d42015a">size</a>;</div><div class="line">         i += RM_LEVELX_NOR_SPI_EXAMPLE_SPI_SECTOR_SIZE)</div><div class="line">    {</div><div class="line">        err = p_spi_flash_instance-&gt;<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#aa393a0e23c69a916e8c30e9dc4e5513b">p_api</a>-&gt;<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a4fb48ee9af80243cf7f8f966b4c6c56e">erase</a>(p_spi_flash_instance-&gt;<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ab7cca7ee8e821effe8d7e8902e6a7514">p_ctrl</a>,</div><div class="line">                                                 (uint8_t *) g_levelx_nor_spi0_cfg.<a class="code" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#a44e353ea1aa9280fe4ce369367a37b24">base_address</a> + i,</div><div class="line">                                                 RM_LEVELX_NOR_SPI_EXAMPLE_SPI_SECTOR_SIZE);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">        status.write_in_progress = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">while</span> (status.write_in_progress)</div><div class="line">        {</div><div class="line">            err = p_spi_flash_instance-&gt;<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#aa393a0e23c69a916e8c30e9dc4e5513b">p_api</a>-&gt;<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a36600006109effd5c9d47283a7760ce6">statusGet</a>(p_spi_flash_instance-&gt;<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ab7cca7ee8e821effe8d7e8902e6a7514">p_ctrl</a>, &amp;status);</div><div class="line">            assert(FSP_SUCCESS == err);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    err = p_spi_flash_instance-&gt;<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#aa393a0e23c69a916e8c30e9dc4e5513b">p_api</a>-&gt;<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a28bdae798428b85222739a0b9fd43a15">close</a>(p_spi_flash_instance-&gt;<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ab7cca7ee8e821effe8d7e8902e6a7514">p_ctrl</a>);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize LevelX */</span></div><div class="line">    lx_nor_flash_initialize();</div><div class="line"></div><div class="line">    UINT lx_err = lx_nor_flash_open(&amp;g_lx_nor_flash0, <span class="stringliteral">&quot;LX_NOR_SPI_EXAMPLE&quot;</span>, g_levelx_nor_spi0_initialize);</div><div class="line">    handle_lx_error(lx_err);</div><div class="line"></div><div class="line">    <span class="comment">/* Write test value to sector 0 then read back to verify */</span></div><div class="line">    lx_err = lx_nor_flash_sector_write(&amp;g_lx_nor_flash0, 0, write_buffer);</div><div class="line">    handle_lx_error(lx_err);</div><div class="line"></div><div class="line">    lx_err = lx_nor_flash_sector_read(&amp;g_lx_nor_flash0, 0, read_buffer);</div><div class="line">    handle_lx_error(lx_err);</div><div class="line"></div><div class="line">    assert(0 == memcmp(read_buffer, write_buffer, <span class="keyword">sizeof</span>(read_buffer)));</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Callback Wait Example</h2>
<p>This shows how to use the LevelX NOR SPI driver callback with ThreadX in order to wait for operations to complete.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">/* Callback called by LevelX NOR SPI driver needs to wait on operation. */</span></div><div class="line"><span class="keywordtype">void</span> rm_levelx_nor_spi_callback_wait_example (<a class="code" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#structrm__levelx__nor__spi__callback__args__t">rm_levelx_nor_spi_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (p_args-&gt;<a class="code" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#a381b10499c261c1e18267d3a56a89b49">event</a> &amp; <a class="code" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#gga676216a9403ce51b4b46f14c4d669500ae8f299f88f0b4348648c9aa17861b1c4">RM_LEVELX_NOR_SPI_EVENT_BUSY</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Put the thread to sleep while waiting for operation to complete. */</span></div><div class="line">        tx_thread_sleep(1);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structrm__levelx__nor__spi__callback__args__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#structrm__levelx__nor__spi__callback__args__t">rm_levelx_nor_spi_callback_args_t</a></td></tr>
<tr class="separator:structrm__levelx__nor__spi__callback__args__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structrm__levelx__nor__spi__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#structrm__levelx__nor__spi__cfg__t">rm_levelx_nor_spi_cfg_t</a></td></tr>
<tr class="separator:structrm__levelx__nor__spi__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structrm__levelx__nor__spi__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#structrm__levelx__nor__spi__instance__ctrl__t">rm_levelx_nor_spi_instance_ctrl_t</a></td></tr>
<tr class="separator:structrm__levelx__nor__spi__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga676216a9403ce51b4b46f14c4d669500"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#ga676216a9403ce51b4b46f14c4d669500">rm_levelx_nor_spi_event_t</a> </td></tr>
<tr class="separator:ga676216a9403ce51b4b46f14c4d669500"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structrm__levelx__nor__spi__callback__args__t" id="structrm__levelx__nor__spi__callback__args__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structrm__levelx__nor__spi__callback__args__t">&#9670;&nbsp;</a></span>rm_levelx_nor_spi_callback_args_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rm_levelx_nor_spi_callback_args_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>RM_LEVELX_NOR_SPI callback arguments definitions </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a381b10499c261c1e18267d3a56a89b49"></a><a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#ga676216a9403ce51b4b46f14c4d669500">rm_levelx_nor_spi_event_t</a></td>
<td class="fieldname">
event</td>
<td class="fielddoc">
LevelX NOR driver callback event. </td></tr>
<tr><td class="fieldtype">
<a id="adfa298c52fd3d39dfe07f63dcd81cd48"></a>void *</td>
<td class="fieldname">
p_context</td>
<td class="fielddoc">
Placeholder for user data. </td></tr>
</table>

</div>
</div>
<a name="structrm__levelx__nor__spi__cfg__t" id="structrm__levelx__nor__spi__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structrm__levelx__nor__spi__cfg__t">&#9670;&nbsp;</a></span>rm_levelx_nor_spi_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rm_levelx_nor_spi_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>SF_EL_LX_NOR Config Block Type </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a7dcadbcfcfa10de3673c1c008e35bfc5"><td class="memItemLeft" align="right" valign="top"><a id="a7dcadbcfcfa10de3673c1c008e35bfc5"></a>
<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__instance__t">spi_flash_instance_t</a> const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#a7dcadbcfcfa10de3673c1c008e35bfc5">p_lower_lvl</a></td></tr>
<tr class="memdesc:a7dcadbcfcfa10de3673c1c008e35bfc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower level memory pointer. <br /></td></tr>
<tr class="separator:a7dcadbcfcfa10de3673c1c008e35bfc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58fb740929de95fc018e27db889c59db"><td class="memItemLeft" align="right" valign="top"><a id="a58fb740929de95fc018e27db889c59db"></a>
LX_NOR_FLASH *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#a58fb740929de95fc018e27db889c59db">p_lx_nor_flash</a></td></tr>
<tr class="memdesc:a58fb740929de95fc018e27db889c59db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the LevelX nor flash instance. <br /></td></tr>
<tr class="separator:a58fb740929de95fc018e27db889c59db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e353ea1aa9280fe4ce369367a37b24"><td class="memItemLeft" align="right" valign="top"><a id="a44e353ea1aa9280fe4ce369367a37b24"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#a44e353ea1aa9280fe4ce369367a37b24">base_address</a></td></tr>
<tr class="memdesc:a44e353ea1aa9280fe4ce369367a37b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base address of memory mapped region. <br /></td></tr>
<tr class="separator:a44e353ea1aa9280fe4ce369367a37b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6dc54ab7b793bc4c241956cf743a2d"><td class="memItemLeft" align="right" valign="top"><a id="a6d6dc54ab7b793bc4c241956cf743a2d"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#a6d6dc54ab7b793bc4c241956cf743a2d">address_offset</a></td></tr>
<tr class="memdesc:a6d6dc54ab7b793bc4c241956cf743a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset to use subset of available flash size if desired. <br /></td></tr>
<tr class="separator:a6d6dc54ab7b793bc4c241956cf743a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e980602115f51ad7b912d79d42015a"><td class="memItemLeft" align="right" valign="top"><a id="a28e980602115f51ad7b912d79d42015a"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#a28e980602115f51ad7b912d79d42015a">size</a></td></tr>
<tr class="memdesc:a28e980602115f51ad7b912d79d42015a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the partitioned region. <br /></td></tr>
<tr class="separator:a28e980602115f51ad7b912d79d42015a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18036aee930a79ce8cc82caefa8bc63"><td class="memItemLeft" align="right" valign="top"><a id="ab18036aee930a79ce8cc82caefa8bc63"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#ab18036aee930a79ce8cc82caefa8bc63">poll_status_count</a></td></tr>
<tr class="memdesc:ab18036aee930a79ce8cc82caefa8bc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of times to poll for operation complete status before returning an error. <br /></td></tr>
<tr class="separator:ab18036aee930a79ce8cc82caefa8bc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166aad26844679ac2a44935fe88fb4c0"><td class="memItemLeft" align="right" valign="top"><a id="a166aad26844679ac2a44935fe88fb4c0"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#a166aad26844679ac2a44935fe88fb4c0">p_context</a></td></tr>
<tr class="memdesc:a166aad26844679ac2a44935fe88fb4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placeholder for user data. Passed to the user callback. <br /></td></tr>
<tr class="separator:a166aad26844679ac2a44935fe88fb4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbd865b547c53c18bec452285c0f52b"><td class="memItemLeft" align="right" valign="top"><a id="aebbd865b547c53c18bec452285c0f52b"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#aebbd865b547c53c18bec452285c0f52b">p_callback</a> )(<a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#structrm__levelx__nor__spi__callback__args__t">rm_levelx_nor_spi_callback_args_t</a> *p_args)</td></tr>
<tr class="memdesc:aebbd865b547c53c18bec452285c0f52b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function. <br /></td></tr>
<tr class="separator:aebbd865b547c53c18bec452285c0f52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<a name="structrm__levelx__nor__spi__instance__ctrl__t" id="structrm__levelx__nor__spi__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structrm__levelx__nor__spi__instance__ctrl__t">&#9670;&nbsp;</a></span>rm_levelx_nor_spi_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rm_levelx_nor_spi_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>SF_EL_LX_NOR Control Block Type </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a1c848864f90d349dd5f73ad44330bf60"></a><a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#structrm__levelx__nor__spi__cfg__t">rm_levelx_nor_spi_cfg_t</a> const  *</td>
<td class="fieldname">
p_cfg</td>
<td class="fielddoc">
Pointer to instance configuration. </td></tr>
<tr><td class="fieldtype">
<a id="a0eef8f460517ce46cb5108a311c5f99a"></a>uint32_t</td>
<td class="fieldname">
start_address</td>
<td class="fielddoc">
Start address of partition to use within memory mapped region. </td></tr>
<tr><td class="fieldtype">
<a id="ab189c0b0d1b0574c5a44301c3c69d059"></a>uint32_t</td>
<td class="fieldname">
minimum_erase_size</td>
<td class="fielddoc">
Minimum erase size of SPI memory. </td></tr>
<tr><td class="fieldtype">
<a id="a1c1ee97dfc03119a46e578d3fa6000d0"></a>uint8_t</td>
<td class="fieldname">
page_buffer[RM_LEVELX_NOR_SPI_CFG_BUFFER_SIZE]</td>
<td class="fielddoc">
Page buffer for situations when writing to SPI memory from a source within SPI memory. </td></tr>
<tr><td class="fieldtype">
<a id="a2195e4518742a5df5f6c5dd9d12691bf"></a>uint32_t</td>
<td class="fieldname">
open</td>
<td class="fielddoc">
Used to determine if module is initialized. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga676216a9403ce51b4b46f14c4d669500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga676216a9403ce51b4b46f14c4d669500">&#9670;&nbsp;</a></span>rm_levelx_nor_spi_event_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#ga676216a9403ce51b4b46f14c4d669500">rm_levelx_nor_spi_event_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Common macro for FSP header files. There is also a corresponding FSP_FOOTER macro at the end of this file. Options for the callback events. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga676216a9403ce51b4b46f14c4d669500ae8f299f88f0b4348648c9aa17861b1c4"></a>RM_LEVELX_NOR_SPI_EVENT_BUSY&#160;</td><td class="fielddoc"><p>Pending operation, user can define their own wait functionality. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaef0eb4a11efcf102f39c399c288c5bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef0eb4a11efcf102f39c399c288c5bf7">&#9670;&nbsp;</a></span>RM_LEVELX_NOR_SPI_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> RM_LEVELX_NOR_SPI_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#structrm__levelx__nor__spi__instance__ctrl__t">rm_levelx_nor_spi_instance_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#structrm__levelx__nor__spi__cfg__t">rm_levelx_nor_spi_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes LevelX NOR SPI port read/write and control. </p>
<p>Calls lower level SPI memory functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_ctrl</td><td>Control block for the LevelX NOR SPI instance. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_cfg</td><td>Configuration for LevelX NOR SPI port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>LevelX NOR driver is successfully opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl or p_cfg is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Driver is already in OPEN state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See Common_Error_Codes or lower level drivers for other possible return codes. This function calls<ul>
<li><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__api__t">spi_flash_api_t</a>:open </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga18056338e334dcea8947d33ed1182a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18056338e334dcea8947d33ed1182a34">&#9670;&nbsp;</a></span>RM_LEVELX_NOR_SPI_Read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> RM_LEVELX_NOR_SPI_Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#structrm__levelx__nor__spi__instance__ctrl__t">rm_levelx_nor_spi_instance_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG *const&#160;</td>
          <td class="paramname"><em>p_flash_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG *const&#160;</td>
          <td class="paramname"><em>p_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG&#160;</td>
          <td class="paramname"><em>word_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LevelX NOR driver "read sector" service. </p>
<p>This is responsible for reading a specific sector in a specific block of the NOR flash. All error checking and correcting logic is the responsibility of this service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_ctrl</td><td>Control block for the LevelX NOR SPI instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_flash_addr</td><td>Specifies the address of a logical sector within a NOR flash block of memory. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_dest</td><td>Specifies where to place the sector contents. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">word_count</td><td>Specifies how many 32-bit words to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>LevelX NOR flash sector read successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl, p_flash_addr or p_dest is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver not in OPEN state for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See Common_Error_Codes or lower level drivers for other possible return codes. </dd></dl>

</div>
</div>
<a id="gab39574b2e0bf5fb608e78b06b1cef652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab39574b2e0bf5fb608e78b06b1cef652">&#9670;&nbsp;</a></span>RM_LEVELX_NOR_SPI_Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> RM_LEVELX_NOR_SPI_Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#structrm__levelx__nor__spi__instance__ctrl__t">rm_levelx_nor_spi_instance_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG *const&#160;</td>
          <td class="paramname"><em>p_flash_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG *const&#160;</td>
          <td class="paramname"><em>p_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG&#160;</td>
          <td class="paramname"><em>word_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LevelX NOR driver "write sector" service. </p>
<p>This is responsible for writing a specific sector into a block of the NOR flash. All error checking is the responsibility of the this service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_ctrl</td><td>Control block for the LevelX NOR SPI instance. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_flash_addr</td><td>Specifies the address of a logical sector within a NOR flash block of memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_src</td><td>Specifies the source of the write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">word_count</td><td>Specifies how many 32-bit words to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>LevelX NOR flash sector write successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl, p_flash_addr or p_src is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver not in OPEN state for writing. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timeout occurred while waiting for operation to complete. </td></tr>
    <tr><td class="paramname">FSP_ERR_WRITE_FAILED</td><td>Verification of Write operation failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ADDRESS</td><td>Write address or size falls outside of flash memory range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See Common_Error_Codes or lower level drivers for other possible return codes. This function calls<ul>
<li><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__api__t">spi_flash_api_t</a>:write </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga76ecc63c9080d4cde63f24748172642e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76ecc63c9080d4cde63f24748172642e">&#9670;&nbsp;</a></span>RM_LEVELX_NOR_SPI_BlockErase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> RM_LEVELX_NOR_SPI_BlockErase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#structrm__levelx__nor__spi__instance__ctrl__t">rm_levelx_nor_spi_instance_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG&#160;</td>
          <td class="paramname"><em>erase_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LevelX NOR driver "block erase" service. </p>
<p>This is responsible for erasing the specified block of the NOR flash.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_ctrl</td><td>Control block for the LevelX NOR SPI instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Specifies which NOR block to erase. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">erase_count</td><td>Provided for diagnostic purposes(currently unused).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>LevelX NOR flash block erase successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver not in OPEN state for erasing. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timeout occurred while waiting for operation to complete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See Common_Error_Codes or lower level drivers for other possible return codes. This function calls<ul>
<li><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__api__t">spi_flash_api_t</a>:erase </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga53d112c770001682ff41534279304dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53d112c770001682ff41534279304dae">&#9670;&nbsp;</a></span>RM_LEVELX_NOR_SPI_BlockErasedVerify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> RM_LEVELX_NOR_SPI_BlockErasedVerify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#structrm__levelx__nor__spi__instance__ctrl__t">rm_levelx_nor_spi_instance_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LevelX NOR driver "block erased verify" service. </p>
<p>This is responsible for verifying the specified block of the NOR flash is erased.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_ctrl</td><td>Control block for the LevelX NOR SPI instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Specifies which block to verify that it is erased.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>LevelX flash block erase verification successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl or lower level driver is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver not in OPEN state for verifying. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_ERASED</td><td>The block is not erased properly. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See Common_Error_Codes or lower level drivers for other possible return codes. </dd></dl>

</div>
</div>
<a id="ga7118bff110a7f290102ff6e4f1c53ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7118bff110a7f290102ff6e4f1c53ce4">&#9670;&nbsp;</a></span>RM_LEVELX_NOR_SPI_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> RM_LEVELX_NOR_SPI_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_m___l_e_v_e_l_x___n_o_r___s_p_i.html#structrm__levelx__nor__spi__instance__ctrl__t">rm_levelx_nor_spi_instance_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LevelX NOR driver close service. </p>
<p>This is responsible for closing the driver properly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_ctrl</td><td>Control block for the LevelX NOR SPI instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>LevelX flash is available and is now open for read, write, and control access. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver not in OPEN state for closing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See Common_Error_Codes or lower level drivers for other possible return codes. This function calls<ul>
<li><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__api__t">spi_flash_api_t</a>:close </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v6.2.0 User's Manual Copyright © (2025) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
