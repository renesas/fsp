<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: USB (r_usb_basic)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
    $(document).ready(function() {
        $("tr.tree_lvl_1").nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
		$("tr.tree_lvl_1").data("expanded","0");
		$("tr.tree_lvl_2").data("expanded","0");
		$("tr.tree_lvl_3").data("expanded","0");
		$("tr.tree_lvl_4").data("expanded","0");
		$("tr.tree_lvl_5").data("expanded","0");
        $("tr.tree_lvl_1").click(function() {
		    var lvl_1_is_open = $(this).data("expanded");
		    if (lvl_1_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2, tr.tree_lvl_1_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_2").click(function() {
		    var lvl_2_is_open = $(this).data("expanded");
		    if (lvl_2_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3, tr.tree_lvl_2_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_3").click(function() {
		    var lvl_3_is_open = $(this).data("expanded");
		    if (lvl_3_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_3_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_4").click(function() {
		    var lvl_4_is_open = $(this).data("expanded");
		    if (lvl_4_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5, tr.tree_lvl_4_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_5").click(function() {
		    var lvl_5_is_open = $(this).data("expanded");
		    if (lvl_5_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4_item,tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
     });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v6.2.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">

    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text">
      </span>
      <span class="right">
          &nbsp;
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___u_s_b.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body.
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len));
            }
          }
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element.
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">USB (r_usb_basic)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___c_o_n_n_e_c_t_i_v_i_t_y___m_o_d_u_l_e_s.html">Connectivity</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf882576a8f79312c27fa700d3fb94951"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#gaf882576a8f79312c27fa700d3fb94951">R_USB_EventGet</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___u_s_b___a_p_i.html#ga56bea25fbffdbda134044c49d40d5e40">usb_status_t</a> *event)</td></tr>
<tr class="memdesc:gaf882576a8f79312c27fa700d3fb94951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains completed USB related events. (OS-less Only)  <a href="#gaf882576a8f79312c27fa700d3fb94951">More...</a><br /></td></tr>
<tr class="separator:gaf882576a8f79312c27fa700d3fb94951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2560b302dca363895820a82ea6a2ba9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#ga2560b302dca363895820a82ea6a2ba9c">R_USB_Callback</a> (usb_callback_t *p_callback)</td></tr>
<tr class="memdesc:ga2560b302dca363895820a82ea6a2ba9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a callback function to be called upon completion of a USB related event. (RTOS only)  <a href="#ga2560b302dca363895820a82ea6a2ba9c">More...</a><br /></td></tr>
<tr class="separator:ga2560b302dca363895820a82ea6a2ba9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9810a1d8e322cb89a9a7f9ca84a368f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#gab9810a1d8e322cb89a9a7f9ca84a368f">R_USB_Open</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___u_s_b___a_p_i.html#structusb__cfg__t">usb_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="memdesc:gab9810a1d8e322cb89a9a7f9ca84a368f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies power to the USB module specified in the argument (p_ctrl).  <a href="#gab9810a1d8e322cb89a9a7f9ca84a368f">More...</a><br /></td></tr>
<tr class="separator:gab9810a1d8e322cb89a9a7f9ca84a368f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42c6c75ae96e3860b726d1b0dcbf110d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#ga42c6c75ae96e3860b726d1b0dcbf110d">R_USB_Close</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="memdesc:ga42c6c75ae96e3860b726d1b0dcbf110d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminates power to the USB module specified in argument (p_ctrl). USB0 module stops when USB_IP0 is specified to the member (module), USB1 module stops when USB_IP1 is specified to the member (module).  <a href="#ga42c6c75ae96e3860b726d1b0dcbf110d">More...</a><br /></td></tr>
<tr class="separator:ga42c6c75ae96e3860b726d1b0dcbf110d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42ad1cbad598d06023d83e8a91fd49d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#ga42ad1cbad598d06023d83e8a91fd49d4">R_USB_Read</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl, uint8_t *p_buf, uint32_t size, uint8_t destination)</td></tr>
<tr class="memdesc:ga42ad1cbad598d06023d83e8a91fd49d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bulk/Interrupt data transfer.  <a href="#ga42ad1cbad598d06023d83e8a91fd49d4">More...</a><br /></td></tr>
<tr class="separator:ga42ad1cbad598d06023d83e8a91fd49d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga001f40866be6438435e65e78871a54d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#ga001f40866be6438435e65e78871a54d5">R_USB_Write</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl, uint8_t const *const p_buf, uint32_t size, uint8_t destination)</td></tr>
<tr class="memdesc:ga001f40866be6438435e65e78871a54d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bulk/Interrupt data transfer.  <a href="#ga001f40866be6438435e65e78871a54d5">More...</a><br /></td></tr>
<tr class="separator:ga001f40866be6438435e65e78871a54d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b594879fb754ed4ae76685d6c261e5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#ga6b594879fb754ed4ae76685d6c261e5d">R_USB_Stop</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___u_s_b___a_p_i.html#ga0c47f1426b999f2cd8aea9adca06fbde">usb_transfer_t</a> direction, uint8_t destination)</td></tr>
<tr class="memdesc:ga6b594879fb754ed4ae76685d6c261e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests a data read/write transfer be terminated when a data read/write transfer is being performed.  <a href="#ga6b594879fb754ed4ae76685d6c261e5d">More...</a><br /></td></tr>
<tr class="separator:ga6b594879fb754ed4ae76685d6c261e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78ea3782bd018162fc06e3d24dc46b83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#ga78ea3782bd018162fc06e3d24dc46b83">R_USB_Suspend</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="memdesc:ga78ea3782bd018162fc06e3d24dc46b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a SUSPEND signal from the USB module assigned to the member (module) of the usb_crtl_t structure.  <a href="#ga78ea3782bd018162fc06e3d24dc46b83">More...</a><br /></td></tr>
<tr class="separator:ga78ea3782bd018162fc06e3d24dc46b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9851b21f1891e71de574a47589ea0282"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#ga9851b21f1891e71de574a47589ea0282">R_USB_Resume</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="memdesc:ga9851b21f1891e71de574a47589ea0282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a RESUME signal from the USB module assigned to the member (module) of the usb_ctrl_tstructure.  <a href="#ga9851b21f1891e71de574a47589ea0282">More...</a><br /></td></tr>
<tr class="separator:ga9851b21f1891e71de574a47589ea0282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d8d4651d5f1fa839cc85d32374f9018"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#ga0d8d4651d5f1fa839cc85d32374f9018">R_USB_VbusSet</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl, uint16_t state)</td></tr>
<tr class="memdesc:ga0d8d4651d5f1fa839cc85d32374f9018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies starting or stopping the VBUS supply.  <a href="#ga0d8d4651d5f1fa839cc85d32374f9018">More...</a><br /></td></tr>
<tr class="separator:ga0d8d4651d5f1fa839cc85d32374f9018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60b7dbef6ec571c6f2cacedcc5dccbcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#ga60b7dbef6ec571c6f2cacedcc5dccbcd">R_USB_InfoGet</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl, usb_info_t *p_info, uint8_t destination)</td></tr>
<tr class="memdesc:ga60b7dbef6ec571c6f2cacedcc5dccbcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains completed USB-related events.  <a href="#ga60b7dbef6ec571c6f2cacedcc5dccbcd">More...</a><br /></td></tr>
<tr class="separator:ga60b7dbef6ec571c6f2cacedcc5dccbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bee47c1fb4dfb12eba430226122bd57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#ga5bee47c1fb4dfb12eba430226122bd57">R_USB_PipeRead</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl, uint8_t *p_buf, uint32_t size, uint8_t pipe_number)</td></tr>
<tr class="memdesc:ga5bee47c1fb4dfb12eba430226122bd57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests a data read (Bulk/Interrupt transfer) via the pipe specified in the argument.  <a href="#ga5bee47c1fb4dfb12eba430226122bd57">More...</a><br /></td></tr>
<tr class="separator:ga5bee47c1fb4dfb12eba430226122bd57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f800b5c189c92d58d23972142214d22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#ga4f800b5c189c92d58d23972142214d22">R_USB_PipeWrite</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl, uint8_t *p_buf, uint32_t size, uint8_t pipe_number)</td></tr>
<tr class="memdesc:ga4f800b5c189c92d58d23972142214d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests a data write (Bulk/Interrupt transfer).  <a href="#ga4f800b5c189c92d58d23972142214d22">More...</a><br /></td></tr>
<tr class="separator:ga4f800b5c189c92d58d23972142214d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5311e5c477a72f6ac531516e49467d16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#ga5311e5c477a72f6ac531516e49467d16">R_USB_PipeStop</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl, uint8_t pipe_number)</td></tr>
<tr class="memdesc:ga5311e5c477a72f6ac531516e49467d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminates a data read/write operation.  <a href="#ga5311e5c477a72f6ac531516e49467d16">More...</a><br /></td></tr>
<tr class="separator:ga5311e5c477a72f6ac531516e49467d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga112c7de01280de80c529ec61789c9cc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#ga112c7de01280de80c529ec61789c9cc0">R_USB_UsedPipesGet</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl, uint16_t *p_pipe, uint8_t destination)</td></tr>
<tr class="memdesc:ga112c7de01280de80c529ec61789c9cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the selected pipe number (number of the pipe that has completed initialization) via bit map information.  <a href="#ga112c7de01280de80c529ec61789c9cc0">More...</a><br /></td></tr>
<tr class="separator:ga112c7de01280de80c529ec61789c9cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08f0810f299c825fae9a9f8ada2f9dbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#ga08f0810f299c825fae9a9f8ada2f9dbf">R_USB_PipeInfoGet</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl, usb_pipe_t *p_info, uint8_t pipe_number)</td></tr>
<tr class="memdesc:ga08f0810f299c825fae9a9f8ada2f9dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the following pipe information regarding the pipe specified in the argument (p_ctrl) member (pipe): endpoint number, transfer type, transfer direction and maximum packet size.  <a href="#ga08f0810f299c825fae9a9f8ada2f9dbf">More...</a><br /></td></tr>
<tr class="separator:ga08f0810f299c825fae9a9f8ada2f9dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga999a06f4569d82b8e18c2509e579a35f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#ga999a06f4569d82b8e18c2509e579a35f">R_USB_PullUp</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl, uint8_t state)</td></tr>
<tr class="memdesc:ga999a06f4569d82b8e18c2509e579a35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables or disables pull-up of D+/D- line.  <a href="#ga999a06f4569d82b8e18c2509e579a35f">More...</a><br /></td></tr>
<tr class="separator:ga999a06f4569d82b8e18c2509e579a35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecba62e40820ec837fa0b285140ed13b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#gaecba62e40820ec837fa0b285140ed13b">R_USB_HostControlTransfer</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl, usb_setup_t *p_setup, uint8_t *p_buf, uint8_t device_address)</td></tr>
<tr class="memdesc:gaecba62e40820ec837fa0b285140ed13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs settings and transmission processing when transmitting a setup packet.  <a href="#gaecba62e40820ec837fa0b285140ed13b">More...</a><br /></td></tr>
<tr class="separator:gaecba62e40820ec837fa0b285140ed13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1293995ba77495705db3a3adf703b7f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#ga1293995ba77495705db3a3adf703b7f1">R_USB_PeriControlDataGet</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl, uint8_t *p_buf, uint32_t size)</td></tr>
<tr class="memdesc:ga1293995ba77495705db3a3adf703b7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives data sent by control transfer.  <a href="#ga1293995ba77495705db3a3adf703b7f1">More...</a><br /></td></tr>
<tr class="separator:ga1293995ba77495705db3a3adf703b7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fb9080601ee1041e35073e0538a21b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#ga3fb9080601ee1041e35073e0538a21b0">R_USB_PeriControlDataSet</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl, uint8_t *p_buf, uint32_t size)</td></tr>
<tr class="memdesc:ga3fb9080601ee1041e35073e0538a21b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs transfer processing for control transfer.  <a href="#ga3fb9080601ee1041e35073e0538a21b0">More...</a><br /></td></tr>
<tr class="separator:ga3fb9080601ee1041e35073e0538a21b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8976d11f8be52c3f9422563188d6ab9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#gaf8976d11f8be52c3f9422563188d6ab9">R_USB_PeriControlStatusSet</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___u_s_b___a_p_i.html#ga386cabe04206e06b3be8dbafc0bc3d86">usb_setup_status_t</a> status)</td></tr>
<tr class="memdesc:gaf8976d11f8be52c3f9422563188d6ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the response to the setup packet.  <a href="#gaf8976d11f8be52c3f9422563188d6ab9">More...</a><br /></td></tr>
<tr class="separator:gaf8976d11f8be52c3f9422563188d6ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66ee4c6ec542965dbac67020bd135179"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#ga66ee4c6ec542965dbac67020bd135179">R_USB_RemoteWakeup</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="memdesc:ga66ee4c6ec542965dbac67020bd135179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a remote wake-up signal to the connected Host.  <a href="#ga66ee4c6ec542965dbac67020bd135179">More...</a><br /></td></tr>
<tr class="separator:ga66ee4c6ec542965dbac67020bd135179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f8b7813a97e21b412fc95a80c042fe3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#ga2f8b7813a97e21b412fc95a80c042fe3">R_USB_DriverActivate</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="memdesc:ga2f8b7813a97e21b412fc95a80c042fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate USB Driver for USB Peripheral BareMetal.  <a href="#ga2f8b7813a97e21b412fc95a80c042fe3">More...</a><br /></td></tr>
<tr class="separator:ga2f8b7813a97e21b412fc95a80c042fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaedca302f2e3938e2d85e4a82c44d44b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#gaaedca302f2e3938e2d85e4a82c44d44b">R_USB_CallbackMemorySet</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl, usb_callback_args_t *p_callback_memory)</td></tr>
<tr class="memdesc:gaaedca302f2e3938e2d85e4a82c44d44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback memory to USB Driver for USB Peripheral BareMetal.  <a href="#gaaedca302f2e3938e2d85e4a82c44d44b">More...</a><br /></td></tr>
<tr class="separator:gaaedca302f2e3938e2d85e4a82c44d44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad568903d7571f81da82b56d766bac46f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#gad568903d7571f81da82b56d766bac46f">R_USB_ModuleNumberGet</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl, uint8_t *module_number)</td></tr>
<tr class="memdesc:gad568903d7571f81da82b56d766bac46f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets the module number.  <a href="#gad568903d7571f81da82b56d766bac46f">More...</a><br /></td></tr>
<tr class="separator:gad568903d7571f81da82b56d766bac46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe65188a89a926bcc12676c39ff587ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#gafe65188a89a926bcc12676c39ff587ea">R_USB_ClassTypeGet</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___u_s_b___a_p_i.html#gab1dc4a2240edf1a50cca3945f31dc9f2">usb_class_t</a> *class_type)</td></tr>
<tr class="memdesc:gafe65188a89a926bcc12676c39ff587ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets the class type.  <a href="#gafe65188a89a926bcc12676c39ff587ea">More...</a><br /></td></tr>
<tr class="separator:gafe65188a89a926bcc12676c39ff587ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5115f4b4a93c22485a82d753d5ca30b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#ga5115f4b4a93c22485a82d753d5ca30b4">R_USB_DeviceAddressGet</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl, uint8_t *device_address)</td></tr>
<tr class="memdesc:ga5115f4b4a93c22485a82d753d5ca30b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets the device address.  <a href="#ga5115f4b4a93c22485a82d753d5ca30b4">More...</a><br /></td></tr>
<tr class="separator:ga5115f4b4a93c22485a82d753d5ca30b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a525c37cda36063befdb9451db98489"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#ga8a525c37cda36063befdb9451db98489">R_USB_PipeNumberGet</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl, uint8_t *pipe_number)</td></tr>
<tr class="memdesc:ga8a525c37cda36063befdb9451db98489"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets the pipe number.  <a href="#ga8a525c37cda36063befdb9451db98489">More...</a><br /></td></tr>
<tr class="separator:ga8a525c37cda36063befdb9451db98489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3daaad1d2b7430e08a5c1bf87bfec38d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#ga3daaad1d2b7430e08a5c1bf87bfec38d">R_USB_DeviceStateGet</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl, uint16_t *state)</td></tr>
<tr class="memdesc:ga3daaad1d2b7430e08a5c1bf87bfec38d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets the state of the device.  <a href="#ga3daaad1d2b7430e08a5c1bf87bfec38d">More...</a><br /></td></tr>
<tr class="separator:ga3daaad1d2b7430e08a5c1bf87bfec38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga042d5b513be9896e593f023c8cb81cd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#ga042d5b513be9896e593f023c8cb81cd1">R_USB_DataSizeGet</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl, uint32_t *data_size)</td></tr>
<tr class="memdesc:ga042d5b513be9896e593f023c8cb81cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets the read data size.  <a href="#ga042d5b513be9896e593f023c8cb81cd1">More...</a><br /></td></tr>
<tr class="separator:ga042d5b513be9896e593f023c8cb81cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga628af921919f90a9232c8c1713cc6c48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#ga628af921919f90a9232c8c1713cc6c48">R_USB_SetupGet</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl, usb_setup_t *setup)</td></tr>
<tr class="memdesc:ga628af921919f90a9232c8c1713cc6c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets the setup information.  <a href="#ga628af921919f90a9232c8c1713cc6c48">More...</a><br /></td></tr>
<tr class="separator:ga628af921919f90a9232c8c1713cc6c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66b9f21c7fc7cce60388edeaf7861d0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#ga66b9f21c7fc7cce60388edeaf7861d0e">R_USB_OtgCallbackSet</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl, usb_otg_callback_t *p_callback)</td></tr>
<tr class="memdesc:ga66b9f21c7fc7cce60388edeaf7861d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback function to be called when the OTG role swap was completed on Azure RTOS.  <a href="#ga66b9f21c7fc7cce60388edeaf7861d0e">More...</a><br /></td></tr>
<tr class="separator:ga66b9f21c7fc7cce60388edeaf7861d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a52197abba908bdd990e9bca22d50a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#ga1a52197abba908bdd990e9bca22d50a7">R_USB_OtgSRP</a> (<a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="memdesc:ga1a52197abba908bdd990e9bca22d50a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the SRP processing for OTG on Azure RTOS.  <a href="#ga1a52197abba908bdd990e9bca22d50a7">More...</a><br /></td></tr>
<tr class="separator:ga1a52197abba908bdd990e9bca22d50a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the USB peripheral on RA MCUs. This module implements the <a class="el" href="group___u_s_b___a_p_i.html">USB Interface</a>. </p>
<h1><a class="anchor" id="r-usb_basic-overview"></a>
Overview</h1>
<p>The USB module operates in combination with the device class drivers provided by Renesas to form a complete USB stack.</p>
<h2><a class="anchor" id="r-usb_basic-features"></a>
Features</h2>
<p>The USB module has the following key features:</p>
<ul>
<li>USB Host mode<ul>
<li>Enumerates Low/Full/High-speed devices (see note below)</li>
<li>Automatic transfer error determination and retry</li>
</ul>
</li>
<li>USB Peripheral mode<ul>
<li>Supports USB1.1/2.0/3.0 hosts</li>
</ul>
</li>
<li>Automatic processing of device connect/disconnect, suspend/resume, and USB bus reset</li>
<li>Up to 10 pipes<ul>
<li>Control transfers supported on pipe 0</li>
<li>Data transfer on pipes 1 to 9 (Bulk or Interrupt)</li>
</ul>
</li>
<li>Functions with or without an RTOS</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Supported speeds are dependent on the MCU.</dd></dl>
<h1><a class="anchor" id="r-usb_basic-support-device-class"></a>
Support Device Class</h1>
<p>This driver supports the following device classes.</p>
<table class="doxtable">
<tr>
<th align="left">Host/Peripheral </th><th align="left">Device Class </th><th align="left">BareMetal </th><th align="left">FreeRTOS </th><th align="left">AzureRTOS  </th></tr>
<tr>
<td align="left">Host </td><td align="left">HCDC (ACM) </td><td align="left">Yes </td><td align="left">Yes </td><td align="left">Yes </td></tr>
<tr>
<td align="left"></td><td align="left">HCDC (ECM) </td><td align="left">&ndash; </td><td align="left">Yes </td><td align="left">&ndash; </td></tr>
<tr>
<td align="left"></td><td align="left">HHID </td><td align="left">Yes </td><td align="left">Yes </td><td align="left">Yes </td></tr>
<tr>
<td align="left"></td><td align="left">HMSC </td><td align="left">Yes </td><td align="left">Yes </td><td align="left">Yes </td></tr>
<tr>
<td align="left"></td><td align="left">HPRN </td><td align="left">&ndash; </td><td align="left">&ndash; </td><td align="left">Yes </td></tr>
<tr>
<td align="left"></td><td align="left">HUVC </td><td align="left">&ndash; </td><td align="left">&ndash; </td><td align="left">Yes </td></tr>
<tr>
<td align="left"></td><td align="left">HVND </td><td align="left">Yes </td><td align="left">Yes </td><td align="left">&ndash; </td></tr>
<tr>
<td align="left"></td><td align="left">HAUD </td><td align="left">Yes </td><td align="left">Yes </td><td align="left">Yes </td></tr>
<tr>
<td align="left"></td><td align="left">HCDC+HMSC (Composite) </td><td align="left">&ndash; </td><td align="left">Yes </td><td align="left">&ndash; </td></tr>
<tr>
<td align="left">Peripheral </td><td align="left">PCDC </td><td align="left">Yes </td><td align="left">Yes </td><td align="left">Yes </td></tr>
<tr>
<td align="left"></td><td align="left">PHID </td><td align="left">Yes </td><td align="left">Yes </td><td align="left">Yes </td></tr>
<tr>
<td align="left"></td><td align="left">PMSC </td><td align="left">Yes </td><td align="left">Yes </td><td align="left">Yes </td></tr>
<tr>
<td align="left"></td><td align="left">PPRN </td><td align="left">Yes </td><td align="left">Yes </td><td align="left">Yes </td></tr>
<tr>
<td align="left"></td><td align="left">PAUD </td><td align="left">Yes </td><td align="left">Yes </td><td align="left">Yes </td></tr>
<tr>
<td align="left"></td><td align="left">DFU </td><td align="left">&ndash; </td><td align="left">&ndash; </td><td align="left">Yes </td></tr>
<tr>
<td align="left"></td><td align="left">PVND </td><td align="left">Yes </td><td align="left">Yes </td><td align="left">&ndash; </td></tr>
<tr>
<td align="left"></td><td align="left">PCDC+PMSC </td><td align="left">Yes </td><td align="left">Yes </td><td align="left">Yes </td></tr>
<tr>
<td align="left"></td><td align="left">PHID+PMSC </td><td align="left">Yes </td><td align="left">Yes </td><td align="left">&ndash; </td></tr>
<tr>
<td align="left"></td><td align="left">PCDC+PHID </td><td align="left">Yes </td><td align="left">Yes </td><td align="left">&ndash; </td></tr>
<tr>
<td align="left"></td><td align="left">PCDC+PCDC </td><td align="left">Yes </td><td align="left">Yes </td><td align="left">&ndash; </td></tr>
<tr>
<td align="left"></td><td align="left">PHID+PHID </td><td align="left">Yes </td><td align="left">Yes </td><td align="left">&ndash; </td></tr>
<tr>
<td align="left"></td><td align="left">PCDC+PVND </td><td align="left">Yes </td><td align="left">Yes </td><td align="left">&ndash; </td></tr>
<tr>
<td align="left">Other </td><td align="left">OTG (CDC) </td><td align="left">&ndash; </td><td align="left">&ndash; </td><td align="left">Yes </td></tr>
<tr>
<td align="left"></td><td align="left">OTG (HID) </td><td align="left">&ndash; </td><td align="left">&ndash; </td><td align="left">Yes </td></tr>
<tr>
<td align="left"></td><td align="left">OTG (MSC) </td><td align="left">&ndash; </td><td align="left">&ndash; </td><td align="left">Yes </td></tr>
</table>
<h1><a class="anchor" id="r-usb_basic-configuration"></a>
Configuration</h1>
<p><h2>Build Time Configurations for r_usb_basic</h2>
The following build time configurations are defined in fsp_cfg/r_usb_basic_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr class="tree_none">
<td>CL Only Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>To reduce power consumption, a classic-only mode where operation is only in accord with the USB 1.1 standard is selectable. </td></tr>
<tr class="tree_none">
<td>CPU Bus Access Wait Cycles</td><td>MCU Specific Options</td><td></td><td>This setting controls the delay for consecutive USB peripheral register access. Set this value to a number of CPU cycles that is equivalent to 40.8ns or more. </td></tr>
<tr class="tree_none">
<td>Battery Charging</td><td>MCU Specific Options</td><td></td><td>Specify whether or not to include battery charging functionality. </td></tr>
<tr class="tree_none">
<td>Power IC Shutdown Polarity</td><td>MCU Specific Options</td><td></td><td>Select the polarity of the Shutdown signal on the power supply IC (if provided). </td></tr>
<tr class="tree_none">
<td>Dedicated Charging Port (DCP) Mode</td><td>MCU Specific Options</td><td></td><td>When enabled, USB communication is disabled and the port is used for charging only. </td></tr>
<tr class="tree_none">
<td>Notifications for SET_INTERFACE/SET_FEATURE/CLEAR_FEATURE</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Enabled </td><td>When enabled, the application will receive notifications for SET_INTERFACE, SET_FEATURE and CLEAR_FEATURE messages. </td></tr>
<tr class="tree_none">
<td>Double Buffering</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Enabled </td><td>When enabled, the FIFOs for Pipes 1-5 are double-buffered. </td></tr>
<tr class="tree_none">
<td>Continuous Transfer Mode</td><td>MCU Specific Options</td><td></td><td>Enable or disable continuous transfer mode. </td></tr>
<tr class="tree_none">
<td>LDO Regulator</td><td>MCU Specific Options</td><td></td><td>Enable or disable LDO regulator. </td></tr>
<tr class="tree_none">
<td>DMA/DTC Support</td><td>MCU Specific Options</td><td></td><td>Enable or disable DMA/DTC support for the USB module. </td></tr>
<tr class="tree_none">
<td>DMA/DTC Source Address</td><td>MCU Specific Options</td><td></td><td>Set this to match the speed mode when DMA/DTC is enabled. Otherwise, set to 'DMA Disabled'/'DTC Disabled'. </td></tr>
<tr class="tree_none">
<td>DMA/DTC Destination Address</td><td>MCU Specific Options</td><td></td><td>Set this to match the speed mode when DMA/DTC is enabled. Otherwise, set to 'DMA Disabled'/'DTC Disabled'. </td></tr>
<tr class="tree_none">
<td>USB Compliance Test mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Display the information required to take the compliance test.  </td></tr>
<tr class="tree_none">
<td>USB TPL table name</td><td>Enter the TPL table name.</td><td>NULL </td><td>Enter the name of the TPL Table.  </td></tr>
</table>
 <h2>Configurations for Connectivity &gt; USB (r_usb_basic)</h2>
<table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Name</td><td>Name must be a valid C symbol</td><td>g_basic0 </td><td>Module name. </td></tr>
<tr class="tree_none">
<td>USB Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Host mode</li>
<li>
Peri mode</li>
<li>
OTG mode</li>
</ul>
</td><td>Host mode </td><td>Select the usb mode. </td></tr>
<tr class="tree_none">
<td>USB Speed</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Full Speed</li>
<li>
Hi Speed</li>
<li>
Low Speed</li>
</ul>
</td><td>Full Speed </td><td>Select the USB speed. </td></tr>
<tr class="tree_none">
<td>USB Module Number</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
USB_IP0 Port</li>
<li>
USB_IP1 Port</li>
</ul>
</td><td>USB_IP0 Port </td><td>Specify the USB module number to be used. </td></tr>
<tr class="tree_none">
<td>USB Device Class</td><td>Refer to the RA Configuration tool for available options.</td><td>Peripheral Communications Device Class </td><td>Select the USB device class. </td></tr>
<tr class="tree_none">
<td>USB Descriptor</td><td>USB Descriptor must be a valid C symbol.</td><td>g_usb_descriptor </td><td>Enter the name of the descriptor to be used.<br />
For how to create a descriptor structure, refer to the Descriptor definition chapter in the usb_basic manual.<br />
Specify NULL when using the Host class. </td></tr>
<tr class="tree_none">
<td>USB Compliance Callback</td><td>Compliance Callback must be a valid C symbol.</td><td>NULL </td><td>Set the callback for compliance tests here. </td></tr>
<tr class="tree_none">
<td>USBFS Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select the interrupt priority used by the main USBFS ISR. </td></tr>
<tr class="tree_none">
<td>USBFS Resume Priority</td><td>MCU Specific Options</td><td></td><td>Select the interrupt priority used by the USBFS Resume ISR. </td></tr>
<tr class="tree_none">
<td>USBFS D0FIFO Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select the interrupt priority used by the USBFS D0FIFO. </td></tr>
<tr class="tree_none">
<td>USBFS D1FIFO Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select the interrupt priority used by the USBFS D1FIFO. </td></tr>
<tr class="tree_none">
<td>USBHS Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select the interrupt priority used by the main USBHS ISR. </td></tr>
<tr class="tree_none">
<td>USBHS D0FIFO Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select the interrupt priority used by the USBHS D0FIFO ISR. </td></tr>
<tr class="tree_none">
<td>USBHS D1FIFO Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select the interrupt priority used by the USBHS D1FIFO ISR. </td></tr>
<tr class="tree_none">
<td>USB Callback</td><td>Enter the address of the function.</td><td>NULL </td><td>A user callback function can be defined here. </td></tr>
<tr class="tree_none">
<td>USB Callback Context</td><td>Enter the address of the context.</td><td>NULL </td><td>Set the callback context here. </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-usb_basic-clock-configuration"></a>
Clock Configuration</h2>
<p>The USB module uses PLL as the clock source. The PLL frequency can be set in the <b>Clocks</b> tab of the configuration editor or by using the CGC Interface at run-time.</p>
<dl class="section note"><dt>Note</dt><dd>When using HOCO as the PLL source on Cortex M33 parts the FLL function must be enabled for correct USB operation. Refer to the MCU Family -&gt; Clocks group of the BSP properties in the RA configuration tool to adjust FLL settings.</dd></dl>
<h2><a class="anchor" id="r-usb_basic-pin-configuration"></a>
Pin Configuration</h2>
<p>In peripheral mode the USB_VBUS and/or USBHS_VBUS pins are used to detect the USB connection status (connected or disconnected) and should be connected to the USB VBUS signal.</p>
<dl class="section note"><dt>Note</dt><dd>USB_VBUS and USBHS_VBUS are 5V-tolerant pins.</dd></dl>
<p>In host mode the USBHS_VBUSEN, USBHS_OVRCURA and USBHS_OVRCURB pins should be connected to the relevant pins of an external power supply IC, if available. These pins will be used to manage the USB VBUS supply.</p>
<h2><a class="anchor" id="r-usb_basic-dma-configuration"></a>
DMA Configuration</h2>
<p>When using DMA with USB the following properties must be configured for each DMAC module:</p>
<table class="doxtable">
<tr>
<th align="left">Config Name </th><th align="left">Select Name </th><th align="left">Description  </th></tr>
<tr>
<td align="left">Transfer Size </td><td align="left">2 Bytes<br />
4 Bytes</td><td align="left">In FS mode, select "2 Bytes"<br />
In HS mode, select "4 Bytes" </td></tr>
<tr>
<td align="left">Activation source</td><td align="left">USBFS FIFO 0<br />
USBFS FIFO 1<br />
USBHS FIFO 0<br />
USBHS FIFO 1</td><td align="left">USB FS Reception<br />
USB FS Transmission<br />
USB HS Reception<br />
USB HS Transmission </td></tr>
</table>
<h1><a class="anchor" id="r-usb_basic-descriptor-definition"></a>
Descriptor definition</h1>
<p>In Peripheral mode, the usb_descriptor_t structure stores descriptor information including the device and configuration descriptors. The values set in this structure are sent to the USB host as part of enumeration.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>usb_descriptor</div><div class="line">{</div><div class="line">    uint8_t *p_device;    <span class="comment">/* Pointer to device descriptor */</span></div><div class="line">    uint8_t *p_config_f;  <span class="comment">/* Pointer to full-speed configuration descriptor */</span></div><div class="line">    uint8_t *p_config_h;  <span class="comment">/* Pointer to high-speed configuration descriptor (HS only) */</span></div><div class="line">    uint8_t *p_qualifier; <span class="comment">/* Pointer to device qualifier descriptor (HS only) */</span></div><div class="line">    uint8_t **pp_string;  <span class="comment">/* Pointer to string descriptor table */</span></div><div class="line">    uint8_t num_string;   <span class="comment">/* Number of strings in table */</span></div><div class="line">} usb_descriptor_t;</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Even in high-speed mode the full-speed configuration must be made available: <div class="fragment"><div class="line"><span class="comment">/* Example USB FS descriptor struct */</span></div><div class="line">usb_descriptor_t g_usb_descriptor =</div><div class="line">{</div><div class="line">    smp_device,</div><div class="line">    smp_config_f,</div><div class="line">    NULL,</div><div class="line">    NULL,</div><div class="line">    smp_str_table,</div><div class="line">    3,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* Example USB HS descriptor struct */</span></div><div class="line">usb_descriptor_t g_usb_descriptor =</div><div class="line">{</div><div class="line">    smp_device,</div><div class="line">    smp_config_f,</div><div class="line">    smp_config_h,</div><div class="line">    smp_qualifier,</div><div class="line">    smp_str_table,</div><div class="line">    3,</div><div class="line">};</div></div><!-- fragment --></dd></dl>
<h2>String Descriptor</h2>
<p>This USB driver requires string descriptors to be registered in the string descriptor table. Use the following format to define the elements:</p>
<div class="fragment"><div class="line"><span class="comment">/* String descriptor 0 is reserved for language ID information */</span></div><div class="line">uint8_t str_descriptor_0[]</div><div class="line">{</div><div class="line">    0x04,      <span class="comment">/* Length */</span></div><div class="line">    0x03,      <span class="comment">/* Descriptor type */</span></div><div class="line">    0x09, 0x04 <span class="comment">/* Language ID */</span></div><div class="line">};</div><div class="line"></div><div class="line">uint8_t str_descriptor_manufacturer[] =</div><div class="line">{</div><div class="line">    0x10,      <span class="comment">/* Length */</span></div><div class="line">    0x03,      <span class="comment">/* Descriptor type */</span></div><div class="line">    <span class="charliteral">&#39;R&#39;</span>, 0x00,</div><div class="line">    <span class="charliteral">&#39;E&#39;</span>, 0x00,</div><div class="line">    <span class="charliteral">&#39;N&#39;</span>, 0x00,</div><div class="line">    <span class="charliteral">&#39;E&#39;</span>, 0x00,</div><div class="line">    <span class="charliteral">&#39;S&#39;</span>, 0x00,</div><div class="line">    <span class="charliteral">&#39;A&#39;</span>, 0x00,</div><div class="line">    <span class="charliteral">&#39;S&#39;</span>, 0x00</div><div class="line">};</div><div class="line"></div><div class="line">uint8_t str_descriptor_product[] =</div><div class="line">{</div><div class="line">    0x12,      <span class="comment">/* Length */</span></div><div class="line">    0x03,      <span class="comment">/* Descriptor type */</span></div><div class="line">    <span class="charliteral">&#39;C&#39;</span>, 0x00,</div><div class="line">    <span class="charliteral">&#39;D&#39;</span>, 0x00,</div><div class="line">    <span class="charliteral">&#39;C&#39;</span>, 0x00,</div><div class="line">    <span class="charliteral">&#39;_&#39;</span>, 0x00,</div><div class="line">    <span class="charliteral">&#39;D&#39;</span>, 0x00,</div><div class="line">    <span class="charliteral">&#39;E&#39;</span>, 0x00,</div><div class="line">    <span class="charliteral">&#39;M&#39;</span>, 0x00,</div><div class="line">    <span class="charliteral">&#39;O&#39;</span>, 0x00</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* String descriptor table */</span></div><div class="line">uint8_t * smp_str_table[] =</div><div class="line">{</div><div class="line">    str_descriptor_0,            <span class="comment">/* Index: 0 */</span></div><div class="line">    str_descriptor_manufacturer, <span class="comment">/* Index: 1 */</span></div><div class="line">    str_descriptor_product,      <span class="comment">/* Index: 2 */</span></div><div class="line">};</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Set the string index values in the device/configuration descriptors (iManufacturer, iConfiguration etc.) to the index of the desired string in the string descriptor table. For example, in the table below, the manufacturer is described in <b>str_descriptor_manufacturer</b> and the value of iManufacturer in the device descriptor is <b>1</b>.</dd></dl>
<h2>Other Descriptors</h2>
<p>Refer to the Universal Serial Bus Revision 2.0 specification (<a href="http://www.usb.org/developers/docs/">http://www.usb.org/developers/docs/</a>) for details on how to construct the device, configuration and qualifier descriptors.</p>
<h1><a class="anchor" id="r-usb_basic-usage_notes"></a>
Usage Notes</h1>
<h2>Program Structure</h2>
<p>USB applications (whether using an RTOS or not) should be written as an event-handling loop. Either a callback function (RTOS only) or R_USB_EventGet should be used to provide event data to the application loop where a switch statement handles the event.</p>
<dl class="section note"><dt>Note</dt><dd>1.The USB_STATUS_CONFIGURED event should be confirmed before calling R_USB_Read or R_USB_Write.<br />
 2.When attaching or detaching USB cable, the suspend or resume event may be notified to the application program in USB peripheral mode. Please ignore these events since the notification of these events to the application program does not affect the operation.<br />
 3.USB applications always need to check the USB device status member(<em>status</em>) of <em>usb_event_info_t</em> control structure before proceeding to event-handling loop. If device status is success (FSP_SUCCESS) then only proceed with handling of received events.<br />
</dd></dl>
<h2><a class="anchor" id="r-usb_basic-limitations"></a>
Limitations</h2>
<p>Developers should be aware of the following limitations when using the USB driver:</p>
<ul>
<li>In USB host mode, the module does not support suspend during data transfers. Execute suspend only after confirming that all transfers are complete.</li>
<li>Multiconfigurations are not supported.</li>
<li>This driver does not support CPU transfers using the D0FIFO/D1FIFO register.</li>
<li>In USB host mode, this USB driver does not support the composite device other than "HMSC + HCDC (for FreeRTOS)".</li>
<li>The user can not specify DMA transfer to USB IP0 and IP1 modules at the same time when using USB multi-port feature. USB multi-port function: Simultaneous operation feature of USB Host and Peripheral.</li>
<li>In USB host mode, When using a USB High-speed module, enumeration may not start when the user slowly detach the USB cable and attach USB cable.</li>
</ul>
<h2><a class="anchor" id="r-usb_basic-compliancetest"></a>
Compliance Test</h2>
<p>Please set as follows to the following items in RA configuration (r_usb_basic) when doing the compliance test.</p>
<p>1.USB Compliance Test mode Set "Enabled" in this item.</p>
<div class="image">
<img src="compliance_enable.png" alt="compliance_enable.png"/>
<div class="caption">
Compliance Test Setting</div></div>
<p>2.USB TPL table name. Set the start address of TPL(Target Peripheral List) defined in the application program.</p>
<div class="image">
<img src="tpl_start_address.png" alt="tpl_start_address.png"/>
<div class="caption">
TPL Start Address Setting</div></div>
<p> Please refer to the following about how to define for TPL.<br />
 The following example is when two devices are set in TPL.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> uint16_t usb_tpl_table[] =</div><div class="line">{</div><div class="line">    2,                <span class="comment">/* Number of tpl */</span></div><div class="line">    0,                <span class="comment">/* Reserved */</span></div><div class="line">    0x0123, 0x4567,   <span class="comment">/* Vendor ID, Product ID (1st device) */</span></div><div class="line">    0x89ab, 0xcdef    <span class="comment">/* Vendor ID, Product ID (2nd device) */</span></div><div class="line">};</div></div><!-- fragment --><p>3.USB Compliance Callback Set the start address of the callback function defined in the application program.</p>
<div class="image">
<img src="compliance_callback.png" alt="compliance_callback.png"/>
<div class="caption">
Compliance Callback Setting</div></div>
<p> The user needs to create this callback function by referring to the following.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> usb_compliance_disp (<span class="keywordtype">void</span> * param)</div><div class="line">{</div><div class="line">    usb_compliance_t     *disp_data;</div><div class="line">    uint8_t             print_data[32];</div><div class="line"></div><div class="line">    disp_data = (usb_compliance_t*)param;</div><div class="line"></div><div class="line">    <span class="keywordflow">switch</span>(disp_data-&gt;status)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___u_s_b___a_p_i.html#gga565d5746bce505ef376bc2d3777d9302abf6fb86e88281a4c9d441b6c923b3111">USB_COMPLIANCETEST_ATTACH</a>:            <span class="comment">/* Device Attach Detection */</span></div><div class="line">            display(<span class="stringliteral">&quot;\nATTACH \n&quot;</span>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___u_s_b___a_p_i.html#gga565d5746bce505ef376bc2d3777d9302af5e68b2dca0d8369a411723260a3a306">USB_COMPLIANCETEST_DETACH</a>:            <span class="comment">/* Device Detach Detection */</span></div><div class="line">            display(<span class="stringliteral">&quot;\nDETACH \n&quot;</span>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___u_s_b___a_p_i.html#gga565d5746bce505ef376bc2d3777d9302af2aa5006fcd9d18549d28cad9e735794">USB_COMPLIANCETEST_TPL</a>:               <span class="comment">/* TPL device connect */</span></div><div class="line">            display(<span class="stringliteral">&quot;\nTPL PID:%04x VID:%04x \n&quot;</span>,disp_data-&gt;pid, disp_data-&gt;vid);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___u_s_b___a_p_i.html#gga565d5746bce505ef376bc2d3777d9302ac3f55ab9add455009a2d2bcc987ef209">USB_COMPLIANCETEST_NOTTPL</a>:            <span class="comment">/* Not TPL device connect */</span></div><div class="line">            display(<span class="stringliteral">&quot;\nNOTPL PID:%04x VID:%04x \n&quot;</span>,disp_data-&gt;pid, disp_data-&gt;vid);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___u_s_b___a_p_i.html#gga565d5746bce505ef376bc2d3777d9302a48e08241727b6babb37a9a6ea9fc4f8c">USB_COMPLIANCETEST_HUB</a>:               <span class="comment">/* USB Hub connect */</span></div><div class="line">            display(<span class="stringliteral">&quot;\nHub    \n&quot;</span>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___u_s_b___a_p_i.html#gga565d5746bce505ef376bc2d3777d9302a6f7dd243303d816f65ab5f83e3857b8a">USB_COMPLIANCETEST_OVRC</a>:              <span class="comment">/* over current */</span></div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___u_s_b___a_p_i.html#gga565d5746bce505ef376bc2d3777d9302a6efe30ef900a8492f5f0a1e02a7beb34">USB_COMPLIANCETEST_NORES</a>:             <span class="comment">/* Response Time out for Control Read Transfer */</span></div><div class="line">            display(<span class="stringliteral">&quot;\nNOTRESP \n&quot;</span>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___u_s_b___a_p_i.html#gga565d5746bce505ef376bc2d3777d9302a26cbdc184b4aec0124d1b6b7fd23eb1c">USB_COMPLIANCETEST_SETUP_ERR</a>:         <span class="comment">/* Setup Transaction Error */</span></div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">}   <span class="comment">/* End of function usb_compliance_disp() */</span></div></div><!-- fragment --><p>Please replace the display function described in the example with the display function created by the customer.</p>
<h2><a class="anchor" id="r-usb_basic-callback-peripheral"></a>
Callback function for USB Peripheral</h2>
<p>The user can get completed USB event using callback function in USB Peripheral for BareMetal.</p>
<ul>
<li><p class="startli">Please specify user callback function in the following item.</p>
<div class="image">
<img src="user_callback.png" alt="user_callback.png"/>
<div class="caption">
User Callback Function Setting</div></div>
</li>
<li>Please call the <em>R_USB_DriverActivate</em> function using one of the following methods.<ul>
<li>Infinite loop in user application program</li>
<li>Timer Interrupt (Add r_gpt module in user system)</li>
</ul>
</li>
<li>Please sepecify the area to store USB events to USB driver using <em>R_USB_CallbackMemorySet</em> function after calling <em>R_USB_Open</em> function.</li>
</ul>
<div class="fragment"><div class="line">usb_callback_args_t  g_apl_usb_event_callback;</div></div><!-- fragment --><ul>
<li>Please allocate a buffer area such as a ring buffer to store USB event information in user application program.</li>
</ul>
<div class="fragment"><div class="line">#define BUFSIZE 10</div><div class="line">usb_callback_args_t  g_apl_usb_event_buffer[BUFSIZE];</div></div><!-- fragment --><ul>
<li>The USB driver calls the callback function when the USB event completes. USB event information is stored in the area indicated by the callback function argument.Copy the callback function argument to the ring buffer area or other area secured above.</li>
</ul>
<div class="fragment"><div class="line">g_apl_usb_event_buffer[g_apl_buffer_wp] = g_apl_usb_event_callback;</div><div class="line">g_apl_buffer_wp++;</div><div class="line">g_apl_buffer_wp %= BUFSIZE;</div></div><!-- fragment --><h2><a class="anchor" id="r-usb_basic-trustzone"></a>
TrustZone</h2>
<ol type="1">
<li>The USB driver for FreeRTOS cannot be allocated in Secure region.</li>
<li>Please place the descriptor file in Secure region when using Non-Secure Callable.</li>
<li>The user callback function should be specified using the <em>R_USB_Callback</em> function after calling the <em>R_USB_Open</em> function when using Non-Secure Callable.</li>
<li>For Non-Secure region, please do USB clock setting when creating Secure project.</li>
<li>Please do USB pin setting when creating USB driver project.</li>
</ol>
<h2><a class="anchor" id="r-usb_basic-hostcompoiste"></a>
Support Composite Device</h2>
<p>This driver for FreeRTOS supports the following compoiste device when this driver for FreeRTOS works in USB Host mode.</p>
<ol type="1">
<li>PCDC + PMSC</li>
</ol>
<h3><a class="anchor" id="r-usb_basic-hostcompoiste-configuration"></a>
How to Configuration</h3>
<ul>
<li>Add HMSC and HCDC stack as follow.</li>
</ul>
<div class="image">
<img src="USB_Host_composite_stack1.png" alt="USB_Host_composite_stack1.png"/>
<div class="caption">
Add HMSC and HCDC Stack</div></div>
<ul>
<li>Delete the "g_basic1" instance manually since this instance is not used in composite device. (Refer to the red frame in the above figure.)</li>
</ul>
<div class="image">
<img src="USB_Host_composite_stack2.png" alt="USB_Host_composite_stack2.png"/>
<div class="caption">
Delete g_basic1 instance</div></div>
 <h2>Using Hub</h2>
<ul>
<li>The user can use USB Hub when using the following device classes (Bare Metal + FreeRTOS):<ul>
<li>Host Communication Device Class (HCDC)</li>
<li>Host Human Interface Device Class (HHID)</li>
<li>Host Mass Storage Class (HMSC)</li>
</ul>
</li>
<li>When configuring single-class host hub, be sure to enable hub support property in each class stack: <div class="image">
<img src="USB_hub_single_class_enable.png" alt="USB_hub_single_class_enable.png"/>
<div class="caption">
USB Hub CDC-CDC setting</div></div>
 <h3>Note</h3>
</li>
</ul>
<ul>
<li>For USB Hub usage with Azure RTOS, please refer to <a class="el" href="group___u_s_b_x.html">Azure RTOS USBX Port (rm_usbx_port)</a>.</li>
<li>The followings are the limitation when using USB Hub:<ul>
<li>The current USB driver does not support for multi-class host hub and DMA transfer.</li>
<li>The USB driver allocates USB PIPE9 for USB Hub.</li>
<li>For HCDC, the user cannot connect more than 2 CDC devices to USB Hub.</li>
<li>For HHID, the user cannot connect more than 3 HID devices to USB Hub.</li>
<li>For HMSC, the user cannot connect more than 4 MSC devices to USB Hub.</li>
</ul>
</li>
<li>Depending on the Hub used, it may be necessary to supply power to the Hub.</li>
<li>For HHID Hub, do not connect two HID devices that support both Interrupt IN and Interrupt Out transfer.</li>
<li>For HMSC Hub, HMSC driver may not work properly due to the combination of the Hub device and USB stick.</li>
<li>HVND and HCDC-ECM do not support USB Hub.</li>
</ul>
<h2><a class="anchor" id="r-usb_basic-uclk_setting"></a>
UCLK setting</h2>
<p>Enable UCLK in "Clocks" tab on e&sup2; studio when using the following MCU.</p><ol type="1">
<li>RA6M4</li>
</ol>
<h1><a class="anchor" id="r-usb_basic-examples"></a>
Examples</h1>
<h2>USB Basic Example</h2>
<p>This is a basic example of minimal use of the USB in an application.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> usb_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    usb_event_info_t event_info;</div><div class="line">    <a class="code" href="group___u_s_b___a_p_i.html#ga56bea25fbffdbda134044c49d40d5e40">usb_status_t</a>     event;</div><div class="line"></div><div class="line">    g_usb_on_usb.<a class="code" href="group___u_s_b___a_p_i.html#a71c50854a60a443915487767eac07b01">open</a>(&amp;g_basic0_ctrl, &amp;g_basic0_cfg);</div><div class="line"></div><div class="line"></div><div class="line">    memset(&amp;event_info, 0, <span class="keyword">sizeof</span>(usb_event_info_t));</div><div class="line"></div><div class="line">    <span class="comment">/* Loop back between PC(TerminalSoft) and USB MCU */</span></div><div class="line">    <span class="keywordflow">while</span> (1)</div><div class="line">    {</div><div class="line">        g_usb_on_usb.<a class="code" href="group___u_s_b___a_p_i.html#ab9275462e1796a4c109af0dbf7424b4c">eventGet</a>(&amp;event_info, &amp;event);</div><div class="line">        <span class="keywordflow">switch</span> (event)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">case</span> <a class="code" href="group___u_s_b___a_p_i.html#gga56bea25fbffdbda134044c49d40d5e40ab5c3bd23fe62533150eef3a4e8c8d13c">USB_STATUS_CONFIGURED</a>:</div><div class="line">                g_usb_on_usb.<a class="code" href="group___u_s_b___a_p_i.html#a0c728ad83559809e18f18793dfd489ef">read</a>(&amp;g_basic0_ctrl, g_buf, DATA_LEN, <a class="code" href="group___u_s_b___a_p_i.html#ggab1dc4a2240edf1a50cca3945f31dc9f2a80c133e3ac3ddabc6aa656c3daf78c5e">USB_CLASS_PCDC</a>);</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">            <span class="keywordflow">case</span> <a class="code" href="group___u_s_b___a_p_i.html#gga56bea25fbffdbda134044c49d40d5e40ad44448290b4f36868a09b48e4588b29d">USB_STATUS_WRITE_COMPLETE</a>:</div><div class="line">                <span class="keywordflow">if</span> (FSP_SUCCESS == event_info.status)</div><div class="line">                {</div><div class="line">                    g_usb_on_usb.<a class="code" href="group___u_s_b___a_p_i.html#a0c728ad83559809e18f18793dfd489ef">read</a>(&amp;g_basic0_ctrl, g_buf, DATA_LEN, <a class="code" href="group___u_s_b___a_p_i.html#ggab1dc4a2240edf1a50cca3945f31dc9f2a80c133e3ac3ddabc6aa656c3daf78c5e">USB_CLASS_PCDC</a>);</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line"></div><div class="line">            <span class="keywordflow">case</span> <a class="code" href="group___u_s_b___a_p_i.html#gga56bea25fbffdbda134044c49d40d5e40a63dd4552584256ef9d1a0d5da2159e9c">USB_STATUS_READ_COMPLETE</a>:</div><div class="line">                <span class="keywordflow">if</span> ((FSP_SUCCESS == event_info.status) || (FSP_ERR_USB_SIZE_SHORT == event_info.status))</div><div class="line">                {</div><div class="line">                    g_usb_on_usb.<a class="code" href="group___u_s_b___a_p_i.html#a72dd66056efbc6284c61f557016a75cd">write</a>(&amp;g_basic0_ctrl, g_buf, event_info.data_size, <a class="code" href="group___u_s_b___a_p_i.html#ggab1dc4a2240edf1a50cca3945f31dc9f2a80c133e3ac3ddabc6aa656c3daf78c5e">USB_CLASS_PCDC</a>);</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line"></div><div class="line">            <span class="keywordflow">case</span> <a class="code" href="group___u_s_b___a_p_i.html#gga56bea25fbffdbda134044c49d40d5e40a8b49ebc4d15054963bdbe8d843a2cf5a">USB_STATUS_REQUEST</a>:   <span class="comment">/* Receive Class Request */</span></div><div class="line">                <span class="keywordflow">if</span> (<a class="code" href="group___u_s_b___p_c_d_c___a_p_i.html#ga9e76ac14dae5e5e44b5df6e8cbee6bd0">USB_PCDC_SET_LINE_CODING</a> == (event_info.setup.request_type &amp; <a class="code" href="group___u_s_b___a_p_i.html#ga3a6743f3e336fc05e70e59b05206f634">USB_BREQUEST</a>))</div><div class="line">                {</div><div class="line">                    g_usb_on_usb.<a class="code" href="group___u_s_b___a_p_i.html#afa3c12df088caabc41abfe9538df563a">periControlDataGet</a>(&amp;g_basic0_ctrl, (uint8_t *) &amp;g_line_coding, LINE_CODING_LENGTH);</div><div class="line">                }</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="group___u_s_b___p_c_d_c___a_p_i.html#ga3e7ae95dcfc42bd8912fe18339893d82">USB_PCDC_GET_LINE_CODING</a> == (event_info.setup.request_type &amp; <a class="code" href="group___u_s_b___a_p_i.html#ga3a6743f3e336fc05e70e59b05206f634">USB_BREQUEST</a>))</div><div class="line">                {</div><div class="line">                    g_usb_on_usb.<a class="code" href="group___u_s_b___a_p_i.html#adf500dc4e48aab1cce6ecd5d8ed37d87">periControlDataSet</a>(&amp;g_basic0_ctrl, (uint8_t *) &amp;g_line_coding, LINE_CODING_LENGTH);</div><div class="line">                }</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                {</div><div class="line">                    g_usb_on_usb.<a class="code" href="group___u_s_b___a_p_i.html#a2bf6b2b55ae43aadcf7ed5970f27eb3c">periControlStatusSet</a>(&amp;g_basic0_ctrl, <a class="code" href="group___u_s_b___a_p_i.html#gga386cabe04206e06b3be8dbafc0bc3d86a20a1e7b4a77141981d824649cab7554b">USB_SETUP_STATUS_ACK</a>);</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">            <span class="keywordflow">case</span> <a class="code" href="group___u_s_b___a_p_i.html#gga56bea25fbffdbda134044c49d40d5e40adb879552af43dda95b70261eaa810777">USB_STATUS_SUSPEND</a>:</div><div class="line">            <span class="keywordflow">case</span> <a class="code" href="group___u_s_b___a_p_i.html#gga56bea25fbffdbda134044c49d40d5e40ae9bcf94bdb90960ca692b1dfecb98e78">USB_STATUS_DETACH</a>:</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">            <span class="keywordflow">default</span>:</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">    }</div><div class="line">}                                      <span class="comment">/* End of function usb_main() */</span></div><div class="line"></div></div><!-- fragment --> <h2>USB Host Composite (CDC+MSC) Example</h2>
<p>This is Host composiete (CDC+MSC) example of minimal use of the USB in an application.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define RESET_VALUE               (0x00)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define EP_INFO                                                                                            \</span></div><div class="line"><span class="preprocessor">    &quot;\r\nThis example project demonstrates basic functionalities of USB Host Communication Device \r\n&quot;    \</span></div><div class="line"><span class="preprocessor">    &quot;Class (HCDC) driver on Renesas RA MCUs using 2 RA Boards. The Board 1(with USB HCDC Example  \r\n&quot;    \</span></div><div class="line"><span class="preprocessor">    &quot;running on it)communicates with Board2(with USB PCDC Example project running). Board 1 initiates\r\n&quot; \</span></div><div class="line"><span class="preprocessor">    &quot;the communication by sending commands to Board 2 and Board 2 responds by sending the data.\r\n&quot;       \</span></div><div class="line"><span class="preprocessor">    &quot;Board1 prints the received data on the RTTViewer.\r\n\n\n&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define HCDC_TSK_STACK_SIZE       1024</span></div><div class="line"><span class="preprocessor">#define HCDC_TSK_PRI              2</span></div><div class="line"><span class="preprocessor">#define BUF_SIZE                  512</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define KIT_INFO                  (&#39;1&#39;)</span></div><div class="line"><span class="preprocessor">#define NEXT_STEPS                (&#39;2&#39;)</span></div><div class="line"><span class="preprocessor">#define CARRIAGE_RETURN           (&#39;\r&#39;)</span></div><div class="line"><span class="preprocessor">#define SET_LINE_CODING           (USB_CDC_SET_LINE_CODING | USB_HOST_TO_DEV | USB_CLASS | USB_INTERFACE)</span></div><div class="line"><span class="preprocessor">#define GET_LINE_CODING           (USB_CDC_GET_LINE_CODING | USB_DEV_TO_HOST | USB_CLASS | USB_INTERFACE)</span></div><div class="line"><span class="preprocessor">#define SET_CONTROL_LINE_STATE    (USB_CDC_SET_CONTROL_LINE_STATE | USB_HOST_TO_DEV | USB_CLASS | USB_INTERFACE)</span></div><div class="line"><span class="preprocessor">#define LINE_CODING_LENGTH        (0x07U)</span></div><div class="line"><span class="preprocessor">#define VALUE_ZERO                (0x0000U)</span></div><div class="line"><span class="preprocessor">#define NO_WAIT_TIME              0</span></div><div class="line"><span class="preprocessor">#define CDC_READ_DATA_LEN         512</span></div><div class="line"><span class="preprocessor">#define CDC_WRITE_DATA_LEN        512</span></div><div class="line"><span class="preprocessor">#define ZERO_INDEX                0</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> usb_app_hcdc_task(<span class="keywordtype">void</span> * pvParameters);</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span>      usb_app_common_callback(usb_event_info_t * p_event_info, usb_hdl_t cur_task, <a class="code" href="group___u_s_b___a_p_i.html#ga647c9ea8cc8c82a26dcec32f7749c73d">usb_onoff_t</a> usb_state);</div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span>      usb_app_hcdc_callback(usb_event_info_t * p_event_info, usb_hdl_t cur_task, <a class="code" href="group___u_s_b___a_p_i.html#ga647c9ea8cc8c82a26dcec32f7749c73d">usb_onoff_t</a> usb_state);</div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span>      set_line_coding(<a class="code" href="group___u_s_b.html#gad5c104adfb44c721d9c664bf7fabddfb">usb_instance_ctrl_t</a> * p_ctrl, uint8_t device_address);</div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span>      set_control_line_state(<a class="code" href="group___u_s_b.html#gad5c104adfb44c721d9c664bf7fabddfb">usb_instance_ctrl_t</a> * p_ctrl, uint8_t device_address);</div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span>      get_line_coding(<a class="code" href="group___u_s_b.html#gad5c104adfb44c721d9c664bf7fabddfb">usb_instance_ctrl_t</a> * p_ctrl, uint8_t device_address);</div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span>      usb_data_process(usb_event_info_t * event_info);</div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span>      handle_error(<a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err, <span class="keywordtype">char</span> * err_str);</div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span>      process_usb_operation(uint8_t p_input_buffer);</div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span>      usb_write_operation(<span class="keywordtype">void</span>);</div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span>      usb_read_operation(<span class="keywordtype">void</span>);</div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span>      format_usb_device(<span class="keywordtype">void</span>);</div><div class="line"><span class="keyword">static</span> <span class="keywordtype">bool</span>      check_usb_connection(<span class="keywordtype">void</span>);</div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span>      usb_safely_eject(<span class="keywordtype">void</span>);</div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span>      update_buffer(<span class="keywordtype">void</span>);</div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span>      fat_clean_up(<span class="keywordtype">void</span>);</div><div class="line"><span class="keyword">static</span> <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> usb_init(<span class="keywordtype">void</span>);</div><div class="line"></div><div class="line"><span class="keyword">static</span> TaskHandle_t          g_app_hcdc_tsk_hdl;</div><div class="line"><span class="keyword">static</span> usb_callback_t      * g_usb_host_apl_callback[2];</div><div class="line"><span class="keyword">static</span> FF_Disk_t             my_disk;</div><div class="line"><span class="keyword">static</span> <a class="code" href="group___u_s_b___h_c_d_c___a_p_i.html#structusb__hcdc__linecoding__t">usb_hcdc_linecoding_t</a> g_serial_state;</div><div class="line"><span class="keyword">static</span> <a class="code" href="group___u_s_b___h_c_d_c___a_p_i.html#structusb__hcdc__linecoding__t">usb_hcdc_linecoding_t</a> g_com_parm;</div><div class="line"><span class="keyword">static</span> uint8_t               g_write_data[WRITE_ITEM_SIZE]             = {RESET_VALUE}; <span class="comment">/* Data(10k) to write to file */</span></div><div class="line"><span class="keyword">static</span> uint8_t               g_read_data[WRITE_ITEM_SIZE]              = {RESET_VALUE}; <span class="comment">/* Variable to store the data read from file */</span></div><div class="line"><span class="keyword">static</span> uint8_t               g_snd_buf[BUF_SIZE] BSP_ALIGN_VARIABLE(4) = {RESET_VALUE};</div><div class="line"><span class="keyword">static</span> uint8_t               g_rcv_buf[BUF_SIZE] BSP_ALIGN_VARIABLE(4) = {RESET_VALUE};</div><div class="line"><span class="keyword">static</span> uint8_t               g_usb_dummy = RESET_VALUE;                                 <span class="comment">/* dummy variable to send */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keywordtype">bool</span>         g_err_flag  = <span class="keyword">false</span>;                                       <span class="comment">/* error flag bit */</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">bool</span>          b_usb_hmsc_close    = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keywordtype">bool</span> g_rm_freertos_plus_fat_insertion_events = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="keyword">extern</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> new_thread0_entry (<span class="keywordtype">void</span> * pvParameters)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gaf0afcbc9a110ac9366a811d96ee06029">FSP_PARAMETER_NOT_USED</a>(pvParameters);</div><div class="line"></div><div class="line">    BaseType_t err_task = pdFALSE;</div><div class="line"></div><div class="line">    memset(&amp;my_disk, RESET_VALUE, <span class="keyword">sizeof</span>(my_disk));</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___c_o_m_m_o_n.html#unionfsp__pack__version__t">fsp_pack_version_t</a> version = {RESET_VALUE};</div><div class="line"></div><div class="line">    <span class="comment">/* version get API for FLEX pack information */</span></div><div class="line">    <a class="code" href="group___b_s_p___m_c_u.html#gaf3ee66233fc75acfcc21a97d7a767aa1">R_FSP_VersionGet</a>(&amp;version);</div><div class="line"></div><div class="line">    g_usb_host_apl_callback[0] = usb_app_hcdc_callback;           <span class="comment">// HCDC App Callback</span></div><div class="line">    g_usb_host_apl_callback[1] = g_basic0_cfg.p_usb_apl_callback; <span class="comment">// HMSC App Callback</span></div><div class="line">    <a class="code" href="group___u_s_b.html#ga2560b302dca363895820a82ea6a2ba9c">R_USB_Callback</a>(usb_app_common_callback);</div><div class="line"></div><div class="line">    <span class="comment">/* Example Project information printed on the Console */</span></div><div class="line">    APP_PRINT(BANNER_INFO,</div><div class="line">              EP_VERSION,</div><div class="line">              version.version_id_b.<a class="code" href="group___r_e_n_e_s_a_s___c_o_m_m_o_n.html#a85964fe9ef31d11bde39475763db564c">major</a>,</div><div class="line">              version.version_id_b.<a class="code" href="group___r_e_n_e_s_a_s___c_o_m_m_o_n.html#a00ab09fb1ebf2eb2ca08e364a3289e44">minor</a>,</div><div class="line">              version.version_id_b.<a class="code" href="group___r_e_n_e_s_a_s___c_o_m_m_o_n.html#ab2723e465037db8a30e2cb2e2392a98f">patch</a>);</div><div class="line">    APP_PRINT(EP_INFO);</div><div class="line"></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> freertos_fat_error = FSP_SUCCESS;</div><div class="line"></div><div class="line">    freertos_fat_error = usb_init();</div><div class="line">    <span class="keywordflow">if</span> (FSP_SUCCESS != freertos_fat_error)</div><div class="line">    {</div><div class="line">        APP_ERR_PRINT(<span class="stringliteral">&quot;\r\nError in initializing FreeRTOS+FAT with USB_HMSC\r\n&quot;</span>);</div><div class="line">        APP_ERR_TRAP(freertos_fat_error);</div><div class="line">    }</div><div class="line"></div><div class="line">    err_task = xTaskCreate((TaskFunction_t) usb_app_hcdc_task, </div><div class="line">                           <span class="stringliteral">&quot;HCDC_TSK&quot;</span>,                         </div><div class="line">                           HCDC_TSK_STACK_SIZE,                </div><div class="line">                           NULL,                               </div><div class="line">                           HCDC_TSK_PRI,                       </div><div class="line">                           &amp;g_app_hcdc_tsk_hdl);               </div><div class="line">    <span class="keywordflow">if</span> (pdPASS != err_task)</div><div class="line">    {</div><div class="line">        APP_ERR_PRINT(<span class="stringliteral">&quot;\r\nAppTask Create failed.\r\n&quot;</span>);</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Print USB HMSC menu */</span></div><div class="line">    APP_PRINT(USB_HMSC_MENU);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        <span class="keyword">static</span> uint8_t rtt_input_buf[BUFFER_SIZE_DOWN] = {RESET_VALUE};</div><div class="line">        <span class="keyword">static</span> uint8_t converted_rtt_input             = RESET_VALUE;</div><div class="line"></div><div class="line">        <span class="comment">/*Read RTT input from user*/</span></div><div class="line">        <span class="keywordflow">if</span> (APP_CHECK_DATA)</div><div class="line">        {</div><div class="line">            APP_READ(rtt_input_buf);</div><div class="line">            converted_rtt_input = (uint8_t) atoi((<span class="keywordtype">char</span> *) rtt_input_buf);</div><div class="line">            process_usb_operation(converted_rtt_input);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((<span class="keyword">false</span> == b_usb_hmsc_close) &amp;&amp; (<span class="keyword">false</span> == g_rm_freertos_plus_fat_insertion_events))</div><div class="line">        {</div><div class="line">            APP_PRINT(<span class="stringliteral">&quot;\r\n\n USB Device disconnected without Eject option.\r\n&quot;</span>);</div><div class="line">            APP_PRINT(<span class="stringliteral">&quot;\r\n Connect the USB and Execute Safely Eject option to make sure file operations works&quot;</span></div><div class="line">                      <span class="stringliteral">&quot;correctly\r\n&quot;</span>);</div><div class="line"></div><div class="line">            <span class="comment">/* Wait until USB Device is connected */</span></div><div class="line">            <span class="keywordflow">while</span> (<span class="keyword">true</span> != check_usb_connection())</div><div class="line">            {</div><div class="line">                ;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        vTaskDelay(1);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*******************************************************************************************************************</span></div><div class="line"><span class="comment"> * This function initiates the USB operation by calling respective functions.</span></div><div class="line"><span class="comment"> **********************************************************************************************************************/</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> process_usb_operation (uint8_t input_buffer)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> freertos_fat_error = FSP_SUCCESS;</div><div class="line">    <span class="keywordflow">switch</span> (input_buffer)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">case</span> USB_WRITE:</div><div class="line">        {</div><div class="line">            usb_write_operation();</div><div class="line">            usb_read_operation();</div><div class="line">            APP_PRINT(USB_HMSC_MENU);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> USB_FORMAT:</div><div class="line">        {</div><div class="line">            format_usb_device();</div><div class="line">            APP_PRINT(USB_HMSC_MENU);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> USB_SAFELY_EJECT:</div><div class="line">        {</div><div class="line">            usb_safely_eject();</div><div class="line">            APP_PRINT(USB_HMSC_MENU);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> USB_INIT:</div><div class="line">        {</div><div class="line">            <span class="keywordflow">if</span> (<span class="keyword">true</span> == b_usb_hmsc_close)</div><div class="line">            {</div><div class="line">                freertos_fat_error = usb_init();</div><div class="line">                <span class="keywordflow">if</span> (FSP_SUCCESS != freertos_fat_error)</div><div class="line">                {</div><div class="line">                    APP_ERR_PRINT(<span class="stringliteral">&quot;\r\nError in initializing FreeRTOS+FAT with USB_HMSC\r\n&quot;</span>);</div><div class="line">                    APP_ERR_TRAP(freertos_fat_error);</div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">            {</div><div class="line">                APP_PRINT(<span class="stringliteral">&quot;\r\n FreeRTOS+FAT USB_HMSC driver is already Initialized. Provide any other command\r\n&quot;</span>);</div><div class="line">            }</div><div class="line"></div><div class="line">            APP_PRINT(USB_HMSC_MENU);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">        {</div><div class="line">            APP_PRINT(<span class="stringliteral">&quot;\r\n Invalid input. Provide a valid input\r\n&quot;</span>);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*******************************************************************************************************************</span></div><div class="line"><span class="comment"> * This function performs USB HMSC write operation.</span></div><div class="line"><span class="comment"> ******************************************************************************************************************/</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> usb_write_operation (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    FF_FILE * file_pointer = NULL;</div><div class="line">    FF_Stat_t file_details;</div><div class="line">    int32_t   file_error = SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Capture the number of bytes written in the variable to check write status. */</span></div><div class="line">    <span class="keywordtype">size_t</span> bytes_written = RESET_VALUE;</div><div class="line"></div><div class="line">    memset(&amp;file_details, RESET_VALUE, <span class="keyword">sizeof</span>(file_details));</div><div class="line"></div><div class="line">    <span class="comment">/* Double check the connection again to ensure the USB device is still mounted */</span></div><div class="line">    <span class="keywordflow">if</span> ((<span class="keyword">true</span> == check_usb_connection()) &amp;&amp; (<span class="keyword">true</span> != b_usb_hmsc_close))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Once connection is detected open file is write mode */</span></div><div class="line">        file_pointer = ff_fopen((<span class="keyword">const</span> <span class="keywordtype">char</span> *) FILE_NAME, WRITE_MODE);</div><div class="line">        <span class="keywordflow">if</span> (NULL != file_pointer)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Fill write buffer with data */</span></div><div class="line">            update_buffer();</div><div class="line"></div><div class="line">            APP_PRINT(<span class="stringliteral">&quot;   USB write operation will be initiated.\n&quot;</span>);</div><div class="line"></div><div class="line">            <span class="comment">/* Write API writes  */</span></div><div class="line">            bytes_written = ff_fwrite(g_write_data, <span class="keyword">sizeof</span>(g_write_data[RESET_VALUE]), WRITE_ITEM_SIZE, file_pointer);</div><div class="line">            <span class="keywordflow">if</span> (WRITE_ITEM_SIZE != bytes_written)</div><div class="line">            {</div><div class="line">                APP_ERR_PRINT(<span class="stringliteral">&quot; ff_write API failed. Closing opened file.\r\n&quot;</span>);</div><div class="line"></div><div class="line">                <span class="comment">/* Adding extra %d as parses string and prints %d as-is. */</span></div><div class="line">                APP_PRINT(<span class="stringliteral">&quot; %d\r\n&quot;</span>, stdioGET_ERRNO());</div><div class="line">                file_error = ff_fclose(file_pointer);</div><div class="line">                <span class="keywordflow">if</span> (SUCCESS != file_error)</div><div class="line">                {</div><div class="line">                    APP_ERR_PRINT(<span class="stringliteral">&quot;ff_fclose API failed&quot;</span>);</div><div class="line"></div><div class="line">                    <span class="comment">/* Adding extra %d as parses string and prints %d as-is. */</span></div><div class="line">                    APP_PRINT(<span class="stringliteral">&quot; %d\r\n&quot;</span>, stdioGET_ERRNO());</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="keywordflow">return</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">/* Close the file after write operation and open again in read mode */</span></div><div class="line">            file_error = ff_fclose(file_pointer);</div><div class="line">            <span class="keywordflow">if</span> (SUCCESS != file_error)</div><div class="line">            {</div><div class="line">                APP_ERR_PRINT(<span class="stringliteral">&quot;ff_fclose API failed&quot;</span>);</div><div class="line"></div><div class="line">                <span class="comment">/* Adding extra %d as parses string and prints %d as-is. */</span></div><div class="line">                APP_PRINT(<span class="stringliteral">&quot; %d\r\n&quot;</span>, stdioGET_ERRNO());</div><div class="line"></div><div class="line">                <span class="keywordflow">return</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            file_error = ff_stat((<span class="keyword">const</span> <span class="keywordtype">char</span> *) FILE_NAME, &amp;file_details);</div><div class="line"></div><div class="line">            <span class="comment">/* ff_stat returns 0 on success and -1 on error */</span></div><div class="line">            <span class="keywordflow">if</span> (SUCCESS == file_error)</div><div class="line">            {</div><div class="line">                <span class="comment">/* Compare the actual bytes written and file size after write operation */</span></div><div class="line">                <span class="keywordflow">if</span> (bytes_written == file_details.st_size)</div><div class="line">                {</div><div class="line">                    APP_PRINT(<span class="stringliteral">&quot;   %d bytes Data successfully written to file  %s \n&quot;</span>, bytes_written, FILE_NAME);</div><div class="line">                    APP_PRINT(<span class="stringliteral">&quot;   Write operation is Successful \n&quot;</span>);</div><div class="line">                }</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                {</div><div class="line">                    APP_ERR_PRINT(<span class="stringliteral">&quot;ff_write API failed &quot;</span>);</div><div class="line"></div><div class="line">                    <span class="comment">/* Adding extra %d as parses string and prints %d as-is. */</span></div><div class="line">                    APP_PRINT(<span class="stringliteral">&quot; %d\r\n&quot;</span>, stdioGET_ERRNO());</div><div class="line"></div><div class="line">                    <span class="keywordflow">return</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">            {</div><div class="line">                APP_ERR_PRINT(<span class="stringliteral">&quot;ff_stat API failed&quot;</span>);</div><div class="line"></div><div class="line">                <span class="comment">/* Adding extra %d as parses string and prints %d as-is. */</span></div><div class="line">                APP_PRINT(<span class="stringliteral">&quot; %d\r\n&quot;</span>, stdioGET_ERRNO());</div><div class="line"></div><div class="line">                <span class="keywordflow">return</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            APP_ERR_PRINT(<span class="stringliteral">&quot;ff_fopen API failed&quot;</span>);</div><div class="line"></div><div class="line">            <span class="comment">/* Adding extra %d as parses string and prints %d as-is. */</span></div><div class="line">            APP_PRINT(<span class="stringliteral">&quot; %d\r\n&quot;</span>, stdioGET_ERRNO());</div><div class="line"></div><div class="line">            <span class="keywordflow">return</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        APP_PRINT(<span class="stringliteral">&quot;USB Device disconnected or not initialized after Eject command\n&quot;</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*******************************************************************************************************************</span></div><div class="line"><span class="comment"> * This function performs USB HMSC read operation.</span></div><div class="line"><span class="comment"> *******************************************************************************************************************/</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> usb_read_operation (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    FF_FILE * file_pointer = NULL;</div><div class="line">    FF_Stat_t file_details;</div><div class="line">    int32_t   file_error = SUCCESS;</div><div class="line"></div><div class="line">    memset(&amp;file_details, RESET_VALUE, <span class="keyword">sizeof</span>(file_details));</div><div class="line"></div><div class="line">    <span class="comment">/* Double check the connection again to ensure the USB device is still mounted */</span></div><div class="line">    <span class="keywordflow">if</span> ((<span class="keyword">true</span> == check_usb_connection()) &amp;&amp; (<span class="keyword">true</span> != b_usb_hmsc_close))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Open the file read mode to read data written previously */</span></div><div class="line">        file_pointer = ff_fopen((<span class="keyword">const</span> <span class="keywordtype">char</span> *) FILE_NAME, READ_MODE);</div><div class="line">        <span class="keywordflow">if</span> (file_pointer != NULL)</div><div class="line">        {</div><div class="line">            APP_PRINT(<span class="stringliteral">&quot;   USB read operation will be initiated.\n&quot;</span>);</div><div class="line"></div><div class="line">            <span class="comment">/* Capture the number of bytes read in the variable to check read status. */</span></div><div class="line">            <span class="keywordtype">size_t</span> bytes_read = RESET_VALUE;</div><div class="line">            bytes_read = ff_fread(g_read_data, <span class="keyword">sizeof</span>(g_read_data[RESET_VALUE]), WRITE_ITEM_SIZE, file_pointer);</div><div class="line">            <span class="keywordflow">if</span> (READ_WRITE_FAILURE == bytes_read)</div><div class="line">            {</div><div class="line">                APP_ERR_PRINT(<span class="stringliteral">&quot; ff_read API failed. Closing opened file \r\n&quot;</span>, stdioGET_ERRNO());</div><div class="line">                file_error = ff_fclose(file_pointer);</div><div class="line">                <span class="keywordflow">if</span> (SUCCESS != file_error)</div><div class="line">                {</div><div class="line">                    APP_ERR_PRINT(<span class="stringliteral">&quot;ff_fclose API failed&quot;</span>);</div><div class="line"></div><div class="line">                    <span class="comment">/* Adding extra %d as parses string and prints %d as-is. */</span></div><div class="line">                    APP_PRINT(<span class="stringliteral">&quot; %d\r\n&quot;</span>, stdioGET_ERRNO());</div><div class="line"></div><div class="line">                    <span class="keywordflow">return</span>;</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="keywordflow">return</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            file_error = ff_fclose(file_pointer);</div><div class="line">            <span class="keywordflow">if</span> (SUCCESS != file_error)</div><div class="line">            {</div><div class="line">                APP_ERR_PRINT(<span class="stringliteral">&quot;ff_fclose API failed&quot;</span>);</div><div class="line"></div><div class="line">                <span class="comment">/* Adding extra %d as parses string and prints %d as-is. */</span></div><div class="line">                APP_PRINT(<span class="stringliteral">&quot; %d\r\n&quot;</span>, stdioGET_ERRNO());</div><div class="line"></div><div class="line">                <span class="keywordflow">return</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            file_error = ff_stat((<span class="keyword">const</span> <span class="keywordtype">char</span> *) FILE_NAME, &amp;file_details);</div><div class="line"></div><div class="line">            <span class="comment">/* ff_stat returns 0 on success and -1 on error */</span></div><div class="line">            <span class="keywordflow">if</span> (SUCCESS == file_error)</div><div class="line">            {</div><div class="line">                <span class="comment">/* Compare the actual bytes written and file size after write operation */</span></div><div class="line">                <span class="keywordflow">if</span> (bytes_read == file_details.st_size)</div><div class="line">                {</div><div class="line">                    APP_PRINT(<span class="stringliteral">&quot;   %d bytes Data successfully read from file  %s \n&quot;</span>, bytes_read, FILE_NAME);</div><div class="line">                    APP_PRINT(<span class="stringliteral">&quot;   Read operation is Successful \n&quot;</span>);</div><div class="line">                }</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                {</div><div class="line">                    APP_ERR_PRINT(<span class="stringliteral">&quot;ff_write API failed &quot;</span>);</div><div class="line"></div><div class="line">                    <span class="comment">/* Adding extra %d as parses string and prints %d as-is. */</span></div><div class="line">                    APP_PRINT(<span class="stringliteral">&quot; %d\r\n&quot;</span>, stdioGET_ERRNO());</div><div class="line"></div><div class="line">                    <span class="keywordflow">return</span>;</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="comment">/* Compare Write and Read data. */</span></div><div class="line">                <span class="keywordflow">if</span> (SUCCESS == memcmp(g_write_data, g_read_data, WRITE_ITEM_SIZE))</div><div class="line">                {</div><div class="line">                    APP_PRINT(<span class="stringliteral">&quot;\r\nWrite and Read data is same\r\n&quot;</span>);</div><div class="line">                }</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                {</div><div class="line">                    APP_ERR_PRINT(<span class="stringliteral">&quot;\r\nWrite and Read data did not match\r\n&quot;</span>);</div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">            {</div><div class="line">                APP_ERR_PRINT(<span class="stringliteral">&quot;ff_stat API failed&quot;</span>);</div><div class="line"></div><div class="line">                <span class="comment">/* Adding extra %d as parses string and prints %d as-is. */</span></div><div class="line">                APP_PRINT(<span class="stringliteral">&quot; %d\r\n&quot;</span>, stdioGET_ERRNO());</div><div class="line"></div><div class="line">                <span class="keywordflow">return</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            APP_ERR_PRINT(<span class="stringliteral">&quot;ff_fopen API failed&quot;</span>);</div><div class="line"></div><div class="line">            <span class="comment">/* Adding extra %d as parses string and prints %d as-is. */</span></div><div class="line">            APP_PRINT(<span class="stringliteral">&quot; %d\r\n&quot;</span>, stdioGET_ERRNO());</div><div class="line"></div><div class="line">            <span class="keywordflow">return</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        APP_PRINT(<span class="stringliteral">&quot;USB Device disconnected or not initialized after Eject command\n&quot;</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*******************************************************************************************************************</span></div><div class="line"><span class="comment"> * This function performs USB HMSC format operation.</span></div><div class="line"><span class="comment"> ******************************************************************************************************************/</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> format_usb_device (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> ((<span class="keyword">true</span> == check_usb_connection()) &amp;&amp; (<span class="keyword">true</span> != b_usb_hmsc_close))</div><div class="line">    {</div><div class="line">        APP_PRINT(<span class="stringliteral">&quot;\r\n USB Device Formatting will be initiated. Formatting will take time &quot;</span></div><div class="line">                  <span class="stringliteral">&quot;depending on USB Device capacity.\r\n&quot;</span>);</div><div class="line">        APP_PRINT(<span class="stringliteral">&quot; Do not disconnect the USB device while formatting is in progress.   Please Wait ...\r\n&quot;</span>);</div><div class="line"></div><div class="line">        <span class="comment">/* Formatting time varies with USB Device capacity. Might take longer time for higher capacity USB Device */</span></div><div class="line">        FF_Error_t ff_error = FF_Format(&amp;my_disk, my_disk.xStatus.bPartitionNumber, pdFALSE, pdFALSE);</div><div class="line">        <span class="keywordflow">if</span> (FF_ERR_NONE != ff_error)</div><div class="line">        {</div><div class="line">            APP_ERR_PRINT(<span class="stringliteral">&quot;\r\n FF_Format API failed  %d. Check the USB Device.\r\n&quot;</span>, FF_GetErrMessage(ff_error));</div><div class="line">            APP_PRINT(<span class="stringliteral">&quot; %d\r\n&quot;</span>, FF_GetErrMessage(ff_error));</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            APP_PRINT(<span class="stringliteral">&quot;\r\nUSB Device Formatted successfully \r\n&quot;</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        APP_PRINT(<span class="stringliteral">&quot;USB Device disconnected or not initialized after Eject command\n&quot;</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*******************************************************************************************************************</span></div><div class="line"><span class="comment"> * This function closes USB HMSC on FreeRTOS+FAT and safely ejects.</span></div><div class="line"><span class="comment"> ******************************************************************************************************************/</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> usb_safely_eject (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Check the USB Device Connection before formating */</span></div><div class="line">    <span class="keywordflow">if</span> ((<span class="keyword">true</span> == check_usb_connection()) &amp;&amp; (<span class="keyword">true</span> != b_usb_hmsc_close))</div><div class="line">    {</div><div class="line">        <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> freertos_fat_error = <a class="code" href="group___r_m___f_r_e_e_r_t_o_s___p_l_u_s___f_a_t.html#gabd2d76912b7540217a3f8ec17c89457a">RM_FREERTOS_PLUS_FAT_DiskDeinit</a>(&amp;g_rm_freertos_plus_fat0_ctrl, &amp;my_disk);</div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS != freertos_fat_error)</div><div class="line">        {</div><div class="line">            APP_ERR_PRINT(<span class="stringliteral">&quot;\r\nFREERTOS PLUS FAT DiskDeinit API failed\r\n&quot;</span>);</div><div class="line">            APP_ERR_TRAP(freertos_fat_error);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Close the FREERTOS_PLUS_FAT_Close instance on safely ejecting */</span></div><div class="line">        freertos_fat_error = <a class="code" href="group___r_m___f_r_e_e_r_t_o_s___p_l_u_s___f_a_t.html#ga61918aa8d20ab8423b92601dc2cfb25d">RM_FREERTOS_PLUS_FAT_Close</a>(&amp;g_rm_freertos_plus_fat0_ctrl);</div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS != freertos_fat_error)</div><div class="line">        {</div><div class="line">            APP_ERR_PRINT(<span class="stringliteral">&quot;\r\nFREERTOS PLUS FAT CLOSE API failed\r\n&quot;</span>);</div><div class="line">            APP_ERR_TRAP(freertos_fat_error);</div><div class="line">        }</div><div class="line"></div><div class="line">        APP_PRINT(<span class="stringliteral">&quot;\r\nUSB Device can be safely removed now\r\n&quot;</span>);</div><div class="line"></div><div class="line">        <span class="comment">/* Update the flag */</span></div><div class="line">        b_usb_hmsc_close = <span class="keyword">true</span>;</div><div class="line">        g_rm_freertos_plus_fat_insertion_events = <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* USB Device disconnected */</span></div><div class="line">        APP_PRINT(<span class="stringliteral">&quot;USB Device disconnected or not initialized after Eject command\n&quot;</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*******************************************************************************************************************</span></div><div class="line"><span class="comment"> * This function checks the USB HMSC connection status.</span></div><div class="line"><span class="comment"> ******************************************************************************************************************/</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">bool</span> check_usb_connection (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (<span class="keyword">true</span> != g_rm_freertos_plus_fat_insertion_events)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        APP_PRINT(<span class="stringliteral">&quot;\r\n USB Device is connected\r\n&quot;</span>);</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*******************************************************************************************************************</span></div><div class="line"><span class="comment"> * This function updates write buffer with data and clears read buffer.</span></div><div class="line"><span class="comment"> ******************************************************************************************************************/</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> update_buffer (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span> (uint16_t i = RESET_VALUE; i &lt; WRITE_ITEM_SIZE; i++)</div><div class="line">    {</div><div class="line">        g_write_data[i] = ASCII_CHAR_A;</div><div class="line">        g_read_data[i]  = RESET_VALUE;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*******************************************************************************************************************</span></div><div class="line"><span class="comment"> * This function is callback for FreeRTOS+FAT and triggered when USB Pen drive is removed or inserted.</span></div><div class="line"><span class="comment"> ******************************************************************************************************************/</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> free_rtos_fat_callback (<a class="code" href="group___r_m___f_r_e_e_r_t_o_s___p_l_u_s___f_a_t___a_p_i.html#structrm__freertos__plus__fat__callback__args__t">rm_freertos_plus_fat_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (p_args-&gt;<a class="code" href="group___r_m___f_r_e_e_r_t_o_s___p_l_u_s___f_a_t___a_p_i.html#a48d8fdc4c2478bc8a9c9c4fbafa09229">event</a> &amp; <a class="code" href="group___r_m___f_r_e_e_r_t_o_s___p_l_u_s___f_a_t___a_p_i.html#ggab7684e811b3d1074ec0fde335c021900a6525a46d3ba3ad13d893861a54c0a9fd">RM_FREERTOS_PLUS_FAT_EVENT_MEDIA_INSERTED</a>)</div><div class="line">    {</div><div class="line">        g_rm_freertos_plus_fat_insertion_events = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (p_args-&gt;<a class="code" href="group___r_m___f_r_e_e_r_t_o_s___p_l_u_s___f_a_t___a_p_i.html#a48d8fdc4c2478bc8a9c9c4fbafa09229">event</a> &amp; <a class="code" href="group___r_m___f_r_e_e_r_t_o_s___p_l_u_s___f_a_t___a_p_i.html#ggab7684e811b3d1074ec0fde335c021900abb0902851973dc77e7b2d2355d082832">RM_FREERTOS_PLUS_FAT_EVENT_MEDIA_REMOVED</a>)</div><div class="line">    {</div><div class="line">        g_rm_freertos_plus_fat_insertion_events = <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*******************************************************************************************************************</span></div><div class="line"><span class="comment"> * This function Initializes the FreeRTOS+FAT instance..</span></div><div class="line"><span class="comment"> *******************************************************************************************************************/</span></div><div class="line"><span class="keyword">static</span> <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> usb_init (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> freertos_fat_error = FSP_SUCCESS;</div><div class="line">    int32_t   file_error         = SUCCESS;</div><div class="line">    <a class="code" href="group___r_m___f_r_e_e_r_t_o_s___p_l_u_s___f_a_t___a_p_i.html#structrm__freertos__plus__fat__device__t">rm_freertos_plus_fat_device_t</a> device;</div><div class="line"></div><div class="line">    memset(&amp;device, RESET_VALUE, <span class="keyword">sizeof</span>(device));</div><div class="line"></div><div class="line">    <span class="comment">/* Open FreeRTOS PLUS FAT  */</span></div><div class="line">    freertos_fat_error = <a class="code" href="group___r_m___f_r_e_e_r_t_o_s___p_l_u_s___f_a_t.html#ga43e981ad23366dcef897017dae2ade1d">RM_FREERTOS_PLUS_FAT_Open</a>(&amp;g_rm_freertos_plus_fat0_ctrl, &amp;g_rm_freertos_plus_fat0_cfg);</div><div class="line">    <span class="keywordflow">if</span> (FSP_SUCCESS != freertos_fat_error)</div><div class="line">    {</div><div class="line">        APP_ERR_PRINT(<span class="stringliteral">&quot;\r\nFREERTOS PLUS FAT OPEN API failed\r\n&quot;</span>);</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> freertos_fat_error;</div><div class="line">    }</div><div class="line"></div><div class="line">    APP_PRINT(<span class="stringliteral">&quot;\r\n\nFreeRTOS+FAT Open successful\r\n&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for USB Device connection  */</span></div><div class="line">    APP_PRINT(<span class="stringliteral">&quot; Connect USB Device...\r\n&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait until USB Device is connected */</span></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span> != check_usb_connection())</div><div class="line">    {</div><div class="line">        ;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the mass storage device.  This should not be done until the device is plugged in and initialized. */</span></div><div class="line">    freertos_fat_error = <a class="code" href="group___r_m___f_r_e_e_r_t_o_s___p_l_u_s___f_a_t.html#ga0b57cc55832b6dce144b866a28e2d9bd">RM_FREERTOS_PLUS_FAT_MediaInit</a>(&amp;g_rm_freertos_plus_fat0_ctrl, &amp;device);</div><div class="line">    <span class="keywordflow">if</span> (FSP_SUCCESS != freertos_fat_error)</div><div class="line">    {</div><div class="line">        APP_ERR_PRINT(<span class="stringliteral">&quot;\r\nFreeRTOS Plus FAT Media Init API failed\r\n&quot;</span>);</div><div class="line">        fat_clean_up();</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> freertos_fat_error;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize one disk for each partition used in the application. */</span></div><div class="line">    freertos_fat_error = <a class="code" href="group___r_m___f_r_e_e_r_t_o_s___p_l_u_s___f_a_t.html#ga66282bce19e633b37185e1e3c48fe576">RM_FREERTOS_PLUS_FAT_DiskInit</a>(&amp;g_rm_freertos_plus_fat0_ctrl,</div><div class="line">                                                       &amp;g_rm_freertos_plus_fat0_disk_cfg,</div><div class="line">                                                       &amp;my_disk);</div><div class="line">    <span class="keywordflow">if</span> (FSP_SUCCESS != freertos_fat_error)</div><div class="line">    {</div><div class="line">        APP_ERR_PRINT(<span class="stringliteral">&quot;\r\nFreeRTOS Plus FAT Disk Init API failed\r\n&quot;</span>);</div><div class="line">        fat_clean_up();</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> freertos_fat_error;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Mount each disk.  This assumes the disk is already partitioned and formatted. */</span></div><div class="line">    FF_Error_t ff_err = FF_Mount(&amp;my_disk, my_disk.xStatus.bPartitionNumber);</div><div class="line">    <span class="keywordflow">if</span> (FSP_SUCCESS != ff_err)</div><div class="line">    {</div><div class="line">        APP_ERR_PRINT(<span class="stringliteral">&quot;\r\nFF_Mount API failed\r\n&quot;</span>);</div><div class="line"></div><div class="line">        <span class="comment">/* Close the FREERTOS_PLUS_FAT_Close instance on safely ejecting */</span></div><div class="line">        fat_clean_up();</div><div class="line"></div><div class="line">        <span class="comment">/* As function returns fsp_err_t, ff_err cannot be returned. Hence trapping the error here */</span></div><div class="line">        APP_ERR_TRAP(ff_err);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Add the disk to the file system. */</span></div><div class="line">    file_error = FF_FS_Add(<span class="stringliteral">&quot;/&quot;</span>, &amp;my_disk);</div><div class="line">    <span class="keywordflow">if</span> (SUCCESS == file_error)</div><div class="line">    {</div><div class="line">        APP_ERR_PRINT(<span class="stringliteral">&quot;\r\nFF_Mount API failed\r\n&quot;</span>);</div><div class="line"></div><div class="line">        <span class="comment">/* Close the FREERTOS_PLUS_FAT_Close instance on safely ejecting */</span></div><div class="line">        fat_clean_up();</div><div class="line"></div><div class="line">        <span class="comment">/* As function returns fsp_err_t, ff_err cannot be returned. Hence trapping the error here */</span></div><div class="line">        APP_ERR_TRAP(file_error);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Set this flag to let application know that USB is initialized */</span></div><div class="line">    b_usb_hmsc_close = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> freertos_fat_error;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*******************************************************************************************************************</span></div><div class="line"><span class="comment"> * This function closes the FreeRTOS+FAT instance..</span></div><div class="line"><span class="comment"> *******************************************************************************************************************/</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> fat_clean_up (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> freertos_fat_error = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Close the FREERTOS_PLUS_FAT_Close instance on any failure */</span></div><div class="line">    freertos_fat_error = <a class="code" href="group___r_m___f_r_e_e_r_t_o_s___p_l_u_s___f_a_t.html#ga61918aa8d20ab8423b92601dc2cfb25d">RM_FREERTOS_PLUS_FAT_Close</a>(&amp;g_rm_freertos_plus_fat0_ctrl);</div><div class="line">    <span class="keywordflow">if</span> (FSP_SUCCESS != freertos_fat_error)</div><div class="line">    {</div><div class="line">        APP_PRINT(<span class="stringliteral">&quot;\r\nFREERTOS PLUS FAT CLOSE API failed\r\n&quot;</span>);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        APP_PRINT(<span class="stringliteral">&quot;\r\nFREERTOS PLUS FAT instance Closed successfully.\r\n&quot;</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/******************************************************************************</span></div><div class="line"><span class="comment"> * Event notification thread for Interrupt IN/OUT test.</span></div><div class="line"><span class="comment"> ******************************************************************************/</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> usb_app_hcdc_task (<span class="keywordtype">void</span> * pvParameters)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>                 err        = FSP_SUCCESS;</div><div class="line">    <span class="keyword">static</span> usb_event_info_t * event_info = NULL;</div><div class="line">    BaseType_t                err_queue  = pdFALSE;</div><div class="line">    memset(&amp;g_serial_state, RESET_VALUE, <span class="keyword">sizeof</span>(g_serial_state));</div><div class="line">    memset(&amp;g_com_parm, RESET_VALUE, <span class="keyword">sizeof</span>(g_com_parm));</div><div class="line">    g_snd_buf[ZERO_INDEX] = KIT_INFO;</div><div class="line"></div><div class="line">    uint32_t i;</div><div class="line"></div><div class="line">    <span class="comment">/*Fill the write buffer*/</span></div><div class="line">    <span class="keywordflow">for</span> (i = RESET_VALUE; i &lt; CDC_WRITE_DATA_LEN; i++)</div><div class="line">    {</div><div class="line">        g_snd_buf[i] = (uint8_t) i;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Handle error if queue send fails*/</span></div><div class="line">        <span class="keywordflow">if</span> (<span class="keyword">true</span> == g_err_flag)</div><div class="line">        {</div><div class="line">            handle_error(g_err_flag, <span class="stringliteral">&quot;Error in sending usb event through queue&quot;</span>);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Receive message from queue and analyzing the received message*/</span></div><div class="line">        err_queue = xQueueReceive(g_usb_queue, &amp;event_info, (portMAX_DELAY));</div><div class="line"></div><div class="line">        <span class="comment">/* Handle error */</span></div><div class="line">        <span class="keywordflow">if</span> (pdTRUE != err_queue)</div><div class="line">        {</div><div class="line">            handle_error(err_queue, <span class="stringliteral">&quot;Error in receiving USB event message through queue&quot;</span>);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">switch</span> (event_info-&gt;event)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">case</span> <a class="code" href="group___u_s_b___a_p_i.html#gga56bea25fbffdbda134044c49d40d5e40ab5c3bd23fe62533150eef3a4e8c8d13c">USB_STATUS_CONFIGURED</a>:</div><div class="line">            {</div><div class="line">                vTaskDelay(200);       <span class="comment">// GR_debug</span></div><div class="line"></div><div class="line">                <span class="comment">/* CDC Class request &quot;SetLineCoding&quot; */</span></div><div class="line">                set_line_coding(&amp;g_basic0_ctrl, event_info-&gt;device_address);</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keywordflow">case</span> <a class="code" href="group___u_s_b___a_p_i.html#gga56bea25fbffdbda134044c49d40d5e40a63dd4552584256ef9d1a0d5da2159e9c">USB_STATUS_READ_COMPLETE</a>:</div><div class="line">            {</div><div class="line">                <span class="keywordflow">if</span> ((FSP_SUCCESS == event_info.status) || (FSP_ERR_USB_SIZE_SHORT == event_info.status))</div><div class="line">                {</div><div class="line">                    <span class="comment">/* CDC class communication data process */</span></div><div class="line">                    usb_data_process(event_info);</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keywordflow">case</span> <a class="code" href="group___u_s_b___a_p_i.html#gga56bea25fbffdbda134044c49d40d5e40ad44448290b4f36868a09b48e4588b29d">USB_STATUS_WRITE_COMPLETE</a>:</div><div class="line">            {</div><div class="line">                <span class="keywordflow">if</span> (FSP_SUCCESS == event_info.status)</div><div class="line">                {</div><div class="line">                    <span class="comment">/* Report receive start */</span></div><div class="line">                    err = <a class="code" href="group___u_s_b.html#ga42ad1cbad598d06023d83e8a91fd49d4">R_USB_Read</a>(&amp;g_basic0_ctrl, g_rcv_buf, CDC_READ_DATA_LEN, event_info-&gt;device_address);</div><div class="line"></div><div class="line">                    <span class="comment">/* Handle Error */</span></div><div class="line">                    <span class="keywordflow">if</span> (FSP_SUCCESS != err)</div><div class="line">                    {</div><div class="line">                        handle_error(err, <span class="stringliteral">&quot;**R_USB_Read API FAILED**&quot;</span>);</div><div class="line">                    }</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keywordflow">case</span> <a class="code" href="group___u_s_b___a_p_i.html#gga56bea25fbffdbda134044c49d40d5e40a24e9ad4653245663e5e89bda173141fd">USB_STATUS_REQUEST_COMPLETE</a>:</div><div class="line">            {</div><div class="line">                <span class="comment">/* Check Complete request &quot;SetLineCoding&quot; */</span></div><div class="line">                <span class="keywordflow">if</span> (USB_CDC_SET_LINE_CODING == (event_info-&gt;setup.request_type &amp; <a class="code" href="group___u_s_b___a_p_i.html#ga3a6743f3e336fc05e70e59b05206f634">USB_BREQUEST</a>))</div><div class="line">                {</div><div class="line">                    <span class="comment">/* Class notification &quot;SerialState&quot; receive start */</span></div><div class="line">                    set_control_line_state(&amp;g_basic0_ctrl, event_info-&gt;device_address);</div><div class="line">                }</div><div class="line">                <span class="comment">/* Check Complete request &quot;SetControlLineState&quot; */</span></div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (USB_CDC_SET_CONTROL_LINE_STATE == (event_info-&gt;setup.request_type &amp; <a class="code" href="group___u_s_b___a_p_i.html#ga3a6743f3e336fc05e70e59b05206f634">USB_BREQUEST</a>))</div><div class="line">                {</div><div class="line">                    <span class="comment">/* CDC Class request &quot;SetLineCoding&quot; */</span></div><div class="line">                    get_line_coding(&amp;g_basic0_ctrl, event_info-&gt;device_address);</div><div class="line">                }</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (USB_CDC_GET_LINE_CODING == (event_info-&gt;setup.request_type &amp; <a class="code" href="group___u_s_b___a_p_i.html#ga3a6743f3e336fc05e70e59b05206f634">USB_BREQUEST</a>))</div><div class="line">                {</div><div class="line">                    err = <a class="code" href="group___u_s_b.html#ga001f40866be6438435e65e78871a54d5">R_USB_Write</a>(&amp;g_basic0_ctrl, g_snd_buf, CDC_WRITE_DATA_LEN, event_info-&gt;device_address);</div><div class="line">                    <span class="keywordflow">if</span> (FSP_SUCCESS != err)</div><div class="line">                    {</div><div class="line">                        handle_error(err, <span class="stringliteral">&quot;**R_USB_Write API FAILED**&quot;</span>);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                {</div><div class="line">                    <span class="comment">/* Not support request */</span></div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keywordflow">default</span>:</div><div class="line">            {</div><div class="line">                <span class="comment">/* No operation to do*/</span></div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        vTaskDelay(200);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*******************************************************************************************************************</span></div><div class="line"><span class="comment"> * In this function initializes to set control line state information for host control transfer.</span></div><div class="line"><span class="comment"> ******************************************************************************************************************/</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> set_control_line_state (<a class="code" href="group___u_s_b.html#gad5c104adfb44c721d9c664bf7fabddfb">usb_instance_ctrl_t</a> * p_ctrl, uint8_t device_address)</div><div class="line">{</div><div class="line">    usb_setup_t setup;</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>   err = FSP_SUCCESS;</div><div class="line">    setup.request_type   = SET_CONTROL_LINE_STATE; <span class="comment">/* bRequestCode:SET_CONTROL_LINE_STATE, bmRequestType */</span></div><div class="line">    setup.request_value  = VALUE_ZERO;             <span class="comment">/* wValue:Zero */</span></div><div class="line">    setup.request_index  = VALUE_ZERO;             <span class="comment">/* wIndex:Interface */</span></div><div class="line">    setup.request_length = VALUE_ZERO;             <span class="comment">/* wLength:Zero */</span></div><div class="line"></div><div class="line">    err = <a class="code" href="group___u_s_b.html#gaecba62e40820ec837fa0b285140ed13b">R_USB_HostControlTransfer</a>(p_ctrl, &amp;setup, &amp;g_usb_dummy, device_address);</div><div class="line">    <span class="keywordflow">if</span> (FSP_SUCCESS != err)</div><div class="line">    {</div><div class="line">        handle_error(err, <span class="stringliteral">&quot;**R_USB_HOSTControlTransfer API FAILED**&quot;</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*******************************************************************************************************************</span></div><div class="line"><span class="comment"> * In this function initializes to set line coding information for host control transfer.</span></div><div class="line"><span class="comment"> ******************************************************************************************************************/</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> set_line_coding (<a class="code" href="group___u_s_b.html#gad5c104adfb44c721d9c664bf7fabddfb">usb_instance_ctrl_t</a> * p_ctrl, uint8_t device_address)</div><div class="line">{</div><div class="line">    usb_setup_t setup;</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>   err = FSP_SUCCESS;</div><div class="line">    g_com_parm.<a class="code" href="group___u_s_b___h_c_d_c___a_p_i.html#a922969443adf769f8b1fc25adc685c55">dwdte_rate</a>   = (uint32_t) USB_HCDC_SPEED_9600;</div><div class="line">    g_com_parm.<a class="code" href="group___u_s_b___h_c_d_c___a_p_i.html#afb91b547c4b5102bccc5edeee167d058">bdata_bits</a>   = <a class="code" href="group___u_s_b___h_c_d_c___a_p_i.html#ggab219f0f6daf3dfd72efea91ecb9136b3ac769dd73d437e7f4e178853f7d648c78">USB_HCDC_DATA_BIT_8</a>;</div><div class="line">    g_com_parm.<a class="code" href="group___u_s_b___h_c_d_c___a_p_i.html#af10bc623fb14294fd7f677d43edb4a0c">bchar_format</a> = <a class="code" href="group___u_s_b___h_c_d_c___a_p_i.html#gga8a99f2bb7e53f371b7f92457e20cfe54a79f1f58706b4d5165af0b6a4dc8b5037">USB_HCDC_STOP_BIT_1</a>;</div><div class="line">    g_com_parm.<a class="code" href="group___u_s_b___h_c_d_c___a_p_i.html#ad4395313625a820362ed1c03feb71dc4">bparity_type</a> = <a class="code" href="group___u_s_b___h_c_d_c___a_p_i.html#gga018a04577fdc4d43125c12f84785f548aa213c9d2aebbf6ae4ceb413a19a96486">USB_HCDC_PARITY_BIT_NONE</a>;</div><div class="line"></div><div class="line">    setup.request_type   = SET_LINE_CODING;    <span class="comment">/* bRequestCode:SET_LINE_CODING, bmRequestType */</span></div><div class="line">    setup.request_value  = VALUE_ZERO;         <span class="comment">/* wValue:Zero */</span></div><div class="line">    setup.request_index  = VALUE_ZERO;         <span class="comment">/* wIndex:Interface */</span></div><div class="line">    setup.request_length = LINE_CODING_LENGTH; <span class="comment">/* Data:Line Coding Structure */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Request Control transfer */</span></div><div class="line">    err = <a class="code" href="group___u_s_b.html#gaecba62e40820ec837fa0b285140ed13b">R_USB_HostControlTransfer</a>(p_ctrl, &amp;setup, (uint8_t *) &amp;g_com_parm, device_address);</div><div class="line">    <span class="keywordflow">if</span> (FSP_SUCCESS != err)</div><div class="line">    {</div><div class="line">        handle_error(err, <span class="stringliteral">&quot;**R_USB_HostControlTransfer API FAILED**&quot;</span>);</div><div class="line">    }</div><div class="line">}                                      <span class="comment">/* End of function cdc_set_line_coding */</span></div><div class="line"></div><div class="line"><span class="comment">/*******************************************************************************************************************</span></div><div class="line"><span class="comment"> * In this function initializes to get line coding information for host control transfer.</span></div><div class="line"><span class="comment"> ******************************************************************************************************************/</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> get_line_coding (<a class="code" href="group___u_s_b.html#gad5c104adfb44c721d9c664bf7fabddfb">usb_instance_ctrl_t</a> * p_ctrl, uint8_t device_address)</div><div class="line">{</div><div class="line">    usb_setup_t setup;</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>   err = FSP_SUCCESS;</div><div class="line">    setup.request_type   = GET_LINE_CODING;    <span class="comment">/* bRequestCode:GET_LINE_CODING, bmRequestType */</span></div><div class="line">    setup.request_value  = VALUE_ZERO;         <span class="comment">/* wValue:Zero */</span></div><div class="line">    setup.request_index  = VALUE_ZERO;         <span class="comment">/* wIndex:Interface */</span></div><div class="line">    setup.request_length = LINE_CODING_LENGTH; <span class="comment">/* Data:Line Coding Structure */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Request Control transfer */</span></div><div class="line">    err = <a class="code" href="group___u_s_b.html#gaecba62e40820ec837fa0b285140ed13b">R_USB_HostControlTransfer</a>(p_ctrl, &amp;setup, (uint8_t *) &amp;g_com_parm, device_address);</div><div class="line">    <span class="keywordflow">if</span> (FSP_SUCCESS != err)</div><div class="line">    {</div><div class="line">        handle_error(err, <span class="stringliteral">&quot;**R_USB_HostControlTransfer API FAILED**&quot;</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*******************************************************************************************************************</span></div><div class="line"><span class="comment"> * This function is called to do closing of usb module using its HAL level API and handles the error trap.</span></div><div class="line"><span class="comment"> * Handle the Error internally with Proper Message. Application handles the rest.</span></div><div class="line"><span class="comment"> ******************************************************************************************************************/</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> handle_error (<a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err, <span class="keywordtype">char</span> * err_str)</div><div class="line">{</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*******************************************************************************************************************</span></div><div class="line"><span class="comment"> * This function is to do data process with peripheral device</span></div><div class="line"><span class="comment"> ******************************************************************************************************************/</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> usb_data_process (usb_event_info_t * event_info)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___u_s_b___a_p_i.html#ggab1dc4a2240edf1a50cca3945f31dc9f2aa31d93178a24f042fb19db6da3b5a2d8">USB_CLASS_HCDC</a> == event_info-&gt;type)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (RESET_VALUE &lt; event_info-&gt;data_size)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">if</span> (0 != memcmp(g_rcv_buf, g_snd_buf, event_info-&gt;data_size))</div><div class="line">            {</div><div class="line">                APP_PRINT(<span class="stringliteral">&quot;\r\n Sending and receiving data do not match :%s&quot;</span>, g_rcv_buf);</div><div class="line">            }</div><div class="line"></div><div class="line">            err = <a class="code" href="group___u_s_b.html#ga001f40866be6438435e65e78871a54d5">R_USB_Write</a>(&amp;g_basic0_ctrl, g_snd_buf, CDC_WRITE_DATA_LEN, event_info-&gt;device_address);</div><div class="line">            <span class="keywordflow">if</span> (FSP_SUCCESS != err)</div><div class="line">            {</div><div class="line">                handle_error(err, <span class="stringliteral">&quot;**R_USB_Write API FAILED**&quot;</span>);</div><div class="line">            }</div><div class="line"></div><div class="line">            APP_PRINT(<span class="stringliteral">&quot;\r\n Received data :%s&quot;</span>, g_rcv_buf);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            <span class="comment">/* Send the data reception request when the zero-length packet is received. */</span></div><div class="line">            err = <a class="code" href="group___u_s_b.html#ga42ad1cbad598d06023d83e8a91fd49d4">R_USB_Read</a>(&amp;g_basic0_ctrl, g_rcv_buf, event_info-&gt;data_size, event_info-&gt;device_address);</div><div class="line">            <span class="keywordflow">if</span> (FSP_SUCCESS != err)</div><div class="line">            {</div><div class="line">                handle_error(err, <span class="stringliteral">&quot;**R_USB_Read API FAILED**&quot;</span>);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Class notification &quot;SerialState&quot; receive start */</span></div><div class="line">        err = <a class="code" href="group___u_s_b.html#ga42ad1cbad598d06023d83e8a91fd49d4">R_USB_Read</a>(&amp;g_basic0_ctrl,</div><div class="line">                         (uint8_t *) &amp;g_serial_state,</div><div class="line">                         USB_HCDC_SERIAL_STATE_MSG_LEN,</div><div class="line">                         event_info-&gt;device_address);</div><div class="line"></div><div class="line">        <span class="comment">/* Error Handle */</span></div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS != err)</div><div class="line">        {</div><div class="line">            handle_error(err, <span class="stringliteral">&quot;**R_USB_Read API FAILED**&quot;</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}                                      <span class="comment">/* End of function usb_data_process */</span></div><div class="line"></div><div class="line"><span class="comment">/*******************************************************************************************************************</span></div><div class="line"><span class="comment"> * This function is callback for FreeRTOS+HCDC and triggers when USB event occurs from the device.</span></div><div class="line"><span class="comment"> ******************************************************************************************************************/</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> usb_app_common_callback (usb_event_info_t * p_event_info, usb_hdl_t cur_task, <a class="code" href="group___u_s_b___a_p_i.html#ga647c9ea8cc8c82a26dcec32f7749c73d">usb_onoff_t</a> usb_state)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gaf0afcbc9a110ac9366a811d96ee06029">FSP_PARAMETER_NOT_USED</a>(cur_task);</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gaf0afcbc9a110ac9366a811d96ee06029">FSP_PARAMETER_NOT_USED</a>(usb_state);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___u_s_b___a_p_i.html#ggab1dc4a2240edf1a50cca3945f31dc9f2ac5ba0e58af39bb09ef467e27446a2d58">USB_CLASS_REQUEST</a> == p_event_info-&gt;type)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> ((USB_CDC_SET_LINE_CODING == (p_event_info-&gt;setup.request_type &amp; <a class="code" href="group___u_s_b___a_p_i.html#ga3a6743f3e336fc05e70e59b05206f634">USB_BREQUEST</a>)) ||</div><div class="line">            (USB_CDC_GET_LINE_CODING == (p_event_info-&gt;setup.request_type &amp; <a class="code" href="group___u_s_b___a_p_i.html#ga3a6743f3e336fc05e70e59b05206f634">USB_BREQUEST</a>)) ||</div><div class="line">            (USB_CDC_SET_CONTROL_LINE_STATE == (p_event_info-&gt;setup.request_type &amp; <a class="code" href="group___u_s_b___a_p_i.html#ga3a6743f3e336fc05e70e59b05206f634">USB_BREQUEST</a>)))</div><div class="line">        {</div><div class="line">            g_usb_host_apl_callback[0](p_event_info, cur_task, usb_state); <span class="comment">// HCDC Callback</span></div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            g_usb_host_apl_callback[1](p_event_info, cur_task, usb_state); <span class="comment">// HMSC Callback</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> ((<a class="code" href="group___u_s_b___a_p_i.html#ggab1dc4a2240edf1a50cca3945f31dc9f2aa31d93178a24f042fb19db6da3b5a2d8">USB_CLASS_HCDC</a> == p_event_info-&gt;type) || (<a class="code" href="group___u_s_b___a_p_i.html#ggab1dc4a2240edf1a50cca3945f31dc9f2a849e5469fce2840fde1a475474f3ddc4">USB_CLASS_HCDCC</a> == p_event_info-&gt;type))</div><div class="line">        {</div><div class="line">            g_usb_host_apl_callback[0](p_event_info, cur_task, usb_state); <span class="comment">// HCDC Callback</span></div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            g_usb_host_apl_callback[1](p_event_info, cur_task, usb_state); <span class="comment">// HMSC Callback</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*******************************************************************************************************************</span></div><div class="line"><span class="comment"> * This function is callback for FreeRTOS+HCDC and triggers when USB event occurs from the device.</span></div><div class="line"><span class="comment"> ******************************************************************************************************************/</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> usb_app_hcdc_callback (usb_event_info_t * p_event_info, usb_hdl_t cur_task, <a class="code" href="group___u_s_b___a_p_i.html#ga647c9ea8cc8c82a26dcec32f7749c73d">usb_onoff_t</a> usb_state)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gaf0afcbc9a110ac9366a811d96ee06029">FSP_PARAMETER_NOT_USED</a>(cur_task);</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gaf0afcbc9a110ac9366a811d96ee06029">FSP_PARAMETER_NOT_USED</a>(usb_state);</div><div class="line"></div><div class="line">    <span class="comment">/* Send event received to queue */</span></div><div class="line">    <span class="keywordflow">if</span> (pdTRUE != (xQueueSend(g_usb_queue, (<span class="keyword">const</span> <span class="keywordtype">void</span> *) &amp;p_event_info, (TickType_t) (NO_WAIT_TIME))))</div><div class="line">    {</div><div class="line">        g_err_flag = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad5c104adfb44c721d9c664bf7fabddfb"><td class="memItemLeft" align="right" valign="top">typedef usb_event_info_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b.html#gad5c104adfb44c721d9c664bf7fabddfb">usb_instance_ctrl_t</a></td></tr>
<tr class="separator:gad5c104adfb44c721d9c664bf7fabddfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gad5c104adfb44c721d9c664bf7fabddfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5c104adfb44c721d9c664bf7fabddfb">&#9670;&nbsp;</a></span>usb_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef usb_event_info_t <a class="el" href="group___u_s_b.html#gad5c104adfb44c721d9c664bf7fabddfb">usb_instance_ctrl_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USB private control block. DO NOT MODIFY. Initialization occurs when R_USB_Open is called. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf882576a8f79312c27fa700d3fb94951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf882576a8f79312c27fa700d3fb94951">&#9670;&nbsp;</a></span>R_USB_EventGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_EventGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga56bea25fbffdbda134044c49d40d5e40">usb_status_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains completed USB related events. (OS-less Only) </p>
<p>In USB host mode, the device address value of the USB device that completed an event is specified in the usb_ctrl_t structure member (address) specified by the event's argument. In USB peripheral mode, USB_NULL is specified in member (address). If this function is called in the RTOS execution environment, a failure is returned.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Event Get Success. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_FAILED</td><td>If called in the RTOS environment, an error is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Do not use the same variable as the first argument of R_USB_Open for the first argument. </dd>
<dd>
Do not call this API in the interrupt function. </dd></dl>

</div>
</div>
<a id="ga2560b302dca363895820a82ea6a2ba9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2560b302dca363895820a82ea6a2ba9c">&#9670;&nbsp;</a></span>R_USB_Callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_Callback </td>
          <td>(</td>
          <td class="paramtype">usb_callback_t *&#160;</td>
          <td class="paramname"><em>p_callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a callback function to be called upon completion of a USB related event. (RTOS only) </p>
<p>This function registers a callback function to be called when a USB-related event has completed. If this function is called in the OS-less execution environment, a failure is returned.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successfully completed. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Parameter is NULL error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Do not call this API in the interrupt function. </dd></dl>

</div>
</div>
<a id="gab9810a1d8e322cb89a9a7f9ca84a368f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9810a1d8e322cb89a9a7f9ca84a368f">&#9670;&nbsp;</a></span>R_USB_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#structusb__cfg__t">usb_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies power to the USB module specified in the argument (p_ctrl). </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Success in open. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_BUSY</td><td>Specified USB module now in use. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Parameter is NULL error. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_FAILED</td><td>The function could not be completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_PARAMETER</td><td>Parameter error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Do not call this API in the following function. </dd>
<dd>
(1). Interrupt function. </dd>
<dd>
(2). Callback function ( for RTOS ). </dd></dl>

</div>
</div>
<a id="ga42c6c75ae96e3860b726d1b0dcbf110d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42c6c75ae96e3860b726d1b0dcbf110d">&#9670;&nbsp;</a></span>R_USB_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminates power to the USB module specified in argument (p_ctrl). USB0 module stops when USB_IP0 is specified to the member (module), USB1 module stops when USB_IP1 is specified to the member (module). </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Success. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_FAILED</td><td>The function could not be completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_NOT_OPEN</td><td>USB module is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Parameter is NULL error. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_PARAMETER</td><td>Parameter error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Do not call this API in the following function. </dd>
<dd>
(1). Interrupt function. </dd>
<dd>
(2). Callback function ( for RTOS ). </dd></dl>

</div>
</div>
<a id="ga42ad1cbad598d06023d83e8a91fd49d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42ad1cbad598d06023d83e8a91fd49d4">&#9670;&nbsp;</a></span>R_USB_Read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bulk/Interrupt data transfer. </p>
<p>Requests USB data read (bulk/interrupt transfer). The read data is stored in the area specified by argument (p_buf). After data read is completed, confirm the operation by checking the return value (USB_STATUS_READ_COMPLETE) of the R_USB_GetEvent function. The received data size is set in member (size) of the usb_ctrl_t structure. To figure out the size of the data when a read is complete, check the return value (USB_STATUS_READ_COMPLETE) of the R_USB_GetEvent function, and then refer to the member (size) of the usb_crtl_t structure.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successfully completed (Data read request completed). </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_FAILED</td><td>The function could not be completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_BUSY</td><td>Data receive request already in process for USB device with same device address. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Parameter is NULL error. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_PARAMETER</td><td>Parameter error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>1. Do not call this API in the following function. </dd>
<dd>
(1). Interrupt function. </dd>
<dd>
(2). Callback function ( for RTOS ). </dd>
<dd>
2. Allocate the following the storage area when using DMA transfer and specify the start address of the allocated storage area to the 2nd argument(p_buf). </dd>
<dd>
(1). When using High-speed and enabling continuous transfer mode, allocate the storage area with a size that is a multiple of 2048. </dd>
<dd>
(2). When using High-speed and disabling continuous transfer mode, allocate the storage area with a size that is a multiple of 512. </dd>
<dd>
(3). When using Full-speed, allocate the storage area with a size that is a multiple of 64. </dd>
<dd>
3. Specify the following address to the 2nd argument (p_buf) when using DMA transfer. </dd>
<dd>
(1). When using High-speed module, specify start address of the buffer area aligned on 4-byte boundary. </dd>
<dd>
(2). When using Full-speed module, specify start address of the buffer area aligned on 2-byte boundary. </dd></dl>

</div>
</div>
<a id="ga001f40866be6438435e65e78871a54d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga001f40866be6438435e65e78871a54d5">&#9670;&nbsp;</a></span>R_USB_Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *const&#160;</td>
          <td class="paramname"><em>p_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bulk/Interrupt data transfer. </p>
<p>Requests USB data write (bulk/interrupt transfer). Stores write data in area specified by argument (p_buf). Set the device class type in usb_ctrl_t structure member (type). Confirm after data write is completed by checking the return value (USB_STATUS_WRITE_COMPLETE) of the R_USB_GetEvent function. For sending a zero-length packet, please refer the following Note.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successfully completed. (Data write request completed) </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_FAILED</td><td>The function could not be completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_BUSY</td><td>Data write request already in process for USB device with same device address. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Parameter is NULL error. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_PARAMETER</td><td>Parameter error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>1. The user needs to send the zero-length packet(ZLP) since this USB driver does not send the ZLP automatically. </dd>
<dd>
When sending a ZLP, the user sets USB_NULL in the third argument (size) of R_USB_Write function as follow. </dd>
<dd>
e.g) </dd>
<dd>
R_USB_Write (&amp;g_basic0_ctrl, &amp;g_buf, USB_NULL); </dd>
<dd>
2. Specify the following address to the 2nd argument (p_buf) when using DMA transfer. </dd>
<dd>
(1). When using High-speed module, specify start address of the buffer area aligned on 4-byte boundary. </dd>
<dd>
(2). When using Full-speed module, specify start address of the buffer area aligned on 2-byte boundary. </dd>
<dd>
3. Do not call this API in the following function. </dd>
<dd>
(1). Interrupt function. </dd>
<dd>
(2). Callback function ( for RTOS ). </dd></dl>

</div>
</div>
<a id="ga6b594879fb754ed4ae76685d6c261e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b594879fb754ed4ae76685d6c261e5d">&#9670;&nbsp;</a></span>R_USB_Stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga0c47f1426b999f2cd8aea9adca06fbde">usb_transfer_t</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requests a data read/write transfer be terminated when a data read/write transfer is being performed. </p>
<p>To stop a data read, set USB_TRANSFER_READ as the argument (type); to stop a data write, specify USB_WRITE as the argument (type).</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successfully completed. (stop completed) </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_FAILED</td><td>The function could not be completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Parameter is NULL error. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_BUSY</td><td>Stop processing is called multiple times. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_PARAMETER</td><td>Parameter error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Do not call this API in the following function. </dd>
<dd>
(1). Interrupt function. </dd>
<dd>
(2). Callback function ( for RTOS ). </dd></dl>

</div>
</div>
<a id="ga78ea3782bd018162fc06e3d24dc46b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78ea3782bd018162fc06e3d24dc46b83">&#9670;&nbsp;</a></span>R_USB_Suspend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_Suspend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a SUSPEND signal from the USB module assigned to the member (module) of the usb_crtl_t structure. </p>
<p>After the suspend request is completed, confirm the operation with the return value (USB_STATUS_SUSPEND) of the R_USB_EventGet function.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successfully completed. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_FAILED</td><td>The function could not be completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_BUSY</td><td>During a suspend request to the specified USB module, or when the USB module is already in the suspended state. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Parameter is NULL error. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_PARAMETER</td><td>Parameter error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Do not call this API in the following function. </dd>
<dd>
(1). Interrupt function. </dd>
<dd>
(2). Callback function ( for RTOS ). </dd></dl>

</div>
</div>
<a id="ga9851b21f1891e71de574a47589ea0282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9851b21f1891e71de574a47589ea0282">&#9670;&nbsp;</a></span>R_USB_Resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_Resume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a RESUME signal from the USB module assigned to the member (module) of the usb_ctrl_tstructure. </p>
<p>After the resume request is completed, confirm the operation with the return value (USB_STATUS_RESUME) of the R_USB_EventGet function</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successfully completed. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_FAILED</td><td>The function could not be completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_BUSY</td><td>Resume already requested for same device address. (USB host mode only) </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_NOT_SUSPEND</td><td>USB device is not in the SUSPEND state. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Parameter is NULL error. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_PARAMETER</td><td>Parameter error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Do not call this API in the following function. </dd>
<dd>
(1). Interrupt function. </dd>
<dd>
(2). Callback function ( for RTOS ). </dd></dl>

</div>
</div>
<a id="ga0d8d4651d5f1fa839cc85d32374f9018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d8d4651d5f1fa839cc85d32374f9018">&#9670;&nbsp;</a></span>R_USB_VbusSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_VbusSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies starting or stopping the VBUS supply. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful completion. (VBUS supply start/stop completed) </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_FAILED</td><td>The function could not be completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Parameter is NULL error. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_PARAMETER</td><td>Parameter error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Do not call this API in the following function. </dd>
<dd>
(1). Interrupt function. </dd>
<dd>
(2). Callback function ( for RTOS ). </dd></dl>

</div>
</div>
<a id="ga60b7dbef6ec571c6f2cacedcc5dccbcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60b7dbef6ec571c6f2cacedcc5dccbcd">&#9670;&nbsp;</a></span>R_USB_InfoGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_InfoGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">usb_info_t *&#160;</td>
          <td class="paramname"><em>p_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains completed USB-related events. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful completion. (VBUS supply start/stop completed) </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Parameter is NULL error. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_FAILED</td><td>The function could not be completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_PARAMETER</td><td>Parameter error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5bee47c1fb4dfb12eba430226122bd57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bee47c1fb4dfb12eba430226122bd57">&#9670;&nbsp;</a></span>R_USB_PipeRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_PipeRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pipe_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requests a data read (Bulk/Interrupt transfer) via the pipe specified in the argument. </p>
<p>The read data is stored in the area specified in the argument (p_buf). After the data read is completed, confirm the operation with the R_USB_GetEvent function return value(USB_STATUS_READ_COMPLETE). To figure out the size of the data when a read is complete, check the return value (USB_STATUS_READ_COMPLETE) of the R_USB_GetEvent function, and then refer to the member (size) of the usb_crtl_t structure.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successfully completed. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_BUSY</td><td>Specified pipe now handling data receive/send request. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_FAILED</td><td>The function could not be completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Parameter is NULL error. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_PARAMETER</td><td>Parameter error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>1. Do not call this API in the following function. </dd>
<dd>
(1). Interrupt function. </dd>
<dd>
(2). Callback function ( for RTOS ). </dd>
<dd>
2. Allocate the following the storage area when using DMA transfer and specify the start address of the allocated storage area to the 2nd argument(p_buf). </dd>
<dd>
(1). When using High-speed and enabling continuous transfer mode, allocate the storage area with a size that is a multiple of 2048. </dd>
<dd>
(2). When using High-speed and disabling continuous transfer mode, allocate the storage area with a size that is a multiple of 512. </dd>
<dd>
(3). When using Full-speed, allocate the storage area with a size that is a multiple of 64. </dd>
<dd>
3. Specify the following address to the 2nd argument (p_buf) when using DMA transfer. </dd>
<dd>
(1). When using High-speed module, specify start address of the buffer area aligned on 4-byte boundary. </dd>
<dd>
(2). When using Full-speed module, specify start address of the buffer area aligned on 2-byte boundary. </dd></dl>

</div>
</div>
<a id="ga4f800b5c189c92d58d23972142214d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f800b5c189c92d58d23972142214d22">&#9670;&nbsp;</a></span>R_USB_PipeWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_PipeWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pipe_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requests a data write (Bulk/Interrupt transfer). </p>
<p>The write data is stored in the area specified in the argument (p_buf). After data write is completed, confirm the operation with the return value (USB_STATUS_WRITE_COMPLETE) of the EventGet function. For sending a zero-length packet, please refer the following Note.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successfully completed. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_BUSY</td><td>Specified pipe now handling data receive/send request. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_FAILED</td><td>The function could not be completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Parameter is NULL error. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_PARAMETER</td><td>Parameter error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>1. The user needs to send the zero-length packet(ZLP) since this USB driver does not send the ZLP automatically. </dd>
<dd>
When sending a ZLP, the user sets USB_NULL in the third argument (size) of R_USB_PipeWrite function as follow. </dd>
<dd>
e.g) </dd>
<dd>
R_USB_PipeWrite (&amp;g_basic0_ctrl, &amp;g_buf, USB_NULL, pipe_number); </dd>
<dd>
2. Specify the following address to the 2nd argument (p_buf) when using DMA transfer. </dd>
<dd>
(1). When using High-speed module, specify start address of the buffer area aligned on 4-byte boundary. </dd>
<dd>
(2). When using Full-speed module, specify start address of the buffer area aligned on 2-byte boundary. </dd>
<dd>
3. Do not call this API in the following function. </dd>
<dd>
(1). Interrupt function. </dd>
<dd>
(2). Callback function ( for RTOS ). </dd></dl>

</div>
</div>
<a id="ga5311e5c477a72f6ac531516e49467d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5311e5c477a72f6ac531516e49467d16">&#9670;&nbsp;</a></span>R_USB_PipeStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_PipeStop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pipe_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminates a data read/write operation. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successfully completed. (Stop request completed) </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_FAILED</td><td>The function could not be completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Parameter is NULL error. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_PARAMETER</td><td>Parameter error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Do not call this API in the following function. </dd>
<dd>
(1). Interrupt function. </dd>
<dd>
(2). Callback function ( for RTOS ). </dd></dl>

</div>
</div>
<a id="ga112c7de01280de80c529ec61789c9cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga112c7de01280de80c529ec61789c9cc0">&#9670;&nbsp;</a></span>R_USB_UsedPipesGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_UsedPipesGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>p_pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the selected pipe number (number of the pipe that has completed initialization) via bit map information. </p>
<p>The bit map information is stored in the area specified in argument (p_pipe). Based on the information (module member and address member) assigned to the usb_ctrl_t structure, obtains the PIPE information of that USB device.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successfully completed. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_FAILED</td><td>The function could not be completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Parameter is NULL error. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_PARAMETER</td><td>Parameter error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga08f0810f299c825fae9a9f8ada2f9dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08f0810f299c825fae9a9f8ada2f9dbf">&#9670;&nbsp;</a></span>R_USB_PipeInfoGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_PipeInfoGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">usb_pipe_t *&#160;</td>
          <td class="paramname"><em>p_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pipe_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the following pipe information regarding the pipe specified in the argument (p_ctrl) member (pipe): endpoint number, transfer type, transfer direction and maximum packet size. </p>
<p>The obtained pipe information is stored in the area specified in the argument (p_info).</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successfully completed. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_FAILED</td><td>The function could not be completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Parameter is NULL error. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_PARAMETER</td><td>Parameter error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga999a06f4569d82b8e18c2509e579a35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga999a06f4569d82b8e18c2509e579a35f">&#9670;&nbsp;</a></span>R_USB_PullUp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_PullUp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables or disables pull-up of D+/D- line. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful completion. (Pull-up enable/disable setting completed) </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_FAILED</td><td>The function could not be completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Parameter is NULL error. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_PARAMETER</td><td>Parameter error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Do not call this API in the following function. </dd>
<dd>
(1). Interrupt function. </dd>
<dd>
(2). Callback function ( for RTOS ). </dd></dl>

</div>
</div>
<a id="gaecba62e40820ec837fa0b285140ed13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecba62e40820ec837fa0b285140ed13b">&#9670;&nbsp;</a></span>R_USB_HostControlTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_HostControlTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">usb_setup_t *&#160;</td>
          <td class="paramname"><em>p_setup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>device_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs settings and transmission processing when transmitting a setup packet. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful completion. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_FAILED</td><td>The function could not be completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Parameter is NULL error. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_PARAMETER</td><td>Parameter error. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_BUSY</td><td>Specified pipe now handling data receive/send request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Do not call this API in the following function. </dd>
<dd>
(1). Interrupt function. </dd>
<dd>
(2). Callback function ( for RTOS ). </dd></dl>

</div>
</div>
<a id="ga1293995ba77495705db3a3adf703b7f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1293995ba77495705db3a3adf703b7f1">&#9670;&nbsp;</a></span>R_USB_PeriControlDataGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_PeriControlDataGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives data sent by control transfer. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful completion. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_FAILED</td><td>The function could not be completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Parameter is NULL error. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_BUSY</td><td>Specified pipe now handling data receive/send request. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_PARAMETER</td><td>Parameter error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Do not call this API in the following function. </dd>
<dd>
(1). Interrupt function. </dd>
<dd>
(2). Callback function ( for RTOS ). </dd></dl>

</div>
</div>
<a id="ga3fb9080601ee1041e35073e0538a21b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fb9080601ee1041e35073e0538a21b0">&#9670;&nbsp;</a></span>R_USB_PeriControlDataSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_PeriControlDataSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs transfer processing for control transfer. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful completion. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_FAILED</td><td>The function could not be completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Parameter is NULL error. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_BUSY</td><td>Specified pipe now handling data receive/send request. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_PARAMETER</td><td>Parameter error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Do not call this API in the following function. </dd>
<dd>
(1). Interrupt function. </dd>
<dd>
(2). Callback function ( for RTOS ). </dd></dl>

</div>
</div>
<a id="gaf8976d11f8be52c3f9422563188d6ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8976d11f8be52c3f9422563188d6ab9">&#9670;&nbsp;</a></span>R_USB_PeriControlStatusSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_PeriControlStatusSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga386cabe04206e06b3be8dbafc0bc3d86">usb_setup_status_t</a>&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the response to the setup packet. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful completion. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_FAILED</td><td>The function could not be completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Parameter is NULL error. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_PARAMETER</td><td>Parameter error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Do not call this API in the following function. </dd>
<dd>
(1). Interrupt function. </dd>
<dd>
(2). Callback function ( for RTOS ). </dd></dl>

</div>
</div>
<a id="ga66ee4c6ec542965dbac67020bd135179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66ee4c6ec542965dbac67020bd135179">&#9670;&nbsp;</a></span>R_USB_RemoteWakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_RemoteWakeup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a remote wake-up signal to the connected Host. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful completion. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_FAILED</td><td>The function could not be completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Parameter is NULL error. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_NOT_SUSPEND</td><td>Device is not suspended. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_BUSY</td><td>The device is in resume operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Do not call this API in the following function. </dd>
<dd>
(1). Interrupt function. </dd>
<dd>
(2). Callback function ( for RTOS ). </dd></dl>

</div>
</div>
<a id="ga2f8b7813a97e21b412fc95a80c042fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f8b7813a97e21b412fc95a80c042fe3">&#9670;&nbsp;</a></span>R_USB_DriverActivate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_DriverActivate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activate USB Driver for USB Peripheral BareMetal. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful completion. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_FAILED</td><td>The function could not be completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Parameter is NULL error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Call this API in the in the infinite loop of the application program or a timer interrupt. </dd></dl>

</div>
</div>
<a id="gaaedca302f2e3938e2d85e4a82c44d44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaedca302f2e3938e2d85e4a82c44d44b">&#9670;&nbsp;</a></span>R_USB_CallbackMemorySet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_CallbackMemorySet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">usb_callback_args_t *&#160;</td>
          <td class="paramname"><em>p_callback_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set callback memory to USB Driver for USB Peripheral BareMetal. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful completion. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_FAILED</td><td>The function could not be completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Parameter is NULL error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Call this API after calling R_USB_Open function. </dd></dl>

</div>
</div>
<a id="gad568903d7571f81da82b56d766bac46f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad568903d7571f81da82b56d766bac46f">&#9670;&nbsp;</a></span>R_USB_ModuleNumberGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_ModuleNumberGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>module_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets the module number. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful completion. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafe65188a89a926bcc12676c39ff587ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe65188a89a926bcc12676c39ff587ea">&#9670;&nbsp;</a></span>R_USB_ClassTypeGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_ClassTypeGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#gab1dc4a2240edf1a50cca3945f31dc9f2">usb_class_t</a> *&#160;</td>
          <td class="paramname"><em>class_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets the class type. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful completion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In Bare-Metal, In the Bare-Metal version, please specify the variable specified by the 1st argument of the R_USB_EventGet function to the 1st argument of this API. </dd>
<dd>
In the FreeRTOS, please specify one of the following to the 1st argument of this API. </dd>
<dd>
1. The 1st argument of the callback function specified in Conguration. </dd>
<dd>
2. The start address of the area where the structure area of the 1st argument was copied. </dd></dl>

</div>
</div>
<a id="ga5115f4b4a93c22485a82d753d5ca30b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5115f4b4a93c22485a82d753d5ca30b4">&#9670;&nbsp;</a></span>R_USB_DeviceAddressGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_DeviceAddressGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>device_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets the device address. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful completion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In Bare-Metal, In the Bare-Metal version, please specify the variable specified by the 1st argument of the R_USB_EventGet function to the 1st argument of this API. </dd>
<dd>
In the FreeRTOS, please specify one of the following to the 1st argument of this API. </dd>
<dd>
1. The 1st argument of the callback function specified in Conguration. </dd>
<dd>
2. The start address of the area where the structure area of the 1st argument was copied. </dd></dl>

</div>
</div>
<a id="ga8a525c37cda36063befdb9451db98489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a525c37cda36063befdb9451db98489">&#9670;&nbsp;</a></span>R_USB_PipeNumberGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_PipeNumberGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pipe_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets the pipe number. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful completion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In Bare-Metal, In the Bare-Metal version, please specify the variable specified by the 1st argument of the R_USB_EventGet function to the 1st argument of this API. </dd>
<dd>
In the FreeRTOS, please specify one of the following to the 1st argument of this API. </dd>
<dd>
1. The 1st argument of the callback function specified in Conguration. </dd>
<dd>
2. The start address of the area where the structure area of the 1st argument was copied. </dd></dl>

</div>
</div>
<a id="ga3daaad1d2b7430e08a5c1bf87bfec38d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3daaad1d2b7430e08a5c1bf87bfec38d">&#9670;&nbsp;</a></span>R_USB_DeviceStateGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_DeviceStateGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets the state of the device. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful completion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In Bare-Metal, In the Bare-Metal version, please specify the variable specified by the 1st argument of the R_USB_EventGet function to the 1st argument of this API. </dd>
<dd>
In the FreeRTOS, please specify one of the following to the 1st argument of this API. </dd>
<dd>
1. The 1st argument of the callback function specified in Conguration. </dd>
<dd>
2. The start address of the area where the structure area of the 1st argument was copied. </dd></dl>

</div>
</div>
<a id="ga042d5b513be9896e593f023c8cb81cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga042d5b513be9896e593f023c8cb81cd1">&#9670;&nbsp;</a></span>R_USB_DataSizeGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_DataSizeGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets the read data size. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful completion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In Bare-Metal, In the Bare-Metal version, please specify the variable specified by the 1st argument of the R_USB_EventGet function to the 1st argument of this API. </dd>
<dd>
In the FreeRTOS, please specify one of the following to the 1st argument of this API. </dd>
<dd>
1. The 1st argument of the callback function specified in Conguration. </dd>
<dd>
2. The start address of the area where the structure area of the 1st argument was copied. </dd></dl>

</div>
</div>
<a id="ga628af921919f90a9232c8c1713cc6c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga628af921919f90a9232c8c1713cc6c48">&#9670;&nbsp;</a></span>R_USB_SetupGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_SetupGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">usb_setup_t *&#160;</td>
          <td class="paramname"><em>setup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets the setup information. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful completion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In Bare-Metal, In the Bare-Metal version, please specify the variable specified by the 1st argument of the R_USB_EventGet function to the 1st argument of this API. </dd>
<dd>
In the FreeRTOS, please specify one of the following to the 1st argument of this API. </dd>
<dd>
1. The 1st argument of the callback function specified in Conguration. </dd>
<dd>
2. The start address of the area where the structure area of the 1st argument was copied. </dd></dl>

</div>
</div>
<a id="ga66b9f21c7fc7cce60388edeaf7861d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66b9f21c7fc7cce60388edeaf7861d0e">&#9670;&nbsp;</a></span>R_USB_OtgCallbackSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_OtgCallbackSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">usb_otg_callback_t *&#160;</td>
          <td class="paramname"><em>p_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set callback function to be called when the OTG role swap was completed on Azure RTOS. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful completion. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_FAILED</td><td>The function could not be completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Parameter is NULL error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1a52197abba908bdd990e9bca22d50a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a52197abba908bdd990e9bca22d50a7">&#9670;&nbsp;</a></span>R_USB_OtgSRP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_USB_OtgSRP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b___a_p_i.html#ga00a5a797b57dec247564f11056ac7230">usb_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the SRP processing for OTG on Azure RTOS. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful completion. </td></tr>
    <tr><td class="paramname">FSP_ERR_USB_FAILED</td><td>The function could not be completed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Parameter is NULL error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Do not support the VBUS Pulsing since OTG 2.0 does not support the VBUS Pulsing.. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v6.2.0 User's Manual Copyright © (2025) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
