<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: FileX I/O (rm_filex_block_media)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
    $(document).ready(function() {
        $("tr.tree_lvl_1").nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
		$("tr.tree_lvl_1").data("expanded","0");
		$("tr.tree_lvl_2").data("expanded","0");
		$("tr.tree_lvl_3").data("expanded","0");
		$("tr.tree_lvl_4").data("expanded","0");
		$("tr.tree_lvl_5").data("expanded","0");
        $("tr.tree_lvl_1").click(function() {
		    var lvl_1_is_open = $(this).data("expanded");
		    if (lvl_1_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2, tr.tree_lvl_1_item").show(); 
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed"); 
				$(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        }); 
		$("tr.tree_lvl_2").click(function() {
		    var lvl_2_is_open = $(this).data("expanded");
		    if (lvl_2_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3, tr.tree_lvl_2_item").show(); 
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();                
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_3").click(function() {
		    var lvl_3_is_open = $(this).data("expanded");
		    if (lvl_3_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_3_item").show(); 
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").data("expanded","0");				
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_4").click(function() {
		    var lvl_4_is_open = $(this).data("expanded");
		    if (lvl_4_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5, tr.tree_lvl_4_item").show(); 
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");	
				$(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").data("expanded","0");				
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        }); 
		$("tr.tree_lvl_5").click(function() {
		    var lvl_5_is_open = $(this).data("expanded");
		    if (lvl_5_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5_item").show(); 
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4_item,tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();                
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        }); 
     }); 
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v5.4.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">
 
    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text"> 
      </span>
      <span class="right">
          &nbsp; 
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() { 
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body. 
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works 
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len)); 
            }
          } 
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }    
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element. 
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;  
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<div class="title">FileX I/O (rm_filex_block_media)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___s_t_o_r_a_g_e___m_o_d_u_l_e_s.html">Storage</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9a2d0b8326679daa0b5e0dcb3e361d08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a.html#ga9a2d0b8326679daa0b5e0dcb3e361d08">RM_FILEX_BLOCK_MEDIA_Open</a> (<a class="el" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a___a_p_i.html#ga1514f18e864b2396487bc68704841e7f">rm_filex_block_media_ctrl_t</a> *const p_ctrl, <a class="el" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a___a_p_i.html#structrm__filex__block__media__cfg__t">rm_filex_block_media_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:ga9a2d0b8326679daa0b5e0dcb3e361d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00b16572b181e4e0f79f64268d5dca17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a.html#ga00b16572b181e4e0f79f64268d5dca17">RM_FILEX_BLOCK_MEDIA_Close</a> (<a class="el" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a___a_p_i.html#ga1514f18e864b2396487bc68704841e7f">rm_filex_block_media_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:ga00b16572b181e4e0f79f64268d5dca17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga137a5f28a4ba749468ec0bf7e2528607"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a.html#ga137a5f28a4ba749468ec0bf7e2528607">RM_FILEX_BLOCK_MEDIA_BlockDriver</a> (FX_MEDIA *p_fx_media)</td></tr>
<tr class="memdesc:ga137a5f28a4ba749468ec0bf7e2528607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access Block Media device functions open, close, read, write and control.  <a href="#ga137a5f28a4ba749468ec0bf7e2528607">More...</a><br /></td></tr>
<tr class="separator:ga137a5f28a4ba749468ec0bf7e2528607"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Middleware for the Azure RTOS FileX File System control using Block Media on RA MCUs. </p>
<h1><a class="anchor" id="rm-filex-block-media-overview"></a>
Overview</h1>
<p>This module provides the hardware port layer for FileX file system. After initializing this module, refer to the FileX API reference to use the file system: <a href="https://docs.microsoft.com/en-us/azure/rtos/filex/">https://docs.microsoft.com/en-us/azure/rtos/filex/</a></p>
<h2><a class="anchor" id="rm-filex-block-media-features"></a>
Features</h2>
<p>The FileX Block Media module supports the following features:</p><ul>
<li>Callbacks for insertion and removal for removable devices.<a class="anchor" id="um_rm_filex_block_media_removal"></a><a class="anchor" id="um_rm_filex_block_media_insertion"></a></li>
<li>ThreadX is typically required for FileX. To use FileX without ThreadX FX_STANDALONE_ENABLE must be defined.</li>
<li>Unless FX_SINGLE_THREAD or FX_STANDALONE_ENABLE are defined, all FileX operations are thread safe.<a class="anchor" id="um_rm_filex_thread_safe"></a> </li>
</ul>
<h1><a class="anchor" id="rm-filex-block-media-configurations"></a>
Configuration</h1>
<p><h2>Build Time Configurations for rm_filex_block_media</h2>
The following build time configurations are defined in fsp_cfg/middleware/rm_filex_block_media_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>Selects if code for parameter checking is to be included in the build. </td></tr>
</table>
 <h2>Configurations for Storage &gt; FileX I/O (rm_filex_block_media)</h2>
<table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Name</td><td>Name must be a valid C symbol</td><td>g_rm_filex_block_media_0 </td><td>Module name. </td></tr>
<tr class="tree_none">
<td>Callback</td><td>Name must be a valid C symbol</td><td>g_rm_filex_block_media_0_callback </td><td>A user callback function can be provided. If this callback function is provided, it will be called when media is inserted or removed. It will also be called during operations by the lower level block media as a way for the user to provide their desired waiting functionality. </td></tr>
<tr class="tree_none">
<td>Partition Number</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
0</li>
<li>
1</li>
<li>
2</li>
<li>
3</li>
</ul>
</td><td>0 </td><td>The partition to use for partitioned media. This partition will only be used if a Master Boot Record with partition table exists at block 0 of the media, otherwise the FileX FAT boot record should exist or be formatted to block 0. </td></tr>
</table>
 <h2>Build Time Configurations for fx</h2>
The following build time configurations are defined in fsp_cfg/azure/fx/fx_user.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Common  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Max Long Name Len</td><td>Value must be an integer greater than or equal to 13 and less than or equal to 256, or empty</td><td></td><td>Specifies the maximum file name size for FileX. If left blank the default value is 256. Legal values range between 13 and 256. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Max Last Name Len</td><td>Value must be an integer greater than or equal to 13 and less than or equal to 256, or empty</td><td></td><td>This value defines the maximum file name length, which includes full path name. If left blank the default value is 256. Legal values range between 13 and 256. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Max Sector Cache</td><td>Value must be an integer greater than 0 and power of 2 or empty</td><td></td><td>Specifies the maximum number of logical sectors that can be cached by FileX. The actual number of sectors that can be cached is lesser of this constant and how many sectors can fit in the amount of memory supplied at fx_media_open. The default value if left blank is 256. All values must be a power of 2. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Fat Map Size</td><td>Value must be an integer greater than 0 or empty</td><td></td><td>Specifies the number of sectors that can be represented in the FAT update map. The default value if left blank is 256. Larger values help reduce unneeded updates of secondary FAT sectors. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Max Fat Cache</td><td>Value must be an integer greater than 0 and power of 2 or empty</td><td></td><td>Specifies the number of entries in the internal FAT cache. The default value if left blank is 16. All values must be a power of 2. </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Threading  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Update Rate (Seconds)</td><td>Value must be an integer greater than 0 or empty</td><td></td><td>Specifies rate at which system time in FileX is adjusted. Default value if left blank is 10, specifying that the FileX system time is updated every 10 seconds. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">No Timer</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled (default)</li>
</ul>
</td><td>Disabled (default) </td><td>Eliminates the ThreadX timer setup to update the FileX system time and date. Doing so causes default time and date to be placed on all file operations. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Single Thread</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled (default)</li>
</ul>
</td><td>Disabled (default) </td><td>Eliminates ThreadX protection logic from the FileX source. It should be used if FileX is being used only from one thread. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Standalone</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled (default)</li>
</ul>
</td><td>Disabled (default) </td><td>Enables FileX to be used in standalone mode (without Azure RTOS). </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Extra Features  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Don't Update Open Files</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled (default)</li>
</ul>
</td><td>Disabled (default) </td><td>When enabled, FileX does not update already opened files. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Media Search Cache</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (default)</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled (default) </td><td>When disabled, the file search cache optimization is disabled. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Direct Data Read Cache Fill</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (default)</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled (default) </td><td>When disabled, the direct read sector update of cache is disabled. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Media Statistics</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (default)</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled (default) </td><td>When disabled, gathering of media statistics is disabled. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Single Open Legacy</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled (default)</li>
</ul>
</td><td>Disabled (default) </td><td>When enabled, legacy single open logic for the same file is enabled. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Rename Path Inherit</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled (default)</li>
</ul>
</td><td>Disabled (default) </td><td>When enabled, renaming inherits path information. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">No Local Path</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled (default)</li>
</ul>
</td><td>Disabled (default) </td><td>When enabled, removes local path logic from FileX, resulting in smaller code size. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">64-bit LBA</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled (default)</li>
</ul>
</td><td>Disabled (default) </td><td>When enabled, 64-bits sector addresses are used in I/O driver. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Cache</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (default)</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled (default) </td><td>Enables or disables the cache, default is enabled. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">File Close</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (default)</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled (default) </td><td>Enables or disables file close, default is enabled. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Fast Close</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (default)</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled (default) </td><td>Enables or disables fast open, default is enabled. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Force Memory Operation</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (default)</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled (default) </td><td>Enables or disables force memory operation, default is enabled. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Build Options</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (default)</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled (default) </td><td>Enables or disables build options, default is enabled. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">One Line Function</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (default)</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled (default) </td><td>Enables or disables one line function, default is enabled. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">FAT Entry Refresh</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (default)</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled (default) </td><td>Enables or disables FAT entry refresh, default is enabled. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Consecutive Detect</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (default)</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled (default) </td><td>Enables or disables consecutive detect, default is enabled. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Enable exFAT</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled (default)</li>
</ul>
</td><td>Disabled (default) </td><td>Enables exFAT support in FileX. </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Fault Tolerant  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Fault Tolerant Service</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled (default)</li>
</ul>
</td><td>Disabled (default) </td><td>When enabled, enables the FileX Fault Tolerant Module. Enabling Fault Tolerant automatically defines the symbol FX_FAULT_TOLERANT and FX_FAULT_TOLERANT_DATA. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Fault Tolerant Data</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled (default)</li>
</ul>
</td><td>Disabled (default) </td><td>When enabled, FileX immediately passes all file data write requests to the media's driver. This potentially decreases performance, but helps limit lost file data. Note that enabling this feature does not automatically enable FileX Fault Tolerant Module, which should be enabled separately. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Fault Tolerant</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled (default)</li>
</ul>
</td><td>Disabled (default) </td><td>When enabled, FileX immediately passes write requests of all system sectors (boot, FAT, and directory sectors) to the media's driver. This potentially decreases performance, but helps limit corruption to lost clusters. Note that enabling this feature does not automatically enable FileX Fault Tolerant Module, which should be enabled separately. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Fault Tolerant Boot Index</td><td>Value must be an integer greater than or equal to 116 and less than or equal to 119</td><td></td><td>Defines byte offset in the boot sector where the cluster for the fault tolerant log is. By default if left blank this value is 116. This field takes 4 bytes. Bytes 116 through 119 are chosen because they are marked as reserved by FAT 12/16/32/exFAT specification. </td></tr>
<tr class="tree_none">
<td>Error Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (default)</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled (default) </td><td></td></tr>
</table>
 <h2>Configurations for Storage &gt; Azure RTOS FileX on Block Media</h2>
This module can be added to the Stacks tab via New Stack &gt; Storage &gt; Azure RTOS FileX on Block Media.<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Name</td><td>Name must be a valid C symbol</td><td>g_fx_media0 </td><td>Symbol used for media_ptr parameter in FileX APIs </td></tr>
<tr class="tree_none">
<td>Volume Name</td><td>Name must be a maximum of 11 characters</td><td>Volume 1 </td><td>Volume name string, which is a maximum of 11 characters. </td></tr>
<tr class="tree_none">
<td>Number of FATs</td><td>Number of FATs must be an integer greater than 0</td><td>1 </td><td>Number of FATs in the media. The minimal value is 1 for the primary FAT. Values greater than 1 result in additional FAT copies being maintained at run-time. </td></tr>
<tr class="tree_none">
<td>Directory Entries</td><td>Number of Directory Entries must be an integer greater than 0</td><td>256 </td><td>Number of directory entries in the root directory. </td></tr>
<tr class="tree_none">
<td>Hidden Sectors</td><td>Number of Hidden Sectors must be an integer</td><td>0 </td><td>Number of sectors hidden before this mediaâ€™s boot sector. If using media formatted with multiple partitions this number should correspond to the starting block number for the desired partition. </td></tr>
<tr class="tree_none">
<td>Total Sectors</td><td>Total Sectors must be an integer greater than 0</td><td>65536 </td><td>Total number of sectors in the media. When using a Renesas provided block media implementation, total sectors can be fetched by the infoGet from the block media API. Any removable media must be inserted and initialized first to retrieve this info. </td></tr>
<tr class="tree_none">
<td>Bytes per Sector</td><td>Bytes per Sector must be multiple of 32</td><td>512 </td><td>Number of bytes per sector, which is typically 512. FileX requires this to be a multiple of 32. When using a Renesas provided block media implementation, bytes per sector can be fetched by the infoGet from the block media API. Any removable media must be inserted and initialized first to retrieve this info. </td></tr>
<tr class="tree_none">
<td>Sectors per Cluster</td><td>Sectors per Cluster must be an integer greater than 0</td><td>1 </td><td>Number of sectors in each cluster. The cluster is the minimum allocation unit in a FAT file system. </td></tr>
<tr class="tree_none">
<td>Volume Serial Number (exFAT only)</td><td>Volume Serial Number must be an integer greater than 0</td><td>12345 </td><td>Serial number to be used for this volume. exFAT only. </td></tr>
<tr class="tree_none">
<td>Boundary Unit (exFAT only)</td><td>Boundary unit must be an integer greater than 0</td><td>128 </td><td>Physical data area alignment size, in number of sectors. exFAT only. </td></tr>
<tr class="tree_none">
<td>Working media memory size</td><td>Memory size must be an integer greater than or equal to the size of one sector</td><td>512 </td><td>Memory allocated for file system. Memory size must be an integer greater than or equal to the size of one sector. </td></tr>
</table>
</p>
<h1><a class="anchor" id="rm-filex-block-media-usage-notes"></a>
Usage Notes</h1>
<h2>Pending during Read/Write</h2>
<p>The FileX Block Media driver provides a number of events in the user callback to handle waiting or pending while it is doing blocking operations. The events received in the callback will differ depending on the lower level block media driver in use.</p>
<p>If the lower level block media driver is rm_block_media_spi (SPI blocks on read/write operations):</p>
<ul>
<li>The user will receive RM_BLOCK_MEDIA_EVENT_POLL_STATUS in the user callback while the lower level driver is polling for the read/write operation to be complete. The user can choose to do a thread sleep or software delay upon receiving this event in the callback.</li>
<li>Once the operation is complete no other callbacks will be received.</li>
</ul>
<p>If the lower level block media driver is rm_block_media_sdmmc (SDMMC is interrupt based, the FileX Block Media driver will still block while waiting for interrupts from SDMMC):</p>
<ul>
<li>The user will receive RM_BLOCK_MEDIA_EVENT_WAIT in the user callback when the FileX Block Media driver begins waiting for an interrupt event from SDMMC. This is sent from a thread context. The user can choose to pend on a semaphore, sleep the thread, or do a software delay upon receiving this event in the callback. The FileX Block Media driver thread will block until an interrupt is received.</li>
<li>Once an SDMMC interrupt is received the user will receive RM_BLOCK_MEDIA_EVENT_WAIT_END in the user callback. This is sent from an interrupt context. The user can choose to give a semaphore on this event or do nothing.</li>
<li>If SDMMC is busy on a long erase after receiving the interrupt the FileX Block Media driver will send RM_BLOCK_MEDIA_EVENT_POLL_STATUS to the user callback and proceed to do a blocking poll on SDMMC status. The user can choose to do a thread sleep or software delay upon receiving this event in the callback. This event will not be received by the user on typical operations by FileX.</li>
</ul>
<h2>Partitioned Media</h2>
<p>When using fx_format to format a partition the number of hidden sectors should match the starting block number of the partition and the total number of sectors should be equal to the number of sectors in the partition.<a class="anchor" id="um_rm_filex_multiple_partitions"></a> </p><h2>Unused User Callback Events</h2>
<p>Certain events are defined in rm_block_media_event_t but not returned by the FileX Block Media user callback:</p>
<ul>
<li>RM_BLOCK_MEDIA_EVENT_OPERATION_COMPLETE: This event is handled internally and operation success is indicated by FileX API calls returning FX_SUCCESS.</li>
<li>RM_BLOCK_MEDIA_EVENT_ERROR: This event is handled internally and operation failure will be indicated by an error return code from FileX API calls.</li>
</ul>
<h2>Erasing Flash Memory Prior to Usage</h2>
<p>The area of the flash memory being used for the FileX instance should be erased using the lower level flash API prior to usage. Otherwise, FileX open operation may fail when fx_media_open( ) is called.</p>
<h1><a class="anchor" id="rm-filex-block-media-examples"></a>
Examples</h1>
<h2>Basic Example</h2>
<p>This is a basic example of FileX Block Media in an application.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define RM_FILEX_BLOCK_MEDIA_EXAMPLE_FILE_NAME                &quot;TEST_FILE.txt&quot;</span></div><div class="line"><span class="preprocessor">#define RM_FILEX_BLOCK_MEDIA_EXAMPLE_BUFFER_SIZE_BYTES        (10240)</span></div><div class="line"><span class="preprocessor">#define RM_FILEX_BLOCK_MEDIA_EXAMPLE_PARTITION_NUMBER         (0)</span></div><div class="line"><span class="preprocessor">#define RM_FILEX_BLOCK_MEDIA_EXAMPLE_BLOCK_SIZE               (512)</span></div><div class="line"><span class="preprocessor">#define RM_FILEX_BLOCK_MEDIA_EXAMPLE_NUM_DIRECTORY_ENTRIES    (128)</span></div><div class="line"><span class="preprocessor">#define RM_FILEX_BLOCK_MEDIA_EXAMPLE_NUM_FATS                 (1)</span></div><div class="line"><span class="preprocessor">#define RM_FILEX_BLOCK_MEDIA_EXAMPLE_HIDDEN_SECTORS           (0)</span></div><div class="line"><span class="preprocessor">#define RM_FILEX_BLOCK_MEDIA_EXAMPLE_TOTAL_SECTORS            (1073741824)</span></div><div class="line"><span class="preprocessor">#define RM_FILEX_BLOCK_MEDIA_EXAMPLE_SECTOR_SIZE              (512)</span></div><div class="line"><span class="preprocessor">#define RM_FILEX_BLOCK_MEDIA_EXAMPLE_SECTORS_PER_CLUSTER      (1)</span></div><div class="line"><span class="preprocessor">#define RM_FILEX_BLOCK_MEDIA_EXAMPLE_NUM_HEADS                (1)</span></div><div class="line"><span class="preprocessor">#define RM_FILEX_BLOCK_MEDIA_EXAMPLE_SECTORS_PER_TRACK        (1)</span></div><div class="line"></div><div class="line"><span class="keyword">extern</span> <a class="code" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a___a_p_i.html#structrm__filex__block__media__instance__t">rm_filex_block_media_instance_t</a>      g_filex_block_media0;</div><div class="line"><span class="keyword">extern</span> <a class="code" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a.html#structrm__filex__block__media__instance__ctrl__t">rm_filex_block_media_instance_ctrl_t</a> g_filex_block_media0_ctrl;</div><div class="line"><span class="keyword">extern</span> <a class="code" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a___a_p_i.html#structrm__filex__block__media__cfg__t">rm_filex_block_media_cfg_t</a>           g_filex_block_media0_cfg;</div><div class="line"></div><div class="line"><span class="keyword">extern</span> FX_MEDIA g_fx_media0;</div><div class="line"><span class="keyword">extern</span> uint8_t  g_fx_media0_memory[RM_FILEX_BLOCK_MEDIA_EXAMPLE_BLOCK_SIZE];</div><div class="line"><span class="keyword">extern</span> uint8_t  g_file_data[RM_FILEX_BLOCK_MEDIA_EXAMPLE_BUFFER_SIZE_BYTES];</div><div class="line"><span class="keyword">extern</span> uint8_t  g_read_buffer[RM_FILEX_BLOCK_MEDIA_EXAMPLE_BUFFER_SIZE_BYTES];</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> rm_filex_block_media_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line"></div><div class="line">    <span class="comment">/* Open media driver.*/</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a.html#ga9a2d0b8326679daa0b5e0dcb3e361d08">RM_FILEX_BLOCK_MEDIA_Open</a>(&amp;g_filex_block_media0_ctrl, &amp;g_filex_block_media0_cfg);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize FileX */</span></div><div class="line">    fx_system_initialize();</div><div class="line"></div><div class="line">    <span class="comment">/* Open the media. If the media is removable, it must be inserted before calling</span></div><div class="line"><span class="comment">     * fx_media_open. This assumes the disk is already partitioned and formatted. */</span></div><div class="line">    UINT fx_err = fx_media_open(&amp;g_fx_media0,</div><div class="line">                                <span class="stringliteral">&quot;filex_example_media&quot;</span>,</div><div class="line">                                <a class="code" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a.html#ga137a5f28a4ba749468ec0bf7e2528607">RM_FILEX_BLOCK_MEDIA_BlockDriver</a>,</div><div class="line">                                &amp;g_filex_block_media0,</div><div class="line">                                g_fx_media0_memory,</div><div class="line">                                <span class="keyword">sizeof</span>(g_fx_media0_memory));</div><div class="line">    handle_fx_error(fx_err);</div><div class="line"></div><div class="line">    <span class="comment">/* Create a file */</span></div><div class="line">    fx_err = fx_file_create(&amp;g_fx_media0, RM_FILEX_BLOCK_MEDIA_EXAMPLE_FILE_NAME);</div><div class="line">    handle_fx_error(fx_err);</div><div class="line"></div><div class="line">    <span class="comment">/* Open source file for writing. */</span></div><div class="line">    FX_FILE sourceFile;</div><div class="line">    fx_err = fx_file_open(&amp;g_fx_media0, &amp;sourceFile, RM_FILEX_BLOCK_MEDIA_EXAMPLE_FILE_NAME, FX_OPEN_FOR_WRITE);</div><div class="line">    handle_fx_error(fx_err);</div><div class="line"></div><div class="line">    <span class="comment">/* Write file data. */</span></div><div class="line">    fx_err = fx_file_write(&amp;sourceFile, g_file_data, <span class="keyword">sizeof</span>(g_file_data));</div><div class="line">    handle_fx_error(fx_err);</div><div class="line"></div><div class="line">    <span class="comment">/* Close the file. */</span></div><div class="line">    fx_err = fx_file_close(&amp;sourceFile);</div><div class="line">    handle_fx_error(fx_err);</div><div class="line"></div><div class="line">    <span class="comment">/* Open the source file in read mode. */</span></div><div class="line">    fx_err = fx_file_open(&amp;g_fx_media0, &amp;sourceFile, RM_FILEX_BLOCK_MEDIA_EXAMPLE_FILE_NAME, FX_OPEN_FOR_READ);</div><div class="line">    handle_fx_error(fx_err);</div><div class="line"></div><div class="line">    <span class="comment">/* Read file data. */</span></div><div class="line">    ULONG actual_size_read;</div><div class="line">    fx_err = fx_file_read(&amp;sourceFile, g_read_buffer, <span class="keyword">sizeof</span>(g_file_data), &amp;actual_size_read);</div><div class="line">    handle_fx_error(fx_err);</div><div class="line">    assert(<span class="keyword">sizeof</span>(g_file_data) == actual_size_read);</div><div class="line"></div><div class="line">    <span class="comment">/* Close the file. */</span></div><div class="line">    fx_err = fx_file_close(&amp;sourceFile);</div><div class="line">    handle_fx_error(fx_err);</div><div class="line"></div><div class="line">    <span class="comment">/* Verify the file data read matches the file written. */</span></div><div class="line">    assert(0U == memcmp(g_file_data, g_read_buffer, <span class="keyword">sizeof</span>(g_file_data)));</div><div class="line"></div><div class="line">    <span class="comment">/* Close the Media */</span></div><div class="line">    fx_err = fx_media_close(&amp;g_fx_media0);</div><div class="line">    handle_fx_error(fx_err);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Format Example</h2>
<p>This shows how to partition and format a disk if it is not already partitioned and formatted.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> rm_filex_block_media_format_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Open media driver.*/</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a.html#ga9a2d0b8326679daa0b5e0dcb3e361d08">RM_FILEX_BLOCK_MEDIA_Open</a>(&amp;g_filex_block_media0_ctrl, &amp;g_filex_block_media0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Format the media */</span></div><div class="line">    UINT fx_err = fx_media_format(&amp;g_fx_media0,                                       <span class="comment">// Pointer to FileX media control block.</span></div><div class="line">                                  <a class="code" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a.html#ga137a5f28a4ba749468ec0bf7e2528607">RM_FILEX_BLOCK_MEDIA_BlockDriver</a>,                   <span class="comment">// Driver entry</span></div><div class="line">                                  &amp;g_filex_block_media0,                              <span class="comment">// Pointer to Block Media Driver</span></div><div class="line">                                  g_fx_media0_memory,                                 <span class="comment">// Media buffer pointer</span></div><div class="line">                                  <span class="keyword">sizeof</span>(g_fx_media0_memory),                         <span class="comment">// Media buffer size</span></div><div class="line">                                  <span class="stringliteral">&quot;EXAMPLE_VOLUME&quot;</span>,                                   <span class="comment">// Volume Name</span></div><div class="line">                                  RM_FILEX_BLOCK_MEDIA_EXAMPLE_NUM_FATS,              <span class="comment">// Number of FATs</span></div><div class="line">                                  RM_FILEX_BLOCK_MEDIA_EXAMPLE_NUM_DIRECTORY_ENTRIES, <span class="comment">// Directory Entries</span></div><div class="line">                                  RM_FILEX_BLOCK_MEDIA_EXAMPLE_HIDDEN_SECTORS,        <span class="comment">// Hidden sectors</span></div><div class="line">                                  RM_FILEX_BLOCK_MEDIA_EXAMPLE_TOTAL_SECTORS,         <span class="comment">// Total sectors</span></div><div class="line">                                  RM_FILEX_BLOCK_MEDIA_EXAMPLE_SECTOR_SIZE,           <span class="comment">// Sector size</span></div><div class="line">                                  RM_FILEX_BLOCK_MEDIA_EXAMPLE_SECTORS_PER_CLUSTER,   <span class="comment">// Sectors per cluster</span></div><div class="line">                                  RM_FILEX_BLOCK_MEDIA_EXAMPLE_NUM_HEADS,             <span class="comment">// Heads</span></div><div class="line">                                  RM_FILEX_BLOCK_MEDIA_EXAMPLE_SECTORS_PER_TRACK);    <span class="comment">// Sectors per track</span></div><div class="line">    handle_fx_error(fx_err);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Callback Pend Example</h2>
<p>This shows how to use the I/O driver callback with ThreadX in order to wait/pend for operations to complete.</p>
<div class="fragment"><div class="line">TX_SEMAPHORE g_operation_wait_semaphore;</div><div class="line"></div><div class="line"><span class="comment">/* Callback called by FileX block media I/O driver needs to pend on operation. */</span></div><div class="line"><span class="keywordtype">void</span> rm_filex_block_media_test_callback_pend (<a class="code" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a___a_p_i.html#structrm__filex__block__media__callback__args__t">rm_filex_block_media_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (p_args-&gt;<a class="code" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a___a_p_i.html#a9daee8dc246992319bf85f04ecead786">event</a> &amp; <a class="code" href="group___r_m___b_l_o_c_k___m_e_d_i_a___a_p_i.html#ggaa3f328da3b53e36f2682f63d0ae1c96ca0bcf0a99f241213e4a0599f687de715d">RM_BLOCK_MEDIA_EVENT_WAIT</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Interrupt has not happened for operation, get semaphore to wait for it. This will be called from the FileX I/O driver thread. */</span></div><div class="line">        tx_semaphore_get(&amp;g_operation_wait_semaphore, TX_WAIT_FOREVER);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (p_args-&gt;<a class="code" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a___a_p_i.html#a9daee8dc246992319bf85f04ecead786">event</a> &amp; <a class="code" href="group___r_m___b_l_o_c_k___m_e_d_i_a___a_p_i.html#ggaa3f328da3b53e36f2682f63d0ae1c96cab2141da3f7b3e229d63e6dbc4a7d4d4c">RM_BLOCK_MEDIA_EVENT_WAIT_END</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Interrupt has occurred for operation, post semaphore so that wait will end. This will be called from an interrupt context. */</span></div><div class="line">        tx_semaphore_put(&amp;g_operation_wait_semaphore);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (p_args-&gt;<a class="code" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a___a_p_i.html#a9daee8dc246992319bf85f04ecead786">event</a> &amp; <a class="code" href="group___r_m___b_l_o_c_k___m_e_d_i_a___a_p_i.html#ggaa3f328da3b53e36f2682f63d0ae1c96cad5d83659edff4f48bfda6d323aaed3e9">RM_BLOCK_MEDIA_EVENT_POLL_STATUS</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Interrupt has been received from block media device but operation is still ongoing. The FileX I/O driver will wait on the driver busy status.</span></div><div class="line"><span class="comment">         * This event can be used to put the thread to sleep while waiting. This will be called from the FileX I/O driver thread. */</span></div><div class="line">        tx_thread_sleep(1);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> rm_filex_block_media_callback_pend_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Create semaphore for driver use */</span></div><div class="line">    tx_semaphore_create(&amp;g_operation_wait_semaphore, <span class="stringliteral">&quot;operation_wait_semaphore&quot;</span>, 0);</div><div class="line"></div><div class="line">    <span class="comment">/* Open media driver.*/</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a.html#ga9a2d0b8326679daa0b5e0dcb3e361d08">RM_FILEX_BLOCK_MEDIA_Open</a>(&amp;g_filex_block_media0_ctrl, &amp;g_filex_block_media0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Format the media */</span></div><div class="line">    UINT fx_err = fx_media_format(&amp;g_fx_media0,                                       <span class="comment">// Pointer to FileX media control block.</span></div><div class="line">                                  <a class="code" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a.html#ga137a5f28a4ba749468ec0bf7e2528607">RM_FILEX_BLOCK_MEDIA_BlockDriver</a>,                   <span class="comment">// Driver entry</span></div><div class="line">                                  &amp;g_filex_block_media0,                              <span class="comment">// Pointer to Block Media Driver</span></div><div class="line">                                  g_fx_media0_memory,                                 <span class="comment">// Media buffer pointer</span></div><div class="line">                                  <span class="keyword">sizeof</span>(g_fx_media0_memory),                         <span class="comment">// Media buffer size</span></div><div class="line">                                  <span class="stringliteral">&quot;EXAMPLE_VOLUME&quot;</span>,                                   <span class="comment">// Volume Name</span></div><div class="line">                                  RM_FILEX_BLOCK_MEDIA_EXAMPLE_NUM_FATS,              <span class="comment">// Number of FATs</span></div><div class="line">                                  RM_FILEX_BLOCK_MEDIA_EXAMPLE_NUM_DIRECTORY_ENTRIES, <span class="comment">// Directory Entries</span></div><div class="line">                                  RM_FILEX_BLOCK_MEDIA_EXAMPLE_HIDDEN_SECTORS,        <span class="comment">// Hidden sectors</span></div><div class="line">                                  RM_FILEX_BLOCK_MEDIA_EXAMPLE_TOTAL_SECTORS,         <span class="comment">// Total sectors</span></div><div class="line">                                  RM_FILEX_BLOCK_MEDIA_EXAMPLE_SECTOR_SIZE,           <span class="comment">// Sector size</span></div><div class="line">                                  RM_FILEX_BLOCK_MEDIA_EXAMPLE_SECTORS_PER_CLUSTER,   <span class="comment">// Sectors per cluster</span></div><div class="line">                                  RM_FILEX_BLOCK_MEDIA_EXAMPLE_NUM_HEADS,             <span class="comment">// Heads</span></div><div class="line">                                  RM_FILEX_BLOCK_MEDIA_EXAMPLE_SECTORS_PER_TRACK);    <span class="comment">// Sectors per track</span></div><div class="line">    handle_fx_error(fx_err);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Media Insertion Example</h2>
<p>This shows how to use the callback to wait for media insertion.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keyword">volatile</span> uint32_t g_rm_filex_block_media_insertion_events = 0;</div><div class="line"><span class="keyword">volatile</span> uint32_t g_rm_filex_block_media_removal_events   = 0;</div><div class="line"></div><div class="line"><span class="comment">/* Callback called by media driver when a removable device is inserted or removed. */</span></div><div class="line"><span class="keywordtype">void</span> rm_filex_block_media_test_callback (<a class="code" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a___a_p_i.html#structrm__filex__block__media__callback__args__t">rm_filex_block_media_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (p_args-&gt;<a class="code" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a___a_p_i.html#a9daee8dc246992319bf85f04ecead786">event</a> &amp; <a class="code" href="group___r_m___b_l_o_c_k___m_e_d_i_a___a_p_i.html#ggaa3f328da3b53e36f2682f63d0ae1c96ca824ad009871b7f393b49e7a8a63c6ed9">RM_BLOCK_MEDIA_EVENT_MEDIA_INSERTED</a>)</div><div class="line">    {</div><div class="line">        g_rm_filex_block_media_insertion_events++;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (p_args-&gt;<a class="code" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a___a_p_i.html#a9daee8dc246992319bf85f04ecead786">event</a> &amp; <a class="code" href="group___r_m___b_l_o_c_k___m_e_d_i_a___a_p_i.html#ggaa3f328da3b53e36f2682f63d0ae1c96cae1eaef4a8e7225d6ccee904c4e6795df">RM_BLOCK_MEDIA_EVENT_MEDIA_REMOVED</a>)</div><div class="line">    {</div><div class="line">        g_rm_filex_block_media_removal_events++;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> rm_filex_block_media_media_insertion_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Open media driver.*/</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a.html#ga9a2d0b8326679daa0b5e0dcb3e361d08">RM_FILEX_BLOCK_MEDIA_Open</a>(&amp;g_filex_block_media0_ctrl, &amp;g_filex_block_media0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for media insertion. */</span></div><div class="line">    <span class="keywordflow">while</span> (0U == g_rm_filex_block_media_insertion_events)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait for media insertion. */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Open the media. If the media is removable, it must be inserted before calling</span></div><div class="line"><span class="comment">     * fx_media_open. This assumes the disk is already partitioned and formatted. */</span></div><div class="line">    UINT fx_err = fx_media_open(&amp;g_fx_media0,</div><div class="line">                                <span class="stringliteral">&quot;filex_example_media&quot;</span>,</div><div class="line">                                <a class="code" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a.html#ga137a5f28a4ba749468ec0bf7e2528607">RM_FILEX_BLOCK_MEDIA_BlockDriver</a>,</div><div class="line">                                &amp;g_filex_block_media0,</div><div class="line">                                g_fx_media0_memory,</div><div class="line">                                <span class="keyword">sizeof</span>(g_fx_media0_memory));</div><div class="line">    handle_fx_error(fx_err);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Using FileX with Custom Block Media Implementations</h2>
<p>When using a Custom Block Media implementation with rm_filex_block_media the custom implementation must call rm_filex_block_media_memory_callback upon the completion of a read/write operation. This callback should be called with an event of RM_BLOCK_MEDIA_EVENT_OPERATION_COMPLETE and p_context of <a class="el" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a.html#structrm__filex__block__media__instance__ctrl__t">rm_filex_block_media_instance_ctrl_t</a> *. The following example shows how this should be done in the context of a demo RAM block media read function.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define EXAMPLE_BLOCK_MEDIA_RAM_START_ADDR          (0x20004AFE)</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_BLOCK_MEDIA_RAM_BLOCK_SIZE_BYTES    (512)</span></div><div class="line"></div><div class="line"><span class="comment">/* Example implementation of rm_block_media_api_t::read(), user should define custom block media RAM implementation. */</span></div><div class="line"><a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> RM_BLOCK_MEDIA_CUSTOM_RAM_Read (<a class="code" href="group___r_m___b_l_o_c_k___m_e_d_i_a___a_p_i.html#ga19bc09de5e45b09066d0bddcc46956b0">rm_block_media_ctrl_t</a> * <span class="keyword">const</span> p_ctrl,</div><div class="line">                                          uint8_t * <span class="keyword">const</span>               p_dest_address,</div><div class="line">                                          uint32_t <span class="keyword">const</span>                block_address,</div><div class="line">                                          uint32_t <span class="keyword">const</span>                num_blocks)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gaf0afcbc9a110ac9366a811d96ee06029">FSP_PARAMETER_NOT_USED</a>(p_ctrl);</div><div class="line"></div><div class="line">    memcpy(p_dest_address,</div><div class="line">           (<span class="keywordtype">void</span> *) (EXAMPLE_BLOCK_MEDIA_RAM_START_ADDR + (block_address * EXAMPLE_BLOCK_MEDIA_RAM_BLOCK_SIZE_BYTES)),</div><div class="line">           (EXAMPLE_BLOCK_MEDIA_RAM_BLOCK_SIZE_BYTES * num_blocks));</div><div class="line"></div><div class="line">    <span class="comment">/* Notify FileX port of operation complete through calling the callback, this is required for custom block media/FileX port integration */</span></div><div class="line">    <a class="code" href="group___r_m___b_l_o_c_k___m_e_d_i_a___a_p_i.html#structrm__block__media__callback__args__t">rm_block_media_callback_args_t</a> args;</div><div class="line">    args.<a class="code" href="group___r_m___b_l_o_c_k___m_e_d_i_a___a_p_i.html#aa13fc0ea05379836574c850687293ade">event</a>     = <a class="code" href="group___r_m___b_l_o_c_k___m_e_d_i_a___a_p_i.html#ggaa3f328da3b53e36f2682f63d0ae1c96ca5150a4a6be559ecc22ce94d509af55e3">RM_BLOCK_MEDIA_EVENT_OPERATION_COMPLETE</a>;</div><div class="line">    args.<a class="code" href="group___r_m___b_l_o_c_k___m_e_d_i_a___a_p_i.html#ab4bf95c6ac852ce84523363671b60af3">p_context</a> = (<span class="keywordtype">void</span> *) &amp;g_filex_block_media0_ctrl;</div><div class="line">    rm_filex_block_media_memory_callback(&amp;args);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> FSP_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structrm__filex__block__media__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a.html#structrm__filex__block__media__instance__ctrl__t">rm_filex_block_media_instance_ctrl_t</a></td></tr>
<tr class="separator:structrm__filex__block__media__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structrm__filex__block__media__instance__ctrl__t" id="structrm__filex__block__media__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structrm__filex__block__media__instance__ctrl__t">&#9670;&nbsp;</a></span>rm_filex_block_media_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rm_filex_block_media_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Common macro for FSP header files. There is also a corresponding FSP_FOOTER macro at the end of this file. FileX block media private control block. DO NOT MODIFY. Initialization occurs when RM_FILEX_BLOCK_MEDIA_Open is called. </p>
</div>
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9a2d0b8326679daa0b5e0dcb3e361d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a2d0b8326679daa0b5e0dcb3e361d08">&#9670;&nbsp;</a></span>RM_FILEX_BLOCK_MEDIA_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> RM_FILEX_BLOCK_MEDIA_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a___a_p_i.html#ga1514f18e864b2396487bc68704841e7f">rm_filex_block_media_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a___a_p_i.html#structrm__filex__block__media__cfg__t">rm_filex_block_media_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The file system relies on the media to be formatted prior to creating directories and files The sector size and sector count will change depending on the media type and size.</p>
<p>The File Allocation Table (FAT) starts after the reserved sectors in the media. The FAT area is basically an array of 12-bit, 16-bit, or 32-bit entries that determine if that cluster is allocated or part of a chain of clusters comprising a subdirectory or a file. The size of each FAT entry is determined by the number of clusters that need to be represented. If the number of clusters (derived from the total sectors divided by the sectors per cluster) is less than 4,086, 12-bit FAT entries are used. If the total number of clusters is greater than 4,086 and less than or equal to 65,525, 16-bit FAT entries are used. Otherwise, if the total number of clusters is greater than 65,525, 32-bit FAT entries are used. Initializes callback and configuration for FileX Block Media interface. Call this before calling any FileX functions.</p>
<p>Implements <a class="el" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a___a_p_i.html#ad25250a24321b77c1bcca53f184b1c4b">rm_filex_block_media_api_t::open()</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Success. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input parameter was invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Module is already open.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html">Common Error Codes</a> or functions called by this function for other possible return codes. </dd></dl>

</div>
</div>
<a id="ga00b16572b181e4e0f79f64268d5dca17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00b16572b181e4e0f79f64268d5dca17">&#9670;&nbsp;</a></span>RM_FILEX_BLOCK_MEDIA_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> RM_FILEX_BLOCK_MEDIA_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a___a_p_i.html#ga1514f18e864b2396487bc68704841e7f">rm_filex_block_media_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes media device.</p>
<p>Implements <a class="el" href="group___r_m___f_i_l_e_x___b_l_o_c_k___m_e_d_i_a___a_p_i.html#aec93d5fe85ac5c8e8ddf175409c5c120">rm_filex_block_media_api_t::close()</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Media device closed. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input parameter was invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module not open.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html">Common Error Codes</a> or functions called by this function for other possible return codes. </dd></dl>

</div>
</div>
<a id="ga137a5f28a4ba749468ec0bf7e2528607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga137a5f28a4ba749468ec0bf7e2528607">&#9670;&nbsp;</a></span>RM_FILEX_BLOCK_MEDIA_BlockDriver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RM_FILEX_BLOCK_MEDIA_BlockDriver </td>
          <td>(</td>
          <td class="paramtype">FX_MEDIA *&#160;</td>
          <td class="paramname"><em>p_fx_media</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access Block Media device functions open, close, read, write and control. </p>
<p>The RM_FILEX_BLOCK_MEDIA_BlockDriver function is called from the FileX file system driver and issues requests to a Block Media device through the FSP Block Media Interface. Uses block media driver for accesses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_fx_media</td><td>FileX media control block. All information about each open media device are maintained in the FX_MEDIA data type. The I/O driver communicates the success or failure of the request through the fx_media_driver_status member of FX_MEDIA (p_fx_media-&gt;fx_media_driver_status). Possible values are documented in the FileX User Guide.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing, but updates FileX media control block. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v5.4.0 User's Manual Copyright Â© (2024) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
