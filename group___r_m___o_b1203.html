<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: OB1203 Light/Proximity/PPG Sensor Middleware (rm_ob1203)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v3.7.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">
 
    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text"> 
      </span>
      <span class="right">
          &nbsp; 
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___r_m___o_b1203.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() { 
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body. 
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works 
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len)); 
            }
          } 
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }    
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element. 
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;  
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<div class="title">OB1203 Light/Proximity/PPG Sensor Middleware (rm_ob1203)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___s_e_n_s_o_r___m_o_d_u_l_e_s.html">Sensor</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga34d3b67d431ab9cdb45fa561196d8e85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#ga34d3b67d431ab9cdb45fa561196d8e85">RM_OB1203_Open</a> (<a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__cfg__t">rm_ob1203_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="memdesc:ga34d3b67d431ab9cdb45fa561196d8e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens and configures the OB1203 Middle module. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#a3d137e0be66735864d9a95669fa2c1f3">rm_ob1203_api_t::open</a>.  <a href="#ga34d3b67d431ab9cdb45fa561196d8e85">More...</a><br /></td></tr>
<tr class="separator:ga34d3b67d431ab9cdb45fa561196d8e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff536e258d187d8efd6fac712ca885e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#gaff536e258d187d8efd6fac712ca885e1">RM_OB1203_Close</a> (<a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="memdesc:gaff536e258d187d8efd6fac712ca885e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables specified OB1203 control block. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#afb392158117d2cc57e8c0ec5042b1361">rm_ob1203_api_t::close</a>.  <a href="#gaff536e258d187d8efd6fac712ca885e1">More...</a><br /></td></tr>
<tr class="separator:gaff536e258d187d8efd6fac712ca885e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabca4420cac85f4ea23be2454863d443"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#gaabca4420cac85f4ea23be2454863d443">RM_OB1203_MeasurementStart</a> (<a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="memdesc:gaabca4420cac85f4ea23be2454863d443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start measurement. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#af9780f361fb17b04000550de7543134a">rm_ob1203_api_t::measurementStart</a>.  <a href="#gaabca4420cac85f4ea23be2454863d443">More...</a><br /></td></tr>
<tr class="separator:gaabca4420cac85f4ea23be2454863d443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab851b2d1c598510756bea3608f3261a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#gab851b2d1c598510756bea3608f3261a3">RM_OB1203_MeasurementStop</a> (<a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="memdesc:gab851b2d1c598510756bea3608f3261a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop measurement. If device interrupt is enabled, interrupt bits are cleared after measurement stop. If PPG mode, FIFO information is also reset after measurement stop. In RTOS and Light/Proximity/Light Proximity mode, if device interrupt is enabled, blocks 2 bytes on the I2C bus. In RTOS and PPG mode, if device interrupt is enabled, blocks 6 bytes on the I2C bus. If device interrupt is disabled, blocks 4 bytes on the I2C bus. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#a9365629cc58e4f4c9cf33420b07416f5">rm_ob1203_api_t::measurementStop</a>.  <a href="#gab851b2d1c598510756bea3608f3261a3">More...</a><br /></td></tr>
<tr class="separator:gab851b2d1c598510756bea3608f3261a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3e86f2d3ee11e505e5df6fc8e1b5c1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#gad3e86f2d3ee11e505e5df6fc8e1b5c1f">RM_OB1203_LightRead</a> (<a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__raw__data__t">rm_ob1203_raw_data_t</a> *const p_raw_data, <a class="el" href="group___r_m___o_b1203___a_p_i.html#ga0c0d347b4e6af84c4f4148ea68280337">rm_ob1203_light_data_type_t</a> type)</td></tr>
<tr class="memdesc:gad3e86f2d3ee11e505e5df6fc8e1b5c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads Light ADC data from OB1203 device. If device interrupt is enabled, interrupt bits are cleared after data read. In RTOS and Light mode, if device interrupt is enabled, blocks 2 bytes on the I2C bus. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#ad778eb596d6af74ccedec46ed4dec9f7">rm_ob1203_api_t::lightRead</a>.  <a href="#gad3e86f2d3ee11e505e5df6fc8e1b5c1f">More...</a><br /></td></tr>
<tr class="separator:gad3e86f2d3ee11e505e5df6fc8e1b5c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56f8661c39d7b7b41e0799d528f08c92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#ga56f8661c39d7b7b41e0799d528f08c92">RM_OB1203_LightDataCalculate</a> (<a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__raw__data__t">rm_ob1203_raw_data_t</a> *const p_raw_data, <a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__light__data__t">rm_ob1203_light_data_t</a> *const p_ob1203_data)</td></tr>
<tr class="memdesc:ga56f8661c39d7b7b41e0799d528f08c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate light data from raw data. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#aa3ca0efc07f8e5cdf3086fe422239b60">rm_ob1203_api_t::lightDataCalculate</a>.  <a href="#ga56f8661c39d7b7b41e0799d528f08c92">More...</a><br /></td></tr>
<tr class="separator:ga56f8661c39d7b7b41e0799d528f08c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1de710492d4da21656a5cbd62eb2b721"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#ga1de710492d4da21656a5cbd62eb2b721">RM_OB1203_ProxRead</a> (<a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__raw__data__t">rm_ob1203_raw_data_t</a> *const p_raw_data)</td></tr>
<tr class="memdesc:ga1de710492d4da21656a5cbd62eb2b721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads Proximity ADC data from OB1203 device. If device interrupt is enabled, interrupt bits are cleared after data read. In RTOS and Proximity mode, if device interrupt is enabled, blocks 2 bytes on the I2C bus. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#a198466f69342eda1f86d4853d0157f22">rm_ob1203_api_t::proxRead</a>.  <a href="#ga1de710492d4da21656a5cbd62eb2b721">More...</a><br /></td></tr>
<tr class="separator:ga1de710492d4da21656a5cbd62eb2b721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5888f249d9e67a2af39ce7977065d359"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#ga5888f249d9e67a2af39ce7977065d359">RM_OB1203_ProxDataCalculate</a> (<a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__raw__data__t">rm_ob1203_raw_data_t</a> *const p_raw_data, <a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__prox__data__t">rm_ob1203_prox_data_t</a> *const p_ob1203_data)</td></tr>
<tr class="memdesc:ga5888f249d9e67a2af39ce7977065d359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate proximity data from raw data. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#a9b7d68fb7a2baf7cca79ff3026e36cd5">rm_ob1203_api_t::proxDataCalculate</a>.  <a href="#ga5888f249d9e67a2af39ce7977065d359">More...</a><br /></td></tr>
<tr class="separator:ga5888f249d9e67a2af39ce7977065d359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga306ea4427230d2c7c2e2c0ae53346a0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#ga306ea4427230d2c7c2e2c0ae53346a0b">RM_OB1203_PpgRead</a> (<a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__raw__data__t">rm_ob1203_raw_data_t</a> *const p_raw_data, uint8_t const number_of_samples)</td></tr>
<tr class="memdesc:ga306ea4427230d2c7c2e2c0ae53346a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads PPG ADC data from OB1203 device. One sample requires three bytes. 0 cannot set to the number of samples. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#a9f902d2c8bf975288a49f443f20092ae">rm_ob1203_api_t::ppgRead</a>.  <a href="#ga306ea4427230d2c7c2e2c0ae53346a0b">More...</a><br /></td></tr>
<tr class="separator:ga306ea4427230d2c7c2e2c0ae53346a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffe63df6ba35eb27989b694af004a87b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#gaffe63df6ba35eb27989b694af004a87b">RM_OB1203_PpgDataCalculate</a> (<a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__raw__data__t">rm_ob1203_raw_data_t</a> *const p_raw_data, <a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__ppg__data__t">rm_ob1203_ppg_data_t</a> *const p_ob1203_data)</td></tr>
<tr class="memdesc:gaffe63df6ba35eb27989b694af004a87b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate PPG data from raw data. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#a2f7c11ddb2c3d8c9cf91c25e3183daa1">rm_ob1203_api_t::ppgDataCalculate</a>.  <a href="#gaffe63df6ba35eb27989b694af004a87b">More...</a><br /></td></tr>
<tr class="separator:gaffe63df6ba35eb27989b694af004a87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga554b7652ea5ee0de096b21e6580f164f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#ga554b7652ea5ee0de096b21e6580f164f">RM_OB1203_GainSet</a> (<a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__gain__t">rm_ob1203_gain_t</a> const gain)</td></tr>
<tr class="memdesc:ga554b7652ea5ee0de096b21e6580f164f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set gain. This function should be called after calling <a class="el" href="group___r_m___o_b1203.html#gab851b2d1c598510756bea3608f3261a3" title="Stop measurement. If device interrupt is enabled, interrupt bits are cleared after measurement stop...">RM_OB1203_MeasurementStop()</a>. In RTOS and Light Proximity mode, blocks 2 bytes on the I2C bus. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#a82fdd4f8e1ef45d2f06a355d60979968">rm_ob1203_api_t::gainSet</a>.  <a href="#ga554b7652ea5ee0de096b21e6580f164f">More...</a><br /></td></tr>
<tr class="separator:ga554b7652ea5ee0de096b21e6580f164f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5666b0538afdae80059de7271667694c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#ga5666b0538afdae80059de7271667694c">RM_OB1203_LedCurrentSet</a> (<a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__led__current__t">rm_ob1203_led_current_t</a> const led_current)</td></tr>
<tr class="memdesc:ga5666b0538afdae80059de7271667694c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set currents. This function should be called after calling <a class="el" href="group___r_m___o_b1203.html#gab851b2d1c598510756bea3608f3261a3" title="Stop measurement. If device interrupt is enabled, interrupt bits are cleared after measurement stop...">RM_OB1203_MeasurementStop()</a>. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#a7d3decdc87199472697b5aec3387d406">rm_ob1203_api_t::ledCurrentSet</a>.  <a href="#ga5666b0538afdae80059de7271667694c">More...</a><br /></td></tr>
<tr class="separator:ga5666b0538afdae80059de7271667694c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae791e9a53d7642b5ab9bed5ddfb195fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#gae791e9a53d7642b5ab9bed5ddfb195fa">RM_OB1203_DeviceInterruptCfgSet</a> (<a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__device__interrupt__cfg__t">rm_ob1203_device_interrupt_cfg_t</a> const interrupt_cfg)</td></tr>
<tr class="memdesc:gae791e9a53d7642b5ab9bed5ddfb195fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set device interrupt configurations. This function should be called after calling <a class="el" href="group___r_m___o_b1203.html#gab851b2d1c598510756bea3608f3261a3" title="Stop measurement. If device interrupt is enabled, interrupt bits are cleared after measurement stop...">RM_OB1203_MeasurementStop()</a>. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#a32be3218edf3a0a22e3fd7403ae8d5e7">rm_ob1203_api_t::deviceInterruptCfgSet</a>.  <a href="#gae791e9a53d7642b5ab9bed5ddfb195fa">More...</a><br /></td></tr>
<tr class="separator:gae791e9a53d7642b5ab9bed5ddfb195fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ffbbe58d90adb8001d2f6424987e71b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#ga6ffbbe58d90adb8001d2f6424987e71b">RM_OB1203_FifoInfoGet</a> (<a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__fifo__info__t">rm_ob1203_fifo_info_t</a> *const p_fifo_info)</td></tr>
<tr class="memdesc:ga6ffbbe58d90adb8001d2f6424987e71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get FIFO information from OB1203 device. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#ace63f4f8958af6e1424ad4fa176bbcf2">rm_ob1203_api_t::fifoInfoGet</a>.  <a href="#ga6ffbbe58d90adb8001d2f6424987e71b">More...</a><br /></td></tr>
<tr class="separator:ga6ffbbe58d90adb8001d2f6424987e71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13ab57714aafa9a3023a32f83c88e1dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#ga13ab57714aafa9a3023a32f83c88e1dd">RM_OB1203_DeviceStatusGet</a> (<a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__device__status__t">rm_ob1203_device_status_t</a> *const p_status)</td></tr>
<tr class="memdesc:ga13ab57714aafa9a3023a32f83c88e1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get device status from OB1203 device. Clear all interrupt bits. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#abd612814bfe809e1435fab3ba2c6b2e2">rm_ob1203_api_t::deviceStatusGet</a>.  <a href="#ga13ab57714aafa9a3023a32f83c88e1dd">More...</a><br /></td></tr>
<tr class="separator:ga13ab57714aafa9a3023a32f83c88e1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Middleware to implement the OB1203 sensor interface. This module implements the <a class="el" href="group___r_m___o_b1203___a_p_i.html">OB1203 Middleware Interface</a>. </p>
<h1><a class="anchor" id="rm-ob1203-overview"></a>
Overview</h1>
<p>This module provides APIs for configuring and controlling the OB1203 sensor operation modes. Supported OB1203 sensor operation modes are below.</p><ul>
<li>Light mode</li>
<li>Proximity mode</li>
<li>Light Proximity mode</li>
<li>PPG mode</li>
</ul>
<h2><a class="anchor" id="rm-ob1203-features"></a>
Features</h2>
<p>The OB1203 sensor interface implementation has the following key features:</p><ul>
<li>Initialize the sensor for measurement<a class="anchor" id="um_rm_ob1203_configuration"></a></li>
<li>Start and stop a measurement at any time<a class="anchor" id="um_rm_ob1203_measurementstart"></a></li>
<li>Get the ADC data from the sensor<a class="anchor" id="um_rm_ob1203_read"></a></li>
<li>Calculate the Light/Proximity/PPG values.<a class="anchor" id="um_rm_ob1203_datacalculate"></a></li>
<li>Software reset</li>
</ul>
<h1><a class="anchor" id="rm-ob1203-configuration"></a>
Configuration</h1>
<p><h2>Build Time Configurations for rm_ob1203</h2>
The following build time configurations are defined in fsp_cfg/rm_ob1203_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
</table>
 <h2>Configurations for Sensor &gt; OB1203 Light/Proximity/PPG Sensor (rm_ob1203)</h2>
This module can be added to the Stacks tab via New Stack &gt; Sensor &gt; OB1203 Light/Proximity/PPG Sensor (rm_ob1203).<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Name</td><td>Manual Entry</td><td>g_ob1203_sensor0 </td><td>Module name. </td></tr>
<tr>
<td>Semaphore Timeout (RTOS only)</td><td>Value must be a non-negative integer</td><td>0xFFFFFFFF </td><td>Set timeout for blocking in using RTOS. </td></tr>
<tr>
<td>Comms I2C Callback</td><td>Name must be a valid C symbol</td><td>ob1203_comms_i2c_callback </td><td>A user COMMS I2C callback function can be provided. </td></tr>
<tr>
<td>IRQ Callback</td><td>Name must be a valid C symbol</td><td>ob1203_irq_callback </td><td>A user IRQ callback function can be provided. </td></tr>
</table>
 <h2>Configurations for Sensor &gt; OB1203 Light mode (rm_ob1203)</h2>
<table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Operation Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
LS mode</li>
<li>
CS mode</li>
</ul>
</td><td>LS mode </td><td>Set operation mode. </td></tr>
<tr>
<td>Interrupt Type</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Threshold</li>
<li>
Variation</li>
</ul>
</td><td>Threshold </td><td>Set interrupt type. </td></tr>
<tr>
<td>Interrupt Source</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Clear channel</li>
<li>
Green channel</li>
<li>
Red channel (CS mode only)</li>
<li>
Blue channel (CS mode only)</li>
</ul>
</td><td>Clear channel </td><td>Set interrupt source. </td></tr>
<tr>
<td>The Number of Similar Consecutive Interrupt Events</td><td>Value must be a non-negative integer</td><td>0x02 </td><td>The number of similar consecutive Light mode interrupt events that must occur before the interrupt is asserted (4bits). Min = 0x0 and Max = 0xF </td></tr>
<tr>
<td>Sleep after Interrupt</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Set sleep after interrupt. </td></tr>
<tr>
<td>Gain</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1</li>
<li>
3</li>
<li>
6</li>
</ul>
</td><td>3 </td><td>Set gain for detection range. </td></tr>
<tr>
<td>Resolution and Measurement Period</td><td>Refer to the RA Configuration tool for available options.</td><td>Resolution:18bit. Measurement Period:100ms </td><td>Set resolution and measurement period. </td></tr>
<tr>
<td>Upper Threshold</td><td>Value must be a non-negative integer</td><td>0x00CCC </td><td>Set upper threshold value (20bits). Min = 0x00000 and Max = 0xFFFFF. </td></tr>
<tr>
<td>Lower Threshold</td><td>Value must be a non-negative integer</td><td>0x00000 </td><td>Set lower threshold value (20bits). Min = 0x00000 and Max = 0xFFFFF. </td></tr>
<tr>
<td>Variance Threshold</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
+/- 8 counts</li>
<li>
+/- 16 counts</li>
<li>
+/- 32 counts</li>
<li>
+/- 64 counts</li>
<li>
+/- 128 counts</li>
<li>
+/- 256 counts</li>
<li>
+/- 512 counts</li>
<li>
+/- 1024 counts</li>
</ul>
</td><td>+/- 128 counts </td><td>Set variance threshold. New data varies by selected counts compared to previous result. </td></tr>
</table>
 <h2>Configurations for Sensor &gt; OB1203 Proximity mode (rm_ob1203)</h2>
<table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Interrupt Type</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Normal</li>
<li>
Logic</li>
</ul>
</td><td>Normal </td><td>Set interrupt type. </td></tr>
<tr>
<td>The Number of Similar Consecutive Interrupt Events</td><td>Value must be a non-negative integer</td><td>0x02 </td><td>The number of similar consecutive Proximity mode interrupt events that must occur before the interrupt is asserted (4bits). Min = 0x0 and Max = 0xF </td></tr>
<tr>
<td>Sleep after Interrupt</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Set sleep after interrupt. </td></tr>
<tr>
<td>Gain</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1</li>
<li>
1.5</li>
<li>
2</li>
<li>
4</li>
</ul>
</td><td>1 </td><td>Set gain of ADC output and noise. </td></tr>
<tr>
<td>LED Current</td><td>Value must be a non-negative integer</td><td>0x100 </td><td>Set Current for LED (10bits). Min = 0x000 and Max = 0x3FF </td></tr>
<tr>
<td>LED Order</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
IR LED first, Red LED second</li>
<li>
Red LED first, IR LED second</li>
</ul>
</td><td>IR LED first, Red LED second </td><td>Set LED order. </td></tr>
<tr>
<td>LED Analog Cancellation</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (50% offset of the full-scale value)</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Set analog cancellation level. </td></tr>
<tr>
<td>LED Digital Cancellation</td><td>Value must be a non-negative integer</td><td>0x100 </td><td>Set digital cancellation level (16bits). Min = 0x0000 and Max = 0xFFFF </td></tr>
<tr>
<td>Number of LED pulses</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1 pulse</li>
<li>
2 pulses</li>
<li>
4 pulses</li>
<li>
8 pulses</li>
<li>
16 pulses</li>
<li>
32 pulses</li>
</ul>
</td><td>8 pulses </td><td>Set number of LED pulses. </td></tr>
<tr>
<td>Pulse Width and Measurement Period</td><td>Refer to the RA Configuration tool for available options.</td><td>Pulse width:42us. Measurement Period:100ms </td><td>Set pulse width and measurement period. </td></tr>
<tr>
<td>Moving Average</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Set moving average. </td></tr>
<tr>
<td>Hysteresis</td><td>Value must be a non-negative integer</td><td>0x00 </td><td>Set hysteresis level (7bits). Min = 0x00 and Max = 0x7F. </td></tr>
<tr>
<td>Upper Threshold</td><td>Value must be a non-negative integer</td><td>0x0600 </td><td>Set upper threshold value (16bits). Min = 0x0000 and Max = 0xFFFF. </td></tr>
<tr>
<td>Lower Threshold</td><td>Value must be a non-negative integer</td><td>0x0000 </td><td>Set lower threshold value (16bits). Min = 0x0000 and Max = 0xFFFF. </td></tr>
</table>
 <h2>Configurations for Sensor &gt; OB1203 PPG mode (rm_ob1203)</h2>
<table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Operation Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
PPG1 mode</li>
<li>
PPG2 mode</li>
</ul>
</td><td>PPG2 mode </td><td>Set operation mode. </td></tr>
<tr>
<td>Interrupt Type</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Data</li>
<li>
FIFO Almost Full</li>
</ul>
</td><td>Data </td><td>Set interrupt type. </td></tr>
<tr>
<td>Gain</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1</li>
<li>
1.5</li>
<li>
2</li>
<li>
4</li>
</ul>
</td><td>1 </td><td>Set gain of ADC output and noise. </td></tr>
<tr>
<td>IR LED Current</td><td>Value must be a non-negative integer</td><td>0x366 </td><td>Set Current for IR LED (10bits). Min = 0x000 and Max = 0x3FF </td></tr>
<tr>
<td>Red LED Current</td><td>Value must be a non-negative integer</td><td>0x1B3 </td><td>Set Current for Red LED (9bits). Min = 0x000 and Max = 0x1FF </td></tr>
<tr>
<td>Power Save Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Set power save mode. </td></tr>
<tr>
<td>LED Order</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
IR LED first, Red LED second</li>
<li>
Red LED first, IR LED second</li>
</ul>
</td><td>IR LED first, Red LED second </td><td>Set LED order. </td></tr>
<tr>
<td>IR LED Analog Cancellation</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (50% offset of the full-scale value)</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Set analog cancellation level. </td></tr>
<tr>
<td>Red LED Analog Cancellation</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (50% offset of the full-scale value)</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Set analog cancellation level. </td></tr>
<tr>
<td>Number of Averaged PPG Samples</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1 (No averaging)</li>
<li>
2 consecutives samples are averaged</li>
<li>
4 consecutives samples are averaged</li>
<li>
8 consecutives samples are averaged</li>
<li>
16 consecutives samples are averaged</li>
<li>
32 consecutives samples are averaged</li>
</ul>
</td><td>8 consecutives samples are averaged </td><td>Set number of averaged for PPG samples. </td></tr>
<tr>
<td>Pulse Width and Measurement Period</td><td>Refer to the RA Configuration tool for available options.</td><td>Pulse width:130us. Measurement Period:1.25ms </td><td>Set pulse width and measurement period. </td></tr>
<tr>
<td>FIFO Rollover</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>Set FIFO rollover. </td></tr>
<tr>
<td>FIFO Almost Full Value</td><td>Value must be a non-negative integer</td><td>0x0C </td><td>Set the number of empty FIFO words when the FIFO almost full interrupt is issued (4bits). Min = 0x0 and Max = 0xF. In PPG2 Mode, only even values must be used. </td></tr>
</table>
 <h2>Configurations for Sensor &gt; OB1203 Light Proximity mode (rm_ob1203)</h2>
<table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>General &gt; Device Interrupt</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Light mode</li>
<li>
Proximity mode</li>
</ul>
</td><td>Light mode </td><td>Select an operation mode using device interrupt. </td></tr>
<tr>
<td>Light mode &gt; Operation Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
LS mode</li>
<li>
CS mode</li>
</ul>
</td><td>LS mode </td><td>Set operation mode. </td></tr>
<tr>
<td>Light mode &gt; Interrupt Type</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Threshold</li>
<li>
Variation</li>
</ul>
</td><td>Threshold </td><td>Set interrupt type. </td></tr>
<tr>
<td>Light mode &gt; Interrupt Source</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Clear channel</li>
<li>
Green channel</li>
<li>
Red channel (CS mode only)</li>
<li>
Blue channel (CS mode only)</li>
</ul>
</td><td>Clear channel </td><td>Set interrupt source. </td></tr>
<tr>
<td>Light mode &gt; The Number of Similar Consecutive Interrupt Events</td><td>Value must be a non-negative integer</td><td>0x02 </td><td>The number of similar consecutive Light mode interrupt events that must occur before the interrupt is asserted (4bits). Min = 0x0 and Max = 0xF </td></tr>
<tr>
<td>Light mode &gt; Sleep after Interrupt</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Set sleep after interrupt. </td></tr>
<tr>
<td>Light mode &gt; Gain</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1</li>
<li>
3</li>
<li>
6</li>
</ul>
</td><td>3 </td><td>Set gain for detection range. </td></tr>
<tr>
<td>Light mode &gt; Resolution and Measurement Period</td><td>Refer to the RA Configuration tool for available options.</td><td>Resolution:18bit. Measurement Period:100ms </td><td>Set resolution and measurement period. </td></tr>
<tr>
<td>Light mode &gt; Upper Threshold</td><td>Value must be a non-negative integer</td><td>0x00CCC </td><td>Set upper threshold value (20bits). Min = 0x00000 and Max = 0xFFFFF. </td></tr>
<tr>
<td>Light mode &gt; Lower Threshold</td><td>Value must be a non-negative integer</td><td>0x00000 </td><td>Set lower threshold value (20bits). Min = 0x00000 and Max = 0xFFFFF. </td></tr>
<tr>
<td>Light mode &gt; Variance Threshold</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
+/- 8 counts</li>
<li>
+/- 16 counts</li>
<li>
+/- 32 counts</li>
<li>
+/- 64 counts</li>
<li>
+/- 128 counts</li>
<li>
+/- 256 counts</li>
<li>
+/- 512 counts</li>
<li>
+/- 1024 counts</li>
</ul>
</td><td>+/- 128 counts </td><td>Set variance threshold. New data varies by selected counts compared to previous result. </td></tr>
<tr>
<td>Proximity mode &gt; Interrupt Type</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Normal</li>
<li>
Logic</li>
</ul>
</td><td>Normal </td><td>Set interrupt type. </td></tr>
<tr>
<td>Proximity mode &gt; The Number of Similar Consecutive Interrupt Events</td><td>Value must be a non-negative integer</td><td>0x02 </td><td>The number of similar consecutive Proximity mode interrupt events that must occur before the interrupt is asserted (4bits). Min = 0x0 and Max = 0xF </td></tr>
<tr>
<td>Proximity mode &gt; Sleep after Interrupt</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Set sleep after interrupt. </td></tr>
<tr>
<td>Proximity mode &gt; Gain</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1</li>
<li>
1.5</li>
<li>
2</li>
<li>
4</li>
</ul>
</td><td>1 </td><td>Set gain of ADC output and noise. </td></tr>
<tr>
<td>Proximity mode &gt; LED Current</td><td>Value must be a non-negative integer</td><td>0x100 </td><td>Set Current for LED (10bits). Min = 0x000 and Max = 0x3FF </td></tr>
<tr>
<td>Proximity mode &gt; LED Order</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
IR LED first, Red LED second</li>
<li>
Red LED first, IR LED second</li>
</ul>
</td><td>IR LED first, Red LED second </td><td>Set LED order. </td></tr>
<tr>
<td>Proximity mode &gt; LED Analog Cancellation</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled (50% offset of the full-scale value)</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Set analog cancellation level. </td></tr>
<tr>
<td>Proximity mode &gt; LED Digital Cancellation</td><td>Value must be a non-negative integer</td><td>0x100 </td><td>Set digital cancellation level (16bits). Min = 0x0000 and Max = 0xFFFF </td></tr>
<tr>
<td>Proximity mode &gt; Number of LED pulses</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1 pulse</li>
<li>
2 pulses</li>
<li>
4 pulses</li>
<li>
8 pulses</li>
<li>
16 pulses</li>
<li>
32 pulses</li>
</ul>
</td><td>8 pulses </td><td>Set number of LED pulses. </td></tr>
<tr>
<td>Proximity mode &gt; Pulse Width and Measurement Period</td><td>Refer to the RA Configuration tool for available options.</td><td>Pulse width:42us. Measurement Period:100ms </td><td>Set pulse width and measurement period. </td></tr>
<tr>
<td>Proximity mode &gt; Moving Average</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Set moving average. </td></tr>
<tr>
<td>Proximity mode &gt; Hysteresis</td><td>Value must be a non-negative integer</td><td>0x00 </td><td>Set hysteresis level (7bits). Min = 0x00 and Max = 0x7F. </td></tr>
<tr>
<td>Proximity mode &gt; Upper Threshold</td><td>Value must be a non-negative integer</td><td>0x0600 </td><td>Set upper threshold value (16bits). Min = 0x0000 and Max = 0xFFFF. </td></tr>
<tr>
<td>Proximity mode &gt; Lower Threshold</td><td>Value must be a non-negative integer</td><td>0x0000 </td><td>Set lower threshold value (16bits). Min = 0x0000 and Max = 0xFFFF. </td></tr>
</table>
</p>
<h2><a class="anchor" id="rm-ob1203-pin-configuration"></a>
Pin Configuration</h2>
<p>This module uses I2C Master, SCI I2C and IRQ drivers. Therefore, this module uses SDA and SCL pins of I2C Master and SCI I2C and an IRQ pin.</p>
<h1><a class="anchor" id="rm-ob1203-usage_notes"></a>
Usage Notes</h1>
<p><a href="https://www.renesas.com/jp/ja/document/dst/ob1203-datasheet?language=en&amp;r=460026">OB1203 datasheet is here. </a> <br />
 The OB1203 has four operation modes.<br />
 </p><h2>Light mode</h2>
<p>Light mode has two operation modes.<br />
</p><table class="doxtable">
<tr>
<th>Operation mode </th><th>Red </th><th>Green </th><th>Blue </th><th>Clear </th><th>Comp *1  </th></tr>
<tr>
<td>LS mode </td><td></td><td>✓ </td><td></td><td>✓ </td><td>✓ </td></tr>
<tr>
<td>CS mode </td><td>✓ </td><td>✓ </td><td>✓ </td><td>✓ </td><td>✓ </td></tr>
</table>
<p>*1 : Temperature compensation data<br />
<br />
Light mode features are below.</p><ul>
<li>High lux accuracy over different light sources</li>
<li>Absolute sensitivity: 0.06 lux to &gt; 150000 lux</li>
<li>Output resolution: 13 to 20 bits</li>
<li>Three LS/CS gain modes: x1 to x6</li>
<li>Highly linear output, 50Hz/60Hz light and fluorescent light flicker immunity</li>
<li>Four parallel channels (red, green, blue, clear)</li>
<li>Accurate Correlated Color Temperature (CCT)</li>
<li>Accurate CIE 1931 XYZ (RGB) color measurement</li>
<li>Very stable spectral response over angle of light incidence</li>
</ul>
<h2>Proximity mode</h2>
<p>Proximity mode features are below.</p><ul>
<li>Integrated and trimmed LED source, driver, and photodetector</li>
<li>Programmable pulsed LED up to 250mA output current</li>
<li>High resolution (12 to 16 bits)</li>
<li>Object movement detection (in/out)</li>
<li>Ambient light suppression &gt; 100klx sun light</li>
<li>Crosstalk cancelation (analog and digital)</li>
</ul>
<h2>PPG mode</h2>
<p>PPG mode has two operation modes.<br />
</p><table class="doxtable">
<tr>
<th>Operation mode </th><th>Discription  </th></tr>
<tr>
<td>PPG1 mode </td><td>Only one LED is used. This mode allows determination of parameters related to heart rate with an appropriate algorithm </td></tr>
<tr>
<td>PPG2 mode </td><td>Two LED are used. Second LED is used as a transmitter. This mode supports further analysis, such as SpO2 and respiration rate determination. </td></tr>
</table>
<p>PPG mode features are below.</p><ul>
<li>SpO2 measurement behind visibly dark, IR transmissive ink</li>
<li>Industry’s smallest optical biosensor module</li>
<li>Fully integrated and trimmed module, including two LEDs, 250mA maximum drive current, and photodetectors</li>
<li>Output resolution PPG: 16 to 18 bits</li>
<li>Data stored in 18-bit wide, 32-sample FIFO memory</li>
<li>Integrated averaging function for higher signal-to-noise ratio(SNR) and data rate reduction</li>
<li>Programmable measurement rate: up to 3200 samples per second</li>
<li>High SNR</li>
</ul>
<h2>Light Proximity mode</h2>
<p>Light mode and Proximity mode can be used in parallel.</p>
<h2>Bus Initialization</h2>
<p>The OB1203 interface expects a bus instance to be opened before opening any OB1203 device. The interface will handle switching between devices on the bus but will not open or close the bus instance. The user should open the bus with the appropriate <a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html">I2C Master Interface</a> open call.</p>
<p>If an RTOS is used, blocking and bus lock for I2C bus are available.</p><ul>
<li>If blocking of an I2C bus is required, it is necessary to create a semaphore for blocking.</li>
<li>If bus lock is required, it is necessary to create a mutex for bus lock. Bus lock is only available when a semaphore for blocking is used.</li>
</ul>
<h2>Initialization</h2>
<p>Initialize with <a class="el" href="group___r_m___o_b1203.html#ga34d3b67d431ab9cdb45fa561196d8e85">RM_OB1203_Open()</a>.</p>
<h2>From measurement start to data acquisition</h2>
<p>After normal completion, start the measurement with <a class="el" href="group___r_m___o_b1203.html#gaabca4420cac85f4ea23be2454863d443">RM_OB1203_MeasurementStart()</a>.</p>
<h3>Light mode</h3>
<h4>If IRQ is enabled</h4>
<ol type="1">
<li>Wait until RM_OB1203_EVENT_THRESHOLD_CROSSED is received via IRQ callback.</li>
<li>Call <a class="el" href="group___r_m___o_b1203.html#gad3e86f2d3ee11e505e5df6fc8e1b5c1f">RM_OB1203_LightRead()</a>. This function will read the ADC data and clear the interrupt bits.</li>
<li>Wait until RM_OB1203_EVENT_SUCCESS is received.</li>
<li>Call <a class="el" href="group___r_m___o_b1203.html#ga56f8661c39d7b7b41e0799d528f08c92">RM_OB1203_LightDataCalculate()</a>. This function will calculate light data from the ADC data.</li>
</ol>
<h4>If IRQ is disabled</h4>
<ol type="1">
<li>Wait for measurement period configured.</li>
<li>Call <a class="el" href="group___r_m___o_b1203.html#gad3e86f2d3ee11e505e5df6fc8e1b5c1f">RM_OB1203_LightRead()</a>. This function will read the ADC data.</li>
<li>Wait until RM_OB1203_EVENT_SUCCESS is received.</li>
<li>Call <a class="el" href="group___r_m___o_b1203.html#ga56f8661c39d7b7b41e0799d528f08c92">RM_OB1203_LightDataCalculate()</a>. This function will calculate light data from the ADC data.</li>
</ol>
<h3>Proximity mode</h3>
<h4>If IRQ is enabled</h4>
<ol type="1">
<li>Wait until RM_OB1203_EVENT_THRESHOLD_CROSSED or RM_OB1203_EVENT_OBJECT_NEAR is received via IRQ callback.</li>
<li>Call <a class="el" href="group___r_m___o_b1203.html#ga1de710492d4da21656a5cbd62eb2b721">RM_OB1203_ProxRead()</a>. This function will read the ADC data and clear the interrupt bits.</li>
<li>Wait until RM_OB1203_EVENT_SUCCESS is received.</li>
<li>Call <a class="el" href="group___r_m___o_b1203.html#ga5888f249d9e67a2af39ce7977065d359">RM_OB1203_ProxDataCalculate()</a>. This function will calculate proximity data from the ADC data.</li>
</ol>
<h4>If IRQ is disabled</h4>
<ol type="1">
<li>Wait for measurement period configured.</li>
<li>Call <a class="el" href="group___r_m___o_b1203.html#ga1de710492d4da21656a5cbd62eb2b721">RM_OB1203_ProxRead()</a>. This function will read the ADC data.</li>
<li>Wait until RM_OB1203_EVENT_SUCCESS is received.</li>
<li>Call <a class="el" href="group___r_m___o_b1203.html#ga5888f249d9e67a2af39ce7977065d359">RM_OB1203_ProxDataCalculate()</a>. This function will calculate proximity data from the ADC data.</li>
</ol>
<h3>PPG mode</h3>
<h4>If IRQ is enabled</h4>
<ol type="1">
<li>Wait until RM_OB1203_EVENT_MEASUREMENT_COMPLETE is received via IRQ callback.</li>
<li>Call <a class="el" href="group___r_m___o_b1203.html#ga306ea4427230d2c7c2e2c0ae53346a0b">RM_OB1203_PpgRead()</a>. This function will read the ADC data and clear the interrupt bits. In PPG2 mode, the number of read FIFO samples must be even value because two samples is one pair.</li>
<li>Wait until RM_OB1203_EVENT_SUCCESS is received.</li>
<li>Call <a class="el" href="group___r_m___o_b1203.html#gaffe63df6ba35eb27989b694af004a87b">RM_OB1203_PpgDataCalculate()</a>. This function will calculate PPG data from the ADC data.</li>
</ol>
<h4>If IRQ is disabled</h4>
<ol type="1">
<li>Wait for measurement period configured.</li>
<li>Call <a class="el" href="group___r_m___o_b1203.html#ga306ea4427230d2c7c2e2c0ae53346a0b">RM_OB1203_PpgRead()</a>. This function will read the ADC data. In PPG2 mode, the number of read FIFO samples must be even value because two samples is one pair.</li>
<li>Wait until RM_OB1203_EVENT_SUCCESS is received.</li>
<li>Call <a class="el" href="group___r_m___o_b1203.html#gaffe63df6ba35eb27989b694af004a87b">RM_OB1203_PpgDataCalculate()</a>. This function will calculate PPG data from the ADC data.</li>
</ol>
<h3>Light Proximity mode</h3>
<p>Combination of the above Light mode and Proximity mode.</p>
<h2>Getting device status</h2>
<p>Call <a class="el" href="group___r_m___o_b1203.html#ga13ab57714aafa9a3023a32f83c88e1dd">RM_OB1203_DeviceStatusGet()</a>. This function will get device status over I2C.</p>
<ul>
<li>If power_on_reset_occur is true, the part has had a power-up event, either because the part was turned on or because there was a power-supply voltage disturbance.</li>
<li>If light_interrupt_occur is true, Light mode interrupt condition has occurred.</li>
<li>If light_measurement_complete is true, Light mode measurement is complete.</li>
<li>If ts_measurement_complete is true, TS measurement is complete.</li>
<li>If fifo_afull_interrupt_occur is true, FIFO almost full interrupt condition has occurred.</li>
<li>If ppg_measurement_complete is true, PPG mode measurement is complete.</li>
<li>If object_near is true, an object is near.</li>
<li>If prox_interrupt_occur is true, Proximity mode interrupt condition has occurred.</li>
<li>If prox_measurement_complete is true, Proximity mode measurement is complete.</li>
</ul>
<h2>Clearing interrupt bits</h2>
<p>If interrupt bits are needed to clear without calling <a class="el" href="group___r_m___o_b1203.html#gad3e86f2d3ee11e505e5df6fc8e1b5c1f">RM_OB1203_LightRead()</a>, <a class="el" href="group___r_m___o_b1203.html#ga1de710492d4da21656a5cbd62eb2b721" title="Reads Proximity ADC data from OB1203 device. If device interrupt is enabled, interrupt bits are clear...">RM_OB1203_ProxRead()</a>, <a class="el" href="group___r_m___o_b1203.html#ga306ea4427230d2c7c2e2c0ae53346a0b" title="Reads PPG ADC data from OB1203 device. One sample requires three bytes. 0 cannot set to the number of...">RM_OB1203_PpgRead()</a> and <a class="el" href="group___r_m___o_b1203.html#gab851b2d1c598510756bea3608f3261a3">RM_OB1203_MeasurementStop()</a>, please call <a class="el" href="group___r_m___o_b1203.html#ga13ab57714aafa9a3023a32f83c88e1dd">RM_OB1203_DeviceStatusGet()</a>. Interrupt bits are reset by STATUS_0 and STATUS_1 registers read.</p>
<h2>Sleep after interrupt</h2>
<p>Sleep after interrupt is valid in Light mode and Proximity mode. If a sleep after interrupt bit are set, a measurement will be stopped after an interrupt occurs. After STATUS_0 and STATUS_1 registers are read, a measurement will be started. please call <a class="el" href="group___r_m___o_b1203.html#ga13ab57714aafa9a3023a32f83c88e1dd">RM_OB1203_DeviceStatusGet()</a>.</p>
<h2>PPG FIFO</h2>
<p>PPG FIFO data is stored in 18-bit wide, 32-sample FIFO memory.<br />
The FIFO almost full interrupt is triggered when a certain number of free FIFO registers are remaining.<br />
If FIFO informations (write index, read index, overflow counter, unread_samples) are got, Call <a class="el" href="group___r_m___o_b1203.html#ga6ffbbe58d90adb8001d2f6424987e71b">RM_OB1203_FifoInfoGet()</a>.</p><ul>
<li>write_index is the FIFO index where the next sample of PPG data will be written in the FIFO.</li>
<li>read_index is the index of the next sample to be read from the FIFO_DATA register.</li>
<li>overflow_counter is the number of old samples (up to 15) which are overwritten by new data. If the FIFO Rollover is enabled, the FIFO overflow counter counts.</li>
<li>unread_samples is the number of unread FIFO samples, which can be calculated by write index and read index.</li>
</ul>
<h2>Reconfiguration</h2>
<p>The interface supports the following APIs for reconfiguration. </p><table class="doxtable">
<tr>
<th>API </th><th>Discription  </th></tr>
<tr>
<td><a class="el" href="group___r_m___o_b1203.html#ga554b7652ea5ee0de096b21e6580f164f">RM_OB1203_GainSet()</a> </td><td>Set gain </td></tr>
<tr>
<td><a class="el" href="group___r_m___o_b1203.html#ga5666b0538afdae80059de7271667694c">RM_OB1203_LedCurrentSet()</a> </td><td>Set LED currents.<br />
 Proximity mode and Light Proximity mode: LED Current is 10bits. Min = 0x000 and Max = 0x3FF<br />
 PPG mode: IR/Red LED currents are 10bits/9bits. Min = 0x000/0x000 and Max = 0x3FF/0x1FF </td></tr>
<tr>
<td><a class="el" href="group___r_m___o_b1203.html#gae791e9a53d7642b5ab9bed5ddfb195fa">RM_OB1203_DeviceInterruptCfgSet()</a> </td><td>Set interrupt configurations. </td></tr>
</table>
<h2>Relationship between APIs and registers</h2>
<p>The relationship between APIs and registers accessed by the API is below.</p>
<table class="doxtable">
<tr>
<th>API </th><th>Registers  </th></tr>
<tr>
<td><a class="el" href="group___r_m___o_b1203.html#gaabca4420cac85f4ea23be2454863d443">RM_OB1203_MeasurementStart()</a> </td><td>MAIN_CTRL_0 and MAIN_CTRL_1 </td></tr>
<tr>
<td><a class="el" href="group___r_m___o_b1203.html#gab851b2d1c598510756bea3608f3261a3">RM_OB1203_MeasurementStop()</a> </td><td>MAIN_CTRL_0, MAIN_CTRL_1 , STATUS_0, STATUS_1, FIFO_WR_PTR, FIFO_RD_PTR and FIFO_OVF_CNT </td></tr>
<tr>
<td><a class="el" href="group___r_m___o_b1203.html#gad3e86f2d3ee11e505e5df6fc8e1b5c1f">RM_OB1203_LightRead()</a> </td><td>LS_CLEAR_DATA, LS_GREEN_DATA, LS_BULE_DATA, LS_RED_DATA, COMP_DATA, STATUS_0 and STATUS_1 </td></tr>
<tr>
<td><a class="el" href="group___r_m___o_b1203.html#ga1de710492d4da21656a5cbd62eb2b721">RM_OB1203_ProxRead()</a> </td><td>PS_DATA, STATUS_0 and STATUS_1 </td></tr>
<tr>
<td><a class="el" href="group___r_m___o_b1203.html#ga306ea4427230d2c7c2e2c0ae53346a0b">RM_OB1203_PpgRead()</a> </td><td>FIFO_DATA </td></tr>
<tr>
<td><a class="el" href="group___r_m___o_b1203.html#ga13ab57714aafa9a3023a32f83c88e1dd">RM_OB1203_DeviceStatusGet()</a> </td><td>STATUS_0 and STATUS_1 </td></tr>
<tr>
<td><a class="el" href="group___r_m___o_b1203.html#ga554b7652ea5ee0de096b21e6580f164f">RM_OB1203_GainSet()</a> </td><td>LS_GAIN and PPG_PS_GAIN </td></tr>
<tr>
<td><a class="el" href="group___r_m___o_b1203.html#ga5666b0538afdae80059de7271667694c">RM_OB1203_LedCurrentSet()</a> </td><td>PS_LED_CURR, PPG_IRLED_CURR and PPG_RLED_CURR </td></tr>
<tr>
<td><a class="el" href="group___r_m___o_b1203.html#gae791e9a53d7642b5ab9bed5ddfb195fa">RM_OB1203_DeviceInterruptCfgSet()</a> </td><td>INT_CFG_0, INT_CFG_1 and INT_PST </td></tr>
<tr>
<td><a class="el" href="group___r_m___o_b1203.html#ga6ffbbe58d90adb8001d2f6424987e71b">RM_OB1203_FifoInfoGet()</a> </td><td>FIFO_WR_PTR, FIFO_RD_PTR and FIFO_OVF_CNT </td></tr>
</table>
<h1><a class="anchor" id="rm-ob1203-examples"></a>
Examples</h1>
<h2>Basic Example</h2>
<p>These are basic examples of minimal use of OB1203 sensor implementation in an application.</p>
<h3>Light mode</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> rm_ob1203_light_mode_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>              err = FSP_SUCCESS;</div><div class="line">    <a class="code" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__raw__data__t">rm_ob1203_raw_data_t</a>   raw_data;</div><div class="line">    <a class="code" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__light__data__t">rm_ob1203_light_data_t</a> ob1203_data;</div><div class="line"><span class="preprocessor">#if 0 == RM_OB1203_EXAMPLE_IRQ_ENABLE</span></div><div class="line">    <a class="code" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__device__status__t">rm_ob1203_device_status_t</a> device_status;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="comment">/* Open the I2C bus if it is not already open. */</span></div><div class="line">    rm_comms_i2c_bus_extended_cfg_t * p_extend =</div><div class="line">        (rm_comms_i2c_bus_extended_cfg_t *) g_ob1203_cfg.p_comms_instance-&gt;p_cfg-&gt;p_extend;</div><div class="line">    <a class="code" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#structi2c__master__instance__t">i2c_master_instance_t</a> * p_driver_instance = (<a class="code" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#structi2c__master__instance__t">i2c_master_instance_t</a> *) p_extend-&gt;p_driver_instance;</div><div class="line">    p_driver_instance-&gt;<a class="code" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#a3258c94576c0bc4a69095906a314386d">p_api</a>-&gt;<a class="code" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#a6a35b07fde984333fdce6859dfd56e64">open</a>(p_driver_instance-&gt;p_ctrl, p_driver_instance-&gt;p_cfg);</div><div class="line"></div><div class="line"><span class="preprocessor">#if BSP_CFG_RTOS</span></div><div class="line"></div><div class="line">    <span class="comment">/* Create a semaphore for blocking if a semaphore is not NULL */</span></div><div class="line">    <span class="keywordflow">if</span> (NULL != p_extend-&gt;p_blocking_semaphore)</div><div class="line">    {</div><div class="line"><span class="preprocessor"> #if BSP_CFG_RTOS == 1                 // AzureOS</span></div><div class="line">        tx_semaphore_create(p_extend-&gt;p_blocking_semaphore-&gt;p_semaphore_handle,</div><div class="line">                            p_extend-&gt;p_blocking_semaphore-&gt;p_semaphore_name,</div><div class="line">                            (ULONG) 0);</div><div class="line"><span class="preprocessor"> #elif BSP_CFG_RTOS == 2               // FreeRTOS</span></div><div class="line">        *(p_extend-&gt;p_blocking_semaphore-&gt;p_semaphore_handle) =</div><div class="line">            xSemaphoreCreateCountingStatic((UBaseType_t) 1,</div><div class="line">                                           (UBaseType_t) 0,</div><div class="line">                                           p_extend-&gt;p_blocking_semaphore-&gt;p_semaphore_memory);</div><div class="line"><span class="preprocessor"> #endif</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Create a recursive mutex for bus lock if a recursive mutex is not NULL */</span></div><div class="line">    <span class="keywordflow">if</span> (NULL != p_extend-&gt;p_bus_recursive_mutex)</div><div class="line">    {</div><div class="line"><span class="preprocessor"> #if BSP_CFG_RTOS == 1                 // AzureOS</span></div><div class="line">        tx_mutex_create(p_extend-&gt;p_bus_recursive_mutex-&gt;p_mutex_handle,</div><div class="line">                        p_extend-&gt;p_bus_recursive_mutex-&gt;p_mutex_name,</div><div class="line">                        TX_INHERIT);</div><div class="line"><span class="preprocessor"> #elif BSP_CFG_RTOS == 2               // FreeRTOS</span></div><div class="line">        *(p_extend-&gt;p_bus_recursive_mutex-&gt;p_mutex_handle) =</div><div class="line">            xSemaphoreCreateRecursiveMutexStatic(p_extend-&gt;p_bus_recursive_mutex-&gt;p_mutex_memory);</div><div class="line"><span class="preprocessor"> #endif</span></div><div class="line">    }</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"></div><div class="line">    err = <a class="code" href="group___r_m___o_b1203.html#ga34d3b67d431ab9cdb45fa561196d8e85">RM_OB1203_Open</a>(&amp;g_ob1203_ctrl, &amp;g_ob1203_cfg);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    g_i2c_flag = 0;</div><div class="line"></div><div class="line">    <span class="comment">/* Start measurement */</span></div><div class="line">    <a class="code" href="group___r_m___o_b1203.html#gaabca4420cac85f4ea23be2454863d443">RM_OB1203_MeasurementStart</a>(&amp;g_ob1203_ctrl);</div><div class="line">    <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait callback */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line"><span class="preprocessor">#if RM_OB1203_EXAMPLE_IRQ_ENABLE</span></div><div class="line"></div><div class="line">        <span class="comment">/* Wait IRQ callback */</span></div><div class="line">        <span class="keywordflow">while</span> (0 == g_irq_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_irq_flag = 0;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">        <span class="keywordflow">do</span></div><div class="line">        {</div><div class="line">            g_i2c_flag = 0;</div><div class="line"></div><div class="line">            <span class="comment">/* Get device status */</span></div><div class="line">            <a class="code" href="group___r_m___o_b1203.html#ga13ab57714aafa9a3023a32f83c88e1dd">RM_OB1203_DeviceStatusGet</a>(&amp;g_ob1203_ctrl, &amp;device_status);</div><div class="line">            <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">            {</div><div class="line">                <span class="comment">/* Wait callback */</span></div><div class="line">            }</div><div class="line">        } <span class="keywordflow">while</span> (<span class="keyword">false</span> == device_status.light_measurement_complete);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">        g_i2c_flag = 0;</div><div class="line"></div><div class="line">        <span class="comment">/* Read ADC data */</span></div><div class="line">        <a class="code" href="group___r_m___o_b1203.html#gad3e86f2d3ee11e505e5df6fc8e1b5c1f">RM_OB1203_LightRead</a>(&amp;g_ob1203_ctrl, &amp;raw_data, <a class="code" href="group___r_m___o_b1203___a_p_i.html#gga0c0d347b4e6af84c4f4148ea68280337aea40c00eb88fbcade796b8bbdc7276db">RM_OB1203_LIGHT_DATA_TYPE_ALL</a>);</div><div class="line">        <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Calculate light data */</span></div><div class="line">        <a class="code" href="group___r_m___o_b1203.html#ga56f8661c39d7b7b41e0799d528f08c92">RM_OB1203_LightDataCalculate</a>(&amp;g_ob1203_ctrl, &amp;raw_data, &amp;ob1203_data);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h3>Proximity mode</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> rm_ob1203_prox_mode_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>             err = FSP_SUCCESS;</div><div class="line">    <a class="code" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__raw__data__t">rm_ob1203_raw_data_t</a>  raw_data;</div><div class="line">    <a class="code" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__prox__data__t">rm_ob1203_prox_data_t</a> ob1203_data;</div><div class="line"><span class="preprocessor">#if 0 == RM_OB1203_EXAMPLE_IRQ_ENABLE</span></div><div class="line">    <a class="code" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__device__status__t">rm_ob1203_device_status_t</a> device_status;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="comment">/* Open the I2C bus if it is not already open. */</span></div><div class="line">    rm_comms_i2c_bus_extended_cfg_t * p_extend =</div><div class="line">        (rm_comms_i2c_bus_extended_cfg_t *) g_ob1203_cfg.p_comms_instance-&gt;p_cfg-&gt;p_extend;</div><div class="line">    <a class="code" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#structi2c__master__instance__t">i2c_master_instance_t</a> * p_driver_instance = (<a class="code" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#structi2c__master__instance__t">i2c_master_instance_t</a> *) p_extend-&gt;p_driver_instance;</div><div class="line">    p_driver_instance-&gt;<a class="code" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#a3258c94576c0bc4a69095906a314386d">p_api</a>-&gt;<a class="code" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#a6a35b07fde984333fdce6859dfd56e64">open</a>(p_driver_instance-&gt;p_ctrl, p_driver_instance-&gt;p_cfg);</div><div class="line"></div><div class="line"><span class="preprocessor">#if BSP_CFG_RTOS</span></div><div class="line"></div><div class="line">    <span class="comment">/* Create a semaphore for blocking if a semaphore is not NULL */</span></div><div class="line">    <span class="keywordflow">if</span> (NULL != p_extend-&gt;p_blocking_semaphore)</div><div class="line">    {</div><div class="line"><span class="preprocessor"> #if BSP_CFG_RTOS == 1                 // AzureOS</span></div><div class="line">        tx_semaphore_create(p_extend-&gt;p_blocking_semaphore-&gt;p_semaphore_handle,</div><div class="line">                            p_extend-&gt;p_blocking_semaphore-&gt;p_semaphore_name,</div><div class="line">                            (ULONG) 0);</div><div class="line"><span class="preprocessor"> #elif BSP_CFG_RTOS == 2               // FreeRTOS</span></div><div class="line">        *(p_extend-&gt;p_blocking_semaphore-&gt;p_semaphore_handle) =</div><div class="line">            xSemaphoreCreateCountingStatic((UBaseType_t) 1,</div><div class="line">                                           (UBaseType_t) 0,</div><div class="line">                                           p_extend-&gt;p_blocking_semaphore-&gt;p_semaphore_memory);</div><div class="line"><span class="preprocessor"> #endif</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Create a recursive mutex for bus lock if a recursive mutex is not NULL */</span></div><div class="line">    <span class="keywordflow">if</span> (NULL != p_extend-&gt;p_bus_recursive_mutex)</div><div class="line">    {</div><div class="line"><span class="preprocessor"> #if BSP_CFG_RTOS == 1                 // AzureOS</span></div><div class="line">        tx_mutex_create(p_extend-&gt;p_bus_recursive_mutex-&gt;p_mutex_handle,</div><div class="line">                        p_extend-&gt;p_bus_recursive_mutex-&gt;p_mutex_name,</div><div class="line">                        TX_INHERIT);</div><div class="line"><span class="preprocessor"> #elif BSP_CFG_RTOS == 2               // FreeRTOS</span></div><div class="line">        *(p_extend-&gt;p_bus_recursive_mutex-&gt;p_mutex_handle) =</div><div class="line">            xSemaphoreCreateRecursiveMutexStatic(p_extend-&gt;p_bus_recursive_mutex-&gt;p_mutex_memory);</div><div class="line"><span class="preprocessor"> #endif</span></div><div class="line">    }</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    err = <a class="code" href="group___r_m___o_b1203.html#ga34d3b67d431ab9cdb45fa561196d8e85">RM_OB1203_Open</a>(&amp;g_ob1203_ctrl, &amp;g_ob1203_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    g_i2c_flag = 0;</div><div class="line"></div><div class="line">    <span class="comment">/* Start measurement */</span></div><div class="line">    <a class="code" href="group___r_m___o_b1203.html#gaabca4420cac85f4ea23be2454863d443">RM_OB1203_MeasurementStart</a>(&amp;g_ob1203_ctrl);</div><div class="line">    <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait callback */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line"><span class="preprocessor">#if RM_OB1203_EXAMPLE_IRQ_ENABLE</span></div><div class="line"></div><div class="line">        <span class="comment">/* Wait IRQ callback */</span></div><div class="line">        <span class="keywordflow">while</span> (0 == g_irq_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_irq_flag = 0;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">        <span class="keywordflow">do</span></div><div class="line">        {</div><div class="line">            g_i2c_flag = 0;</div><div class="line"></div><div class="line">            <span class="comment">/* Get device status */</span></div><div class="line">            <a class="code" href="group___r_m___o_b1203.html#ga13ab57714aafa9a3023a32f83c88e1dd">RM_OB1203_DeviceStatusGet</a>(&amp;g_ob1203_ctrl, &amp;device_status);</div><div class="line">            <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">            {</div><div class="line">                <span class="comment">/* Wait callback */</span></div><div class="line">            }</div><div class="line">        } <span class="keywordflow">while</span> (<span class="keyword">false</span> == device_status.prox_measurement_complete);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">        g_i2c_flag = 0;</div><div class="line"></div><div class="line">        <span class="comment">/* Read ADC data */</span></div><div class="line">        <a class="code" href="group___r_m___o_b1203.html#ga1de710492d4da21656a5cbd62eb2b721">RM_OB1203_ProxRead</a>(&amp;g_ob1203_ctrl, &amp;raw_data);</div><div class="line">        <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Calculate proximity data */</span></div><div class="line">        <a class="code" href="group___r_m___o_b1203.html#ga5888f249d9e67a2af39ce7977065d359">RM_OB1203_ProxDataCalculate</a>(&amp;g_ob1203_ctrl, &amp;raw_data, &amp;ob1203_data);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h3>Light Proximity mode</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> rm_ob1203_light_prox_mode_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>              err = FSP_SUCCESS;</div><div class="line">    <a class="code" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__raw__data__t">rm_ob1203_raw_data_t</a>   raw_data;</div><div class="line">    <a class="code" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__light__data__t">rm_ob1203_light_data_t</a> ob1203_light_data;</div><div class="line">    <a class="code" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__prox__data__t">rm_ob1203_prox_data_t</a>  ob1203_prox_data;</div><div class="line"><span class="preprocessor">#if 0 == RM_OB1203_EXAMPLE_IRQ_ENABLE</span></div><div class="line">    <a class="code" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__device__status__t">rm_ob1203_device_status_t</a> device_status;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="comment">/* Open the I2C bus if it is not already open. */</span></div><div class="line">    rm_comms_i2c_bus_extended_cfg_t * p_extend =</div><div class="line">        (rm_comms_i2c_bus_extended_cfg_t *) g_ob1203_cfg.p_comms_instance-&gt;p_cfg-&gt;p_extend;</div><div class="line">    <a class="code" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#structi2c__master__instance__t">i2c_master_instance_t</a> * p_driver_instance = (<a class="code" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#structi2c__master__instance__t">i2c_master_instance_t</a> *) p_extend-&gt;p_driver_instance;</div><div class="line">    p_driver_instance-&gt;<a class="code" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#a3258c94576c0bc4a69095906a314386d">p_api</a>-&gt;<a class="code" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#a6a35b07fde984333fdce6859dfd56e64">open</a>(p_driver_instance-&gt;p_ctrl, p_driver_instance-&gt;p_cfg);</div><div class="line"></div><div class="line"><span class="preprocessor">#if BSP_CFG_RTOS</span></div><div class="line"></div><div class="line">    <span class="comment">/* Create a semaphore for blocking if a semaphore is not NULL */</span></div><div class="line">    <span class="keywordflow">if</span> (NULL != p_extend-&gt;p_blocking_semaphore)</div><div class="line">    {</div><div class="line"><span class="preprocessor"> #if BSP_CFG_RTOS == 1                 // AzureOS</span></div><div class="line">        tx_semaphore_create(p_extend-&gt;p_blocking_semaphore-&gt;p_semaphore_handle,</div><div class="line">                            p_extend-&gt;p_blocking_semaphore-&gt;p_semaphore_name,</div><div class="line">                            (ULONG) 0);</div><div class="line"><span class="preprocessor"> #elif BSP_CFG_RTOS == 2               // FreeRTOS</span></div><div class="line">        *(p_extend-&gt;p_blocking_semaphore-&gt;p_semaphore_handle) =</div><div class="line">            xSemaphoreCreateCountingStatic((UBaseType_t) 1,</div><div class="line">                                           (UBaseType_t) 0,</div><div class="line">                                           p_extend-&gt;p_blocking_semaphore-&gt;p_semaphore_memory);</div><div class="line"><span class="preprocessor"> #endif</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Create a recursive mutex for bus lock if a recursive mutex is not NULL */</span></div><div class="line">    <span class="keywordflow">if</span> (NULL != p_extend-&gt;p_bus_recursive_mutex)</div><div class="line">    {</div><div class="line"><span class="preprocessor"> #if BSP_CFG_RTOS == 1                 // AzureOS</span></div><div class="line">        tx_mutex_create(p_extend-&gt;p_bus_recursive_mutex-&gt;p_mutex_handle,</div><div class="line">                        p_extend-&gt;p_bus_recursive_mutex-&gt;p_mutex_name,</div><div class="line">                        TX_INHERIT);</div><div class="line"><span class="preprocessor"> #elif BSP_CFG_RTOS == 2               // FreeRTOS</span></div><div class="line">        *(p_extend-&gt;p_bus_recursive_mutex-&gt;p_mutex_handle) =</div><div class="line">            xSemaphoreCreateRecursiveMutexStatic(p_extend-&gt;p_bus_recursive_mutex-&gt;p_mutex_memory);</div><div class="line"><span class="preprocessor"> #endif</span></div><div class="line">    }</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    err = <a class="code" href="group___r_m___o_b1203.html#ga34d3b67d431ab9cdb45fa561196d8e85">RM_OB1203_Open</a>(&amp;g_ob1203_ctrl, &amp;g_ob1203_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    g_i2c_flag = 0;</div><div class="line"></div><div class="line">    <span class="comment">/* Start measurement in both Light and Proximity modes */</span></div><div class="line">    <a class="code" href="group___r_m___o_b1203.html#gaabca4420cac85f4ea23be2454863d443">RM_OB1203_MeasurementStart</a>(&amp;g_ob1203_ctrl);</div><div class="line">    <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait callback */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Example :</span></div><div class="line"><span class="comment">     * Device interrupt : Proximity mode</span></div><div class="line"><span class="comment">     * Measurement peroid(Light mode) : 50ms</span></div><div class="line"><span class="comment">     * Measurement peroid(Proximity mode) : 100ms</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Delay 50ms for Light mode */</span></div><div class="line">        <a class="code" href="group___b_s_p___m_c_u.html#gaf3219448adfd1531cf69f68697ab184b">R_BSP_SoftwareDelay</a>(RM_OB1203_EXAMPLE_DELAY_50MS, <a class="code" href="group___b_s_p___m_c_u.html#ggafd98e2a6f080d6a52a3ef72e3d731b2ba59fcc4e8d51046d4a1bd63c87ac64913">BSP_DELAY_UNITS_MILLISECONDS</a>);</div><div class="line"></div><div class="line">        g_i2c_flag = 0;</div><div class="line"></div><div class="line">        <span class="comment">/* Read Light ADC data */</span></div><div class="line">        <a class="code" href="group___r_m___o_b1203.html#gad3e86f2d3ee11e505e5df6fc8e1b5c1f">RM_OB1203_LightRead</a>(&amp;g_ob1203_ctrl, &amp;raw_data, <a class="code" href="group___r_m___o_b1203___a_p_i.html#gga0c0d347b4e6af84c4f4148ea68280337aea40c00eb88fbcade796b8bbdc7276db">RM_OB1203_LIGHT_DATA_TYPE_ALL</a>);</div><div class="line">        <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Calculate Light data */</span></div><div class="line">        <a class="code" href="group___r_m___o_b1203.html#ga56f8661c39d7b7b41e0799d528f08c92">RM_OB1203_LightDataCalculate</a>(&amp;g_ob1203_ctrl, &amp;raw_data, &amp;ob1203_light_data);</div><div class="line"></div><div class="line"><span class="preprocessor">#if RM_OB1203_EXAMPLE_IRQ_ENABLE</span></div><div class="line"></div><div class="line">        <span class="comment">/* Wait IRQ callback */</span></div><div class="line">        <span class="keywordflow">while</span> (0 == g_irq_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_irq_flag = 0;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">        <span class="keywordflow">do</span></div><div class="line">        {</div><div class="line">            g_i2c_flag = 0;</div><div class="line"></div><div class="line">            <span class="comment">/* Get device status */</span></div><div class="line">            <a class="code" href="group___r_m___o_b1203.html#ga13ab57714aafa9a3023a32f83c88e1dd">RM_OB1203_DeviceStatusGet</a>(&amp;g_ob1203_ctrl, &amp;device_status);</div><div class="line">            <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">            {</div><div class="line">                <span class="comment">/* Wait callback */</span></div><div class="line">            }</div><div class="line">        } <span class="keywordflow">while</span> (<span class="keyword">false</span> == device_status.prox_measurement_complete);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">        g_i2c_flag = 0;</div><div class="line"></div><div class="line">        <span class="comment">/* Read Proximity ADC data */</span></div><div class="line">        <a class="code" href="group___r_m___o_b1203.html#ga1de710492d4da21656a5cbd62eb2b721">RM_OB1203_ProxRead</a>(&amp;g_ob1203_ctrl, &amp;raw_data);</div><div class="line">        <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Calculate proximity data */</span></div><div class="line">        <a class="code" href="group___r_m___o_b1203.html#ga5888f249d9e67a2af39ce7977065d359">RM_OB1203_ProxDataCalculate</a>(&amp;g_ob1203_ctrl, &amp;raw_data, &amp;ob1203_prox_data);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h3>PPG mode</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> rm_ob1203_ppg_mode_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>            err = FSP_SUCCESS;</div><div class="line">    <a class="code" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__raw__data__t">rm_ob1203_raw_data_t</a> raw_data;</div><div class="line">    <a class="code" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__ppg__data__t">rm_ob1203_ppg_data_t</a> ob1203_data;</div><div class="line"><span class="preprocessor">#if 0 == RM_OB1203_EXAMPLE_IRQ_ENABLE</span></div><div class="line">    <a class="code" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__device__status__t">rm_ob1203_device_status_t</a> device_status;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="comment">/* Open the I2C bus if it is not already open. */</span></div><div class="line">    rm_comms_i2c_bus_extended_cfg_t * p_extend =</div><div class="line">        (rm_comms_i2c_bus_extended_cfg_t *) g_ob1203_cfg.p_comms_instance-&gt;p_cfg-&gt;p_extend;</div><div class="line">    <a class="code" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#structi2c__master__instance__t">i2c_master_instance_t</a> * p_driver_instance = (<a class="code" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#structi2c__master__instance__t">i2c_master_instance_t</a> *) p_extend-&gt;p_driver_instance;</div><div class="line">    p_driver_instance-&gt;<a class="code" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#a3258c94576c0bc4a69095906a314386d">p_api</a>-&gt;<a class="code" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#a6a35b07fde984333fdce6859dfd56e64">open</a>(p_driver_instance-&gt;p_ctrl, p_driver_instance-&gt;p_cfg);</div><div class="line"></div><div class="line"><span class="preprocessor">#if BSP_CFG_RTOS</span></div><div class="line"></div><div class="line">    <span class="comment">/* Create a semaphore for blocking if a semaphore is not NULL */</span></div><div class="line">    <span class="keywordflow">if</span> (NULL != p_extend-&gt;p_blocking_semaphore)</div><div class="line">    {</div><div class="line"><span class="preprocessor"> #if BSP_CFG_RTOS == 1                 // AzureOS</span></div><div class="line">        tx_semaphore_create(p_extend-&gt;p_blocking_semaphore-&gt;p_semaphore_handle,</div><div class="line">                            p_extend-&gt;p_blocking_semaphore-&gt;p_semaphore_name,</div><div class="line">                            (ULONG) 0);</div><div class="line"><span class="preprocessor"> #elif BSP_CFG_RTOS == 2               // FreeRTOS</span></div><div class="line">        *(p_extend-&gt;p_blocking_semaphore-&gt;p_semaphore_handle) =</div><div class="line">            xSemaphoreCreateCountingStatic((UBaseType_t) 1,</div><div class="line">                                           (UBaseType_t) 0,</div><div class="line">                                           p_extend-&gt;p_blocking_semaphore-&gt;p_semaphore_memory);</div><div class="line"><span class="preprocessor"> #endif</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Create a recursive mutex for bus lock if a recursive mutex is not NULL */</span></div><div class="line">    <span class="keywordflow">if</span> (NULL != p_extend-&gt;p_bus_recursive_mutex)</div><div class="line">    {</div><div class="line"><span class="preprocessor"> #if BSP_CFG_RTOS == 1                 // AzureOS</span></div><div class="line">        tx_mutex_create(p_extend-&gt;p_bus_recursive_mutex-&gt;p_mutex_handle,</div><div class="line">                        p_extend-&gt;p_bus_recursive_mutex-&gt;p_mutex_name,</div><div class="line">                        TX_INHERIT);</div><div class="line"><span class="preprocessor"> #elif BSP_CFG_RTOS == 2               // FreeRTOS</span></div><div class="line">        *(p_extend-&gt;p_bus_recursive_mutex-&gt;p_mutex_handle) =</div><div class="line">            xSemaphoreCreateRecursiveMutexStatic(p_extend-&gt;p_bus_recursive_mutex-&gt;p_mutex_memory);</div><div class="line"><span class="preprocessor"> #endif</span></div><div class="line">    }</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    err = <a class="code" href="group___r_m___o_b1203.html#ga34d3b67d431ab9cdb45fa561196d8e85">RM_OB1203_Open</a>(&amp;g_ob1203_ctrl, &amp;g_ob1203_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    g_i2c_flag = 0;</div><div class="line"></div><div class="line">    <span class="comment">/* Start measurement */</span></div><div class="line">    <a class="code" href="group___r_m___o_b1203.html#gaabca4420cac85f4ea23be2454863d443">RM_OB1203_MeasurementStart</a>(&amp;g_ob1203_ctrl);</div><div class="line">    <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait callback */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line"><span class="preprocessor">#if RM_OB1203_EXAMPLE_IRQ_ENABLE</span></div><div class="line"></div><div class="line">        <span class="comment">/* Wait IRQ callback */</span></div><div class="line">        <span class="keywordflow">while</span> (0 == g_irq_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_irq_flag = 0;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">        <span class="keywordflow">do</span></div><div class="line">        {</div><div class="line">            g_i2c_flag = 0;</div><div class="line"></div><div class="line">            <span class="comment">/* Get device status */</span></div><div class="line">            <a class="code" href="group___r_m___o_b1203.html#ga13ab57714aafa9a3023a32f83c88e1dd">RM_OB1203_DeviceStatusGet</a>(&amp;g_ob1203_ctrl, &amp;device_status);</div><div class="line">            <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">            {</div><div class="line">                <span class="comment">/* Wait callback */</span></div><div class="line">            }</div><div class="line">        } <span class="keywordflow">while</span> (<span class="keyword">false</span> == device_status.ppg_measurement_complete);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">        g_i2c_flag = 0;</div><div class="line"></div><div class="line">        <span class="comment">/* Read ADC data */</span></div><div class="line">        <a class="code" href="group___r_m___o_b1203.html#ga306ea4427230d2c7c2e2c0ae53346a0b">RM_OB1203_PpgRead</a>(&amp;g_ob1203_ctrl, &amp;raw_data, 2);</div><div class="line">        <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Calculate ppg data */</span></div><div class="line">        <a class="code" href="group___r_m___o_b1203.html#gaffe63df6ba35eb27989b694af004a87b">RM_OB1203_PpgDataCalculate</a>(&amp;g_ob1203_ctrl, &amp;raw_data, &amp;ob1203_data);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h3>Light mode reconfiguration at runtime</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> rm_ob1203_light_reconfiguration_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    g_i2c_flag = 0;</div><div class="line"></div><div class="line">    <span class="comment">/* Stop a measurement */</span></div><div class="line">    <a class="code" href="group___r_m___o_b1203.html#gab851b2d1c598510756bea3608f3261a3">RM_OB1203_MeasurementStop</a>(&amp;g_ob1203_ctrl);</div><div class="line">    <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait callback */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    g_i2c_flag = 0;</div><div class="line"></div><div class="line">    <span class="comment">/* Set Light mode gain.</span></div><div class="line"><span class="comment">     * Example : Gain mode is 1.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__gain__t">rm_ob1203_gain_t</a> gain =</div><div class="line">    {</div><div class="line">        .<a class="code" href="group___r_m___o_b1203___a_p_i.html#a895aed77cf1aba3014b6d0b631e8a10d">light</a> = <a class="code" href="group___r_m___o_b1203___a_p_i.html#ggaa246c1288f2d4941973249afa6acb4d4ae9174a008bd9ea518eae214629f0a814">RM_OB1203_LIGHT_GAIN_1</a>,</div><div class="line">    };</div><div class="line">    <a class="code" href="group___r_m___o_b1203.html#ga554b7652ea5ee0de096b21e6580f164f">RM_OB1203_GainSet</a>(&amp;g_ob1203_ctrl, gain);</div><div class="line">    <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait callback */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    g_i2c_flag = 0;</div><div class="line"></div><div class="line"><span class="preprocessor">#if RM_OB1203_EXAMPLE_IRQ_ENABLE</span></div><div class="line"></div><div class="line">    <span class="comment">/* Set interrupt configurations for Light mode.</span></div><div class="line"><span class="comment">     * Example :</span></div><div class="line"><span class="comment">     * Source : Green channel</span></div><div class="line"><span class="comment">     * Type : threshold interrupt</span></div><div class="line"><span class="comment">     * Persist : 0x02</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__device__interrupt__cfg__t">rm_ob1203_device_interrupt_cfg_t</a> interrupt_cfg =</div><div class="line">    {</div><div class="line">        .<a class="code" href="group___r_m___o_b1203___a_p_i.html#a464bef4e7cf70926e60bbed2c0b492af">light_source</a> = <a class="code" href="group___r_m___o_b1203___a_p_i.html#ggad65df49755c15c3a73ea8eb8ca2a9e3aacc3d165eaaefc115adc56edc587ff98e">RM_OB1203_LIGHT_INTERRUPT_SOURCE_GREEN_CHANNEL</a>,</div><div class="line">        .light_type   = <a class="code" href="group___r_m___o_b1203___a_p_i.html#gga4569d4be03632003ce030d966d4e02c5a44bb84ec3d4ec69d6e51912dc260b5b0">RM_OB1203_LIGHT_INTERRUPT_TYPE_THRESHOLD</a>,</div><div class="line">        .persist      = 0x02,</div><div class="line">    };</div><div class="line">    <a class="code" href="group___r_m___o_b1203.html#gae791e9a53d7642b5ab9bed5ddfb195fa">RM_OB1203_DeviceInterruptCfgSet</a>(&amp;g_ob1203_ctrl, interrupt_cfg);</div><div class="line">    <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait callback */</span></div><div class="line">    }</div><div class="line">    g_i2c_flag = 0;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="comment">/* Restart a measurement */</span></div><div class="line">    <a class="code" href="group___r_m___o_b1203.html#gaabca4420cac85f4ea23be2454863d443">RM_OB1203_MeasurementStart</a>(&amp;g_ob1203_ctrl);</div><div class="line">    <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait callback */</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h3>Proximity mode reconfiguration at runtime</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> rm_ob1203_prox_reconfiguration_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    g_i2c_flag = 0;</div><div class="line"></div><div class="line">    <span class="comment">/* Stop a measurement */</span></div><div class="line">    <a class="code" href="group___r_m___o_b1203.html#gab851b2d1c598510756bea3608f3261a3">RM_OB1203_MeasurementStop</a>(&amp;g_ob1203_ctrl);</div><div class="line">    <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait callback */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    g_i2c_flag = 0;</div><div class="line"></div><div class="line">    <span class="comment">/* Set Proximity mode gain.</span></div><div class="line"><span class="comment">     * Example : Gain mode is 2.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__gain__t">rm_ob1203_gain_t</a> gain =</div><div class="line">    {</div><div class="line">        .<a class="code" href="group___r_m___o_b1203___a_p_i.html#a36749f94b25fce91140f34d29c8e30bb">ppg_prox</a> = <a class="code" href="group___r_m___o_b1203___a_p_i.html#gga02afdc6d89538793ab3f1ebd2a84ff6fa37b9289fd92d4c206f21a06ea2a99ca5">RM_OB1203_PPG_PROX_GAIN_2</a>,</div><div class="line">    };</div><div class="line">    <a class="code" href="group___r_m___o_b1203.html#ga554b7652ea5ee0de096b21e6580f164f">RM_OB1203_GainSet</a>(&amp;g_ob1203_ctrl, gain);</div><div class="line">    <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait callback */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    g_i2c_flag = 0;</div><div class="line"></div><div class="line">    <span class="comment">/* Set LED current.</span></div><div class="line"><span class="comment">     * Example :</span></div><div class="line"><span class="comment">     * LED : IR LED</span></div><div class="line"><span class="comment">     * Current : 0x366 (10bits).</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__led__current__t">rm_ob1203_led_current_t</a> led_current =</div><div class="line">    {</div><div class="line">        .<a class="code" href="group___r_m___o_b1203___a_p_i.html#af510fc446832c663bed37b3ab42a90b3">ir_led</a> = RM_OB1203_EXAMPLE_IR_CURRENT_0X366,</div><div class="line">    };</div><div class="line">    <a class="code" href="group___r_m___o_b1203.html#ga5666b0538afdae80059de7271667694c">RM_OB1203_LedCurrentSet</a>(&amp;g_ob1203_ctrl, led_current);</div><div class="line">    <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait callback */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    g_i2c_flag = 0;</div><div class="line"></div><div class="line"><span class="preprocessor">#if RM_OB1203_EXAMPLE_IRQ_ENABLE</span></div><div class="line"></div><div class="line">    <span class="comment">/* Set interrupt configurations for Proximity mode.</span></div><div class="line"><span class="comment">     * Example :</span></div><div class="line"><span class="comment">     * Type : normal interrupt</span></div><div class="line"><span class="comment">     * Persist : 0x02</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__device__interrupt__cfg__t">rm_ob1203_device_interrupt_cfg_t</a> interrupt_cfg =</div><div class="line">    {</div><div class="line">        .<a class="code" href="group___r_m___o_b1203___a_p_i.html#a45f7c3c0573f56bf411ac2953b7c5883">prox_type</a> = <a class="code" href="group___r_m___o_b1203___a_p_i.html#ggaac3af213866be23053d28609f06bf748a6975eb682b450d57085774e5caa4e0a0">RM_OB1203_PROX_INTERRUPT_TYPE_NORMAL</a>,</div><div class="line">        .persist   = 0x02,</div><div class="line">    };</div><div class="line">    <a class="code" href="group___r_m___o_b1203.html#gae791e9a53d7642b5ab9bed5ddfb195fa">RM_OB1203_DeviceInterruptCfgSet</a>(&amp;g_ob1203_ctrl, interrupt_cfg);</div><div class="line">    <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait callback */</span></div><div class="line">    }</div><div class="line">    g_i2c_flag = 0;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="comment">/* Restart a measurement */</span></div><div class="line">    <a class="code" href="group___r_m___o_b1203.html#gaabca4420cac85f4ea23be2454863d443">RM_OB1203_MeasurementStart</a>(&amp;g_ob1203_ctrl);</div><div class="line">    <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait callback */</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h3>Light Proximity mode reconfiguration at runtime</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> rm_ob1203_light_prox_reconfiguration_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    g_i2c_flag = 0;</div><div class="line"></div><div class="line">    <span class="comment">/* Stop a measurement */</span></div><div class="line">    <a class="code" href="group___r_m___o_b1203.html#gab851b2d1c598510756bea3608f3261a3">RM_OB1203_MeasurementStop</a>(&amp;g_ob1203_ctrl);</div><div class="line">    <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait callback */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    g_i2c_flag = 0;</div><div class="line"></div><div class="line">    <span class="comment">/* Set Proximity mode gain.</span></div><div class="line"><span class="comment">     * Example :</span></div><div class="line"><span class="comment">     * Light mode : 1</span></div><div class="line"><span class="comment">     * Proximity mode : 2</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__gain__t">rm_ob1203_gain_t</a> gain =</div><div class="line">    {</div><div class="line">        .<a class="code" href="group___r_m___o_b1203___a_p_i.html#a895aed77cf1aba3014b6d0b631e8a10d">light</a>    = <a class="code" href="group___r_m___o_b1203___a_p_i.html#ggaa246c1288f2d4941973249afa6acb4d4ae9174a008bd9ea518eae214629f0a814">RM_OB1203_LIGHT_GAIN_1</a>,</div><div class="line">        .ppg_prox = <a class="code" href="group___r_m___o_b1203___a_p_i.html#gga02afdc6d89538793ab3f1ebd2a84ff6fa37b9289fd92d4c206f21a06ea2a99ca5">RM_OB1203_PPG_PROX_GAIN_2</a>,</div><div class="line">    };</div><div class="line">    <a class="code" href="group___r_m___o_b1203.html#ga554b7652ea5ee0de096b21e6580f164f">RM_OB1203_GainSet</a>(&amp;g_ob1203_ctrl, gain);</div><div class="line">    <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait callback */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    g_i2c_flag = 0;</div><div class="line"></div><div class="line">    <span class="comment">/* Set LED current.</span></div><div class="line"><span class="comment">     * Example :</span></div><div class="line"><span class="comment">     * LED : IR LED</span></div><div class="line"><span class="comment">     * Current : 0x366 (10bits).</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__led__current__t">rm_ob1203_led_current_t</a> led_current =</div><div class="line">    {</div><div class="line">        .<a class="code" href="group___r_m___o_b1203___a_p_i.html#af510fc446832c663bed37b3ab42a90b3">ir_led</a> = RM_OB1203_EXAMPLE_IR_CURRENT_0X366,</div><div class="line">    };</div><div class="line">    <a class="code" href="group___r_m___o_b1203.html#ga5666b0538afdae80059de7271667694c">RM_OB1203_LedCurrentSet</a>(&amp;g_ob1203_ctrl, led_current);</div><div class="line">    <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait callback */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    g_i2c_flag = 0;</div><div class="line"></div><div class="line"><span class="preprocessor">#if RM_OB1203_EXAMPLE_IRQ_ENABLE</span></div><div class="line"></div><div class="line">    <span class="comment">/* Set interrupt configurations for Light Proximity mode.</span></div><div class="line"><span class="comment">     * Example :</span></div><div class="line"><span class="comment">     * device interrupt : Proximity mode</span></div><div class="line"><span class="comment">     * Type : normal interrupt</span></div><div class="line"><span class="comment">     * Persist : 0x02</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__device__interrupt__cfg__t">rm_ob1203_device_interrupt_cfg_t</a> interrupt_cfg =</div><div class="line">    {</div><div class="line">        .<a class="code" href="group___r_m___o_b1203___a_p_i.html#a098de06ea0c6b7261ccca0d471f964f6">light_prox_mode</a> = <a class="code" href="group___r_m___o_b1203___a_p_i.html#gga6c3b7fc2670bb119c9eb07acecf69847adef6dd35d4907586d53e93c43afa5dba">RM_OB1203_OPERATION_MODE_PROXIMITY</a>,</div><div class="line">        .prox_type       = <a class="code" href="group___r_m___o_b1203___a_p_i.html#ggaac3af213866be23053d28609f06bf748a6975eb682b450d57085774e5caa4e0a0">RM_OB1203_PROX_INTERRUPT_TYPE_NORMAL</a>,</div><div class="line">        .persist         = 0x02,</div><div class="line">    };</div><div class="line">    <a class="code" href="group___r_m___o_b1203.html#gae791e9a53d7642b5ab9bed5ddfb195fa">RM_OB1203_DeviceInterruptCfgSet</a>(&amp;g_ob1203_ctrl, interrupt_cfg);</div><div class="line">    <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait callback */</span></div><div class="line">    }</div><div class="line">    g_i2c_flag = 0;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="comment">/* Restart a measurement */</span></div><div class="line">    <a class="code" href="group___r_m___o_b1203.html#gaabca4420cac85f4ea23be2454863d443">RM_OB1203_MeasurementStart</a>(&amp;g_ob1203_ctrl);</div><div class="line">    <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait callback */</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h3>PPG mode reconfiguration at runtime</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> rm_ob1203_ppg_reconfiguration_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    g_i2c_flag = 0;</div><div class="line"></div><div class="line">    <span class="comment">/* Stop a measurement */</span></div><div class="line">    <a class="code" href="group___r_m___o_b1203.html#gab851b2d1c598510756bea3608f3261a3">RM_OB1203_MeasurementStop</a>(&amp;g_ob1203_ctrl);</div><div class="line">    <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait callback */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    g_i2c_flag = 0;</div><div class="line"></div><div class="line">    <span class="comment">/* Set PPG mode gain.</span></div><div class="line"><span class="comment">     * Example : Gain mode is 2.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__gain__t">rm_ob1203_gain_t</a> gain =</div><div class="line">    {</div><div class="line">        .<a class="code" href="group___r_m___o_b1203___a_p_i.html#a36749f94b25fce91140f34d29c8e30bb">ppg_prox</a> = <a class="code" href="group___r_m___o_b1203___a_p_i.html#gga02afdc6d89538793ab3f1ebd2a84ff6fa37b9289fd92d4c206f21a06ea2a99ca5">RM_OB1203_PPG_PROX_GAIN_2</a>,</div><div class="line">    };</div><div class="line">    <a class="code" href="group___r_m___o_b1203.html#ga554b7652ea5ee0de096b21e6580f164f">RM_OB1203_GainSet</a>(&amp;g_ob1203_ctrl, gain);</div><div class="line">    <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait callback */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    g_i2c_flag = 0;</div><div class="line"></div><div class="line">    <span class="comment">/* Set LED current.</span></div><div class="line"><span class="comment">     * Example :</span></div><div class="line"><span class="comment">     * IR LED   : 0x366 (10bits).</span></div><div class="line"><span class="comment">     * Red LED  : 0x1B3 (9bits).</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__led__current__t">rm_ob1203_led_current_t</a> led_current =</div><div class="line">    {</div><div class="line">        .<a class="code" href="group___r_m___o_b1203___a_p_i.html#af510fc446832c663bed37b3ab42a90b3">ir_led</a>  = RM_OB1203_EXAMPLE_IR_CURRENT_0X366,</div><div class="line">        .red_led = RM_OB1203_EXAMPLE_RED_CURRENT_0X1B3,</div><div class="line">    };</div><div class="line">    <a class="code" href="group___r_m___o_b1203.html#ga5666b0538afdae80059de7271667694c">RM_OB1203_LedCurrentSet</a>(&amp;g_ob1203_ctrl, led_current);</div><div class="line">    <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait callback */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    g_i2c_flag = 0;</div><div class="line"></div><div class="line"><span class="preprocessor">#if RM_OB1203_EXAMPLE_IRQ_ENABLE</span></div><div class="line"></div><div class="line">    <span class="comment">/* Set interrupt configurations for PPG mode.</span></div><div class="line"><span class="comment">     * Example :</span></div><div class="line"><span class="comment">     * Type : data interrupt</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__device__interrupt__cfg__t">rm_ob1203_device_interrupt_cfg_t</a> interrupt_cfg =</div><div class="line">    {</div><div class="line">        .<a class="code" href="group___r_m___o_b1203___a_p_i.html#a53330895d99a2275d9c0017cde87f7be">ppg_type</a> = <a class="code" href="group___r_m___o_b1203___a_p_i.html#gga8ee7cd0bc32e3c09662791b7e86ffe83a45cc5bde2c5eb934a0b8236782159316">RM_OB1203_PPG_INTERRUPT_TYPE_DATA</a>,</div><div class="line">    };</div><div class="line">    <a class="code" href="group___r_m___o_b1203.html#gae791e9a53d7642b5ab9bed5ddfb195fa">RM_OB1203_DeviceInterruptCfgSet</a>(&amp;g_ob1203_ctrl, interrupt_cfg);</div><div class="line">    <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait callback */</span></div><div class="line">    }</div><div class="line">    g_i2c_flag = 0;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="comment">/* Restart a measurement */</span></div><div class="line">    <a class="code" href="group___r_m___o_b1203.html#gaabca4420cac85f4ea23be2454863d443">RM_OB1203_MeasurementStart</a>(&amp;g_ob1203_ctrl);</div><div class="line">    <span class="keywordflow">while</span> (0 == g_i2c_flag)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait callback */</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structrm__ob1203__init__process__params__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#structrm__ob1203__init__process__params__t">rm_ob1203_init_process_params_t</a></td></tr>
<tr class="separator:structrm__ob1203__init__process__params__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structrm__ob1203__mode__extended__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#structrm__ob1203__mode__extended__cfg__t">rm_ob1203_mode_extended_cfg_t</a></td></tr>
<tr class="separator:structrm__ob1203__mode__extended__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structrm__ob1203__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#structrm__ob1203__instance__ctrl__t">rm_ob1203_instance_ctrl_t</a></td></tr>
<tr class="separator:structrm__ob1203__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structrm__ob1203__init__process__params__t" id="structrm__ob1203__init__process__params__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structrm__ob1203__init__process__params__t">&#9670;&nbsp;</a></span>rm_ob1203_init_process_params_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rm_ob1203_init_process_params_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>OB1203 initialization process block </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="aea4edefdaa00495d377261f39c36b33f"></a>volatile bool</td>
<td class="fieldname">
communication_finished</td>
<td class="fielddoc">
Communication flag for blocking. </td></tr>
<tr><td class="fieldtype">
<a id="ac1299c7dc5347bb69d968283a73e655d"></a>volatile <a class="el" href="group___r_m___o_b1203___a_p_i.html#ga649fde9081cd4c40cac825f132598091">rm_ob1203_event_t</a></td>
<td class="fieldname">
event</td>
<td class="fielddoc">
Callback event. </td></tr>
</table>

</div>
</div>
<a name="structrm__ob1203__mode__extended__cfg__t" id="structrm__ob1203__mode__extended__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structrm__ob1203__mode__extended__cfg__t">&#9670;&nbsp;</a></span>rm_ob1203_mode_extended_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rm_ob1203_mode_extended_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>OB1203 mode extended configuration </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ada67105cd21a7dae41a9e6a46e96dd1d"></a><a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__api__t">rm_ob1203_api_t</a> const  *</td>
<td class="fieldname">
p_api</td>
<td class="fielddoc">
Pointer to APIs. </td></tr>
<tr><td class="fieldtype">
<a id="a8b9c2e8ea5903f1d3c42cf99539a6f37"></a><a class="el" href="group___r_m___o_b1203___a_p_i.html#ga6c3b7fc2670bb119c9eb07acecf69847">rm_ob1203_operation_mode_t</a></td>
<td class="fieldname">
mode_irq</td>
<td class="fielddoc">
Operation mode using IRQ. </td></tr>
<tr><td class="fieldtype">
<a id="a7d96e3fa4f80d77e18d6311b58abb351"></a><a class="el" href="group___r_m___o_b1203___a_p_i.html#ga02afdc6d89538793ab3f1ebd2a84ff6f">rm_ob1203_ppg_prox_gain_t</a></td>
<td class="fieldname">
ppg_prox_gain</td>
<td class="fielddoc">
Proximity gain range. </td></tr>
<tr><td class="fieldtype">
<a id="a6ea712faa60b5098695c5bf9dee22fa9"></a><a class="el" href="group___r_m___o_b1203___a_p_i.html#gab0d74efedf983faf97798d0136376219">rm_ob1203_led_order_t</a></td>
<td class="fieldname">
led_order</td>
<td class="fielddoc">
LED order. </td></tr>
<tr><td class="fieldtype">
<a id="a2dff0d73a95082059f417d185b80cb8a"></a><a class="el" href="group___r_m___o_b1203___a_p_i.html#ga35f1462a48dabaf6cf97ece29efe6271">rm_ob1203_light_sensor_mode_t</a></td>
<td class="fieldname">
light_sensor_mode</td>
<td class="fielddoc">
LS or CS sensor mode. </td></tr>
<tr><td class="fieldtype">
<a id="a552c03c8de87ba18c02d7d92ccb492d4"></a><a class="el" href="group___r_m___o_b1203___a_p_i.html#ga4569d4be03632003ce030d966d4e02c5">rm_ob1203_light_interrupt_type_t</a></td>
<td class="fieldname">
light_interrupt_type</td>
<td class="fielddoc">
Light mode interrupt type. </td></tr>
<tr><td class="fieldtype">
<a id="a717ea530db97b35669792d4402106037"></a><a class="el" href="group___r_m___o_b1203___a_p_i.html#gad65df49755c15c3a73ea8eb8ca2a9e3a">rm_ob1203_light_interrupt_source_t</a></td>
<td class="fieldname">
light_interrupt_source</td>
<td class="fielddoc">
Light mode interrupt source. </td></tr>
<tr><td class="fieldtype">
<a id="a022942b085717470822f277c4b31ba3a"></a>uint8_t</td>
<td class="fieldname">
light_interrupt_persist</td>
<td class="fielddoc">
The number of similar consecutive Light mode interrupt events that must occur before the interrupt is asserted (4bits). </td></tr>
<tr><td class="fieldtype">
<a id="aeb793e75865a9f62297d91034603aaf1"></a><a class="el" href="group___r_m___o_b1203___a_p_i.html#ga3de882d54ed2555e788d24da2059217d">rm_ob1203_sleep_after_interrupt_t</a></td>
<td class="fieldname">
light_sleep</td>
<td class="fielddoc">
Sleep after an interrupt. </td></tr>
<tr><td class="fieldtype">
<a id="aa3cb62edd73814ba315627754fd85266"></a><a class="el" href="group___r_m___o_b1203___a_p_i.html#gaa246c1288f2d4941973249afa6acb4d4">rm_ob1203_light_gain_t</a></td>
<td class="fieldname">
light_gain</td>
<td class="fielddoc">
Light gain range. </td></tr>
<tr><td class="fieldtype">
<a id="ac5d15bf27b5bcd1a6b721a0f67374372"></a>uint32_t</td>
<td class="fieldname">
light_upper_threshold</td>
<td class="fielddoc">
Upper threshold for interrupt. </td></tr>
<tr><td class="fieldtype">
<a id="a3d101a3a796221fc394abb203998d492"></a>uint32_t</td>
<td class="fieldname">
light_lower_threshold</td>
<td class="fielddoc">
Lower threshold for interrupt. </td></tr>
<tr><td class="fieldtype">
<a id="afd0c72c77c52c3eeb6c3c82649807cac"></a><a class="el" href="group___r_m___o_b1203___a_p_i.html#gaeae8a766bbc25cd6e1097c44f03c8dea">rm_ob1203_variance_threshold_t</a></td>
<td class="fieldname">
light_variance_threshold</td>
<td class="fielddoc">
variance threshold for interrupt. </td></tr>
<tr><td class="fieldtype">
<a id="a002e10b810510f6ddacf3636941b8ad3"></a><a class="el" href="group___r_m___o_b1203___a_p_i.html#gab55b5fd0ddd115230c80a2ef140cfdc8">rm_ob1203_light_resolution_meas_period_t</a></td>
<td class="fieldname">
light_resolution_period</td>
<td class="fielddoc">
Resolution and measurement period. </td></tr>
<tr><td class="fieldtype">
<a id="a92cbb312b5e1e41706b4e68b38357f02"></a><a class="el" href="group___r_m___o_b1203___a_p_i.html#ga0c0d347b4e6af84c4f4148ea68280337">rm_ob1203_light_data_type_t</a></td>
<td class="fieldname">
light_data_type</td>
<td class="fielddoc">
Light data type. </td></tr>
<tr><td class="fieldtype">
<a id="a1ee453fb8ab99c99f7c66a81ec8930fc"></a><a class="el" href="group___r_m___o_b1203___a_p_i.html#ga3de882d54ed2555e788d24da2059217d">rm_ob1203_sleep_after_interrupt_t</a></td>
<td class="fieldname">
prox_sleep</td>
<td class="fielddoc">
Sleep after an interrupt. </td></tr>
<tr><td class="fieldtype">
<a id="a8f73599ce4c7f63c4c823e74f7c567cb"></a><a class="el" href="group___r_m___o_b1203___a_p_i.html#gaac3af213866be23053d28609f06bf748">rm_ob1203_prox_interrupt_type_t</a></td>
<td class="fieldname">
prox_interrupt_type</td>
<td class="fielddoc">
Proximity mode interrupt type. </td></tr>
<tr><td class="fieldtype">
<a id="a0b8c9711655d57482f2fa4885b6fe358"></a>uint8_t</td>
<td class="fieldname">
prox_interrupt_persist</td>
<td class="fielddoc">
The number of similar consecutive Proximity mode interrupt events that must occur before the interrupt is asserted (4bits). </td></tr>
<tr><td class="fieldtype">
<a id="a5a121bd4d0dd5525fe4fa1940c2807f7"></a>uint16_t</td>
<td class="fieldname">
prox_led_current</td>
<td class="fielddoc">
Proximity LED current. </td></tr>
<tr><td class="fieldtype">
<a id="a76a478bfae379eccb11d7da016c0b223"></a><a class="el" href="group___r_m___o_b1203___a_p_i.html#ga4d79e3bac567b22223b4e219a6ee7f34">rm_ob1203_analog_cancellation_t</a></td>
<td class="fieldname">
prox_ana_can</td>
<td class="fielddoc">
Analog cancellation. </td></tr>
<tr><td class="fieldtype">
<a id="a602e9dc2a52e58a964e3d31d40f804bd"></a>uint16_t</td>
<td class="fieldname">
prox_dig_can</td>
<td class="fielddoc">
Digital cancellation. </td></tr>
<tr><td class="fieldtype">
<a id="a8b1238b9262829b92acf3b488fba8164"></a><a class="el" href="group___r_m___o_b1203___a_p_i.html#gaf6e99ef0d49ecff17a9ffd16f0b096e6">rm_ob1203_number_led_pulses_t</a></td>
<td class="fieldname">
prox_num_led_pulses</td>
<td class="fielddoc">
Number of LED pulses. </td></tr>
<tr><td class="fieldtype">
<a id="a5f59be16765f431c4a5793bfb2d6bf7b"></a>uint16_t</td>
<td class="fieldname">
prox_upper_threshold</td>
<td class="fielddoc">
Upper threshold for interrupt. </td></tr>
<tr><td class="fieldtype">
<a id="a0afb601514b214fc0f69648150d139b4"></a>uint16_t</td>
<td class="fieldname">
prox_lower_threshold</td>
<td class="fielddoc">
Lower threshold for interrupt. </td></tr>
<tr><td class="fieldtype">
<a id="a95edd35c1ca18bb45030ea849f72c079"></a><a class="el" href="group___r_m___o_b1203___a_p_i.html#ga463e63a319a589ebdcf29b0b482b2f00">rm_ob1203_prox_pulse_width_meas_period_t</a></td>
<td class="fieldname">
prox_width_period</td>
<td class="fielddoc">
Proximity pulse width and measurement period. </td></tr>
<tr><td class="fieldtype">
<a id="ae462f5fde180d3b4bc191a7b0b36de1a"></a><a class="el" href="group___r_m___o_b1203___a_p_i.html#ga110a5efe8990e8dd03692e565f452910">rm_ob1203_moving_average_t</a></td>
<td class="fieldname">
prox_moving_average</td>
<td class="fielddoc">
Moving average. </td></tr>
<tr><td class="fieldtype">
<a id="a84152ba34a94d2cc53b01a0195d1e499"></a>uint8_t</td>
<td class="fieldname">
prox_hysteresis</td>
<td class="fielddoc">
Proximity hysteresis threshold (7bits). </td></tr>
<tr><td class="fieldtype">
<a id="a5304c578e8d3e84524754223a865b89c"></a><a class="el" href="group___r_m___o_b1203___a_p_i.html#ga073572d75f036110608bf2a723c62fc8">rm_ob1203_ppg_sensor_mode_t</a></td>
<td class="fieldname">
ppg_sensor_mode</td>
<td class="fielddoc">
PPG1 or PPG2 sensor mode. </td></tr>
<tr><td class="fieldtype">
<a id="a8c2e28fd8857be8e771d04d82bc956ea"></a><a class="el" href="group___r_m___o_b1203___a_p_i.html#ga8ee7cd0bc32e3c09662791b7e86ffe83">rm_ob1203_ppg_interrupt_type_t</a></td>
<td class="fieldname">
ppg_interrupt_type</td>
<td class="fielddoc">
PPG mode interrupt type. </td></tr>
<tr><td class="fieldtype">
<a id="a6d8a552db7926950c4b1c419a48fdf4e"></a>uint16_t</td>
<td class="fieldname">
ppg_ir_led_current</td>
<td class="fielddoc">
PPG IR LED current. </td></tr>
<tr><td class="fieldtype">
<a id="a86d8b953af37f657dfeb162cd0591de0"></a>uint16_t</td>
<td class="fieldname">
ppg_red_led_current</td>
<td class="fielddoc">
PPG Red LED current. </td></tr>
<tr><td class="fieldtype">
<a id="ae35c158322080273b5df3e059528f752"></a><a class="el" href="group___r_m___o_b1203___a_p_i.html#ga904954d6bf969490d7fc31d1589fba5c">rm_ob1203_power_save_mode_t</a></td>
<td class="fieldname">
ppg_power_save_mode</td>
<td class="fielddoc">
PPG power save mode. </td></tr>
<tr><td class="fieldtype">
<a id="a2abd97a96166d245c48e6e0787693fb4"></a><a class="el" href="group___r_m___o_b1203___a_p_i.html#ga4d79e3bac567b22223b4e219a6ee7f34">rm_ob1203_analog_cancellation_t</a></td>
<td class="fieldname">
ppg_ir_led_ana_can</td>
<td class="fielddoc">
IR LED analog cancellations. </td></tr>
<tr><td class="fieldtype">
<a id="a5c280d0afc580954d5ed17337c03f5ef"></a><a class="el" href="group___r_m___o_b1203___a_p_i.html#ga4d79e3bac567b22223b4e219a6ee7f34">rm_ob1203_analog_cancellation_t</a></td>
<td class="fieldname">
ppg_red_led_ana_can</td>
<td class="fielddoc">
Red LED analog cancellations. </td></tr>
<tr><td class="fieldtype">
<a id="a5b83bc78a2501b848235a640aff20547"></a><a class="el" href="group___r_m___o_b1203___a_p_i.html#ga7dc5ec94376eb3c1fa0a16b549c56f5d">rm_ob1203_number_averaged_samples_t</a></td>
<td class="fieldname">
ppg_num_averaged_samples</td>
<td class="fielddoc">
Number of averaged PPG samples. </td></tr>
<tr><td class="fieldtype">
<a id="ae36a5f755dda4ad54a211d7beceaa1fe"></a><a class="el" href="group___r_m___o_b1203___a_p_i.html#ga5bb022affce59b47909e01ae68d01f5c">rm_ob1203_ppg_pulse_width_meas_period_t</a></td>
<td class="fieldname">
ppg_width_period</td>
<td class="fielddoc">
PPG pulse width and measurement period. </td></tr>
<tr><td class="fieldtype">
<a id="a6b1b27c35ae14887c24ac87fc09ae5b2"></a><a class="el" href="group___r_m___o_b1203___a_p_i.html#ga41b9839d52cdeaa01260dc24932d6fe3">rm_ob1203_fifo_rollover_t</a></td>
<td class="fieldname">
ppg_fifo_rollover</td>
<td class="fielddoc">
FIFO rollover enable. </td></tr>
<tr><td class="fieldtype">
<a id="a4a9e23f9ea29a94ce55aecf2a6a90efd"></a>uint8_t</td>
<td class="fieldname">
ppg_fifo_empty_num</td>
<td class="fielddoc">
the number of empty FIFO words when the FIFO almost full interrupt is issued. In PPG2 Mode only even values should be used. (4 bits) </td></tr>
<tr><td class="fieldtype">
<a id="a7653a25ab1427a9ed18b79cdef7bfb16"></a>uint8_t</td>
<td class="fieldname">
ppg_number_of_samples</td>
<td class="fielddoc">
Number of PPG samples. </td></tr>
</table>

</div>
</div>
<a name="structrm__ob1203__instance__ctrl__t" id="structrm__ob1203__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structrm__ob1203__instance__ctrl__t">&#9670;&nbsp;</a></span>rm_ob1203_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rm_ob1203_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>OB1203 Control Block </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:aa46c287c33542e87f8bd3156acc5a978"><td class="memItemLeft" align="right" valign="top"><a id="aa46c287c33542e87f8bd3156acc5a978"></a>
rm_ob1203_semaphore_t const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#aa46c287c33542e87f8bd3156acc5a978">p_semaphore</a></td></tr>
<tr class="memdesc:aa46c287c33542e87f8bd3156acc5a978"><td class="mdescLeft">&#160;</td><td class="mdescRight">The semaphore to wait for callback. This is used for another data read/write after a communication. <br /></td></tr>
<tr class="separator:aa46c287c33542e87f8bd3156acc5a978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1adb0f5fdb98f08dc0795c8946b04e5"><td class="memItemLeft" align="right" valign="top"><a id="af1adb0f5fdb98f08dc0795c8946b04e5"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#af1adb0f5fdb98f08dc0795c8946b04e5">open</a></td></tr>
<tr class="memdesc:af1adb0f5fdb98f08dc0795c8946b04e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open flag. <br /></td></tr>
<tr class="separator:af1adb0f5fdb98f08dc0795c8946b04e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6bcc914fc1ce1cc6f6698aa8221cad"><td class="memItemLeft" align="right" valign="top"><a id="a1f6bcc914fc1ce1cc6f6698aa8221cad"></a>
<a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__cfg__t">rm_ob1203_cfg_t</a> const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#a1f6bcc914fc1ce1cc6f6698aa8221cad">p_cfg</a></td></tr>
<tr class="memdesc:a1f6bcc914fc1ce1cc6f6698aa8221cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to OB1203 Configuration. <br /></td></tr>
<tr class="separator:a1f6bcc914fc1ce1cc6f6698aa8221cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8315472488bcdc83146c0e0c873d8037"><td class="memItemLeft" align="right" valign="top"><a id="a8315472488bcdc83146c0e0c873d8037"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#a8315472488bcdc83146c0e0c873d8037">buf</a> [8]</td></tr>
<tr class="memdesc:a8315472488bcdc83146c0e0c873d8037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer for I2C communications. <br /></td></tr>
<tr class="separator:a8315472488bcdc83146c0e0c873d8037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fbc64795865bea8bc3d64f34a96c74"><td class="memItemLeft" align="right" valign="top"><a id="ae4fbc64795865bea8bc3d64f34a96c74"></a>
<a class="el" href="group___r_m___o_b1203.html#structrm__ob1203__init__process__params__t">rm_ob1203_init_process_params_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#ae4fbc64795865bea8bc3d64f34a96c74">init_process_params</a></td></tr>
<tr class="memdesc:ae4fbc64795865bea8bc3d64f34a96c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">For the initialization process. <br /></td></tr>
<tr class="separator:ae4fbc64795865bea8bc3d64f34a96c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8671a1b4dd57a4e872515a27904d712b"><td class="memItemLeft" align="right" valign="top"><a id="a8671a1b4dd57a4e872515a27904d712b"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#a8671a1b4dd57a4e872515a27904d712b">register_address</a></td></tr>
<tr class="memdesc:a8671a1b4dd57a4e872515a27904d712b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register address to access. <br /></td></tr>
<tr class="separator:a8671a1b4dd57a4e872515a27904d712b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6474b07ae9f3ac43315f3614be9de2d6"><td class="memItemLeft" align="right" valign="top"><a id="a6474b07ae9f3ac43315f3614be9de2d6"></a>
volatile <a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__device__status__t">rm_ob1203_device_status_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#a6474b07ae9f3ac43315f3614be9de2d6">p_device_status</a></td></tr>
<tr class="memdesc:a6474b07ae9f3ac43315f3614be9de2d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to device status. <br /></td></tr>
<tr class="separator:a6474b07ae9f3ac43315f3614be9de2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65f28877e8b54a1b22601e42ab7d1db"><td class="memItemLeft" align="right" valign="top"><a id="af65f28877e8b54a1b22601e42ab7d1db"></a>
volatile <a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__fifo__info__t">rm_ob1203_fifo_info_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#af65f28877e8b54a1b22601e42ab7d1db">p_fifo_info</a></td></tr>
<tr class="memdesc:af65f28877e8b54a1b22601e42ab7d1db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to FIFO information structure. <br /></td></tr>
<tr class="separator:af65f28877e8b54a1b22601e42ab7d1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16876cb1e3093f468775969f97c77a78"><td class="memItemLeft" align="right" valign="top"><a id="a16876cb1e3093f468775969f97c77a78"></a>
volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#a16876cb1e3093f468775969f97c77a78">fifo_reset</a></td></tr>
<tr class="memdesc:a16876cb1e3093f468775969f97c77a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for FIFO reset for PPG mode. <br /></td></tr>
<tr class="separator:a16876cb1e3093f468775969f97c77a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c18e88241e0b27b67d0f7fbaf65d94a"><td class="memItemLeft" align="right" valign="top"><a id="a8c18e88241e0b27b67d0f7fbaf65d94a"></a>
volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#a8c18e88241e0b27b67d0f7fbaf65d94a">prox_gain_update</a></td></tr>
<tr class="memdesc:a8c18e88241e0b27b67d0f7fbaf65d94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for gain update for Proximity mode. <br /></td></tr>
<tr class="separator:a8c18e88241e0b27b67d0f7fbaf65d94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0b5939aa98532a28c344960a62379d"><td class="memItemLeft" align="right" valign="top"><a id="a6c0b5939aa98532a28c344960a62379d"></a>
volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#a6c0b5939aa98532a28c344960a62379d">interrupt_bits_clear</a></td></tr>
<tr class="memdesc:a6c0b5939aa98532a28c344960a62379d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for clearing interrupt bits. <br /></td></tr>
<tr class="separator:a6c0b5939aa98532a28c344960a62379d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ff7aa34215ceac46c9837869566943"><td class="memItemLeft" align="right" valign="top"><a id="a28ff7aa34215ceac46c9837869566943"></a>
<a class="el" href="group___r_m___c_o_m_m_s___a_p_i.html#structrm__comms__instance__t">rm_comms_instance_t</a> const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#a28ff7aa34215ceac46c9837869566943">p_comms_i2c_instance</a></td></tr>
<tr class="memdesc:a28ff7aa34215ceac46c9837869566943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer of I2C Communications Middleware instance structure. <br /></td></tr>
<tr class="separator:a28ff7aa34215ceac46c9837869566943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53827a211cd1402bd8945e8c5f16f5f"><td class="memItemLeft" align="right" valign="top"><a id="af53827a211cd1402bd8945e8c5f16f5f"></a>
<a class="el" href="group___r_m___o_b1203.html#structrm__ob1203__mode__extended__cfg__t">rm_ob1203_mode_extended_cfg_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#af53827a211cd1402bd8945e8c5f16f5f">p_mode</a></td></tr>
<tr class="memdesc:af53827a211cd1402bd8945e8c5f16f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer of OB1203 operation mode extended configuration. <br /></td></tr>
<tr class="separator:af53827a211cd1402bd8945e8c5f16f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189057778d7cbd48ac1ad8a1df064a77"><td class="memItemLeft" align="right" valign="top"><a id="a189057778d7cbd48ac1ad8a1df064a77"></a>
void const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#a189057778d7cbd48ac1ad8a1df064a77">p_irq_instance</a></td></tr>
<tr class="memdesc:a189057778d7cbd48ac1ad8a1df064a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to IRQ instance. <br /></td></tr>
<tr class="separator:a189057778d7cbd48ac1ad8a1df064a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761b053d6f0276e7cdbef4ab857141b9"><td class="memItemLeft" align="right" valign="top"><a id="a761b053d6f0276e7cdbef4ab857141b9"></a>
void const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#a761b053d6f0276e7cdbef4ab857141b9">p_context</a></td></tr>
<tr class="memdesc:a761b053d6f0276e7cdbef4ab857141b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the user-provided context. <br /></td></tr>
<tr class="separator:a761b053d6f0276e7cdbef4ab857141b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf0ccf0e2e10792107bdcb85790bad7"><td class="memItemLeft" align="right" valign="top"><a id="abaf0ccf0e2e10792107bdcb85790bad7"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#abaf0ccf0e2e10792107bdcb85790bad7">p_comms_callback</a> )(<a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__callback__args__t">rm_ob1203_callback_args_t</a> *p_args)</td></tr>
<tr class="memdesc:abaf0ccf0e2e10792107bdcb85790bad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C Communications callback. <br /></td></tr>
<tr class="separator:abaf0ccf0e2e10792107bdcb85790bad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa936e3ee9a75bee3c5a4aad146f04c7e"><td class="memItemLeft" align="right" valign="top"><a id="aa936e3ee9a75bee3c5a4aad146f04c7e"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m___o_b1203.html#aa936e3ee9a75bee3c5a4aad146f04c7e">p_irq_callback</a> )(<a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__callback__args__t">rm_ob1203_callback_args_t</a> *p_args)</td></tr>
<tr class="memdesc:aa936e3ee9a75bee3c5a4aad146f04c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">IRQ callback. <br /></td></tr>
<tr class="separator:aa936e3ee9a75bee3c5a4aad146f04c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga34d3b67d431ab9cdb45fa561196d8e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34d3b67d431ab9cdb45fa561196d8e85">&#9670;&nbsp;</a></span>RM_OB1203_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> RM_OB1203_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__cfg__t">rm_ob1203_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens and configures the OB1203 Middle module. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#a3d137e0be66735864d9a95669fa2c1f3">rm_ob1203_api_t::open</a>. </p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    err = <a class="code" href="group___r_m___o_b1203.html#ga34d3b67d431ab9cdb45fa561196d8e85">RM_OB1203_Open</a>(&amp;g_ob1203_ctrl, &amp;g_ob1203_cfg);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>OB1203 successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer, or one or more configuration options is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Module is already open. This module can only be opened once. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Communication is timeout. </td></tr>
    <tr><td class="paramname">FSP_ERR_ABORTED</td><td>Communication is aborted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaff536e258d187d8efd6fac712ca885e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff536e258d187d8efd6fac712ca885e1">&#9670;&nbsp;</a></span>RM_OB1203_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> RM_OB1203_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables specified OB1203 control block. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#afb392158117d2cc57e8c0ec5042b1361">rm_ob1203_api_t::close</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successfully closed. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaabca4420cac85f4ea23be2454863d443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabca4420cac85f4ea23be2454863d443">&#9670;&nbsp;</a></span>RM_OB1203_MeasurementStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> RM_OB1203_MeasurementStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start measurement. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#af9780f361fb17b04000550de7543134a">rm_ob1203_api_t::measurementStart</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successfully results are read. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not opened configured. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab851b2d1c598510756bea3608f3261a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab851b2d1c598510756bea3608f3261a3">&#9670;&nbsp;</a></span>RM_OB1203_MeasurementStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> RM_OB1203_MeasurementStop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop measurement. If device interrupt is enabled, interrupt bits are cleared after measurement stop. If PPG mode, FIFO information is also reset after measurement stop. In RTOS and Light/Proximity/Light Proximity mode, if device interrupt is enabled, blocks 2 bytes on the I2C bus. In RTOS and PPG mode, if device interrupt is enabled, blocks 6 bytes on the I2C bus. If device interrupt is disabled, blocks 4 bytes on the I2C bus. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#a9365629cc58e4f4c9cf33420b07416f5">rm_ob1203_api_t::measurementStop</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successfully results are read. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not opened configured. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad3e86f2d3ee11e505e5df6fc8e1b5c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3e86f2d3ee11e505e5df6fc8e1b5c1f">&#9670;&nbsp;</a></span>RM_OB1203_LightRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> RM_OB1203_LightRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__raw__data__t">rm_ob1203_raw_data_t</a> *const&#160;</td>
          <td class="paramname"><em>p_raw_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#ga0c0d347b4e6af84c4f4148ea68280337">rm_ob1203_light_data_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads Light ADC data from OB1203 device. If device interrupt is enabled, interrupt bits are cleared after data read. In RTOS and Light mode, if device interrupt is enabled, blocks 2 bytes on the I2C bus. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#ad778eb596d6af74ccedec46ed4dec9f7">rm_ob1203_api_t::lightRead</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successfully results are read. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not opened configured. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga56f8661c39d7b7b41e0799d528f08c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56f8661c39d7b7b41e0799d528f08c92">&#9670;&nbsp;</a></span>RM_OB1203_LightDataCalculate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> RM_OB1203_LightDataCalculate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__raw__data__t">rm_ob1203_raw_data_t</a> *const&#160;</td>
          <td class="paramname"><em>p_raw_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__light__data__t">rm_ob1203_light_data_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ob1203_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate light data from raw data. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#aa3ca0efc07f8e5cdf3086fe422239b60">rm_ob1203_api_t::lightDataCalculate</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successfully results are read. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not opened configured. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1de710492d4da21656a5cbd62eb2b721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1de710492d4da21656a5cbd62eb2b721">&#9670;&nbsp;</a></span>RM_OB1203_ProxRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> RM_OB1203_ProxRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__raw__data__t">rm_ob1203_raw_data_t</a> *const&#160;</td>
          <td class="paramname"><em>p_raw_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads Proximity ADC data from OB1203 device. If device interrupt is enabled, interrupt bits are cleared after data read. In RTOS and Proximity mode, if device interrupt is enabled, blocks 2 bytes on the I2C bus. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#a198466f69342eda1f86d4853d0157f22">rm_ob1203_api_t::proxRead</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successfully results are read. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not opened configured. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5888f249d9e67a2af39ce7977065d359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5888f249d9e67a2af39ce7977065d359">&#9670;&nbsp;</a></span>RM_OB1203_ProxDataCalculate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> RM_OB1203_ProxDataCalculate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__raw__data__t">rm_ob1203_raw_data_t</a> *const&#160;</td>
          <td class="paramname"><em>p_raw_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__prox__data__t">rm_ob1203_prox_data_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ob1203_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate proximity data from raw data. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#a9b7d68fb7a2baf7cca79ff3026e36cd5">rm_ob1203_api_t::proxDataCalculate</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successfully results are read. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not opened configured. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga306ea4427230d2c7c2e2c0ae53346a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga306ea4427230d2c7c2e2c0ae53346a0b">&#9670;&nbsp;</a></span>RM_OB1203_PpgRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> RM_OB1203_PpgRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__raw__data__t">rm_ob1203_raw_data_t</a> *const&#160;</td>
          <td class="paramname"><em>p_raw_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const&#160;</td>
          <td class="paramname"><em>number_of_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads PPG ADC data from OB1203 device. One sample requires three bytes. 0 cannot set to the number of samples. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#a9f902d2c8bf975288a49f443f20092ae">rm_ob1203_api_t::ppgRead</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successfully results are read. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not opened configured. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaffe63df6ba35eb27989b694af004a87b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffe63df6ba35eb27989b694af004a87b">&#9670;&nbsp;</a></span>RM_OB1203_PpgDataCalculate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> RM_OB1203_PpgDataCalculate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__raw__data__t">rm_ob1203_raw_data_t</a> *const&#160;</td>
          <td class="paramname"><em>p_raw_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__ppg__data__t">rm_ob1203_ppg_data_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ob1203_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate PPG data from raw data. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#a2f7c11ddb2c3d8c9cf91c25e3183daa1">rm_ob1203_api_t::ppgDataCalculate</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successfully results are read. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not opened configured. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga554b7652ea5ee0de096b21e6580f164f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga554b7652ea5ee0de096b21e6580f164f">&#9670;&nbsp;</a></span>RM_OB1203_GainSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> RM_OB1203_GainSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__gain__t">rm_ob1203_gain_t</a> const&#160;</td>
          <td class="paramname"><em>gain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set gain. This function should be called after calling <a class="el" href="group___r_m___o_b1203.html#gab851b2d1c598510756bea3608f3261a3" title="Stop measurement. If device interrupt is enabled, interrupt bits are cleared after measurement stop...">RM_OB1203_MeasurementStop()</a>. In RTOS and Light Proximity mode, blocks 2 bytes on the I2C bus. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#a82fdd4f8e1ef45d2f06a355d60979968">rm_ob1203_api_t::gainSet</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successfully results are read. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not opened configured. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5666b0538afdae80059de7271667694c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5666b0538afdae80059de7271667694c">&#9670;&nbsp;</a></span>RM_OB1203_LedCurrentSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> RM_OB1203_LedCurrentSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__led__current__t">rm_ob1203_led_current_t</a> const&#160;</td>
          <td class="paramname"><em>led_current</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set currents. This function should be called after calling <a class="el" href="group___r_m___o_b1203.html#gab851b2d1c598510756bea3608f3261a3" title="Stop measurement. If device interrupt is enabled, interrupt bits are cleared after measurement stop...">RM_OB1203_MeasurementStop()</a>. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#a7d3decdc87199472697b5aec3387d406">rm_ob1203_api_t::ledCurrentSet</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successfully results are read. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not opened configured. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae791e9a53d7642b5ab9bed5ddfb195fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae791e9a53d7642b5ab9bed5ddfb195fa">&#9670;&nbsp;</a></span>RM_OB1203_DeviceInterruptCfgSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> RM_OB1203_DeviceInterruptCfgSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__device__interrupt__cfg__t">rm_ob1203_device_interrupt_cfg_t</a> const&#160;</td>
          <td class="paramname"><em>interrupt_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set device interrupt configurations. This function should be called after calling <a class="el" href="group___r_m___o_b1203.html#gab851b2d1c598510756bea3608f3261a3" title="Stop measurement. If device interrupt is enabled, interrupt bits are cleared after measurement stop...">RM_OB1203_MeasurementStop()</a>. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#a32be3218edf3a0a22e3fd7403ae8d5e7">rm_ob1203_api_t::deviceInterruptCfgSet</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successfully results are read. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not opened configured. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6ffbbe58d90adb8001d2f6424987e71b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ffbbe58d90adb8001d2f6424987e71b">&#9670;&nbsp;</a></span>RM_OB1203_FifoInfoGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> RM_OB1203_FifoInfoGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__fifo__info__t">rm_ob1203_fifo_info_t</a> *const&#160;</td>
          <td class="paramname"><em>p_fifo_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get FIFO information from OB1203 device. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#ace63f4f8958af6e1424ad4fa176bbcf2">rm_ob1203_api_t::fifoInfoGet</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successfully results are read. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not opened configured. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga13ab57714aafa9a3023a32f83c88e1dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13ab57714aafa9a3023a32f83c88e1dd">&#9670;&nbsp;</a></span>RM_OB1203_DeviceStatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> RM_OB1203_DeviceStatusGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#gac6e75ff65e4c3354fac0f8a44b8545bf">rm_ob1203_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___r_m___o_b1203___a_p_i.html#structrm__ob1203__device__status__t">rm_ob1203_device_status_t</a> *const&#160;</td>
          <td class="paramname"><em>p_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get device status from OB1203 device. Clear all interrupt bits. Implements <a class="el" href="group___r_m___o_b1203___a_p_i.html#abd612814bfe809e1435fab3ba2c6b2e2">rm_ob1203_api_t::deviceStatusGet</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successfully results are read. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not opened configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Communication is timeout. </td></tr>
    <tr><td class="paramname">FSP_ERR_ABORTED</td><td>Communication is aborted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v3.7.0 User's Manual Copyright © (2022) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
