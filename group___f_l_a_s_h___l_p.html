<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: Flash (r_flash_lp)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
    $(document).ready(function() {
        $("tr.tree_lvl_1").nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
		$("tr.tree_lvl_1").data("expanded","0");
		$("tr.tree_lvl_2").data("expanded","0");
		$("tr.tree_lvl_3").data("expanded","0");
		$("tr.tree_lvl_4").data("expanded","0");
		$("tr.tree_lvl_5").data("expanded","0");
        $("tr.tree_lvl_1").click(function() {
		    var lvl_1_is_open = $(this).data("expanded");
		    if (lvl_1_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2, tr.tree_lvl_1_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_2").click(function() {
		    var lvl_2_is_open = $(this).data("expanded");
		    if (lvl_2_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3, tr.tree_lvl_2_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_3").click(function() {
		    var lvl_3_is_open = $(this).data("expanded");
		    if (lvl_3_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_3_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_4").click(function() {
		    var lvl_4_is_open = $(this).data("expanded");
		    if (lvl_4_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5, tr.tree_lvl_4_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_5").click(function() {
		    var lvl_5_is_open = $(this).data("expanded");
		    if (lvl_5_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4_item,tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
     });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v6.2.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">

    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text">
      </span>
      <span class="right">
          &nbsp;
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___f_l_a_s_h___l_p.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body.
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len));
            }
          }
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element.
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<div class="title">Flash (r_flash_lp)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___s_t_o_r_a_g_e___m_o_d_u_l_e_s.html">Storage</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga212763f058049cbeefb6b79ee0daba5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___l_p.html#ga212763f058049cbeefb6b79ee0daba5c">R_FLASH_LP_Open</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___f_l_a_s_h___a_p_i.html#structflash__cfg__t">flash_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:ga212763f058049cbeefb6b79ee0daba5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed8935d085cee3dbb83fc21fbb2edcde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___l_p.html#gaed8935d085cee3dbb83fc21fbb2edcde">R_FLASH_LP_Write</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, uint32_t const src_address, uint32_t flash_address, uint32_t const num_bytes)</td></tr>
<tr class="separator:gaed8935d085cee3dbb83fc21fbb2edcde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f01af9392b4ce8d93b1ac1292c47374"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___l_p.html#ga4f01af9392b4ce8d93b1ac1292c47374">R_FLASH_LP_Erase</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, uint32_t const address, uint32_t const num_blocks)</td></tr>
<tr class="separator:ga4f01af9392b4ce8d93b1ac1292c47374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10d5fbf3a9482ab80623f142ac05ec35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___l_p.html#ga10d5fbf3a9482ab80623f142ac05ec35">R_FLASH_LP_BlankCheck</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, uint32_t const address, uint32_t num_bytes, <a class="el" href="group___f_l_a_s_h___a_p_i.html#ga79d0373f9f1ae1d8bd99c40edb44a5b6">flash_result_t</a> *p_blank_check_result)</td></tr>
<tr class="separator:ga10d5fbf3a9482ab80623f142ac05ec35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0e4a6b38d0e89bc28d3cd4548b7ed5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___l_p.html#gaf0e4a6b38d0e89bc28d3cd4548b7ed5d">R_FLASH_LP_StatusGet</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___f_l_a_s_h___a_p_i.html#gab551389322a209cca1dcc1a7b2440f7a">flash_status_t</a> *const p_status)</td></tr>
<tr class="separator:gaf0e4a6b38d0e89bc28d3cd4548b7ed5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8ccfac1df321762e91b217e30e12539"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___l_p.html#gaf8ccfac1df321762e91b217e30e12539">R_FLASH_LP_AccessWindowSet</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, uint32_t const start_addr, uint32_t const end_addr)</td></tr>
<tr class="separator:gaf8ccfac1df321762e91b217e30e12539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4463d5f0443e24943b7925cbfd9e9def"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___l_p.html#ga4463d5f0443e24943b7925cbfd9e9def">R_FLASH_LP_AccessWindowClear</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:ga4463d5f0443e24943b7925cbfd9e9def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82f884cc96c2ebdee2f01274a684c855"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___l_p.html#ga82f884cc96c2ebdee2f01274a684c855">R_FLASH_LP_IdCodeSet</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, uint8_t const *const p_id_code, <a class="el" href="group___f_l_a_s_h___a_p_i.html#ga5879fbdf1d24018416c1c7ccf448b64f">flash_id_code_mode_t</a> mode)</td></tr>
<tr class="separator:ga82f884cc96c2ebdee2f01274a684c855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2192404c726bc0977297b511107ede86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___l_p.html#ga2192404c726bc0977297b511107ede86">R_FLASH_LP_Reset</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:ga2192404c726bc0977297b511107ede86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5db1f5f2c99d6503300567c8f39b60a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___l_p.html#ga5db1f5f2c99d6503300567c8f39b60a7">R_FLASH_LP_StartUpAreaSelect</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___f_l_a_s_h___a_p_i.html#gac8629165c2d649fbbf8c9854c3c7d20b">flash_startup_area_swap_t</a> swap_type, bool is_temporary)</td></tr>
<tr class="separator:ga5db1f5f2c99d6503300567c8f39b60a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe0d36d77021016d4b2d9e0b8da4ea2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___l_p.html#gabe0d36d77021016d4b2d9e0b8da4ea2c">R_FLASH_LP_BankSwap</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:gabe0d36d77021016d4b2d9e0b8da4ea2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71e978be35b105e56bfa9bf6bd1630cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___l_p.html#ga71e978be35b105e56bfa9bf6bd1630cb">R_FLASH_LP_UpdateFlashClockFreq</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:ga71e978be35b105e56bfa9bf6bd1630cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad765ebc7908a00697121bdfb9cd282a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___l_p.html#gad765ebc7908a00697121bdfb9cd282a8">R_FLASH_LP_InfoGet</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___f_l_a_s_h___a_p_i.html#structflash__info__t">flash_info_t</a> *const p_info)</td></tr>
<tr class="separator:gad765ebc7908a00697121bdfb9cd282a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b99806596f72f4d352936a8a97d78f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___l_p.html#ga3b99806596f72f4d352936a8a97d78f6">R_FLASH_LP_Close</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:ga3b99806596f72f4d352936a8a97d78f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1318614721e9980578cbd22d3f3db9bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___l_p.html#ga1318614721e9980578cbd22d3f3db9bf">R_FLASH_LP_CallbackSet</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, void(*p_callback)(<a class="el" href="group___f_l_a_s_h___a_p_i.html#structflash__callback__args__t">flash_callback_args_t</a> *), void *const p_context, <a class="el" href="group___f_l_a_s_h___a_p_i.html#structflash__callback__args__t">flash_callback_args_t</a> *const p_callback_memory)</td></tr>
<tr class="separator:ga1318614721e9980578cbd22d3f3db9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa8e430152d179103a3590e9fdfadabd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___l_p.html#gafa8e430152d179103a3590e9fdfadabd">R_FLASH_LP_AntiRollbackCounterIncrement</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___f_l_a_s_h___a_p_i.html#ga83b0266a3edcc6c865f79a3d04785c21">flash_arc_t</a> counter)</td></tr>
<tr class="separator:gafa8e430152d179103a3590e9fdfadabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6560e54c6ddedf2acf12cf8ef7bea4de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___l_p.html#ga6560e54c6ddedf2acf12cf8ef7bea4de">R_FLASH_LP_AntiRollbackCounterRefresh</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___f_l_a_s_h___a_p_i.html#ga83b0266a3edcc6c865f79a3d04785c21">flash_arc_t</a> counter)</td></tr>
<tr class="separator:ga6560e54c6ddedf2acf12cf8ef7bea4de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49f96e4753cedd557571aab80997d40c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___l_p.html#ga49f96e4753cedd557571aab80997d40c">R_FLASH_LP_AntiRollbackCounterRead</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___f_l_a_s_h___a_p_i.html#ga83b0266a3edcc6c865f79a3d04785c21">flash_arc_t</a> counter, uint32_t *const p_count)</td></tr>
<tr class="separator:ga49f96e4753cedd557571aab80997d40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9c40760a2e7117b2db6016cefb271c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___l_p.html#gad9c40760a2e7117b2db6016cefb271c3">R_FLASH_LP_UserLockableAreaWrite</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, uint32_t const src_address, uint32_t flash_address, uint32_t const num_bytes)</td></tr>
<tr class="separator:gad9c40760a2e7117b2db6016cefb271c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the flash memory on RA low-power MCUs. This module implements the <a class="el" href="group___f_l_a_s_h___a_p_i.html">Flash Interface</a>. </p>
<h1><a class="anchor" id="r-flash-lp-overview"></a>
Overview</h1>
<p>The Flash HAL module APIs allow an application to write, erase and blank check both the data and code flash areas that reside within the MCU. The amount of flash memory available varies across MCU parts.</p>
<h2><a class="anchor" id="r-flash-lp-features"></a>
Features</h2>
<p>The Low-Power Flash HAL module has the following key features:</p>
<ul>
<li>Blocking and non-blocking erasing, writing and blank-checking of data flash.<a class="anchor" id="um_flash_data_flash_blank_check_non_blocking"></a><a class="anchor" id="um_flash_data_flash_erase_non_blocking"></a><a class="anchor" id="um_flash_data_flash_write_non_blocking"></a></li>
<li>Blocking erasing, writing and blank checking of code flash.</li>
<li>Callback functions for completion of non-blocking data flash operations.</li>
<li>Access window (write protection) for code flash, allowing only specified areas of code flash to be erased or written.</li>
<li>Boot block-swapping.</li>
<li>ID code programming support.</li>
</ul>
<h1><a class="anchor" id="r-flash-lp-configuration"></a>
Configuration</h1>
<p><h2>Build Time Configurations for r_flash_lp</h2>
The following build time configurations are defined in fsp_cfg/r_flash_lp_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr class="tree_none">
<td>Code Flash Programming</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Controls whether or not code-flash programming is enabled. Disabling reduces the amount of ROM and RAM used by the API. </td></tr>
<tr class="tree_none">
<td>Code Flash Background Operation Support With Bank Programming</td><td>MCU Specific Options</td><td></td><td>Enables execution from the startup code flash bank while programming the other code flash bank. </td></tr>
<tr class="tree_none">
<td>Data Flash Programming</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>Controls whether or not data-flash programming is enabled. Disabling reduces the amount of ROM used by the API. </td></tr>
<tr class="tree_none">
<td>Data Flash Background Operation Support</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>Controls whether or not Data Flash Background Operation support is included in the build. Disabling reduces the amount of ROM used by the API. </td></tr>
<tr class="tree_none">
<td>Instant Bank Swap (No Reset Required)</td><td>MCU Specific Options</td><td></td><td>Calls to R_FLASH_LP_BankSwap will immediately swap banks without requiring a reset. </td></tr>
</table>
 <h2>Configurations for Storage &gt; Flash (r_flash_lp)</h2>
This module can be added to the Stacks tab via New Stack &gt; Storage &gt; Flash (r_flash_lp).<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Name</td><td>Name must be a valid C symbol</td><td>g_flash0 </td><td>Module name. </td></tr>
<tr class="tree_none">
<td>Data Flash Background Operation</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>Enabling allows Flash API calls that reference data-flash to return immediately, with the operation continuing in the background. </td></tr>
<tr class="tree_none">
<td>Callback</td><td>Name must be a valid C symbol</td><td>NULL </td><td>A user callback function can be specified. Callback function called when a Data Flash Background Operation completes or errors. </td></tr>
<tr class="tree_none">
<td>Flash Ready Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select the flash ready interrupt priority. </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-flash-lp-clock-configuration"></a>
Clock Configuration</h2>
<p>Flash either uses FCLK or ICLK as the clock source depending on the MCU. When writing and erasing the clock source must be at least 4 MHz.</p>
<h2><a class="anchor" id="r-flash-lp-pin-configuration"></a>
Pin Configuration</h2>
<p>This module does not use I/O pins.</p>
<h1><a class="anchor" id="r-flash-lp-usage_notes"></a>
Usage Notes</h1>
<dl class="section warning"><dt>Warning</dt><dd>It is highly recommended that the developer reviews sections 5 and 6 of the Flash Memory section of the target MCUs Hardware User’s Manual prior to using the r_flash_lp module. In particular, understanding ID Code and Access Window functionality can help avoid unrecoverable flash scenarios.</dd></dl>
<h2><a class="anchor" id="r-flash-lp-data-precautions"></a>
Data Flash Background Operation (BGO) Precautions</h2>
<p>When using the data flash BGO, the code flash, RAM and external memory can still be accessed. You must ensure that the data flash is not accessed during a data flash operation. This includes interrupts that may access the data flash.</p>
<h2><a class="anchor" id="r-flash-lp-code-precautions"></a>
Code Flash Precautions</h2>
<p>Modifying code flash has limitations requiring some of the flash code to reside in RAM. The use of Bank Programming can limit these requirements but some still exist.</p>
<p>Code flash cannot be accessed while writing, erasing or blank checking code flash unless Bank Programming is supported. Code flash cannot be accessed while modifying the access window, selecting the startup area or setting the ID code. In order to support modifying code flash or flash settings all supporting code must reside in RAM. This is only done when code flash programming is enabled.</p>
<p>When Bank Programming is disabled or not supported a code flash write, erase or blank check operation will not return before the operation has completed.</p>
<p>By default, the vector table resides in the code flash. If an interrupt occurs during the code flash operation other thank a Bank Programming operation, then code flash will be accessed to fetch the interrupt's starting address and an error will occur. The simplest work-around is to disable interrupts during code flash operations. Another option is to copy the vector table to RAM, update the VTOR (Vector Table Offset Register) accordingly and ensure that any interrupt service routines execute out of RAM. Similarly, you must ensure that if in a multi-threaded environment, threads running from code flash cannot become active while a code flash operation is in progress.</p>
<h2><a class="anchor" id="r-flash-lp-bank-programming-precautions"></a>
Bank Programming Precautions</h2>
<p><a class="anchor" id="um_bank_programming"></a>Bank programming is supported on select MCUs. When enabled Bank1 can be programmed while executing out of Bank0, decreasing the RAM used by the flash driver. When this mode is enabled only Bank1 can be modified.</p>
<h2><a class="anchor" id="r-flash-lp-flash-clock"></a>
Flash Clock Source</h2>
<p><a class="anchor" id="um_flash_fclk_frequency_change"></a>The flash clock source is the clock used by the Flash peripheral in performing all Flash operations. As part of the <a class="el" href="group___f_l_a_s_h___a_p_i.html#a8166d0d1e4f3a59b8bf7f9e89fef9e44">flash_api_t::open</a> function the Flash clock source is checked will return FSP_ERR_FCLK if it is invalid. Once the Flash API has been opened, if the flash clock source frequency is changed, the <a class="el" href="group___f_l_a_s_h___a_p_i.html#ae357c91afece41b956ece618eb82c1a1">flash_api_t::updateFlashClockFreq</a> API function must be called to inform the API of the change. Failure to do so could result in flash operation failures and possibly damage the part.</p>
<h2><a class="anchor" id="r-flash-lp-interrupts"></a>
Interrupts</h2>
<p><a class="anchor" id="um_flash_data_flash_bgo_callbacks"></a>Enable the flash ready interrupt only if you plan to use the data flash BGO. In this mode, the application can initiate a data flash operation and then be asynchronously notified of its completion, or an error, using a user supplied-callback function. The callback function is passed a structure containing event information that indicates the source of the callback event (for example, <a class="el" href="group___f_l_a_s_h___a_p_i.html#gga44753f7d426ae0121c94a307a95314a5a47cf4f3983c35ca46fcfabeb1903e068">flash_api_t::FLASH_EVENT_ERASE_COMPLETE</a>) When the FLASH FRDYI interrupt is enabled, the corresponding ISR will be defined in the flash driver. The ISR will call a user-callback function if one was registered with the <a class="el" href="group___f_l_a_s_h___a_p_i.html#a8166d0d1e4f3a59b8bf7f9e89fef9e44">flash_api_t::open</a> API. </p><dl class="section note"><dt>Note</dt><dd>The Flash HP supports an additional flash-error interrupt and if the BGO mode is enabled for the FLASH HP then both the Flash Ready Interrupt and Flash Error Interrupts must be enabled (assigned a priority).</dd></dl>
<h2><a class="anchor" id="r-flash-lp-e2studio-caching"></a>
Viewing flash contents in e2 studio</h2>
<p>By default, the contents of data flash and code flash are cached by e<sup>2</sup> studio. This means that during a debug session, modifications to these memory regions will not be observed by e<sup>2</sup> studio. When debugging applications using e<sup>2</sup> studio, disable the "Allow caching of flash contents" option in the debug configuration in order to view modified flash contents (Debug Configuration &gt; Debugger &gt; Debug Tool Settings &gt; Allow caching of flash contents).</p>
<div class="image">
<img src="r_flash_hp_disable_caching.png" alt="r_flash_hp_disable_caching.png"/>
<div class="caption">
Debug Configuration</div></div>
 <h2><a class="anchor" id="r-flash-lp-limitations"></a>
Limitations</h2>
<ul>
<li>Write operations must be aligned on page boundaries and must be a multiple of the page boundary size.</li>
<li>Erase operations will erase the entire block the provided address resides in.</li>
<li>Data flash is better suited for storing data as it can be erased and written to while code is still executing from code flash. Data flash is also guaranteed for a larger number of reprogramming/erasure cycles than code flash.</li>
<li>Read values of erased blocks are not guaranteed to be 0xFF. Blank check should be used to determine if memory has been erased but not yet programmed.</li>
</ul>
<h1><a class="anchor" id="r-flash-lp-examples"></a>
Examples</h1>
<h2>Low-Power Flash Basic Example</h2>
<p>This is a basic example of erasing and writing to data flash and code flash.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FLASH_DF_BLOCK_0               0x40100000U </span><span class="comment">/*   1 KB: 0x40100000 - 0x401003FF */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">#define FLASH_CF_BLOCK_10              0x00005000  </span><span class="comment">/*   2 KB: 0x00005000 - 0x000057FF */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">#define FLASH_DATA_BLOCK_SIZE          (1024)</span></div><div class="line"><span class="preprocessor">#define FLASH_LP_EXAMPLE_WRITE_SIZE    32</span></div><div class="line">uint8_t        g_dest[TRANSFER_LENGTH];</div><div class="line">uint8_t        g_src[TRANSFER_LENGTH];</div><div class="line"><a class="code" href="group___f_l_a_s_h___a_p_i.html#ga79d0373f9f1ae1d8bd99c40edb44a5b6">flash_result_t</a> blank_check_result;</div><div class="line"><span class="keywordtype">void</span> R_FLASH_LP_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Initialize p_src to known data */</span></div><div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; TRANSFER_LENGTH; i++)</div><div class="line">    {</div><div class="line">        g_src[i] = (uint8_t) (<span class="charliteral">&#39;A&#39;</span> + (i % 26));</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Open the flash lp instance. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___f_l_a_s_h___l_p.html#ga212763f058049cbeefb6b79ee0daba5c">R_FLASH_LP_Open</a>(&amp;g_flash_ctrl, &amp;g_flash_cfg);</div><div class="line"></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Erase 1 block of data flash starting at block 0. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___l_p.html#ga4f01af9392b4ce8d93b1ac1292c47374">R_FLASH_LP_Erase</a>(&amp;g_flash_ctrl, FLASH_DF_BLOCK_0, 1);</div><div class="line"></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Check if block 0 is erased. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___l_p.html#ga10d5fbf3a9482ab80623f142ac05ec35">R_FLASH_LP_BlankCheck</a>(&amp;g_flash_ctrl, FLASH_DF_BLOCK_0, FLASH_DATA_BLOCK_SIZE, &amp;blank_check_result);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Verify the previously erased area is blank */</span></div><div class="line">    assert(<a class="code" href="group___f_l_a_s_h___a_p_i.html#gga79d0373f9f1ae1d8bd99c40edb44a5b6ac8b28b541918a1275dc3ea21e0b1d028">FLASH_RESULT_BLANK</a> == blank_check_result);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Write 32 bytes to the first block of data flash. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___l_p.html#gaed8935d085cee3dbb83fc21fbb2edcde">R_FLASH_LP_Write</a>(&amp;g_flash_ctrl, (uint32_t) g_src, FLASH_DF_BLOCK_0, FLASH_LP_EXAMPLE_WRITE_SIZE);</div><div class="line"></div><div class="line"></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    assert(0 == memcmp(g_src, (uint8_t *) FLASH_DF_BLOCK_0, FLASH_LP_EXAMPLE_WRITE_SIZE));</div><div class="line"></div><div class="line">    <span class="comment">/* Disable interrupts to prevent vector table access while code flash is in P/E mode. */</span></div><div class="line">    __disable_irq();</div><div class="line"></div><div class="line">    <span class="comment">/* Erase 1 block of code flash starting at block 10. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___l_p.html#ga4f01af9392b4ce8d93b1ac1292c47374">R_FLASH_LP_Erase</a>(&amp;g_flash_ctrl, FLASH_CF_BLOCK_10, 1);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Write 32 bytes to the first block of data flash. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___l_p.html#gaed8935d085cee3dbb83fc21fbb2edcde">R_FLASH_LP_Write</a>(&amp;g_flash_ctrl, (uint32_t) g_src, FLASH_CF_BLOCK_10, FLASH_LP_EXAMPLE_WRITE_SIZE);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable interrupts after code flash operations are complete. */</span></div><div class="line">    __enable_irq();</div><div class="line"></div><div class="line">    assert(0 == memcmp(g_src, (uint8_t *) FLASH_CF_BLOCK_10, FLASH_LP_EXAMPLE_WRITE_SIZE));</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Low-Power Flash Advanced Example</h2>
<p>This example demonstrates using BGO to do non-blocking operations on the data flash.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span>               interrupt_called;</div><div class="line"><a class="code" href="group___f_l_a_s_h___a_p_i.html#ga44753f7d426ae0121c94a307a95314a5">flash_event_t</a>      flash_event;</div><div class="line"><span class="keyword">static</span> <a class="code" href="group___f_l_a_s_h___a_p_i.html#structflash__cfg__t">flash_cfg_t</a> g_flash_bgo_example_cfg =</div><div class="line">{</div><div class="line">    .<a class="code" href="group___f_l_a_s_h___a_p_i.html#ac80ffd6402722097911dc6da638cd54d">p_callback</a>     = flash_callback,</div><div class="line">    .p_context      = 0,</div><div class="line">    .p_extend       = NULL,</div><div class="line">    .data_flash_bgo = <span class="keyword">true</span>,            </div><div class="line">    .ipl            = 5,</div><div class="line">    .irq            = BSP_VECTOR_FLASH_LP_FRDYI_ISR,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> R_FLASH_LP_bgo_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Initialize p_src to known data */</span></div><div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; TRANSFER_LENGTH; i++)</div><div class="line">    {</div><div class="line">        g_src[i] = (uint8_t) (<span class="charliteral">&#39;A&#39;</span> + (i % 26));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Open the flash lp instance. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___f_l_a_s_h___l_p.html#ga212763f058049cbeefb6b79ee0daba5c">R_FLASH_LP_Open</a>(&amp;g_flash_ctrl, &amp;g_flash_bgo_example_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    interrupt_called = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Erase 1 block of data flash starting at block 0. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___l_p.html#ga4f01af9392b4ce8d93b1ac1292c47374">R_FLASH_LP_Erase</a>(&amp;g_flash_ctrl, FLASH_DF_BLOCK_0, 1);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (!interrupt_called)</div><div class="line">    {</div><div class="line">        ;</div><div class="line">    }</div><div class="line"></div><div class="line">    assert(<a class="code" href="group___f_l_a_s_h___a_p_i.html#gga44753f7d426ae0121c94a307a95314a5a47cf4f3983c35ca46fcfabeb1903e068">FLASH_EVENT_ERASE_COMPLETE</a> == flash_event);</div><div class="line"></div><div class="line">    interrupt_called = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Write 32 bytes to the first block of data flash. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___l_p.html#gaed8935d085cee3dbb83fc21fbb2edcde">R_FLASH_LP_Write</a>(&amp;g_flash_ctrl, (uint32_t) g_src, FLASH_DF_BLOCK_0, FLASH_LP_EXAMPLE_WRITE_SIZE);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <a class="code" href="group___f_l_a_s_h___a_p_i.html#gab551389322a209cca1dcc1a7b2440f7a">flash_status_t</a> status;</div><div class="line"></div><div class="line">    <span class="comment">/* Wait until the current flash operation completes. */</span></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        err = <a class="code" href="group___f_l_a_s_h___l_p.html#gaf0e4a6b38d0e89bc28d3cd4548b7ed5d">R_FLASH_LP_StatusGet</a>(&amp;g_flash_ctrl, &amp;status);</div><div class="line">    } <span class="keywordflow">while</span> ((FSP_SUCCESS == err) &amp;&amp; (<a class="code" href="group___f_l_a_s_h___a_p_i.html#ggab551389322a209cca1dcc1a7b2440f7aa9f0e163a2cd4ec43acbe02344235882a">FLASH_STATUS_BUSY</a> == status));</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* If the interrupt wasn&#39;t called process the error. */</span></div><div class="line">    assert(interrupt_called);</div><div class="line"></div><div class="line">    <span class="comment">/* If the event wasn&#39;t a write complete process the error. */</span></div><div class="line">    assert(<a class="code" href="group___f_l_a_s_h___a_p_i.html#gga44753f7d426ae0121c94a307a95314a5a2a000e207e1a0db0f1a7c550599bb804">FLASH_EVENT_WRITE_COMPLETE</a> == flash_event);</div><div class="line"></div><div class="line">    <span class="comment">/* Verify the data was written correctly. */</span></div><div class="line">    assert(0 == memcmp(g_src, (uint8_t *) FLASH_DF_BLOCK_0, FLASH_LP_EXAMPLE_WRITE_SIZE));</div><div class="line"></div><div class="line">    <span class="comment">/* When Bank Programming is enabled the code flash P/E operations are also non blocking. */</span></div><div class="line">    interrupt_called = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Erase the first block of the flash bank not configured as the startup bank. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___l_p.html#ga4f01af9392b4ce8d93b1ac1292c47374">R_FLASH_LP_Erase</a>(&amp;g_flash_ctrl, (BSP_FEATURE_FLASH_CODE_FLASH_START + BSP_ROM_SIZE_BYTES) / 2, 1);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (!interrupt_called)</div><div class="line">    {</div><div class="line">        ;</div><div class="line">    }</div><div class="line"></div><div class="line">    assert(<a class="code" href="group___f_l_a_s_h___a_p_i.html#gga44753f7d426ae0121c94a307a95314a5a47cf4f3983c35ca46fcfabeb1903e068">FLASH_EVENT_ERASE_COMPLETE</a> == flash_event);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> flash_callback (<a class="code" href="group___f_l_a_s_h___a_p_i.html#structflash__callback__args__t">flash_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    interrupt_called = <span class="keyword">true</span>;</div><div class="line">    flash_event      = p_args-&gt;<a class="code" href="group___f_l_a_s_h___a_p_i.html#a85ce087229ae1cb0076dfb4e38238d7e">event</a>;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Low-Power Flash Bank Swap Example</h2>
<p>This example demonstrates swapping which flash bank is located at address 0. This feature is only on select MCUs.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> R_FLASH_LP_bankswap_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Open the flash lp instance. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___f_l_a_s_h___l_p.html#ga212763f058049cbeefb6b79ee0daba5c">R_FLASH_LP_Open</a>(&amp;g_flash_ctrl, &amp;g_flash_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Write the new application starting at 0x0004_0000. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Swap the bank at address 0 with the one at 0x0004_0000 after the next restart.</span></div><div class="line"><span class="comment">     * The application at 0x0004_0000 must be written there by application code. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___l_p.html#gabe0d36d77021016d4b2d9e0b8da4ea2c">R_FLASH_LP_BankSwap</a>(&amp;g_flash_ctrl);</div><div class="line"></div><div class="line">    <span class="comment">/* When using Instant Bank Swap the MCU will now have the banks swapped. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any pre-reset operations here */</span></div><div class="line"></div><div class="line">    <span class="comment">/* When using Bank Swap with Reset the MCU must be reset to swap to the other bank */</span></div><div class="line">    __NVIC_SystemReset();</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structflash__lp__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___l_p.html#structflash__lp__instance__ctrl__t">flash_lp_instance_ctrl_t</a></td></tr>
<tr class="separator:structflash__lp__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structflash__lp__instance__ctrl__t" id="structflash__lp__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structflash__lp__instance__ctrl__t">&#9670;&nbsp;</a></span>flash_lp_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct flash_lp_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Flash instance control block. DO NOT INITIALIZE. Initialization occurs when <a class="el" href="group___f_l_a_s_h___l_p.html#ga212763f058049cbeefb6b79ee0daba5c">R_FLASH_LP_Open()</a> is called. </p>
</div>
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga212763f058049cbeefb6b79ee0daba5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga212763f058049cbeefb6b79ee0daba5c">&#9670;&nbsp;</a></span>R_FLASH_LP_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_LP_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#structflash__cfg__t">flash_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the Low Power flash peripheral. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#a8166d0d1e4f3a59b8bf7f9e89fef9e44">flash_api_t::open</a>.</p>
<p>The Open function initializes the Flash.</p>
<p>This function must be called once prior to calling any other FLASH API functions. If a user supplied callback function is supplied, then the Flash Ready interrupt will be configured to call the users callback routine with an Event type describing the source of the interrupt for Data Flash operations.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Open the flash lp instance. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___f_l_a_s_h___l_p.html#ga212763f058049cbeefb6b79ee0daba5c">R_FLASH_LP_Open</a>(&amp;g_flash_ctrl, &amp;g_flash_cfg);</div><div class="line"></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Providing a callback function in the supplied p_cfg-&gt;callback field automatically configures the Flash for Data Flash to operate in non-blocking background operation (BGO) mode.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Initialization was successful and timer has started. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl, p_cfg or p_callback if BGO is enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_IRQ_BSP_DISABLED</td><td>Caller is requesting BGO but the Flash interrupts are not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_FCLK</td><td>FCLK must be a minimum of 4 MHz for Flash operations. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Flash Open() has already been called. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Failed to exit P/E mode after configuring flash. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_STATE</td><td>The system is not running from the required clock or the required clock is not running and stable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaed8935d085cee3dbb83fc21fbb2edcde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed8935d085cee3dbb83fc21fbb2edcde">&#9670;&nbsp;</a></span>R_FLASH_LP_Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_LP_Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>src_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flash_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>num_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write to the specified Code or Data Flash memory area. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#a01c35b7f1ad8a9bc3a932d4a05f2bcb6">flash_api_t::write</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Write 32 bytes to the first block of data flash. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___l_p.html#gaed8935d085cee3dbb83fc21fbb2edcde">R_FLASH_LP_Write</a>(&amp;g_flash_ctrl, (uint32_t) g_src, FLASH_DF_BLOCK_0, FLASH_LP_EXAMPLE_WRITE_SIZE);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Operation successful. If BGO is enabled this means the operation was started successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>The Flash peripheral is busy with a prior on-going transaction. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The Flash API is not Open. </td></tr>
    <tr><td class="paramname">FSP_ERR_WRITE_FAILED</td><td>Status is indicating a Programming error for the requested operation. This may be returned if the requested Flash area is not blank. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timed out waiting for FCU operation to complete. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_SIZE</td><td>Number of bytes provided was not a multiple of the programming size or exceeded the maximum range. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ADDRESS</td><td>Invalid address was input or address not on programming boundary. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4f01af9392b4ce8d93b1ac1292c47374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f01af9392b4ce8d93b1ac1292c47374">&#9670;&nbsp;</a></span>R_FLASH_LP_Erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_LP_Erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>num_blocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Erase the specified Code or Data Flash blocks. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#ac32a91bb4217997e2ca465463b644211">flash_api_t::erase</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Erase 1 block of data flash starting at block 0. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___l_p.html#ga4f01af9392b4ce8d93b1ac1292c47374">R_FLASH_LP_Erase</a>(&amp;g_flash_ctrl, FLASH_DF_BLOCK_0, 1);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful open. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_BLOCKS</td><td>Invalid number of blocks specified </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ADDRESS</td><td>Invalid address specified </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>Other flash operation in progress, or API not initialized </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The Flash API is not Open. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timed out waiting for FCU to be ready. </td></tr>
    <tr><td class="paramname">FSP_ERR_ERASE_FAILED</td><td>Status is indicating a Erase error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga10d5fbf3a9482ab80623f142ac05ec35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10d5fbf3a9482ab80623f142ac05ec35">&#9670;&nbsp;</a></span>R_FLASH_LP_BlankCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_LP_BlankCheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#ga79d0373f9f1ae1d8bd99c40edb44a5b6">flash_result_t</a> *&#160;</td>
          <td class="paramname"><em>p_blank_check_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a blank check on the specified address area. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#a285a6f933817c94e26a5aa11c48a1b3c">flash_api_t::blankCheck</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Check if block 0 is erased. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___l_p.html#ga10d5fbf3a9482ab80623f142ac05ec35">R_FLASH_LP_BlankCheck</a>(&amp;g_flash_ctrl, FLASH_DF_BLOCK_0, FLASH_DATA_BLOCK_SIZE, &amp;blank_check_result);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Blankcheck operation completed with result in p_blank_check_result, or blankcheck started and in-progess (BGO mode). </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ADDRESS</td><td>Invalid data flash address was input </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_SIZE</td><td>'num_bytes' was either too large or not aligned for the CF/DF boundary size. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>Flash is busy with an on-going operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Flash API has not yet been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timed out waiting for the FCU to become ready. </td></tr>
    <tr><td class="paramname">FSP_ERR_BLANK_CHECK_FAILED</td><td>An error occurred during blank checking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf0e4a6b38d0e89bc28d3cd4548b7ed5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0e4a6b38d0e89bc28d3cd4548b7ed5d">&#9670;&nbsp;</a></span>R_FLASH_LP_StatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_LP_StatusGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gab551389322a209cca1dcc1a7b2440f7a">flash_status_t</a> *const&#160;</td>
          <td class="paramname"><em>p_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the FLASH for its status. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#a5533acb74f21270a17a013d149c32a58">flash_api_t::statusGet</a>.</p>
<p>Example: </p><div class="fragment"><div class="line">    <a class="code" href="group___f_l_a_s_h___a_p_i.html#gab551389322a209cca1dcc1a7b2440f7a">flash_status_t</a> status;</div><div class="line"></div><div class="line">    <span class="comment">/* Wait until the current flash operation completes. */</span></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        err = <a class="code" href="group___f_l_a_s_h___l_p.html#gaf0e4a6b38d0e89bc28d3cd4548b7ed5d">R_FLASH_LP_StatusGet</a>(&amp;g_flash_ctrl, &amp;status);</div><div class="line">    } <span class="keywordflow">while</span> ((FSP_SUCCESS == err) &amp;&amp; (<a class="code" href="group___f_l_a_s_h___a_p_i.html#ggab551389322a209cca1dcc1a7b2440f7aa9f0e163a2cd4ec43acbe02344235882a">FLASH_STATUS_BUSY</a> == status));</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Flash is ready and available to accept commands. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Flash API has not yet been opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf8ccfac1df321762e91b217e30e12539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8ccfac1df321762e91b217e30e12539">&#9670;&nbsp;</a></span>R_FLASH_LP_AccessWindowSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_LP_AccessWindowSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>start_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>end_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure an access window for the Code Flash memory. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#ab8f7f57d6c9b1d3a08281eee4edc0683">flash_api_t::accessWindowSet</a>.</p>
<p>An access window defines a contiguous area in Code Flash for which programming/erase is enabled. This area is on block boundaries. The block containing start_addr is the first block. The block containing end_addr is the last block. The access window then becomes first block (inclusive) &ndash;&gt; last block (exclusive). Anything outside this range of Code Flash is then write protected. As an example, if you wanted to place an accesswindow on Code Flash Blocks 0 and 1, such that only those two blocks were writable, you would need to specify (address in block 0, address in block 2) as the respective start and end address. </p><dl class="section note"><dt>Note</dt><dd>If the start address and end address are set to the same value, then the access window is effectively removed. This accomplishes the same functionality as <a class="el" href="group___f_l_a_s_h___l_p.html#ga4463d5f0443e24943b7925cbfd9e9def">R_FLASH_LP_AccessWindowClear()</a>.</dd></dl>
<p>The invalid address and programming boundaries supported and enforced by this function are dependent on the MCU in use as well as the part package size. Please see the User manual and/or requirements document for additional information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">p_api_ctrl</td><td>The p api control </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_addr</td><td>The start address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_addr</td><td>The end address</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Access window successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ADDRESS</td><td>Invalid settings for start_addr and/or end_addr. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>FLASH peripheral is busy with a prior operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Code Flash Programming is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Flash API has not yet been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timed out waiting for the FCU to become ready. </td></tr>
    <tr><td class="paramname">FSP_ERR_WRITE_FAILED</td><td>Status is indicating a Programming error for the requested operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4463d5f0443e24943b7925cbfd9e9def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4463d5f0443e24943b7925cbfd9e9def">&#9670;&nbsp;</a></span>R_FLASH_LP_AccessWindowClear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_LP_AccessWindowClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove any access window that is configured in the Code Flash. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#a47d162b634f769385c2d39c4cbc6217b">flash_api_t::accessWindowClear</a>. On successful return from this call all Code Flash is writable.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Access window successfully removed. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>FLASH peripheral is busy with a prior operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Code Flash Programming is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Flash API has not yet been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timed out waiting for the FCU to become ready. </td></tr>
    <tr><td class="paramname">FSP_ERR_WRITE_FAILED</td><td>Status is indicating a Programming error for the requested operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga82f884cc96c2ebdee2f01274a684c855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82f884cc96c2ebdee2f01274a684c855">&#9670;&nbsp;</a></span>R_FLASH_LP_IdCodeSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_LP_IdCodeSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *const&#160;</td>
          <td class="paramname"><em>p_id_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#ga5879fbdf1d24018416c1c7ccf448b64f">flash_id_code_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the ID code provided to the id code registers. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#aa27024990278c87ac8ea489c400bab5e">flash_api_t::idCodeSet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>ID code successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>FLASH peripheral is busy with a prior operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Code Flash Programming is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Flash API has not yet been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timed out waiting for completion of extra command. </td></tr>
    <tr><td class="paramname">FSP_ERR_WRITE_FAILED</td><td>Status is indicating a Programming error for the requested operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2192404c726bc0977297b511107ede86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2192404c726bc0977297b511107ede86">&#9670;&nbsp;</a></span>R_FLASH_LP_Reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_LP_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the FLASH peripheral. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#af87f6e3215253ad33a0c961c79979da0">flash_api_t::reset</a>.</p>
<p>No attempt is made to check if the flash is busy before executing the reset since the assumption is that a reset will terminate any existing operation. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Flash circuit successfully reset. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Flash API has not yet been opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5db1f5f2c99d6503300567c8f39b60a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5db1f5f2c99d6503300567c8f39b60a7">&#9670;&nbsp;</a></span>R_FLASH_LP_StartUpAreaSelect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_LP_StartUpAreaSelect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac8629165c2d649fbbf8c9854c3c7d20b">flash_startup_area_swap_t</a>&#160;</td>
          <td class="paramname"><em>swap_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_temporary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select which block is used as the startup area block. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#af01c458da5ffbd29ee404ccc5e8e6869">flash_api_t::startupAreaSelect</a>.</p>
<p>Selects which block - Default (Block 0) or Alternate (Block 1) is used as the startup area block. The provided parameters determine which block will become the active startup block and whether that action will be immediate (but temporary), or permanent subsequent to the next reset. Doing a temporary switch might appear to have limited usefulness. If there is an access window in place such that Block 0 is write protected, then one could do a temporary switch, update the block and switch them back without having to touch the access window.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Start-up area successfully toggled. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>Flash is busy with an on-going operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Flash API has not yet been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_WRITE_FAILED</td><td>Status is indicating a Programming error for the requested operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timed out waiting for the FCU to become ready. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Code Flash Programming is not enabled. Cannot set FLASH_STARTUP_AREA_BTFLG when the temporary flag is false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabe0d36d77021016d4b2d9e0b8da4ea2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe0d36d77021016d4b2d9e0b8da4ea2c">&#9670;&nbsp;</a></span>R_FLASH_LP_BankSwap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_LP_BankSwap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swap the Code Flash bank to update new program. Implement <a class="el" href="group___f_l_a_s_h___a_p_i.html#a27dd022e07eebb8750e1a1be7f80563f">flash_api_t::bankSwap</a>.</p>
<p>Swap the flash bank located at address 0x00000000 and address 0x00040000. After a bank swap is done the MCU will need to be reset for the changes to take place unless instant swap is enabled.</p>
<p>To use this API, Code Flash Programming in the FSP Configuration Tool under Stack Properties must be enabled.</p>
<dl class="section note"><dt>Note</dt><dd>This function only available on MCUs which support bank swap feature.</dd>
<dd>
When active bank is bank 1, startup program protection function is invalid.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_api_ctrl</td><td>The api control instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Banks were swapped. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Module does not support Bank Swap. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>Extra area is being used by other command. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga71e978be35b105e56bfa9bf6bd1630cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71e978be35b105e56bfa9bf6bd1630cb">&#9670;&nbsp;</a></span>R_FLASH_LP_UpdateFlashClockFreq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_LP_UpdateFlashClockFreq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicate to the already open Flash API that the FCLK has changed. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#ae357c91afece41b956ece618eb82c1a1">flash_api_t::updateFlashClockFreq</a>.</p>
<p>This could be the case if the application has changed the system clock, and therefore the FCLK. Failure to call this function subsequent to changing the FCLK could result in damage to the flash macro.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Start-up area successfully toggled. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>Flash is busy with an on-going operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_FCLK</td><td>Invalid flash clock source frequency. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Flash API has not yet been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timed out waiting for the FCU to become ready. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad765ebc7908a00697121bdfb9cd282a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad765ebc7908a00697121bdfb9cd282a8">&#9670;&nbsp;</a></span>R_FLASH_LP_InfoGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_LP_InfoGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#structflash__info__t">flash_info_t</a> *const&#160;</td>
          <td class="paramname"><em>p_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the information about the flash regions. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#aa1168146a81e1cbeab18848c110bf0a2">flash_api_t::infoGet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful retrieved the request information. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl or p_info. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The flash is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3b99806596f72f4d352936a8a97d78f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b99806596f72f4d352936a8a97d78f6">&#9670;&nbsp;</a></span>R_FLASH_LP_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_LP_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release any resources that were allocated by the Flash API. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#a038ae85f83322bc1e71a8f3937b26c5d">flash_api_t::close</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful close. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl or p_cfg. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Flash API has not yet been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>The flash is currently in P/E mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1318614721e9980578cbd22d3f3db9bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1318614721e9980578cbd22d3f3db9bf">&#9670;&nbsp;</a></span>R_FLASH_LP_CallbackSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_LP_CallbackSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="group___f_l_a_s_h___a_p_i.html#structflash__callback__args__t">flash_callback_args_t</a> *)&#160;</td>
          <td class="paramname"><em>p_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>p_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#structflash__callback__args__t">flash_callback_args_t</a> *const&#160;</td>
          <td class="paramname"><em>p_callback_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stub function Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#ad7f5d12c7a8d269de3d55ca91b29edb7">flash_api_t::callbackSet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Function has not been implemented. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafa8e430152d179103a3590e9fdfadabd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa8e430152d179103a3590e9fdfadabd">&#9670;&nbsp;</a></span>R_FLASH_LP_AntiRollbackCounterIncrement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_LP_AntiRollbackCounterIncrement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#ga83b0266a3edcc6c865f79a3d04785c21">flash_arc_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stub function Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#a04bcaaac166052c618406a22df055ad3">flash_api_t::antiRollbackCounterIncrement</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Function has not been implemented. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6560e54c6ddedf2acf12cf8ef7bea4de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6560e54c6ddedf2acf12cf8ef7bea4de">&#9670;&nbsp;</a></span>R_FLASH_LP_AntiRollbackCounterRefresh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_LP_AntiRollbackCounterRefresh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#ga83b0266a3edcc6c865f79a3d04785c21">flash_arc_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stub function Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#aff7182230c963d80fbb4708be92e70d9">flash_api_t::antiRollbackCounterRefresh</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Function has not been implemented. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga49f96e4753cedd557571aab80997d40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49f96e4753cedd557571aab80997d40c">&#9670;&nbsp;</a></span>R_FLASH_LP_AntiRollbackCounterRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_LP_AntiRollbackCounterRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#ga83b0266a3edcc6c865f79a3d04785c21">flash_arc_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *const&#160;</td>
          <td class="paramname"><em>p_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stub function Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#ae292bc9f330a52094347c2745705c001">flash_api_t::antiRollbackCounterRead</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Function has not been implemented. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad9c40760a2e7117b2db6016cefb271c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9c40760a2e7117b2db6016cefb271c3">&#9670;&nbsp;</a></span>R_FLASH_LP_UserLockableAreaWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_LP_UserLockableAreaWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>src_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flash_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>num_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stub function Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#a6e935b63452c47faaad9a1979f303e1c">flash_api_t::userLockableAreaWrite</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Function has not been implemented. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v6.2.0 User's Manual Copyright © (2025) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
