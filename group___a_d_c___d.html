<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: ADC (r_adc_d)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
    $(document).ready(function() {
        $("tr.tree_lvl_1").nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
		$("tr.tree_lvl_1").data("expanded","0");
		$("tr.tree_lvl_2").data("expanded","0");
		$("tr.tree_lvl_3").data("expanded","0");
		$("tr.tree_lvl_4").data("expanded","0");
		$("tr.tree_lvl_5").data("expanded","0");
        $("tr.tree_lvl_1").click(function() {
		    var lvl_1_is_open = $(this).data("expanded");
		    if (lvl_1_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2, tr.tree_lvl_1_item").show(); 
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed"); 
				$(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        }); 
		$("tr.tree_lvl_2").click(function() {
		    var lvl_2_is_open = $(this).data("expanded");
		    if (lvl_2_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3, tr.tree_lvl_2_item").show(); 
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();                
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_3").click(function() {
		    var lvl_3_is_open = $(this).data("expanded");
		    if (lvl_3_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_3_item").show(); 
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").data("expanded","0");				
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_4").click(function() {
		    var lvl_4_is_open = $(this).data("expanded");
		    if (lvl_4_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5, tr.tree_lvl_4_item").show(); 
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");	
				$(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").data("expanded","0");				
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        }); 
		$("tr.tree_lvl_5").click(function() {
		    var lvl_5_is_open = $(this).data("expanded");
		    if (lvl_5_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5_item").show(); 
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4_item,tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();                
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        }); 
     }); 
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v5.8.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">
 
    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text"> 
      </span>
      <span class="right">
          &nbsp; 
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___a_d_c___d.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() { 
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body. 
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works 
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len)); 
            }
          } 
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }    
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element. 
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;  
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">ADC (r_adc_d)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___a_n_a_l_o_g___m_o_d_u_l_e_s.html">Analog</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabcf84f30b3ecb3bd5b4109d048953c2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___d.html#gabcf84f30b3ecb3bd5b4109d048953c2d">R_ADC_D_Open</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#structadc__cfg__t">adc_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:gabcf84f30b3ecb3bd5b4109d048953c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb9e82774f821dda5422f5b1111535a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___d.html#gacb9e82774f821dda5422f5b1111535a8">R_ADC_D_ScanCfg</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, void const *const p_channel_cfg)</td></tr>
<tr class="separator:gacb9e82774f821dda5422f5b1111535a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84fb8166f49f9bc71386b780bd77a807"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___d.html#ga84fb8166f49f9bc71386b780bd77a807">R_ADC_D_CallbackSet</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const p_api_ctrl, void(*p_callback)(<a class="el" href="group___a_d_c___a_p_i.html#structadc__callback__args__t">adc_callback_args_t</a> *), void const *const p_context, <a class="el" href="group___a_d_c___a_p_i.html#structadc__callback__args__t">adc_callback_args_t</a> *const p_callback_memory)</td></tr>
<tr class="separator:ga84fb8166f49f9bc71386b780bd77a807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b056e257147d939fcd82b3f7266ba8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___d.html#ga8b056e257147d939fcd82b3f7266ba8a">R_ADC_D_ScanStart</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:ga8b056e257147d939fcd82b3f7266ba8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga534ed105e6046f8e47f99dfc5c40d5f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___d.html#ga534ed105e6046f8e47f99dfc5c40d5f0">R_ADC_D_ScanGroupStart</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#gaee17c30275c1c9376cc485a62ea121eb">adc_group_mask_t</a> group_id)</td></tr>
<tr class="separator:ga534ed105e6046f8e47f99dfc5c40d5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada44bc8541282d5caee01f0471526c3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___d.html#gada44bc8541282d5caee01f0471526c3b">R_ADC_D_ScanStop</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:gada44bc8541282d5caee01f0471526c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c8a6279c4a0c5dfcc42a4829e95b10c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___d.html#ga1c8a6279c4a0c5dfcc42a4829e95b10c">R_ADC_D_StatusGet</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#structadc__status__t">adc_status_t</a> *p_status)</td></tr>
<tr class="separator:ga1c8a6279c4a0c5dfcc42a4829e95b10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe550c0b1e8300616f083724fa00f3ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___d.html#gabe550c0b1e8300616f083724fa00f3ae">R_ADC_D_Read</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const reg_id, uint16_t *const p_data)</td></tr>
<tr class="separator:gabe550c0b1e8300616f083724fa00f3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74b122f73a880d0dbfbdcf7fc8a4d2bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___d.html#ga74b122f73a880d0dbfbdcf7fc8a4d2bf">R_ADC_D_Read32</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const reg_id, uint32_t *const p_data)</td></tr>
<tr class="separator:ga74b122f73a880d0dbfbdcf7fc8a4d2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bd75c0fb2ab39e9e9e0dde1a56b0842"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___d.html#ga3bd75c0fb2ab39e9e9e0dde1a56b0842">R_ADC_D_InfoGet</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#structadc__info__t">adc_info_t</a> *p_adc_info)</td></tr>
<tr class="separator:ga3bd75c0fb2ab39e9e9e0dde1a56b0842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4771ec4946dc6129779073a0eb3c1538"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___d.html#ga4771ec4946dc6129779073a0eb3c1538">R_ADC_D_Close</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:ga4771ec4946dc6129779073a0eb3c1538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga617a3754d1bed4882006a68ea8631738"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___d.html#ga617a3754d1bed4882006a68ea8631738">R_ADC_D_Calibrate</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const p_ctrl, void const *p_extend)</td></tr>
<tr class="separator:ga617a3754d1bed4882006a68ea8631738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b22e051ef50adc65a1f834b38959da7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___d.html#ga5b22e051ef50adc65a1f834b38959da7">R_ADC_D_OffsetSet</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const reg_id, int32_t offset)</td></tr>
<tr class="separator:ga5b22e051ef50adc65a1f834b38959da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga703c793c94c5c753cda165e2c04651e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___d.html#ga703c793c94c5c753cda165e2c04651e3">R_ADC_D_SnoozeModePrepare</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:ga703c793c94c5c753cda165e2c04651e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga555cc0346624e178f52fc9f864435d2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___d.html#ga555cc0346624e178f52fc9f864435d2a">R_ADC_D_SnoozeModeExit</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:ga555cc0346624e178f52fc9f864435d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for ADC_D version of the ADC12 peripheral on RA MCUs. This module implements the <a class="el" href="group___a_d_c___a_p_i.html">ADC Interface</a>. </p>
<h1><a class="anchor" id="r-adc-d-overview"></a>
Overview</h1>
<h2><a class="anchor" id="r-adc-d-features"></a>
Features</h2>
<p>The ADC module supports the following features:</p>
<ul>
<li>8-, 10-, or 12-bit maximum resolution depending on the MCU</li>
<li>Configure scans to include:<ul>
<li>Single channel or Scan channels</li>
<li>Temperature sensor channel<a class="anchor" id="um_adc_d_support_the_on_chip_temperature_sensor"></a></li>
<li>Voltage sensor channel<a class="anchor" id="um_adc_d_support_the_on_chip_voltage_sensor"></a></li>
</ul>
</li>
<li>Configurable scan start trigger:<ul>
<li>Software scan triggers with no-wait mode or wait mode<a class="anchor" id="um_adc_d_starting_a_conversion"></a></li>
<li>Hardware scan triggers with no-wait mode or wait mode (timer expiration, for example)</li>
</ul>
</li>
<li>Configurable scan mode:<ul>
<li>One-shot scan mode, where each trigger starts a single scan</li>
<li>Sequential scan mode, where all channels are scanned continuously</li>
</ul>
</li>
<li>Optional callback when scan completes<a class="anchor" id="um_adc_d_interrupt_callback_data"></a><ul>
<li>Generated an interrupt request when ADLL &lt;= ADCRn &lt;= ADUL</li>
<li>Generated an interrupt request when ADUL &lt; ADCRn or ADLL &gt; ADCRn</li>
</ul>
</li>
<li>Test mode support<ul>
<li>Checking whether the ADC_D converter is operating normally</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="r-adc-d-configuration"></a>
Configuration</h1>
<p><a class="anchor" id="um_adc_d_configure_conversion_data_resolution"></a><a class="anchor" id="um_adc_d_configure_one_shot_scan_mode"></a><a class="anchor" id="um_adc_d_configure_software_trigger"></a><a class="anchor" id="um_adc_d_configure_the_hardware_trigger"></a><a class="anchor" id="um_adc_d_configure_sequential_mode"></a><a class="anchor" id="um_adc_d_configure_conversion_clockdiv"></a><a class="anchor" id="um_adc_d_reference_voltage_control"></a><a class="anchor" id="um_adc_d_reading_conversion_data"></a> <h2>Build Time Configurations for r_adc_d</h2>
The following build time configurations are defined in fsp_cfg/r_adc_d_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr class="tree_none">
<td>Internal Reference Voltage Support</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Enable Internal Reference Voltage support for the ADC module. </td></tr>
<tr class="tree_none">
<td>Snooze Mode Support</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Enable Snooze Mode Support. </td></tr>
<tr class="tree_none">
<td>Interrupt Support</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>Enable Scan End Interrupt support for the ADC module. </td></tr>
</table>
 <h2>Configurations for Analog &gt; ADC (r_adc_d)</h2>
This module can be added to the Stacks tab via New Stack &gt; Analog &gt; ADC (r_adc_d).<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> General  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Name</td><td>Name must be a valid C symbol</td><td>g_adc0 </td><td>Module name </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Resolution</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
12-Bit</li>
<li>
10-Bit</li>
<li>
8-Bit</li>
</ul>
</td><td>12-Bit </td><td>Specifies the conversion resolution for this unit. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Conversion operation</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
One-shot</li>
<li>
Sequential</li>
</ul>
</td><td>One-shot </td><td>Specifies the conversion operation mode. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Operation trigger</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Wait</li>
<li>
No-wait</li>
</ul>
</td><td>Wait </td><td>Specifies the operation trigger mode. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Operation voltage</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Normal 1</li>
<li>
Normal 2</li>
<li>
Low voltage 1</li>
<li>
Low voltage 2</li>
</ul>
</td><td>Normal 1 </td><td>Specifies operation voltage mode. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Conversion Clock (fAD)</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
PCLK</li>
<li>
PCLK/2</li>
<li>
PCLK/4</li>
<li>
PCLK/8</li>
<li>
PCLK/16</li>
<li>
PCLK/32</li>
</ul>
</td><td>PCLK </td><td>Specifies divider for conversion clock (fAD). </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Input  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Channel Selection Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Select</li>
<li>
Scan</li>
</ul>
</td><td>Select </td><td>Specifies the channel selection mode. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">A/D Input channel</td><td>MCU Specific Options</td><td></td><td>Specifies the input channels. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Negative Side Reference Voltage</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
VSS</li>
<li>
VREFL0</li>
</ul>
</td><td>VSS </td><td>Selection of the Negative Side Reference Voltage. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Positive Side Reference Voltage</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
VCC</li>
<li>
VREFH0</li>
<li>
Internal Reference Voltage</li>
</ul>
</td><td>VCC </td><td>Selection of the Positive Side Reference Voltage. </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Interrupts  </td></tr>
<tr class="tree_lvl_2">
<td class="tree_lvl_2" colspan="4"><span class="chevron-collapsed"></span> Interrupts &gt; Conversion Result upper/lower bound value setting  </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Generates an interrupt request (INTAD)</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
The interrupt signal is output when the ADLL register &lt;= the ADCRn register &lt;= the ADUL register</li>
<li>
The interrupt signal is output when the ADCRn register &lt; the ADLL register or the ADUL register &lt; the ADCRn register</li>
</ul>
</td><td>The interrupt signal is output when the ADLL register &lt;= the ADCRn register &lt;= the ADUL register </td><td>Specify condition generates an interrupt(INTAD) after each time the ADC scan completes. </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Upper bound (ADUL) value</td><td>Must be a valid integer</td><td>255 </td><td>Specify the upper limit conversion value that corresponds to the condition to generate an interrupt request (INTAD). </td></tr>
<tr class="tree_lvl_2_item">
<td class="tree_lvl_2_cell">Lower bound (ADLL) value</td><td>Must be a valid integer</td><td>0 </td><td>Specify the lower limit conversion value that corresponds to the condition to generate an interrupt request (INTAD). </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Callback</td><td>Name must be a valid C symbol</td><td>NULL </td><td>A user callback function. If this callback function is provided, it is called from the interrupt service routine (ISR) each time the ADC scan completes. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Scan End Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select scan end interrupt priority. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Start trigger source</td><td>MCU Specific Options</td><td></td><td>Specifies the trigger type to be used for this unit.  </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-adc-d-clock-configuration"></a>
Clock Configuration</h2>
<p>The ADC_D conversion clock source may be configured to use ICLK with a selectable division ratio.</p>
<p>The ADC_D clock must be at least 1 MHz when the ADC is used.</p>
<h2><a class="anchor" id="r-adc-d-pin-configuration"></a>
Pin Configuration</h2>
<p>The ANxxx pins are analog input channels that can be used with the ADC_D.</p>
<h1><a class="anchor" id="r-adc-d-usage_notes"></a>
Usage Notes</h1>
<h2><a class="anchor" id="adc_d-hal-module-operational-overview"></a>
ADC_D Operational Conversion</h2>
<p>The driver supports two operation conversion mode: One-shot scan and Sequential scan modes. For each time conversion, ADC peripheral only converts for each a pin or group of pins depending on channels selection mode, it can be changed to another pin or group of other pins by calling <a class="el" href="group___a_d_c___d.html#gacb9e82774f821dda5422f5b1111535a8">R_ADC_D_ScanCfg()</a>.</p>
<h3>Oneshot-scan Mode</h3>
<p>In One-shot scan mode, one or group specified channels are scanned once per trigger.</p>
<h3>Sequential-scan Mode</h3>
<p>In Sequential scan mode, a single trigger is required to start the scan. Scans continue until <a class="el" href="group___a_d_c___d.html#gada44bc8541282d5caee01f0471526c3b">R_ADC_D_ScanStop()</a> is called.</p>
<h3>When Interrupt Is Not Enabled</h3>
<p>If interrupts are not enabled, the R_ADC_D_StatusGet API can be used to poll the ADC to determine when the scan has completed. The read API function is used to access the converted ADC result.</p>
<h3>When Interrupt Is Enabled</h3>
<p>An interrupt is generated depend on setting condition of converted ADC result is in range or out of range of Upper Bound Value (ADUL) and Low Bound Value (ADLL). Refer to hardware manual: ADC12 &gt; Registers to Control the A/D Converte &gt; Figure "ADRCK Bit Interrupt Signal Generation Range".</p>
<h3>Selecting Reference Voltage</h3>
<p>The ADC_D positive and negative side reference voltages may be configured for selected MCU's. Please refer to the RA Configuration editor in e2 studio for further details.</p>
<dl class="section note"><dt>Note</dt><dd>When the internal reference voltage is selected as the positive side reference voltage. Please refer condition as below<ul>
<li>Select operation voltage is low-voltage mode 1 or 2.</li>
<li>The conversion clock (fAD) must be range 1 to 2 MHZ.</li>
<li>Do not setting select internal reference voltage or temperature sensor channel as an A/D conversion channel.</li>
</ul>
</dd></dl>
<h3>Selecting Internal Reference Voltage or Temperature Sensor channel</h3>
<p>When the internal reference voltage or temperature sensor output voltage is selected as the target for A/D conversion, please setting operation voltage is normal mode 2 or low-voltage mode 2.</p>
<dl class="section note"><dt>Note</dt><dd>when using operation voltage is low-voltage mode 2, setting a conversion clock (fAD) is less than or equal 16 MHz.</dd></dl>
<h3>Selecting Conversion Clock</h3>
<p>Range for frequency of Conversion Clock (fAD) depends on frequency of ICK. Please refer table as below.</p>
<table class="doxtable">
<tr>
<th>Frequency of ICLK </th><th>Frequency of Conversion Clock (fAD)  </th></tr>
<tr>
<td>4 MHz &lt; ICLK &lt;= 32 MHz</td><td>ICLK to ICLK/32 </td></tr>
<tr>
<td>1 MHz &lt;= fCLK &lt;= 4 MHz</td><td>ICLK to ICLK/4 </td></tr>
</table>
<h3>Selecting Operation Voltage</h3>
<p>The operation voltage is selectable depending on the analog input channel, VREFH0 voltage, operation mode, and ICLK. For detail, refer to hardware manual: ADC12 &gt; Registers to Control the A/D Converter &gt; tables "A/D conversion time in Normal mode 1 and 2" and "A/D conversion time in Low voltage mode 1 and 2".</p>
<dl class="section note"><dt>Note</dt><dd>When operation voltage is low-voltage modes 1 or 2, setting frequency of conversion clock (fAD) should be used with a frequency less than or equal 24 MHz. See in hardware manual: Electrical Characteristics &gt; Analog Characteristics &gt; table "A/D conversion characteristics in Low-voltage modes 1 and 2".</dd></dl>
<h2>ADC_D conversion in Test Mode</h2>
<p>The conversion target for testing can be selected by using the <b>Input &gt; A/D Input channel</b> property in the module configuration.<a class="anchor" id="um_adc_d_set_test_channel"></a> </p><dl class="section note"><dt>Note</dt><dd>For more details on the method of checking, refer to hardware manual: ADC12 &gt; Testing of the A/D .</dd></dl>
<h2>Using the Temperature Sensor with the ADC_D</h2>
<p>The ADC_D HAL module supports reading the data from the on-chip temperature sensor. The value returned from the sensor can be converted into degrees Celsius or Fahrenheit in the application program using the following formula, T = (Vs - V1)/slope + T1, where:</p>
<ul>
<li>T: Measured temperature (degrees C)</li>
<li>Vs: Voltage output by the temperature sensor at the time of temperature measurement (Volts)</li>
<li>T1: Temperature experimentally measured at one point (degrees C)</li>
<li>V1: Voltage output by the temperature sensor at the time of measurement of T1 (Volts)</li>
<li>T2: Temperature at the experimental measurement of another point (degrees C)</li>
<li>V2: Voltage output by the temperature sensor at the time of measurement of T2 (Volts)</li>
<li>Slope: Temperature gradient of the temperature sensor (V/degrees C); slope = (V2 - V1)/ (T2 - T1)</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The slope value can be obtained for each in the Electrical Characteristics Chapter - TSN Characteristics Table, Temperature slope entry.</dd></dl>
<p>For the setting flow, see in hardware manual: ADC12 &gt; Example of Using the ADC12 when Selecting the Temperature Sensor Output Voltage or Internal Reference Voltage, and Software Trigger No-wait Mode and One-shot Conversion Mode.</p>
<h1><a class="anchor" id="r-adc-d-examples"></a>
Examples</h1>
<h2>Basic Example</h2>
<p>This is a basic example of minimal use of the ADC_D in an application.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">/* A channel configuration is generated by the RA Configuration editor based on the options selected. If additional</span></div><div class="line"><span class="comment"> * configurations are desired additional adc_d_channel_cfg_t elements can be defined and passed to R_ADC_D_ScanCfg. */</span></div><div class="line"><a class="code" href="group___a_d_c___d.html#structadc__d__channel__cfg__t">adc_d_channel_cfg_t</a> g_adc_d0_channel_cfg =</div><div class="line">{</div><div class="line">    .channel_input = <a class="code" href="group___a_d_c___a_p_i.html#ggaafc4060027875f8fe46242b0656d7814a203b48944d019f4fda969a6fc2a9e492">ADC_CHANNEL_1</a>,</div><div class="line">};</div><div class="line"><span class="keywordtype">void</span> adc_d_callback (<a class="code" href="group___a_d_c___a_p_i.html#structadc__callback__args__t">adc_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gaf0afcbc9a110ac9366a811d96ee06029">FSP_PARAMETER_NOT_USED</a>(p_args);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> adc_d_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___a_d_c___d.html#gabcf84f30b3ecb3bd5b4109d048953c2d">R_ADC_D_Open</a>(&amp;g_adc_d0_ctrl, &amp;g_adc_d0_cfg);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Enable channels. */</span></div><div class="line">    err = <a class="code" href="group___a_d_c___d.html#gacb9e82774f821dda5422f5b1111535a8">R_ADC_D_ScanCfg</a>(&amp;g_adc_d0_ctrl, &amp;g_adc_d0_channel_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* In software trigger mode, start a scan by calling R_ADC_D_ScanStart(). In other modes, enable hardware</span></div><div class="line"><span class="comment">     * triggers by calling R_ADC_D_ScanStart(). */</span></div><div class="line">    (void) <a class="code" href="group___a_d_c___d.html#ga8b056e257147d939fcd82b3f7266ba8a">R_ADC_D_ScanStart</a>(&amp;g_adc_d0_ctrl);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Wait for conversion to complete. */</span></div><div class="line">    <a class="code" href="group___a_d_c___a_p_i.html#structadc__status__t">adc_status_t</a> status;</div><div class="line">    status.<a class="code" href="group___a_d_c___a_p_i.html#a276869569116678c7838ef506fceb77b">state</a> = <a class="code" href="group___a_d_c___a_p_i.html#gga2783ab2e29809bf0a50bc66c6fa8d3c6abe1c11b191e48669cc5129aca45800d7">ADC_STATE_SCAN_IN_PROGRESS</a>;</div><div class="line">    <span class="keywordflow">while</span> (<a class="code" href="group___a_d_c___a_p_i.html#gga2783ab2e29809bf0a50bc66c6fa8d3c6abe1c11b191e48669cc5129aca45800d7">ADC_STATE_SCAN_IN_PROGRESS</a> == status.<a class="code" href="group___a_d_c___a_p_i.html#a276869569116678c7838ef506fceb77b">state</a>)</div><div class="line">    {</div><div class="line">        (void) <a class="code" href="group___a_d_c___d.html#ga1c8a6279c4a0c5dfcc42a4829e95b10c">R_ADC_D_StatusGet</a>(&amp;g_adc_d0_ctrl, &amp;status);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Read converted data. */</span></div><div class="line">    uint16_t channel1_conversion_result;</div><div class="line">    err = <a class="code" href="group___a_d_c___d.html#gabe550c0b1e8300616f083724fa00f3ae">R_ADC_D_Read</a>(&amp;g_adc_d0_ctrl, <a class="code" href="group___a_d_c___a_p_i.html#ggaafc4060027875f8fe46242b0656d7814a203b48944d019f4fda969a6fc2a9e492">ADC_CHANNEL_1</a>, &amp;channel1_conversion_result);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Temperature Sensor Example</h2>
<p>This example shows how to calculate the MCU temperature using the ADC_D and the temperature sensor.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define ADC_D_EXAMPLE_TEMPERATURE_VOLTAGE_V1             (1050000)</span></div><div class="line"><span class="preprocessor">#define ADC_D_EXAMPLE_VCC_MICROVOLT                      (3300000)</span></div><div class="line"><span class="preprocessor">#define ADC_D_EXAMPLE_TEMPERATURE_RESOLUTION             (4096)</span></div><div class="line"><span class="preprocessor">#define ADC_D_EXAMPLE_ADC_TEST_TEMPERATURE_CELSIUS_T1    (25)</span></div><div class="line"><span class="preprocessor">#define ADC_PRV_COEFFICIENT                              (0.5)</span></div><div class="line"><span class="keywordtype">void</span> adc_d_temperature_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* The following example calculates the temperature using the data provided.</span></div><div class="line"><span class="comment">     * See in hardware manual: Temperature Sensor (TSN) &gt; Preparation for Using the Temperature Sensor */</span></div><div class="line"></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Using normal mode 2 when configure temperature channel */</span></div><div class="line">    g_adc_d0_cfg_extend.operation_voltage = <a class="code" href="group___a_d_c___d.html#gga2c9e8acd064d7ffc4c78e6b30f995fbfac4c74f652fb3985b83e7a5ebe36942cb">ADC_D_VOLTAGE_MODE_NORMAL_2</a>;</div><div class="line">    g_adc_d0_cfg_extend.operation_trigger = <a class="code" href="group___a_d_c___d.html#ggae7eaafed2ff673253d4bbecbde0896b4a8bff13fc5392d6cc146cd71657e91ba2">ADC_D_TRIGGER_MODE_NO_WAIT</a>;</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___a_d_c___d.html#gabcf84f30b3ecb3bd5b4109d048953c2d">R_ADC_D_Open</a>(&amp;g_adc_d0_ctrl, &amp;g_adc_d0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Configure temperature channel */</span></div><div class="line">    g_adc_d0_channel_cfg.channel_input = <a class="code" href="group___a_d_c___a_p_i.html#ggaafc4060027875f8fe46242b0656d7814aff4cf0b5a9bfd1fc634f6b097e34fe73">ADC_CHANNEL_TEMPERATURE</a>;</div><div class="line"></div><div class="line">    <span class="comment">/* Enable temperature sensor. */</span></div><div class="line">    err = <a class="code" href="group___a_d_c___d.html#gacb9e82774f821dda5422f5b1111535a8">R_ADC_D_ScanCfg</a>(&amp;g_adc_d0_ctrl, &amp;g_adc_d0_channel_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Start of A/D conversion */</span></div><div class="line">    (void) <a class="code" href="group___a_d_c___d.html#ga8b056e257147d939fcd82b3f7266ba8a">R_ADC_D_ScanStart</a>(&amp;g_adc_d0_ctrl);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for conversion to complete. */</span></div><div class="line">    <a class="code" href="group___a_d_c___a_p_i.html#structadc__status__t">adc_status_t</a> status;</div><div class="line">    status.<a class="code" href="group___a_d_c___a_p_i.html#a276869569116678c7838ef506fceb77b">state</a> = <a class="code" href="group___a_d_c___a_p_i.html#gga2783ab2e29809bf0a50bc66c6fa8d3c6abe1c11b191e48669cc5129aca45800d7">ADC_STATE_SCAN_IN_PROGRESS</a>;</div><div class="line">    <span class="keywordflow">while</span> (<a class="code" href="group___a_d_c___a_p_i.html#gga2783ab2e29809bf0a50bc66c6fa8d3c6abe1c11b191e48669cc5129aca45800d7">ADC_STATE_SCAN_IN_PROGRESS</a> == status.<a class="code" href="group___a_d_c___a_p_i.html#a276869569116678c7838ef506fceb77b">state</a>)</div><div class="line">    {</div><div class="line">        (void) <a class="code" href="group___a_d_c___d.html#ga1c8a6279c4a0c5dfcc42a4829e95b10c">R_ADC_D_StatusGet</a>(&amp;g_adc_d0_ctrl, &amp;status);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* The 1st conversion result cannot be used. See in hardware manual: ADC12 &gt; A/D Converter Setup Procedure &gt;</span></div><div class="line"><span class="comment">     * Table &quot;Setup when temperature sensor output voltage and internal reference voltage is selected&quot; */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Start of A/D conversion */</span></div><div class="line">    (void) <a class="code" href="group___a_d_c___d.html#ga8b056e257147d939fcd82b3f7266ba8a">R_ADC_D_ScanStart</a>(&amp;g_adc_d0_ctrl);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for conversion to complete. */</span></div><div class="line">    status.<a class="code" href="group___a_d_c___a_p_i.html#a276869569116678c7838ef506fceb77b">state</a> = <a class="code" href="group___a_d_c___a_p_i.html#gga2783ab2e29809bf0a50bc66c6fa8d3c6abe1c11b191e48669cc5129aca45800d7">ADC_STATE_SCAN_IN_PROGRESS</a>;</div><div class="line">    <span class="keywordflow">while</span> (<a class="code" href="group___a_d_c___a_p_i.html#gga2783ab2e29809bf0a50bc66c6fa8d3c6abe1c11b191e48669cc5129aca45800d7">ADC_STATE_SCAN_IN_PROGRESS</a> == status.<a class="code" href="group___a_d_c___a_p_i.html#a276869569116678c7838ef506fceb77b">state</a>)</div><div class="line">    {</div><div class="line">        (void) <a class="code" href="group___a_d_c___d.html#ga1c8a6279c4a0c5dfcc42a4829e95b10c">R_ADC_D_StatusGet</a>(&amp;g_adc_d0_ctrl, &amp;status);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Read converted data. */</span></div><div class="line">    uint16_t temperature_conversion_result;</div><div class="line">    err = <a class="code" href="group___a_d_c___d.html#gabe550c0b1e8300616f083724fa00f3ae">R_ADC_D_Read</a>(&amp;g_adc_d0_ctrl, <a class="code" href="group___a_d_c___a_p_i.html#ggaafc4060027875f8fe46242b0656d7814aff4cf0b5a9bfd1fc634f6b097e34fe73">ADC_CHANNEL_TEMPERATURE</a>, &amp;temperature_conversion_result);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* If the MCU does not provide calibration data, use the value in the hardware manual or determine it</span></div><div class="line"><span class="comment">     * experimentally. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Get Calibration data from the MCU if available. */</span></div><div class="line">    <a class="code" href="group___a_d_c___a_p_i.html#structadc__info__t">adc_info_t</a> adc_info;</div><div class="line">    (void) <a class="code" href="group___a_d_c___d.html#ga3bd75c0fb2ab39e9e9e0dde1a56b0842">R_ADC_D_InfoGet</a>(&amp;g_adc_d0_ctrl, &amp;adc_info);</div><div class="line"></div><div class="line">    <span class="comment">/* NOTE: The slope of the temperature sensor varies from sensor to sensor. Renesas recommends calculating</span></div><div class="line"><span class="comment">     * the slope of the temperature sensor experimentally.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * This example uses the typical slope provided in Table &quot;TSN characteristics&quot; in the user manual */</span></div><div class="line">    int32_t slope_uv_per_c = BSP_FEATURE_ADC_TSN_SLOPE;</div><div class="line"></div><div class="line">    <span class="comment">/* Formula for calculating temperature copied from section &quot;Temperature Sensor (TSN)&quot;</span></div><div class="line"><span class="comment">     * of the user manual:</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * Using this, the measured temperature can be calculated according to the following formula.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * T = (Vs - V1) / Slope + T1 [C]</span></div><div class="line"><span class="comment">     * T: Measured temperature (C)</span></div><div class="line"><span class="comment">     * Vs: Voltage output by the temperature sensor when the temperature is measured (V)</span></div><div class="line"><span class="comment">     * V1: Voltage output by T1(25 C) is 1.05 V. Refer table &quot;TSN characteristics&quot; in the user manual</span></div><div class="line"><span class="comment">     * Slope: Temperature slope given in table &quot;TSN characteristics&quot; -3.3 mV/C</span></div><div class="line"><span class="comment">     * T1: Temperature of T1 is 25 C.Refer table &quot;TSN characteristics&quot; in the user manual</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    int32_t v1_uv = ADC_D_EXAMPLE_TEMPERATURE_VOLTAGE_V1;</div><div class="line"></div><div class="line">    <span class="comment">/* Refer to chapter &quot;Input Voltage and Conversion Results&quot; in the user manual */</span></div><div class="line">    int32_t vs_uv =</div><div class="line">        (int32_t) (((temperature_conversion_result - ADC_PRV_COEFFICIENT) * ADC_D_EXAMPLE_VCC_MICROVOLT) /</div><div class="line">                   ADC_D_EXAMPLE_TEMPERATURE_RESOLUTION);</div><div class="line">    int32_t temperature_c =</div><div class="line">        (int32_t) ((vs_uv - v1_uv) / slope_uv_per_c + ADC_D_EXAMPLE_ADC_TEST_TEMPERATURE_CELSIUS_T1);</div><div class="line"></div><div class="line">    <span class="comment">/* Expect room temperature, break if temperature is outside the range of 20 C to 25 C. */</span></div><div class="line">    <span class="keywordflow">if</span> ((temperature_c &lt; 20) || (temperature_c &gt; 25))</div><div class="line">    {</div><div class="line">        __BKPT(0);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Requesting Snooze mode using ADC_D Hardware Trigger</h2>
<p>ADC_D can request snooze mode via a hardware trigger and perform an ADC conversion in the following modes:</p><ul>
<li>Hardware trigger wait mode (select mode, one-shot conversion mode)</li>
<li>Hardware trigger wait mode (scan mode, one-shot conversion mode)</li>
</ul>
<p>In order to enable this functionality, the application must call <a class="el" href="group___a_d_c___d.html#ga703c793c94c5c753cda165e2c04651e3">R_ADC_D_SnoozeModePrepare()</a> immediately before entering software standby mode, and call <a class="el" href="group___a_d_c___d.html#ga555cc0346624e178f52fc9f864435d2a">R_ADC_D_SnoozeModeExit()</a> immediately after returning from software standby mode.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> adc_d_snooze_request_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Configure ADC_D with the following settings:</span></div><div class="line"><span class="comment">     * - adc_d_extended_cfg_t::trigger_source       = [ADC_D_TRIGGER_SOURCE_TAU0_TMI01,</span></div><div class="line"><span class="comment">     *                                                 ADC_D_TRIGGER_SOURCE_RTC_ALARM_OR_PERIOD,</span></div><div class="line"><span class="comment">     *                                                 ADC_D_TRIGGER_SOURCE_TML0_ITL0,</span></div><div class="line"><span class="comment">     *                                                 ADC_D_TRIGGER_SOURCE_ELC] (Hardware trigger)</span></div><div class="line"><span class="comment">     * - adc_d_extended_cfg_t::operation_trigger    = ADC_D_TRIGGER_MODE_WAIT (Wait mode)</span></div><div class="line"><span class="comment">     * - adc_d_extended_cfg_t::conversion_operation = ADC_D_CONVERSION_MODE_ONESHOT (One shot conversion mode)</span></div><div class="line"><span class="comment">     * - ICLK must be operating off of HOCO or MOCO</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    err = <a class="code" href="group___a_d_c___d.html#gabcf84f30b3ecb3bd5b4109d048953c2d">R_ADC_D_Open</a>(&amp;g_adc_d0_ctrl, &amp;g_adc_d0_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">    err = <a class="code" href="group___a_d_c___d.html#gacb9e82774f821dda5422f5b1111535a8">R_ADC_D_ScanCfg</a>(&amp;g_adc_d0_ctrl, &amp;g_adc_d0_channel_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">    err = <a class="code" href="group___a_d_c___d.html#ga8b056e257147d939fcd82b3f7266ba8a">R_ADC_D_ScanStart</a>(&amp;g_adc_d0_ctrl);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Configure a hardware trigger for ADC_D (Ie. RTC Periodic IRQ). */</span></div><div class="line">    err = <a class="code" href="group___r_t_c___c.html#gabadf3306588a2e313cbc1dbc4fa9d570">R_RTC_C_Open</a>(&amp;g_rtc_ctrl, &amp;g_rtc_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">    err = <a class="code" href="group___r_t_c___c.html#ga3356f86836cbea0224e1fad8e559d7ac">R_RTC_C_CalendarTimeSet</a>(&amp;g_rtc_ctrl, &amp;g_rtc_current_time);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">    err = <a class="code" href="group___r_t_c___c.html#ga40d181ae28907cbcc41cebe7accb94d4">R_RTC_C_PeriodicIrqRateSet</a>(&amp;g_rtc_ctrl, <a class="code" href="group___r_t_c___a_p_i.html#ggacbf0a3d09430a65ca1b3179819183f01a35f83abe856065e723ec538a5e708a6d">RTC_PERIODIC_IRQ_SELECT_1_SECOND</a>);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Configure LPM in snooze mode. */</span></div><div class="line">    err = <a class="code" href="group___l_p_m.html#ga16cb25caff90bf78509e73de4dc58cb5">R_LPM_Open</a>(&amp;g_lpm_ctrl, &amp;g_lpm_snooze_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Prepare ADC_D to operate in snooze mode. This must be called immediately before entering software standby mode. */</span></div><div class="line">    err = <a class="code" href="group___a_d_c___d.html#ga703c793c94c5c753cda165e2c04651e3">R_ADC_D_SnoozeModePrepare</a>(&amp;g_adc_d0_ctrl);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Enter low power mode:</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * When RTC_C Periodic IRQ occurs, ICLK source will be started. ADC_D will wait for the oscillator to stabilize,</span></div><div class="line"><span class="comment">     * then start an ADC conversion.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    err = <a class="code" href="group___l_p_m.html#ga9768304d0a6af030631ad145b3752f07">R_LPM_LowPowerModeEnter</a>(&amp;g_lpm_ctrl);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* After exiting snooze mode, return ADC operation to normal mode. */</span></div><div class="line">    err = <a class="code" href="group___a_d_c___d.html#ga555cc0346624e178f52fc9f864435d2a">R_ADC_D_SnoozeModeExit</a>(&amp;g_adc_d0_ctrl);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structadc__d__channel__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___d.html#structadc__d__channel__cfg__t">adc_d_channel_cfg_t</a></td></tr>
<tr class="separator:structadc__d__channel__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structadc__d__extended__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___d.html#structadc__d__extended__cfg__t">adc_d_extended_cfg_t</a></td></tr>
<tr class="separator:structadc__d__extended__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structadc__d__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___d.html#structadc__d__instance__ctrl__t">adc_d_instance_ctrl_t</a></td></tr>
<tr class="separator:structadc__d__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gac2b2897b9e621fd085bc5bccda88a9cf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___d.html#gac2b2897b9e621fd085bc5bccda88a9cf">adc_d_channel_mode_t</a> </td></tr>
<tr class="separator:gac2b2897b9e621fd085bc5bccda88a9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c9e8acd064d7ffc4c78e6b30f995fbf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___d.html#ga2c9e8acd064d7ffc4c78e6b30f995fbf">adc_d_voltage_mode_t</a> </td></tr>
<tr class="separator:ga2c9e8acd064d7ffc4c78e6b30f995fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97c9e58c7a646465245305d94f6071b4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___d.html#ga97c9e58c7a646465245305d94f6071b4">adc_d_clock_div_t</a> </td></tr>
<tr class="separator:ga97c9e58c7a646465245305d94f6071b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a352e8fc883fe4f5d54eaa3e4831563"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___d.html#ga6a352e8fc883fe4f5d54eaa3e4831563">adc_d_trigger_source_t</a> </td></tr>
<tr class="separator:ga6a352e8fc883fe4f5d54eaa3e4831563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7eaafed2ff673253d4bbecbde0896b4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___d.html#gae7eaafed2ff673253d4bbecbde0896b4">adc_d_trigger_mode_t</a> </td></tr>
<tr class="separator:gae7eaafed2ff673253d4bbecbde0896b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf32568ba58143dd1255d888f316f5f81"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___d.html#gaf32568ba58143dd1255d888f316f5f81">adc_d_conversion_mode_t</a> </td></tr>
<tr class="separator:gaf32568ba58143dd1255d888f316f5f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1cfca4939e1e1577c5943ba14e88390"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___d.html#gac1cfca4939e1e1577c5943ba14e88390">adc_d_boundary_t</a> </td></tr>
<tr class="separator:gac1cfca4939e1e1577c5943ba14e88390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ea7c650de4c474f09b9d3e293076662"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___d.html#ga6ea7c650de4c474f09b9d3e293076662">adc_d_negative_vref_t</a> </td></tr>
<tr class="separator:ga6ea7c650de4c474f09b9d3e293076662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e834e2e27b04dec90e019f89b540152"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c___d.html#ga3e834e2e27b04dec90e019f89b540152">adc_d_positive_vref_t</a> </td></tr>
<tr class="separator:ga3e834e2e27b04dec90e019f89b540152"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structadc__d__channel__cfg__t" id="structadc__d__channel__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structadc__d__channel__cfg__t">&#9670;&nbsp;</a></span>adc_d_channel_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct adc_d_channel_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>ADC_D channel(s) configuration </p>
</div>
</div>
</div>
<a name="structadc__d__extended__cfg__t" id="structadc__d__extended__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structadc__d__extended__cfg__t">&#9670;&nbsp;</a></span>adc_d_extended_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct adc_d_extended_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Extended configuration structure for ADC. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a9271b140ffc71ac877117cce936b9477"></a><a class="el" href="group___a_d_c___d.html#gac2b2897b9e621fd085bc5bccda88a9cf">adc_d_channel_mode_t</a></td>
<td class="fieldname">
channel_mode</td>
<td class="fielddoc">
ADC_D channels mode setting. </td></tr>
<tr><td class="fieldtype">
<a id="a099ea236105d6880a9002257d160f7da"></a><a class="el" href="group___a_d_c___d.html#ga2c9e8acd064d7ffc4c78e6b30f995fbf">adc_d_voltage_mode_t</a></td>
<td class="fieldname">
operation_voltage</td>
<td class="fielddoc">
Voltage mode setting. </td></tr>
<tr><td class="fieldtype">
<a id="ac61212470a6aae4108de65885e7d78db"></a><a class="el" href="group___a_d_c___d.html#ga97c9e58c7a646465245305d94f6071b4">adc_d_clock_div_t</a></td>
<td class="fieldname">
conversion_clockdiv</td>
<td class="fielddoc">
Divider for conversion clock (fAD) setting. </td></tr>
<tr><td class="fieldtype">
<a id="a24c67a930d8b2ea41d6f35f4a5130eec"></a><a class="el" href="group___a_d_c___d.html#ga6a352e8fc883fe4f5d54eaa3e4831563">adc_d_trigger_source_t</a></td>
<td class="fieldname">
trigger_source</td>
<td class="fielddoc">
Trigger source hardware and software setting. </td></tr>
<tr><td class="fieldtype">
<a id="a6692d964432383320284b5ac688be249"></a><a class="el" href="group___a_d_c___d.html#gae7eaafed2ff673253d4bbecbde0896b4">adc_d_trigger_mode_t</a></td>
<td class="fieldname">
operation_trigger</td>
<td class="fielddoc">
Operation mode wait/no wait setting. </td></tr>
<tr><td class="fieldtype">
<a id="ad6a3f100c212b777c6b7815d3c32742a"></a><a class="el" href="group___a_d_c___d.html#gaf32568ba58143dd1255d888f316f5f81">adc_d_conversion_mode_t</a></td>
<td class="fieldname">
conversion_operation</td>
<td class="fielddoc">
Sequential/one-shot conversion setting. </td></tr>
<tr><td class="fieldtype">
<a id="af8abc3eb6c50180446bfeaa53576cae3"></a><a class="el" href="group___a_d_c___d.html#gac1cfca4939e1e1577c5943ba14e88390">adc_d_boundary_t</a></td>
<td class="fieldname">
upper_lower_bound</td>
<td class="fielddoc">
Upper limit and lower limit conversion setting. </td></tr>
<tr><td class="fieldtype">
<a id="a3a18ce046b2222f5f316acf2711f5078"></a><a class="el" href="group___a_d_c___d.html#ga6ea7c650de4c474f09b9d3e293076662">adc_d_negative_vref_t</a></td>
<td class="fieldname">
negative_vref</td>
<td class="fielddoc">
Negative side reference voltage setting. </td></tr>
<tr><td class="fieldtype">
<a id="aa9730b9d5b93a0ffeba36ffe4b0210bb"></a><a class="el" href="group___a_d_c___d.html#ga3e834e2e27b04dec90e019f89b540152">adc_d_positive_vref_t</a></td>
<td class="fieldname">
positive_vref</td>
<td class="fielddoc">
Positive side reference voltage setting. </td></tr>
<tr><td class="fieldtype">
<a id="a1ebdd726d41858aa703f8bf3db6e406a"></a>uint8_t</td>
<td class="fieldname">
upper_bound_limit</td>
<td class="fielddoc">
Setting upper limit conversion value. </td></tr>
<tr><td class="fieldtype">
<a id="a87aea7a5405d805a2d137fd95b4d5909"></a>uint8_t</td>
<td class="fieldname">
lower_bound_limit</td>
<td class="fielddoc">
Setting lower limit conversion value. </td></tr>
</table>

</div>
</div>
<a name="structadc__d__instance__ctrl__t" id="structadc__d__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structadc__d__instance__ctrl__t">&#9670;&nbsp;</a></span>adc_d_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct adc_d_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>ADC_D instance control block. DO NOT INITIALIZE. Initialized in <a class="el" href="group___a_d_c___a_p_i.html#afa184c06541e3fd9f90fc12ed775f468">adc_api_t::open()</a>. </p>
</div>
</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gac2b2897b9e621fd085bc5bccda88a9cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2b2897b9e621fd085bc5bccda88a9cf">&#9670;&nbsp;</a></span>adc_d_channel_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c___d.html#gac2b2897b9e621fd085bc5bccda88a9cf">adc_d_channel_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADC_D channels mode selection </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac2b2897b9e621fd085bc5bccda88a9cfa4218f1187a22ab1672b2e51bfb2cca44"></a>ADC_D_CHANNEL_MODE_SELECT&#160;</td><td class="fielddoc"><p>Select mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac2b2897b9e621fd085bc5bccda88a9cfac8482d3de7289f57a385ae88cd335c6c"></a>ADC_D_CHANNEL_MODE_SCAN&#160;</td><td class="fielddoc"><p>Scan mode. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga2c9e8acd064d7ffc4c78e6b30f995fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c9e8acd064d7ffc4c78e6b30f995fbf">&#9670;&nbsp;</a></span>adc_d_voltage_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c___d.html#ga2c9e8acd064d7ffc4c78e6b30f995fbf">adc_d_voltage_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operation voltage mode selection </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2c9e8acd064d7ffc4c78e6b30f995fbfa1364ad847b53e9a828dbf69146bd5737"></a>ADC_D_VOLTAGE_MODE_NORMAL_1&#160;</td><td class="fielddoc"><p>Normal 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2c9e8acd064d7ffc4c78e6b30f995fbfac4c74f652fb3985b83e7a5ebe36942cb"></a>ADC_D_VOLTAGE_MODE_NORMAL_2&#160;</td><td class="fielddoc"><p>Normal 2. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2c9e8acd064d7ffc4c78e6b30f995fbfa5538600a4461d5c28e235f129317f3cf"></a>ADC_D_VOLTAGE_MODE_LOW_1&#160;</td><td class="fielddoc"><p>Low voltage 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2c9e8acd064d7ffc4c78e6b30f995fbfaccf778b5e33b9396b639d7411391f84d"></a>ADC_D_VOLTAGE_MODE_LOW_2&#160;</td><td class="fielddoc"><p>Low voltage 2. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga97c9e58c7a646465245305d94f6071b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97c9e58c7a646465245305d94f6071b4">&#9670;&nbsp;</a></span>adc_d_clock_div_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c___d.html#ga97c9e58c7a646465245305d94f6071b4">adc_d_clock_div_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divider for Conversion Clock (fAD) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga97c9e58c7a646465245305d94f6071b4a20ce488c5b0d56b78d027373a6ae87c7"></a>ADC_D_CLOCK_DIV_32&#160;</td><td class="fielddoc"><p>ADC_D clock division ICLK/32. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga97c9e58c7a646465245305d94f6071b4aec0ffed41811d4c687e9ad1e3efd2c8e"></a>ADC_D_CLOCK_DIV_16&#160;</td><td class="fielddoc"><p>ADC_D clock division ICLK/16. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga97c9e58c7a646465245305d94f6071b4a6267c785fe7e62571e39bf84f3c28c74"></a>ADC_D_CLOCK_DIV_8&#160;</td><td class="fielddoc"><p>ADC_D clock division ICLK/8. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga97c9e58c7a646465245305d94f6071b4a54a229e36d27e9513d1a2ed4d0e3af64"></a>ADC_D_CLOCK_DIV_4&#160;</td><td class="fielddoc"><p>ADC_D clock division ICLK/4. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga97c9e58c7a646465245305d94f6071b4a9612b5edd5d5de20896b5c591e203be3"></a>ADC_D_CLOCK_DIV_2&#160;</td><td class="fielddoc"><p>ADC_D clock division ICLK/2. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga97c9e58c7a646465245305d94f6071b4a4478f2581119dc008b4c4834e62cfc31"></a>ADC_D_CLOCK_DIV_1&#160;</td><td class="fielddoc"><p>ADC_D clock division ICLK/1. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga6a352e8fc883fe4f5d54eaa3e4831563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a352e8fc883fe4f5d54eaa3e4831563">&#9670;&nbsp;</a></span>adc_d_trigger_source_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c___d.html#ga6a352e8fc883fe4f5d54eaa3e4831563">adc_d_trigger_source_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Selection trigger signal </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6a352e8fc883fe4f5d54eaa3e4831563a97f7a3e5c892d7d3f734bd7cb563bbb9"></a>ADC_D_TRIGGER_SOURCE_TAU0_TMI01&#160;</td><td class="fielddoc"><p>Timer channel 01 count or capture end interrupt signal. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6a352e8fc883fe4f5d54eaa3e4831563a5a373badac18267e06c1eb3fc6710ff5"></a>ADC_D_TRIGGER_SOURCE_RTC_ALARM_OR_PERIOD&#160;</td><td class="fielddoc"><p>Realtime clock interrupt signal. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6a352e8fc883fe4f5d54eaa3e4831563a04e99acc8eb15c262bc8f9f5f7b08cd7"></a>ADC_D_TRIGGER_SOURCE_TML0_ITL0&#160;</td><td class="fielddoc"><p>32-bit interval timer interrupt signal </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6a352e8fc883fe4f5d54eaa3e4831563ae584123256a08acc32ca2e81949d7696"></a>ADC_D_TRIGGER_SOURCE_ELC&#160;</td><td class="fielddoc"><p>Event input from ELC. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6a352e8fc883fe4f5d54eaa3e4831563ad1718cb2b959ec6d15995c384e460451"></a>ADC_D_TRIGGER_SOURCE_SOFTWARE&#160;</td><td class="fielddoc"><p>Software trigger, this option is controlled by bit ADCS, ADCE. </p>
</td></tr>
</table>

</div>
</div>
<a id="gae7eaafed2ff673253d4bbecbde0896b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7eaafed2ff673253d4bbecbde0896b4">&#9670;&nbsp;</a></span>adc_d_trigger_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c___d.html#gae7eaafed2ff673253d4bbecbde0896b4">adc_d_trigger_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select trigger mode </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae7eaafed2ff673253d4bbecbde0896b4a8bff13fc5392d6cc146cd71657e91ba2"></a>ADC_D_TRIGGER_MODE_NO_WAIT&#160;</td><td class="fielddoc"><p>Trigger no-wait mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae7eaafed2ff673253d4bbecbde0896b4a187f7935b235d6be5d5b5bc404f5c33d"></a>ADC_D_TRIGGER_MODE_WAIT&#160;</td><td class="fielddoc"><p>Trigger wait mode. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaf32568ba58143dd1255d888f316f5f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf32568ba58143dd1255d888f316f5f81">&#9670;&nbsp;</a></span>adc_d_conversion_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c___d.html#gaf32568ba58143dd1255d888f316f5f81">adc_d_conversion_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select conversion operation mode </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf32568ba58143dd1255d888f316f5f81a41060ac7a82ec60863e5515d8504a827"></a>ADC_D_CONVERSION_MODE_SEQUENTIAL&#160;</td><td class="fielddoc"><p>Continuous conversion mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf32568ba58143dd1255d888f316f5f81afc24c4d73bd991303180db3f85bf96d9"></a>ADC_D_CONVERSION_MODE_ONESHOT&#160;</td><td class="fielddoc"><p>Single conversion mode. </p>
</td></tr>
</table>

</div>
</div>
<a id="gac1cfca4939e1e1577c5943ba14e88390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1cfca4939e1e1577c5943ba14e88390">&#9670;&nbsp;</a></span>adc_d_boundary_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c___d.html#gac1cfca4939e1e1577c5943ba14e88390">adc_d_boundary_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select the upper limit and lower limit conversion result values </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac1cfca4939e1e1577c5943ba14e88390a37c6809dc8c4aa34428879b869aab916"></a>ADC_D_BOUNDARY_IN_RANGE&#160;</td><td class="fielddoc"><p>The interrupt signal (INTAD) is output in range ADLL and AULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac1cfca4939e1e1577c5943ba14e88390ae59549c4165a9d106f99680b29447f97"></a>ADC_D_BOUNDARY_OUT_OF_RANGE&#160;</td><td class="fielddoc"><p>The interrupt signal (INTAD) is output out of range ADLL and AULL. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga6ea7c650de4c474f09b9d3e293076662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ea7c650de4c474f09b9d3e293076662">&#9670;&nbsp;</a></span>adc_d_negative_vref_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c___d.html#ga6ea7c650de4c474f09b9d3e293076662">adc_d_negative_vref_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The negative side reference voltage selection </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6ea7c650de4c474f09b9d3e293076662ac0dfcf5f302ca32a5c5a02bf03892ecf"></a>ADC_D_NEGATIVE_VREF_VSS&#160;</td><td class="fielddoc"><p>Supplied from VSS. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6ea7c650de4c474f09b9d3e293076662af46e382b39c981c21e6536c640325b48"></a>ADC_D_NEGATIVE_VREF_VREFL0&#160;</td><td class="fielddoc"><p>Supplied from VREFL0. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga3e834e2e27b04dec90e019f89b540152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e834e2e27b04dec90e019f89b540152">&#9670;&nbsp;</a></span>adc_d_positive_vref_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c___d.html#ga3e834e2e27b04dec90e019f89b540152">adc_d_positive_vref_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The positive side reference voltage selection </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3e834e2e27b04dec90e019f89b540152a35c916dfbe4d7c56954a5715397b673f"></a>ADC_D_POSITIVE_VREF_VCC&#160;</td><td class="fielddoc"><p>Supplied from VSS. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3e834e2e27b04dec90e019f89b540152a37f01afc069b0ee0f459d4e2b0471bfb"></a>ADC_D_POSITIVE_VREF_VREFH0&#160;</td><td class="fielddoc"><p>Supplied from VREFH0. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3e834e2e27b04dec90e019f89b540152ad75d07d8b97f7520ccbd3b71475d08f6"></a>ADC_D_POSITIVE_VREF_IVREF&#160;</td><td class="fielddoc"><p>Supplied from the internal reference voltage. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gabcf84f30b3ecb3bd5b4109d048953c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcf84f30b3ecb3bd5b4109d048953c2d">&#9670;&nbsp;</a></span>R_ADC_D_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_D_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#structadc__cfg__t">adc_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the ADC_D peripheral. If interrupt is enabled, the function registers a callback function for notifying the user when a scan has completed. Implements <a class="el" href="group___a_d_c___a_p_i.html#afa184c06541e3fd9f90fc12ed775f468">adc_api_t::open</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Module is ready for use. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>The instance control structure has already been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_IRQ_BSP_DISABLED</td><td>A callback is provided, but the interrupt is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_HW_CONDITION</td><td>Invalid configuration corresponds to condition HardWare UM. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacb9e82774f821dda5422f5b1111535a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb9e82774f821dda5422f5b1111535a8">&#9670;&nbsp;</a></span>R_ADC_D_ScanCfg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_D_ScanCfg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>p_channel_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the ADC_D scan parameters. Channel specific settings are set in this function. Pass a pointer to <a class="el" href="group___a_d_c___d.html#structadc__d__channel__cfg__t">adc_d_channel_cfg_t</a> to p_channel_cfg.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Channel specific settings applied. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_HW_CONDITION</td><td>Invalid configuration corresponds to condition HardWare UM. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_STATE</td><td>Invalid Scan Configuration. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_CHANNEL</td><td>Channel is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga84fb8166f49f9bc71386b780bd77a807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84fb8166f49f9bc71386b780bd77a807">&#9670;&nbsp;</a></span>R_ADC_D_CallbackSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_D_CallbackSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="group___a_d_c___a_p_i.html#structadc__callback__args__t">adc_callback_args_t</a> *)&#160;</td>
          <td class="paramname"><em>p_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>p_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#structadc__callback__args__t">adc_callback_args_t</a> *const&#160;</td>
          <td class="paramname"><em>p_callback_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the user callback and has option of providing memory for callback structure. Implements <a class="el" href="group___a_d_c___a_p_i.html#a2cd8e8911dcf8c4c617fe62f185b4363">adc_api_t::callbackSet</a></p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Callback updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8b056e257147d939fcd82b3f7266ba8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b056e257147d939fcd82b3f7266ba8a">&#9670;&nbsp;</a></span>R_ADC_D_ScanStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_D_ScanStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts a software trigger scan or enables the hardware trigger mode for a scan depending on how the triggers were configured in the R_ADC_D_Open call. If the unit was configured for ELC or interrupt hardware triggering, then this function allows the trigger signal to get to the ADC_D. The function is not able to control the generation of the trigger itself.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Call R_ADC_D_ScanCfg after R_ADC_D_Open before starting a scan.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Scan started (software trigger) or hardware trigger mode enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>ADC_D is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_INITIALIZED</td><td>ADC_D is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga534ed105e6046f8e47f99dfc5c40d5f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga534ed105e6046f8e47f99dfc5c40d5f0">&#9670;&nbsp;</a></span>R_ADC_D_ScanGroupStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_D_ScanGroupStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaee17c30275c1c9376cc485a62ea121eb">adc_group_mask_t</a>&#160;</td>
          <td class="paramname"><em>group_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group___a_d_c___a_p_i.html#a2f9e091ca57ca2c58262f66ab5c341c9">adc_api_t::scanStart</a> is not supported on the ADC_D. Use scanStart instead.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Function not supported in this implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gada44bc8541282d5caee01f0471526c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada44bc8541282d5caee01f0471526c3b">&#9670;&nbsp;</a></span>R_ADC_D_ScanStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_D_ScanStop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables the hardware trigger for a scan or select mode and immediately stops converters. This function will abort conversions.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Scan stopped (software trigger) or hardware triggers disabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_INITIALIZED</td><td>Unit is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1c8a6279c4a0c5dfcc42a4829e95b10c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c8a6279c4a0c5dfcc42a4829e95b10c">&#9670;&nbsp;</a></span>R_ADC_D_StatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_D_StatusGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#structadc__status__t">adc_status_t</a> *&#160;</td>
          <td class="paramname"><em>p_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides the status of any scan process that was started, including scans started by ELC or interrupts triggers.</p>
<dl class="section note"><dt>Note</dt><dd>In Hardware no-wait mode, ADCS retains the value 1 after conversion end.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Module status stored in the provided pointer p_status. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>ADC_D is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabe550c0b1e8300616f083724fa00f3ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe550c0b1e8300616f083724fa00f3ae">&#9670;&nbsp;</a></span>R_ADC_D_Read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_D_Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const&#160;</td>
          <td class="paramname"><em>reg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *const&#160;</td>
          <td class="paramname"><em>p_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads conversion results from a channel or sensor.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Data read into provided p_data. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_INITIALIZED</td><td>Unit is not initialized. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>Invalid configuration for channel_mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga74b122f73a880d0dbfbdcf7fc8a4d2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74b122f73a880d0dbfbdcf7fc8a4d2bf">&#9670;&nbsp;</a></span>R_ADC_D_Read32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_D_Read32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const&#160;</td>
          <td class="paramname"><em>reg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *const&#160;</td>
          <td class="paramname"><em>p_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads conversion results from a select/scan channel or sensor register into a 32-bit result.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Data read into provided p_data. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>ADC_D is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_INITIALIZED</td><td>ADC_D is not initialized. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>Invalid configuration for channel_mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3bd75c0fb2ab39e9e9e0dde1a56b0842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bd75c0fb2ab39e9e9e0dde1a56b0842">&#9670;&nbsp;</a></span>R_ADC_D_InfoGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_D_InfoGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#structadc__info__t">adc_info_t</a> *&#160;</td>
          <td class="paramname"><em>p_adc_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get information of address ADCR to reading the data, determine the size of data that must be read, size data of each transfer, name of the ELC event for the peripheral, name of the peripheral in the ELC list</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Information stored in p_adc_info. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>ADC_D is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_INITIALIZED</td><td>ADC_D is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4771ec4946dc6129779073a0eb3c1538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4771ec4946dc6129779073a0eb3c1538">&#9670;&nbsp;</a></span>R_ADC_D_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_D_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function ends any scan or select mode in progress, disables interrupts, and removes power to the A/D peripheral.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Module closed. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>ADC_D is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga617a3754d1bed4882006a68ea8631738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga617a3754d1bed4882006a68ea8631738">&#9670;&nbsp;</a></span>R_ADC_D_Calibrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_D_Calibrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>p_extend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group___a_d_c___a_p_i.html#a1020d90e58d3bf86cee2f46a62e62fc4">adc_api_t::calibrate</a> is not supported on the ADC_D.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Function not supported in this implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5b22e051ef50adc65a1f834b38959da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b22e051ef50adc65a1f834b38959da7">&#9670;&nbsp;</a></span>R_ADC_D_OffsetSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_D_OffsetSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const&#160;</td>
          <td class="paramname"><em>reg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group___a_d_c___a_p_i.html#a305b2c2466cd88fdddf6134db542dc7e">adc_api_t::offsetSet</a> is not supported on the ADC_D.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Function not supported in this implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga703c793c94c5c753cda165e2c04651e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga703c793c94c5c753cda165e2c04651e3">&#9670;&nbsp;</a></span>R_ADC_D_SnoozeModePrepare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_D_SnoozeModePrepare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepare ADC_D to enter snooze mode via a hardware trigger. This function must be called immediately before entering software standby mode in order to allow the configured hardware trigger to transition the MCU from software standby mode to snooze mode and perform an ADC conversion.</p>
<p>Supported modes for requesting snooze mode via hardware trigger:</p><ul>
<li>channel_mode = ADC_D_CHANNEL_MODE_SELECT, conversion_operation = ADC_D_CONVERSION_MODE_ONESHOT</li>
<li>channel_mode = ADC_D_CHANNEL_MODE_SCAN, conversion_operation = ADC_D_CONVERSION_MODE_ONESHOT</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_ctrl</td><td>Pointer to the ADC control block</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The R_ADC_D_ScanStart must be called in advance.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>ADC is configured to request Snooze mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>ADC_D is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>ADC is in an invalid mode for requesting Snooze mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga555cc0346624e178f52fc9f864435d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga555cc0346624e178f52fc9f864435d2a">&#9670;&nbsp;</a></span>R_ADC_D_SnoozeModeExit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_D_SnoozeModeExit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>After exiting snooze mode, if the ADC_D module was in snooze mode, then this function must be called in order to restore ADC operation to normal mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_ctrl</td><td>Pointer to the ADC control block</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>ADC is configured to request Snooze mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>ADC is in an invalid mode for requesting Snooze mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v5.8.0 User's Manual Copyright  (2025) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
