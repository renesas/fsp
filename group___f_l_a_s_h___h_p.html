<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: Flash (r_flash_hp)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
    $(document).ready(function() {
        $("tr.tree_lvl_1").nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
		$("tr.tree_lvl_1").data("expanded","0");
		$("tr.tree_lvl_2").data("expanded","0");
		$("tr.tree_lvl_3").data("expanded","0");
		$("tr.tree_lvl_4").data("expanded","0");
		$("tr.tree_lvl_5").data("expanded","0");
        $("tr.tree_lvl_1").click(function() {
		    var lvl_1_is_open = $(this).data("expanded");
		    if (lvl_1_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2, tr.tree_lvl_1_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_2").click(function() {
		    var lvl_2_is_open = $(this).data("expanded");
		    if (lvl_2_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3, tr.tree_lvl_2_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_3").click(function() {
		    var lvl_3_is_open = $(this).data("expanded");
		    if (lvl_3_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_3_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_4").click(function() {
		    var lvl_4_is_open = $(this).data("expanded");
		    if (lvl_4_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5, tr.tree_lvl_4_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_5").click(function() {
		    var lvl_5_is_open = $(this).data("expanded");
		    if (lvl_5_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4_item,tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
     });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v6.3.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">

    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text">
      </span>
      <span class="right">
          &nbsp;
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___f_l_a_s_h___h_p.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body.
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len));
            }
          }
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element.
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">Flash (r_flash_hp)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___s_t_o_r_a_g_e___m_o_d_u_l_e_s.html">Storage</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3c593b353cc97d311fb599142b05dc65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#ga3c593b353cc97d311fb599142b05dc65">R_FLASH_HP_Open</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___f_l_a_s_h___a_p_i.html#structflash__cfg__t">flash_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:ga3c593b353cc97d311fb599142b05dc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf516a8b528062a3a47bc35f419879237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#gaf516a8b528062a3a47bc35f419879237">R_FLASH_HP_Write</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, uint32_t const src_address, uint32_t flash_address, uint32_t const num_bytes)</td></tr>
<tr class="separator:gaf516a8b528062a3a47bc35f419879237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa862e982d6e602726ad908e76b7227ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#gaa862e982d6e602726ad908e76b7227ab">R_FLASH_HP_Erase</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, uint32_t const address, uint32_t const num_blocks)</td></tr>
<tr class="separator:gaa862e982d6e602726ad908e76b7227ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad63cb14b8c81fc68b91033a503d1a871"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#gad63cb14b8c81fc68b91033a503d1a871">R_FLASH_HP_BlankCheck</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, uint32_t const address, uint32_t num_bytes, <a class="el" href="group___f_l_a_s_h___a_p_i.html#ga79d0373f9f1ae1d8bd99c40edb44a5b6">flash_result_t</a> *p_blank_check_result)</td></tr>
<tr class="separator:gad63cb14b8c81fc68b91033a503d1a871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68025e44839e70c533b8e5bd325fc64a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#ga68025e44839e70c533b8e5bd325fc64a">R_FLASH_HP_StatusGet</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___f_l_a_s_h___a_p_i.html#gab551389322a209cca1dcc1a7b2440f7a">flash_status_t</a> *const p_status)</td></tr>
<tr class="separator:ga68025e44839e70c533b8e5bd325fc64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05d2e2d0290e251b34355aa1395dd3a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#ga05d2e2d0290e251b34355aa1395dd3a0">R_FLASH_HP_IdCodeSet</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, uint8_t const *const p_id_code, <a class="el" href="group___f_l_a_s_h___a_p_i.html#ga5879fbdf1d24018416c1c7ccf448b64f">flash_id_code_mode_t</a> mode)</td></tr>
<tr class="separator:ga05d2e2d0290e251b34355aa1395dd3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27c1c44f16fac40b8258696a88929f80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#ga27c1c44f16fac40b8258696a88929f80">R_FLASH_HP_AccessWindowSet</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, uint32_t const start_addr, uint32_t const end_addr)</td></tr>
<tr class="separator:ga27c1c44f16fac40b8258696a88929f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d274fe4ee10e0aba086d6dd2baad8a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#ga0d274fe4ee10e0aba086d6dd2baad8a9">R_FLASH_HP_AccessWindowClear</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:ga0d274fe4ee10e0aba086d6dd2baad8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e269255ca9448da5d7b0a745992f6de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#ga4e269255ca9448da5d7b0a745992f6de">R_FLASH_HP_Reset</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:ga4e269255ca9448da5d7b0a745992f6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95b5a01a9c462a38f52397315a346a3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#ga95b5a01a9c462a38f52397315a346a3e">R_FLASH_HP_StartUpAreaSelect</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___f_l_a_s_h___a_p_i.html#gac8629165c2d649fbbf8c9854c3c7d20b">flash_startup_area_swap_t</a> swap_type, bool is_temporary)</td></tr>
<tr class="separator:ga95b5a01a9c462a38f52397315a346a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae72b7f170f44f6fe6cde5f32b5b165a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#gae72b7f170f44f6fe6cde5f32b5b165a3">R_FLASH_HP_BankSwap</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:gae72b7f170f44f6fe6cde5f32b5b165a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad766079d801d722527eb6834fc662e8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#gad766079d801d722527eb6834fc662e8a">R_FLASH_HP_UpdateFlashClockFreq</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:gad766079d801d722527eb6834fc662e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3335f3f8b174db9b86b3773993f341c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#ga3335f3f8b174db9b86b3773993f341c6">R_FLASH_HP_InfoGet</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___f_l_a_s_h___a_p_i.html#structflash__info__t">flash_info_t</a> *const p_info)</td></tr>
<tr class="separator:ga3335f3f8b174db9b86b3773993f341c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga979f52ddca85b3fef0c42d1b857893e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#ga979f52ddca85b3fef0c42d1b857893e7">R_FLASH_HP_Close</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:ga979f52ddca85b3fef0c42d1b857893e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d82c8ae07f0987dfe4dca51703e4eb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#ga3d82c8ae07f0987dfe4dca51703e4eb0">R_FLASH_HP_CallbackSet</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, void(*p_callback)(<a class="el" href="group___f_l_a_s_h___a_p_i.html#structflash__callback__args__t">flash_callback_args_t</a> *), void *const p_context, <a class="el" href="group___f_l_a_s_h___a_p_i.html#structflash__callback__args__t">flash_callback_args_t</a> *const p_callback_memory)</td></tr>
<tr class="separator:ga3d82c8ae07f0987dfe4dca51703e4eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae132f1850e9fa25b77c9f61418d415c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#gae132f1850e9fa25b77c9f61418d415c5">R_FLASH_HP_AntiRollbackCounterIncrement</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___f_l_a_s_h___a_p_i.html#ga83b0266a3edcc6c865f79a3d04785c21">flash_arc_t</a> counter)</td></tr>
<tr class="separator:gae132f1850e9fa25b77c9f61418d415c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36fc3d9dff4fa49aa3eb3f2b5512bba7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#ga36fc3d9dff4fa49aa3eb3f2b5512bba7">R_FLASH_HP_AntiRollbackCounterRefresh</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___f_l_a_s_h___a_p_i.html#ga83b0266a3edcc6c865f79a3d04785c21">flash_arc_t</a> counter)</td></tr>
<tr class="separator:ga36fc3d9dff4fa49aa3eb3f2b5512bba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c09ac07f12fdc6a16427a6e9413e798"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#ga7c09ac07f12fdc6a16427a6e9413e798">R_FLASH_HP_AntiRollbackCounterRead</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___f_l_a_s_h___a_p_i.html#ga83b0266a3edcc6c865f79a3d04785c21">flash_arc_t</a> counter, uint32_t *const p_count)</td></tr>
<tr class="separator:ga7c09ac07f12fdc6a16427a6e9413e798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4221ad70c3c8812487ab247e80277d2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#ga4221ad70c3c8812487ab247e80277d2c">R_FLASH_HP_UserLockableAreaWrite</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, uint32_t const src_address, uint32_t flash_address, uint32_t const num_bytes)</td></tr>
<tr class="separator:ga4221ad70c3c8812487ab247e80277d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the flash memory on RA high-performance MCUs. This module implements the <a class="el" href="group___f_l_a_s_h___a_p_i.html">Flash Interface</a>. </p>
<h1><a class="anchor" id="r-flash-hp-overview"></a>
Overview</h1>
<p>The Flash HAL module APIs allow an application to write, erase and blank check both the data and ROM flash areas that reside within the MCU. The amount of flash memory available varies across MCU parts.</p>
<h2><a class="anchor" id="r-flash-hp-features"></a>
Features</h2>
<p>The R_FLASH_HP module has the following key features:</p>
<ul>
<li>Blocking and non-blocking erasing, writing and blank-checking of data flash.<a class="anchor" id="um_flash_data_flash_blank_check_non_blocking"></a><a class="anchor" id="um_flash_data_flash_erase_non_blocking"></a><a class="anchor" id="um_flash_data_flash_write_non_blocking"></a></li>
<li>Blocking erasing, writing and blank-checking of code flash.</li>
<li>Callback functions for completion of non-blocking data flash operations.</li>
<li>Access window (write protection) for ROM Flash, allowing only specified areas of code flash to be erased or written.</li>
<li>Boot block-swapping.</li>
<li>ID code programming support.</li>
<li>Anti-rollback counter support (select MCUs).<a class="anchor" id="um_flash_anti_rollback_counter_read"></a><a class="anchor" id="um_flash_anti_rollback_counter_refresh"></a><a class="anchor" id="um_flash_anti_rollback_counter_increment"></a></li>
<li>Blocking writing of user lockable data flash option setting memory area (select MCUs).<a class="anchor" id="um_flash_user_lockable_area_write"></a> </li>
</ul>
<h1><a class="anchor" id="r-flash-hp-configuration"></a>
Configuration</h1>
<p><h2>Build Time Configurations for r_flash_hp</h2>
The following build time configurations are defined in fsp_cfg/r_flash_hp_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr class="tree_none">
<td>Code Flash Programming Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Controls whether or not code-flash programming is enabled. Disabling reduces the amount of ROM and RAM used by the API. </td></tr>
<tr class="tree_none">
<td>Data Flash Programming Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>Controls whether or not data-flash programming is enabled. Disabling reduces the amount of ROM used by the API. </td></tr>
</table>
 <h2>Configurations for Storage &gt; Flash (r_flash_hp)</h2>
This module can be added to the Stacks tab via New Stack &gt; Storage &gt; Flash (r_flash_hp). Non-secure callable guard functions can be generated for this module by right clicking the module in the RA Configuration tool and checking the "Non-secure Callable" box.<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Name</td><td>Name must be a valid C symbol</td><td>g_flash0 </td><td>Module name. </td></tr>
<tr class="tree_none">
<td>Data Flash Background Operation</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>Enabling allows Flash API calls that reference data-flash to return immediately, with the operation continuing in the background. </td></tr>
<tr class="tree_none">
<td>Callback</td><td>Name must be a valid C symbol</td><td>NULL </td><td>A user callback function can be specified. Callback function called when a Data Flash Background Operation completes or errors. </td></tr>
<tr class="tree_none">
<td>Flash Ready Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select the flash ready interrupt priority. </td></tr>
<tr class="tree_none">
<td>Flash Error Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select the flash error interrupt priority. </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-flash-hp-clock-configuration"></a>
Clock Configuration</h2>
<p>Flash uses FCLK as the clock source depending on the MCU. When writing and erasing the clock source must be at least 4 MHz.</p>
<h2><a class="anchor" id="r-flash-hp-pin-configuration"></a>
Pin Configuration</h2>
<p>This module does not use I/O pins.</p>
<h1><a class="anchor" id="r-flash-hp-usage_notes"></a>
Usage Notes</h1>
<dl class="section warning"><dt>Warning</dt><dd>It is highly recommended that the developer reviews sections 5 and 6 of the Flash Memory section of the target MCUs Hardware Userâ€™s Manual prior to using the r_flash_hp module. In particular, understanding ID Code and Access Window functionality can help avoid unrecoverable flash scenarios.</dd></dl>
<h2><a class="anchor" id="r-flash-hp-data-precautions"></a>
Data Flash Background Operation (BGO) Precautions</h2>
<p>When using the data flash BGO (Background Operation) mode, you can still access the user ROM, RAM and external memory. You must ensure that the data flash is not accessed during a data flash operation. This includes interrupts that may access the data flash.</p>
<p>Data flash BGO is not supported during anti-rollback counter operations or writes to the user lockable area.</p>
<h2><a class="anchor" id="r-flash-hp-code-precautions"></a>
Code Flash Precautions</h2>
<p>Code flash cannot be accessed while writing, erasing or blank checking code flash. Code flash cannot be accessed while modifying the access window, selecting the startup area or setting the ID code. In order to support modifying code flash all supporting code must reside in RAM. This is only done when code flash programming is enabled. BGO mode is not supported for code flash, so a code flash operation will not return before the operation has completed. By default, the vector table resides in the code flash. If an interrupt occurs during the code flash operation, then code flash will be accessed to fetch the interrupt's starting address and an error will occur. The simplest work-around is to disable interrupts during code flash operations. Another option is to copy the vector table to RAM, update the VTOR (Vector Table Offset Register) accordingly and ensure that any interrupt service routines execute out of RAM. Similarly, you must insure that if in a multi-threaded environment, threads running from code flash cannot become active while a code flash operation is in progress.</p>
<h2><a class="anchor" id="r-flash-hp-flash-clock"></a>
Flash Clock (FCLK)</h2>
<p><a class="anchor" id="um_flash_fclk_frequency_change"></a>The flash clock source is the clock used by the Flash peripheral in performing all Flash operations. As part of the <a class="el" href="group___f_l_a_s_h___a_p_i.html#a8166d0d1e4f3a59b8bf7f9e89fef9e44">flash_api_t::open</a> function the Flash clock source is checked will return FSP_ERR_FCLK if it is invalid. Once the Flash API has been opened, if the flash clock source frequency is changed, the <a class="el" href="group___f_l_a_s_h___a_p_i.html#ae357c91afece41b956ece618eb82c1a1">flash_api_t::updateFlashClockFreq</a> API function must be called to inform the API of the change. Failure to do so could result in flash operation failures and possibly damage the part.</p>
<h2><a class="anchor" id="r-flash-hp-anti-rollback-counters"></a>
Anti Rollback Counter</h2>
<p>Anti-rollback counters are available on select MCUs and can be used to prevent or limit firmware downgrade. The counters can only be incremented and never decremented or reset, even with an external programming tool.</p>
<dl class="section note"><dt>Note</dt><dd><b>The OEM bootloader anti-rollback counter is protected by the security engine and cannot be incremented past the version number specified in the code certificate. This counter works with the First Stage Bootloader (FSBL) set to enabled. For more information, read the 'Secure Boot' section in the 'Security Features' chapter of the user manual of the target MCU and refer to Application Note R11AN0774.</b></dd></dl>
<h3>Anti-Rollback Counter Configuration Setting</h3>
<p>When anti-rollback counters are used for one or more non-secure applications, the Anti-Rollback Counter Configuration Setting for ARC_NSEC (ARCCS) must be configured as either a single line (1xn bits) or multi-line counter (mxn bits). Single line is suitable when there is only one non-secure application using the anti-rollback counter. Multi-line is suitable when there are multiple non-secure applications. Before the counter is configured, it can't be used.</p>
<p>This configuration setting is permanent and must be performed with an external programming tool such as Renesas Flash Programmer (RFP). It cannot be configured in e2 studio.</p>
<p>The secure application and OEM bootloader anti-rollback counters do not require any initial configuration.</p>
<h3>Anti-Rollback Counter Lock Setting</h3>
<p>Select MCUs have the ability to permanently lock the anti-rollback counters using the Anti-Rollback Counter Lock Setting (ARCLS). It cannot be set with e2 studio, but if needed, it can be configured with an external programming tool such as Renesas Flash Programmer (RFP). <b>Once the lock protection is applied to a counter, the counter value can never be incremented again.</b> It is still possible to read the value of a locked counter.</p>
<h3>Anti-Rollback Counter Recovery from Power Loss or other Counter Increment Error</h3>
<p>If an error is returned by <a class="el" href="group___f_l_a_s_h___h_p.html#gae132f1850e9fa25b77c9f61418d415c5">R_FLASH_HP_AntiRollbackCounterIncrement</a> or power loss occurs during increment command processing, a successful call to <a class="el" href="group___f_l_a_s_h___h_p.html#ga36fc3d9dff4fa49aa3eb3f2b5512bba7">R_FLASH_HP_AntiRollbackCounterRefresh</a> is required before reading or incrementing the counter again. Otherwise, the counter flash may be in an invalid state.</p>
<h2>User Lockable Area</h2>
<p>The user lockable area of the data flash configuration area neither requires nor supports erase before rewriting.</p>
<p>Locked sections of the user lockable area cannot be rewritten.</p>
<p>If lockable area is available on the MCU, start address, end address, and write size can be read at runtime in the second element of the data flash block information array (<code>p_info-&gt;data_flash.p_block_array[1]</code>) returned by <a class="el" href="group___f_l_a_s_h___h_p.html#ga3335f3f8b174db9b86b3773993f341c6">R_FLASH_HP_InfoGet</a>.</p>
<h2><a class="anchor" id="r-flash-hp-interrupts"></a>
Interrupts</h2>
<p><a class="anchor" id="um_flash_data_flash_bgo_callbacks"></a><a class="anchor" id="um_flash_tz_callback"></a>Enable the flash ready interrupt only if you plan to use the data flash BGO. In this mode, the application can initiate a data flash operation and then be asynchronously notified of its completion, or an error, using a user supplied-callback function. The callback function is passed a structure containing event information that indicates the source of the callback event (for example, <a class="el" href="group___f_l_a_s_h___a_p_i.html#gga44753f7d426ae0121c94a307a95314a5a47cf4f3983c35ca46fcfabeb1903e068">flash_api_t::FLASH_EVENT_ERASE_COMPLETE</a>) When the FLASH FRDYI interrupt is enabled, the corresponding ISR will be defined in the flash driver. The ISR will call a user-callback function if one was registered with the <a class="el" href="group___f_l_a_s_h___a_p_i.html#a8166d0d1e4f3a59b8bf7f9e89fef9e44">flash_api_t::open</a> API. </p><dl class="section note"><dt>Note</dt><dd>The Flash HP supports an additional flash-error interrupt and if the BGO mode is enabled for the FLASH HP then both the Flash Ready Interrupt and Flash Error Interrupts must be enabled (assigned a priority).</dd></dl>
<h2><a class="anchor" id="r-flash-hp-e2studio-caching"></a>
Viewing flash contents in e2 studio</h2>
<p>By default, the contents of data flash and code flash are cached by e<sup>2</sup> studio. This means that during a debug session, modifications to these memory regions will not be observed by e<sup>2</sup> studio. When debugging applications using e<sup>2</sup> studio, disable the "Allow caching of flash contents" option in the debug configuration in order to view modified flash contents (Debug Configuration &gt; Debugger &gt; Debug Tool Settings &gt; Allow caching of flash contents).</p>
<div class="image">
<img src="r_flash_hp_disable_caching.png" alt="r_flash_hp_disable_caching.png"/>
<div class="caption">
Debug Configuration</div></div>
 <h2><a class="anchor" id="r-flash-hp-limitations"></a>
Limitations</h2>
<ul>
<li>Write operations must be aligned on page boundaries and must be a multiple of the page boundary size.</li>
<li>Erase operations will erase the entire block the provided address resides in.</li>
<li>Data flash is better suited for storing data as it can be erased and written to while code is still executing from code flash. Data flash is also guaranteed for a larger number of reprogramming/erasure cycles than code flash.</li>
<li>Read values of erased data flash blocks are not guaranteed to be 0xFF. Blank check should be used to determine if memory has been erased but not yet programmed.</li>
<li>Runtime locking of the user lockable area is not currently supported. The area can be locked by an external programming tool. Do not write to locked areas of user lockable area.</li>
</ul>
<h1><a class="anchor" id="r-flash-hp-examples"></a>
Examples</h1>
<h2>High-Performance Flash Basic Example</h2>
<p>This is a basic example of erasing and writing to data flash and code flash.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FLASH_DF_BLOCK_0               0x40100000U </span><span class="comment">/*   64 B:  0x40100000 - 0x4010003F */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">#define FLASH_CF_BLOCK_8               0x00010000  </span><span class="comment">/*   32 KB: 0x00010000 - 0x00017FFF */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">#define FLASH_DATA_BLOCK_SIZE          (1024)</span></div><div class="line"><span class="preprocessor">#define FLASH_HP_EXAMPLE_WRITE_SIZE    32</span></div><div class="line"></div><div class="line">uint8_t        g_dest[TRANSFER_LENGTH];</div><div class="line">uint8_t        g_src[TRANSFER_LENGTH];</div><div class="line"><a class="code" href="group___f_l_a_s_h___a_p_i.html#ga79d0373f9f1ae1d8bd99c40edb44a5b6">flash_result_t</a> blank_check_result;</div><div class="line"><span class="keywordtype">void</span> r_flash_hp_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Initialize p_src to known data */</span></div><div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; TRANSFER_LENGTH; i++)</div><div class="line">    {</div><div class="line">        g_src[i] = (uint8_t) (<span class="charliteral">&#39;A&#39;</span> + (i % 26));</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Open the flash hp instance. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___f_l_a_s_h___h_p.html#ga3c593b353cc97d311fb599142b05dc65">R_FLASH_HP_Open</a>(&amp;g_flash_ctrl, &amp;g_flash_cfg);</div><div class="line"></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Erase 1 block of data flash starting at block 0. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___h_p.html#gaa862e982d6e602726ad908e76b7227ab">R_FLASH_HP_Erase</a>(&amp;g_flash_ctrl, FLASH_DF_BLOCK_0, 1);</div><div class="line"></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Check if block 0 is erased. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___h_p.html#gad63cb14b8c81fc68b91033a503d1a871">R_FLASH_HP_BlankCheck</a>(&amp;g_flash_ctrl, FLASH_DF_BLOCK_0, FLASH_DATA_BLOCK_SIZE, &amp;blank_check_result);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Verify the previously erased area is blank */</span></div><div class="line">    assert(<a class="code" href="group___f_l_a_s_h___a_p_i.html#gga79d0373f9f1ae1d8bd99c40edb44a5b6ac8b28b541918a1275dc3ea21e0b1d028">FLASH_RESULT_BLANK</a> == blank_check_result);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Write 32 bytes to the first block of data flash. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___h_p.html#gaf516a8b528062a3a47bc35f419879237">R_FLASH_HP_Write</a>(&amp;g_flash_ctrl, (uint32_t) g_src, FLASH_DF_BLOCK_0, FLASH_HP_EXAMPLE_WRITE_SIZE);</div><div class="line"></div><div class="line"></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    assert(0 == memcmp(g_src, (uint8_t *) FLASH_DF_BLOCK_0, FLASH_HP_EXAMPLE_WRITE_SIZE));</div><div class="line"></div><div class="line">    <span class="comment">/* Disable interrupts to prevent vector table access while code flash is in P/E mode. */</span></div><div class="line">    __disable_irq();</div><div class="line"></div><div class="line">    <span class="comment">/* Erase 1 block of code flash starting at block 10. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___h_p.html#gaa862e982d6e602726ad908e76b7227ab">R_FLASH_HP_Erase</a>(&amp;g_flash_ctrl, FLASH_CF_BLOCK_8, 1);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Write 32 bytes to the first block of data flash. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___h_p.html#gaf516a8b528062a3a47bc35f419879237">R_FLASH_HP_Write</a>(&amp;g_flash_ctrl, (uint32_t) g_src, FLASH_CF_BLOCK_8, FLASH_HP_EXAMPLE_WRITE_SIZE);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable interrupts after code flash operations are complete. */</span></div><div class="line">    __enable_irq();</div><div class="line"></div><div class="line">    assert(0 == memcmp(g_src, (uint8_t *) FLASH_CF_BLOCK_8, FLASH_HP_EXAMPLE_WRITE_SIZE));</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>High-Performance Flash Advanced Example</h2>
<p>This example demonstrates using BGO to do non-blocking operations on the data flash.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span>               interrupt_called;</div><div class="line"><a class="code" href="group___f_l_a_s_h___a_p_i.html#ga44753f7d426ae0121c94a307a95314a5">flash_event_t</a>      flash_event;</div><div class="line"><span class="keyword">static</span> <a class="code" href="group___f_l_a_s_h___a_p_i.html#structflash__cfg__t">flash_cfg_t</a> g_flash_bgo_example_cfg =</div><div class="line">{</div><div class="line">    .<a class="code" href="group___f_l_a_s_h___a_p_i.html#ac80ffd6402722097911dc6da638cd54d">p_callback</a>     = flash_callback,</div><div class="line">    .p_context      = 0,</div><div class="line">    .p_extend       = NULL,</div><div class="line">    .data_flash_bgo = <span class="keyword">true</span>,            </div><div class="line">    .ipl            = 5,</div><div class="line">    .irq            = BSP_VECTOR_FLASH_HP_FRDYI_ISR,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> r_flash_hp_bgo_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Initialize p_src to known data */</span></div><div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; TRANSFER_LENGTH; i++)</div><div class="line">    {</div><div class="line">        g_src[i] = (uint8_t) (<span class="charliteral">&#39;A&#39;</span> + (i % 26));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Open the flash hp instance. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___f_l_a_s_h___h_p.html#ga3c593b353cc97d311fb599142b05dc65">R_FLASH_HP_Open</a>(&amp;g_flash_ctrl, &amp;g_flash_bgo_example_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    interrupt_called = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Erase 1 block of data flash starting at block 0. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___h_p.html#gaa862e982d6e602726ad908e76b7227ab">R_FLASH_HP_Erase</a>(&amp;g_flash_ctrl, FLASH_DF_BLOCK_0, 1);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (!interrupt_called)</div><div class="line">    {</div><div class="line">        ;</div><div class="line">    }</div><div class="line"></div><div class="line">    assert(<a class="code" href="group___f_l_a_s_h___a_p_i.html#gga44753f7d426ae0121c94a307a95314a5a47cf4f3983c35ca46fcfabeb1903e068">FLASH_EVENT_ERASE_COMPLETE</a> == flash_event);</div><div class="line"></div><div class="line">    interrupt_called = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Write 32 bytes to the first block of data flash. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___h_p.html#gaf516a8b528062a3a47bc35f419879237">R_FLASH_HP_Write</a>(&amp;g_flash_ctrl, (uint32_t) g_src, FLASH_DF_BLOCK_0, FLASH_HP_EXAMPLE_WRITE_SIZE);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="group___f_l_a_s_h___a_p_i.html#gab551389322a209cca1dcc1a7b2440f7a">flash_status_t</a> status;</div><div class="line"></div><div class="line">    <span class="comment">/* Wait until the current flash operation completes. */</span></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        err = <a class="code" href="group___f_l_a_s_h___h_p.html#ga68025e44839e70c533b8e5bd325fc64a">R_FLASH_HP_StatusGet</a>(&amp;g_flash_ctrl, &amp;status);</div><div class="line">    } <span class="keywordflow">while</span> ((FSP_SUCCESS == err) &amp;&amp; (<a class="code" href="group___f_l_a_s_h___a_p_i.html#ggab551389322a209cca1dcc1a7b2440f7aa9f0e163a2cd4ec43acbe02344235882a">FLASH_STATUS_BUSY</a> == status));</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* If the interrupt wasn&#39;t called process the error. */</span></div><div class="line">    assert(interrupt_called);</div><div class="line"></div><div class="line">    <span class="comment">/* If the event wasn&#39;t a write complete process the error. */</span></div><div class="line">    assert(<a class="code" href="group___f_l_a_s_h___a_p_i.html#gga44753f7d426ae0121c94a307a95314a5a2a000e207e1a0db0f1a7c550599bb804">FLASH_EVENT_WRITE_COMPLETE</a> == flash_event);</div><div class="line"></div><div class="line">    <span class="comment">/* Verify the data was written correctly. */</span></div><div class="line">    assert(0 == memcmp(g_src, (uint8_t *) FLASH_DF_BLOCK_0, FLASH_HP_EXAMPLE_WRITE_SIZE));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> flash_callback (<a class="code" href="group___f_l_a_s_h___a_p_i.html#structflash__callback__args__t">flash_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    interrupt_called = <span class="keyword">true</span>;</div><div class="line">    flash_event      = p_args-&gt;<a class="code" href="group___f_l_a_s_h___a_p_i.html#a85ce087229ae1cb0076dfb4e38238d7e">event</a>;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>High-Performance Flash Bank Swap Example</h2>
<p>This example demonstrates swapping which flash bank is located at address 0. This feature is only on select MCUs.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> r_flash_hp_bankswap_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Open the flash hp instance. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___f_l_a_s_h___h_p.html#ga3c593b353cc97d311fb599142b05dc65">R_FLASH_HP_Open</a>(&amp;g_flash_ctrl, &amp;g_flash_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Write the new application starting at 0x00200000. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Swap the block at address 0 with the one at 0x00200000 after the next restart.</span></div><div class="line"><span class="comment">     * The application at 0x00200000 must be written there by application code. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___h_p.html#gae72b7f170f44f6fe6cde5f32b5b165a3">R_FLASH_HP_BankSwap</a>(&amp;g_flash_ctrl);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any pre-reset operations here */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Reset the MCU to swap to the other bank */</span></div><div class="line">    __NVIC_SystemReset();</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>High-Performance Anti-Rollback Counter Basic Example</h2>
<p>This example demonstrates basic usage of the anti-rollback counter functions.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> r_flash_hp_anti_rollback_counter_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Open the flash hp instance. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___f_l_a_s_h___h_p.html#ga3c593b353cc97d311fb599142b05dc65">R_FLASH_HP_Open</a>(&amp;g_flash_ctrl, &amp;g_flash_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    uint32_t current_count;</div><div class="line"></div><div class="line">    <span class="comment">/* Read the current counter value for the secure application */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___h_p.html#ga7c09ac07f12fdc6a16427a6e9413e798">R_FLASH_HP_AntiRollbackCounterRead</a>(&amp;g_flash_ctrl, <a class="code" href="group___f_l_a_s_h___a_p_i.html#gga83b0266a3edcc6c865f79a3d04785c21ad3e7b0a0fb8f3856e924021bff04cd3e">FLASH_ARC_SEC</a>, &amp;current_count);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Read the current counter value for the OEM bootloader */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___h_p.html#ga7c09ac07f12fdc6a16427a6e9413e798">R_FLASH_HP_AntiRollbackCounterRead</a>(&amp;g_flash_ctrl, <a class="code" href="group___f_l_a_s_h___a_p_i.html#gga83b0266a3edcc6c865f79a3d04785c21a7cc7171bf4d5525892452eb6dc9901fb">FLASH_ARC_OEMBL</a>, &amp;current_count);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Read the current counter value for the non-secure application if counter is configured as 1xn bits */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___h_p.html#ga7c09ac07f12fdc6a16427a6e9413e798">R_FLASH_HP_AntiRollbackCounterRead</a>(&amp;g_flash_ctrl, <a class="code" href="group___f_l_a_s_h___a_p_i.html#gga83b0266a3edcc6c865f79a3d04785c21ae3656fc3704a6f0ed1ce99086d2bf15a">FLASH_ARC_NSEC_0</a>, &amp;current_count);  <span class="comment">// NSEC App</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Read the current counter value for 4 non-secure applications if counter is configured as mxn bits */</span></div><div class="line">    err  = <a class="code" href="group___f_l_a_s_h___h_p.html#ga7c09ac07f12fdc6a16427a6e9413e798">R_FLASH_HP_AntiRollbackCounterRead</a>(&amp;g_flash_ctrl, <a class="code" href="group___f_l_a_s_h___a_p_i.html#gga83b0266a3edcc6c865f79a3d04785c21ae3656fc3704a6f0ed1ce99086d2bf15a">FLASH_ARC_NSEC_0</a>, &amp;current_count); <span class="comment">// NSEC App 0</span></div><div class="line">    err |= <a class="code" href="group___f_l_a_s_h___h_p.html#ga7c09ac07f12fdc6a16427a6e9413e798">R_FLASH_HP_AntiRollbackCounterRead</a>(&amp;g_flash_ctrl, <a class="code" href="group___f_l_a_s_h___a_p_i.html#gga83b0266a3edcc6c865f79a3d04785c21a034781b29bee3dfb73c84957259c37c8">FLASH_ARC_NSEC_1</a>, &amp;current_count); <span class="comment">// NSEC App 1</span></div><div class="line">    err |= <a class="code" href="group___f_l_a_s_h___h_p.html#ga7c09ac07f12fdc6a16427a6e9413e798">R_FLASH_HP_AntiRollbackCounterRead</a>(&amp;g_flash_ctrl, <a class="code" href="group___f_l_a_s_h___a_p_i.html#gga83b0266a3edcc6c865f79a3d04785c21a00d992daf7a6f08dac482f7ffc579f18">FLASH_ARC_NSEC_2</a>, &amp;current_count); <span class="comment">// NSEC App 2</span></div><div class="line">    err |= <a class="code" href="group___f_l_a_s_h___h_p.html#ga7c09ac07f12fdc6a16427a6e9413e798">R_FLASH_HP_AntiRollbackCounterRead</a>(&amp;g_flash_ctrl, <a class="code" href="group___f_l_a_s_h___a_p_i.html#gga83b0266a3edcc6c865f79a3d04785c21ae81af622dbcb602583ef2f894aa367ce">FLASH_ARC_NSEC_3</a>, &amp;current_count); <span class="comment">// NSEC App 3</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Increment the counter value for the secure application. Caution: The increment cannot be reversed. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___h_p.html#gae132f1850e9fa25b77c9f61418d415c5">R_FLASH_HP_AntiRollbackCounterIncrement</a>(&amp;g_flash_ctrl, <a class="code" href="group___f_l_a_s_h___a_p_i.html#gga83b0266a3edcc6c865f79a3d04785c21ad3e7b0a0fb8f3856e924021bff04cd3e">FLASH_ARC_SEC</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* If error occurred during increment, refresh the counter flash to ensure a valid state */</span></div><div class="line">    <span class="keywordflow">if</span> (FSP_SUCCESS != err)</div><div class="line">    {</div><div class="line">        err = <a class="code" href="group___f_l_a_s_h___h_p.html#ga36fc3d9dff4fa49aa3eb3f2b5512bba7">R_FLASH_HP_AntiRollbackCounterRefresh</a>(&amp;g_flash_ctrl, <a class="code" href="group___f_l_a_s_h___a_p_i.html#gga83b0266a3edcc6c865f79a3d04785c21ad3e7b0a0fb8f3856e924021bff04cd3e">FLASH_ARC_SEC</a>);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>High-Performance User Lockable Area Basic Example</h2>
<p>This example demonstrates writing the user lockable area.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> r_flash_hp_user_lockable_area_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Open the flash hp instance. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___f_l_a_s_h___h_p.html#ga3c593b353cc97d311fb599142b05dc65">R_FLASH_HP_Open</a>(&amp;g_flash_ctrl, &amp;g_flash_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <a class="code" href="group___f_l_a_s_h___a_p_i.html#structflash__info__t">flash_info_t</a> flash_info;</div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___h_p.html#ga3335f3f8b174db9b86b3773993f341c6">R_FLASH_HP_InfoGet</a>(&amp;g_flash_ctrl, &amp;flash_info);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">    assert(flash_info.<a class="code" href="group___f_l_a_s_h___a_p_i.html#ae432ac809721f8f0d46600bc9bfa2107">data_flash</a>.<a class="code" href="group___f_l_a_s_h___a_p_i.html#a4be46b2f7b0f62065e6f12391b2a2b78">num_regions</a> &gt;= 2);</div><div class="line">    <a class="code" href="group___f_l_a_s_h___a_p_i.html#structflash__block__info__t">flash_block_info_t</a> <span class="keyword">const</span> * <span class="keyword">const</span> p_user_area_info = &amp;flash_info.<a class="code" href="group___f_l_a_s_h___a_p_i.html#ae432ac809721f8f0d46600bc9bfa2107">data_flash</a>.<a class="code" href="group___f_l_a_s_h___a_p_i.html#a94feac5c040865357127821519e32cde">p_block_array</a>[1];</div><div class="line"></div><div class="line">    <span class="comment">/* Select initial value to write to the lockable area */</span></div><div class="line">    uint32_t update_complete_flag = 0;</div><div class="line"></div><div class="line">    <span class="comment">/* Set parameters for writing update_complete_flag to start of lockable area */</span></div><div class="line">    uint32_t <span class="keyword">const</span> flash_address    = p_user_area_info-&gt;<a class="code" href="group___f_l_a_s_h___a_p_i.html#a874db1fea2b0582b0a1edebc9f337565">block_section_st_addr</a>;</div><div class="line">    uint32_t <span class="keyword">const</span> write_size_bytes = <span class="keyword">sizeof</span>(update_complete_flag);</div><div class="line"></div><div class="line">    <span class="comment">/* Ensure write size is a multiple of the programming size */</span></div><div class="line">    uint32_t <span class="keyword">const</span> programming_size_bytes = p_user_area_info-&gt;<a class="code" href="group___f_l_a_s_h___a_p_i.html#a4a5aa29e90aae57e3caf8909597dba14">block_size_write</a>;</div><div class="line">    assert(write_size_bytes % programming_size_bytes == 0);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Write data to the beginning of User Lockable Area 0 */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___h_p.html#ga4221ad70c3c8812487ab247e80277d2c">R_FLASH_HP_UserLockableAreaWrite</a>(&amp;g_flash_ctrl,</div><div class="line">                                           (uint32_t) &amp;update_complete_flag,</div><div class="line">                                           flash_address,</div><div class="line">                                           write_size_bytes);</div><div class="line"></div><div class="line"></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Confirm the data was written */</span></div><div class="line">    assert(0 == memcmp(&amp;update_complete_flag, (uint8_t *) flash_address, write_size_bytes));</div><div class="line"></div><div class="line">    <span class="comment">/* Select new value to write to the lockable area */</span></div><div class="line">    update_complete_flag = 1;</div><div class="line"></div><div class="line">    <span class="comment">/* Write new data to the beginning of User Lockable Area 0 */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___h_p.html#ga4221ad70c3c8812487ab247e80277d2c">R_FLASH_HP_UserLockableAreaWrite</a>(&amp;g_flash_ctrl,</div><div class="line">                                           (uint32_t) &amp;update_complete_flag,</div><div class="line">                                           flash_address,</div><div class="line">                                           write_size_bytes);</div><div class="line"></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Confirm the data was written */</span></div><div class="line">    assert(0 == memcmp(&amp;update_complete_flag, (uint8_t *) flash_address, write_size_bytes));</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structflash__hp__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#structflash__hp__instance__ctrl__t">flash_hp_instance_ctrl_t</a></td></tr>
<tr class="separator:structflash__hp__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaf2df0780f6e32a857a43f00d2a34f5f6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#gaf2df0780f6e32a857a43f00d2a34f5f6">flash_bgo_operation_t</a> </td></tr>
<tr class="separator:gaf2df0780f6e32a857a43f00d2a34f5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structflash__hp__instance__ctrl__t" id="structflash__hp__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structflash__hp__instance__ctrl__t">&#9670;&nbsp;</a></span>flash_hp_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct flash_hp_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Flash HP instance control block. DO NOT INITIALIZE. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a0e9c6d859fd6f932e7d723c6c6a520e3"><td class="memItemLeft" align="right" valign="top"><a id="a0e9c6d859fd6f932e7d723c6c6a520e3"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#a0e9c6d859fd6f932e7d723c6c6a520e3">opened</a></td></tr>
<tr class="memdesc:a0e9c6d859fd6f932e7d723c6c6a520e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">To check whether api has been opened or not. <br /></td></tr>
<tr class="separator:a0e9c6d859fd6f932e7d723c6c6a520e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd09c39ddf5233ecdd713a14cdd4b4e"><td class="memItemLeft" align="right" valign="top"><a id="aecd09c39ddf5233ecdd713a14cdd4b4e"></a>
<a class="el" href="group___f_l_a_s_h___h_p.html#gaf2df0780f6e32a857a43f00d2a34f5f6">flash_bgo_operation_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#aecd09c39ddf5233ecdd713a14cdd4b4e">current_operation</a></td></tr>
<tr class="memdesc:aecd09c39ddf5233ecdd713a14cdd4b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation in progress, for example, FLASH_OPERATION_CF_ERASE. <br /></td></tr>
<tr class="separator:aecd09c39ddf5233ecdd713a14cdd4b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaf2df0780f6e32a857a43f00d2a34f5f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2df0780f6e32a857a43f00d2a34f5f6">&#9670;&nbsp;</a></span>flash_bgo_operation_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___f_l_a_s_h___h_p.html#gaf2df0780f6e32a857a43f00d2a34f5f6">flash_bgo_operation_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Possible Flash operation states </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga3c593b353cc97d311fb599142b05dc65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c593b353cc97d311fb599142b05dc65">&#9670;&nbsp;</a></span>R_FLASH_HP_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#structflash__cfg__t">flash_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the high performance flash peripheral. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#a8166d0d1e4f3a59b8bf7f9e89fef9e44">flash_api_t::open</a>.</p>
<p>The Open function initializes the Flash.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Open the flash hp instance. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___f_l_a_s_h___h_p.html#ga3c593b353cc97d311fb599142b05dc65">R_FLASH_HP_Open</a>(&amp;g_flash_ctrl, &amp;g_flash_cfg);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Initialization was successful and timer has started. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>The flash control block is already open. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl or p_cfg. </td></tr>
    <tr><td class="paramname">FSP_ERR_IRQ_BSP_DISABLED</td><td>Caller is requesting BGO but the Flash interrupts are not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_FCLK</td><td>FCLK must be a minimum of 4 MHz for Flash operations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf516a8b528062a3a47bc35f419879237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf516a8b528062a3a47bc35f419879237">&#9670;&nbsp;</a></span>R_FLASH_HP_Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>src_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flash_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>num_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes to the specified Code or Data Flash memory area. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#a01c35b7f1ad8a9bc3a932d4a05f2bcb6">flash_api_t::write</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Write 32 bytes to the first block of data flash. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___h_p.html#gaf516a8b528062a3a47bc35f419879237">R_FLASH_HP_Write</a>(&amp;g_flash_ctrl, (uint32_t) g_src, FLASH_DF_BLOCK_0, FLASH_HP_EXAMPLE_WRITE_SIZE);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Operation successful. If BGO is enabled this means the operation was started successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>The Flash peripheral is busy with a prior on-going transaction. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The Flash API is not Open. </td></tr>
    <tr><td class="paramname">FSP_ERR_CMD_LOCKED</td><td>FCU is in locked state, typically as a result of attempting to Write an area that is protected by an Access Window. </td></tr>
    <tr><td class="paramname">FSP_ERR_WRITE_FAILED</td><td>Status is indicating a Programming error for the requested operation. This may be returned if the requested Flash area is not blank. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timed out waiting for FCU operation to complete. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_SIZE</td><td>Number of bytes provided was not a multiple of the programming size or exceeded the maximum range. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ADDRESS</td><td>Invalid address was input or address not on programming boundary. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl. </td></tr>
    <tr><td class="paramname">FSP_ERR_PE_FAILURE</td><td>Failed to enter or exit P/E mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa862e982d6e602726ad908e76b7227ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa862e982d6e602726ad908e76b7227ab">&#9670;&nbsp;</a></span>R_FLASH_HP_Erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_Erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>num_blocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Erases the specified Code or Data Flash blocks. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#ac32a91bb4217997e2ca465463b644211">flash_api_t::erase</a> by the block_erase_address.</p>
<dl class="section note"><dt>Note</dt><dd>Code flash may contain blocks of different sizes. When erasing code flash it is important to take this into consideration to prevent erasing a larger address space than desired.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Erase 1 block of data flash starting at block 0. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___h_p.html#gaa862e982d6e602726ad908e76b7227ab">R_FLASH_HP_Erase</a>(&amp;g_flash_ctrl, FLASH_DF_BLOCK_0, 1);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful open. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_BLOCKS</td><td>Invalid number of blocks specified </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ADDRESS</td><td>Invalid address specified. If the address is in code flash then code flash programming must be enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>Other flash operation in progress, or API not initialized </td></tr>
    <tr><td class="paramname">FSP_ERR_CMD_LOCKED</td><td>FCU is in locked state, typically as a result of attempting to Erase an area that is protected by an Access Window. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The Flash API is not Open. </td></tr>
    <tr><td class="paramname">FSP_ERR_ERASE_FAILED</td><td>Status is indicating a Erase error. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timed out waiting for the FCU to become ready. </td></tr>
    <tr><td class="paramname">FSP_ERR_PE_FAILURE</td><td>Failed to enter or exit P/E mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad63cb14b8c81fc68b91033a503d1a871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad63cb14b8c81fc68b91033a503d1a871">&#9670;&nbsp;</a></span>R_FLASH_HP_BlankCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_BlankCheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#ga79d0373f9f1ae1d8bd99c40edb44a5b6">flash_result_t</a> *&#160;</td>
          <td class="paramname"><em>p_blank_check_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a blank check on the specified address area. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#a285a6f933817c94e26a5aa11c48a1b3c">flash_api_t::blankCheck</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Check if block 0 is erased. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___h_p.html#gad63cb14b8c81fc68b91033a503d1a871">R_FLASH_HP_BlankCheck</a>(&amp;g_flash_ctrl, FLASH_DF_BLOCK_0, FLASH_DATA_BLOCK_SIZE, &amp;blank_check_result);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Blank check operation completed with result in p_blank_check_result, or blank check started and in-progess (BGO mode). </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ADDRESS</td><td>Invalid data flash address was input. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_SIZE</td><td>'num_bytes' was either too large or not aligned for the CF/DF boundary size. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>Other flash operation in progress or API not initialized. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl. </td></tr>
    <tr><td class="paramname">FSP_ERR_CMD_LOCKED</td><td>FCU is in locked state, typically as a result of attempting to Erase an area that is protected by an Access Window. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The Flash API is not Open. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timed out waiting for the FCU to become ready. </td></tr>
    <tr><td class="paramname">FSP_ERR_PE_FAILURE</td><td>Failed to enter or exit P/E mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_BLANK_CHECK_FAILED</td><td>Blank check operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga68025e44839e70c533b8e5bd325fc64a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68025e44839e70c533b8e5bd325fc64a">&#9670;&nbsp;</a></span>R_FLASH_HP_StatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_StatusGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gab551389322a209cca1dcc1a7b2440f7a">flash_status_t</a> *const&#160;</td>
          <td class="paramname"><em>p_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the FLASH peripheral for its status. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#a5533acb74f21270a17a013d149c32a58">flash_api_t::statusGet</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <a class="code" href="group___f_l_a_s_h___a_p_i.html#gab551389322a209cca1dcc1a7b2440f7a">flash_status_t</a> status;</div><div class="line"></div><div class="line">    <span class="comment">/* Wait until the current flash operation completes. */</span></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        err = <a class="code" href="group___f_l_a_s_h___h_p.html#ga68025e44839e70c533b8e5bd325fc64a">R_FLASH_HP_StatusGet</a>(&amp;g_flash_ctrl, &amp;status);</div><div class="line">    } <span class="keywordflow">while</span> ((FSP_SUCCESS == err) &amp;&amp; (<a class="code" href="group___f_l_a_s_h___a_p_i.html#ggab551389322a209cca1dcc1a7b2440f7aa9f0e163a2cd4ec43acbe02344235882a">FLASH_STATUS_BUSY</a> == status));</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>FLASH peripheral is ready to use. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The Flash API is not Open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga05d2e2d0290e251b34355aa1395dd3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05d2e2d0290e251b34355aa1395dd3a0">&#9670;&nbsp;</a></span>R_FLASH_HP_IdCodeSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_IdCodeSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *const&#160;</td>
          <td class="paramname"><em>p_id_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#ga5879fbdf1d24018416c1c7ccf448b64f">flash_id_code_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#aa27024990278c87ac8ea489c400bab5e">flash_api_t::idCodeSet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>ID Code successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>FLASH peripheral is busy with a prior operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Code Flash Programming is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Flash API has not yet been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_PE_FAILURE</td><td>Failed to enter or exit Code Flash P/E mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timed out waiting for the FCU to become ready. </td></tr>
    <tr><td class="paramname">FSP_ERR_WRITE_FAILED</td><td>Status is indicating a Programming error for the requested operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_CMD_LOCKED</td><td>FCU is in locked state, typically as a result of having received an illegal command. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga27c1c44f16fac40b8258696a88929f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27c1c44f16fac40b8258696a88929f80">&#9670;&nbsp;</a></span>R_FLASH_HP_AccessWindowSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_AccessWindowSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>start_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>end_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure an access window for the Code Flash memory using the provided start and end address. An access window defines a contiguous area in Code Flash for which programming/erase is enabled. This area is on block boundaries. The block containing start_addr is the first block. The block containing end_addr is the last block. The access window then becomes first block &ndash;&gt; last block inclusive. Anything outside this range of Code Flash is then write protected. </p><dl class="section note"><dt>Note</dt><dd>If the start address and end address are set to the same value, then the access window is effectively removed. This accomplishes the same functionality as <a class="el" href="group___f_l_a_s_h___h_p.html#ga0d274fe4ee10e0aba086d6dd2baad8a9">R_FLASH_HP_AccessWindowClear()</a>.</dd></dl>
<p>Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#ab8f7f57d6c9b1d3a08281eee4edc0683">flash_api_t::accessWindowSet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Access window successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ADDRESS</td><td>Invalid settings for start_addr and/or end_addr. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>FLASH peripheral is busy with a prior operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Code Flash Programming is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Flash API has not yet been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_PE_FAILURE</td><td>Failed to enter or exit Code Flash P/E mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timed out waiting for the FCU to become ready. </td></tr>
    <tr><td class="paramname">FSP_ERR_WRITE_FAILED</td><td>Status is indicating a Programming error for the requested operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_CMD_LOCKED</td><td>FCU is in locked state, typically as a result of having received an illegal command. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0d274fe4ee10e0aba086d6dd2baad8a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d274fe4ee10e0aba086d6dd2baad8a9">&#9670;&nbsp;</a></span>R_FLASH_HP_AccessWindowClear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_AccessWindowClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove any access window that is currently configured in the Code Flash. Subsequent to this call all Code Flash is writable. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#a47d162b634f769385c2d39c4cbc6217b">flash_api_t::accessWindowClear</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Access window successfully removed. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>FLASH peripheral is busy with a prior operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Code Flash Programming is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Flash API has not yet been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_PE_FAILURE</td><td>Failed to enter or exit Code Flash P/E mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timed out waiting for the FCU to become ready. </td></tr>
    <tr><td class="paramname">FSP_ERR_WRITE_FAILED</td><td>Status is indicating a Programming error for the requested operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_CMD_LOCKED</td><td>FCU is in locked state, typically as a result of having received an illegal command. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4e269255ca9448da5d7b0a745992f6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e269255ca9448da5d7b0a745992f6de">&#9670;&nbsp;</a></span>R_FLASH_HP_Reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the FLASH peripheral. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#af87f6e3215253ad33a0c961c79979da0">flash_api_t::reset</a>.</p>
<p>No attempt is made to check if the flash is busy before executing the reset since the assumption is that a reset will terminate any existing operation.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Flash circuit successfully reset. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_PE_FAILURE</td><td>Failed to enter or exit P/E mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timed out waiting for the FCU to become ready. </td></tr>
    <tr><td class="paramname">FSP_ERR_CMD_LOCKED</td><td>FCU is in locked state, typically as a result of having received an illegal command. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga95b5a01a9c462a38f52397315a346a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95b5a01a9c462a38f52397315a346a3e">&#9670;&nbsp;</a></span>R_FLASH_HP_StartUpAreaSelect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_StartUpAreaSelect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac8629165c2d649fbbf8c9854c3c7d20b">flash_startup_area_swap_t</a>&#160;</td>
          <td class="paramname"><em>swap_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_temporary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Selects which block, Default (Block 0) or Alternate (Block 1), is used as the startup area block. The provided parameters determine which block will become the active startup block and whether that action will be immediate (but temporary), or permanent subsequent to the next reset. Doing a temporary switch might appear to have limited usefulness. If there is an access window in place such that Block 0 is write protected, then one could do a temporary switch, update the block and switch them back without having to touch the access window. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#af01c458da5ffbd29ee404ccc5e8e6869">flash_api_t::startupAreaSelect</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Start-up area successfully toggled. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>FLASH peripheral is busy with a prior operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Code Flash Programming is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_PE_FAILURE</td><td>Failed to enter or exit Code Flash P/E mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timed out waiting for the FCU to become ready. </td></tr>
    <tr><td class="paramname">FSP_ERR_WRITE_FAILED</td><td>Status is indicating a Programming error for the requested operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_CMD_LOCKED</td><td>FCU is in locked state, typically as a result of having received an illegal command. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae72b7f170f44f6fe6cde5f32b5b165a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae72b7f170f44f6fe6cde5f32b5b165a3">&#9670;&nbsp;</a></span>R_FLASH_HP_BankSwap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_BankSwap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swaps the flash bank located at address 0x00000000 and address 0x00200000. This can only be done when in dual bank mode. Dual bank mode can be enabled in the FSP Configuration Tool under BSP Properties. After a bank swap is done the MCU will need to be reset for the changes to take place. <a class="el" href="group___f_l_a_s_h___a_p_i.html#a27dd022e07eebb8750e1a1be7f80563f">flash_api_t::bankSwap</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Start-up area successfully toggled. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>FLASH peripheral is busy with a prior operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Code Flash Programming is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_PE_FAILURE</td><td>Failed to enter or exit Code Flash P/E mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timed out waiting for the FCU to become ready. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>Cannot switch banks while flash is in Linear mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_WRITE_FAILED</td><td>Flash write operation failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CMD_LOCKED</td><td>FCU is in locked state, typically as a result of having received an illegal command. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad766079d801d722527eb6834fc662e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad766079d801d722527eb6834fc662e8a">&#9670;&nbsp;</a></span>R_FLASH_HP_UpdateFlashClockFreq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_UpdateFlashClockFreq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicate to the already open Flash API that the FCLK has changed. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#ae357c91afece41b956ece618eb82c1a1">flash_api_t::updateFlashClockFreq</a>.</p>
<p>This could be the case if the application has changed the system clock, and therefore the FCLK. Failure to call this function subsequent to changing the FCLK could result in damage to the flash macro.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Start-up area successfully toggled. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>Flash is busy with an on-going operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Flash API has not yet been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_FCLK</td><td>FCLK is not within the acceptable range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3335f3f8b174db9b86b3773993f341c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3335f3f8b174db9b86b3773993f341c6">&#9670;&nbsp;</a></span>R_FLASH_HP_InfoGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_InfoGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#structflash__info__t">flash_info_t</a> *const&#160;</td>
          <td class="paramname"><em>p_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the information about the flash regions. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#aa1168146a81e1cbeab18848c110bf0a2">flash_api_t::infoGet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful retrieved the request information. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl or p_info. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga979f52ddca85b3fef0c42d1b857893e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga979f52ddca85b3fef0c42d1b857893e7">&#9670;&nbsp;</a></span>R_FLASH_HP_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases any resources that were allocated by the Open() or any subsequent Flash operations. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#a038ae85f83322bc1e71a8f3937b26c5d">flash_api_t::close</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful close. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl or p_cfg. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3d82c8ae07f0987dfe4dca51703e4eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d82c8ae07f0987dfe4dca51703e4eb0">&#9670;&nbsp;</a></span>R_FLASH_HP_CallbackSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_CallbackSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="group___f_l_a_s_h___a_p_i.html#structflash__callback__args__t">flash_callback_args_t</a> *)&#160;</td>
          <td class="paramname"><em>p_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>p_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#structflash__callback__args__t">flash_callback_args_t</a> *const&#160;</td>
          <td class="paramname"><em>p_callback_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the user callback with the option to provide memory for the callback argument structure. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#ad7f5d12c7a8d269de3d55ca91b29edb7">flash_api_t::callbackSet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Callback updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_NO_CALLBACK_MEMORY</td><td>p_callback is non-secure and p_callback_memory is either secure or NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae132f1850e9fa25b77c9f61418d415c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae132f1850e9fa25b77c9f61418d415c5">&#9670;&nbsp;</a></span>R_FLASH_HP_AntiRollbackCounterIncrement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_AntiRollbackCounterIncrement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#ga83b0266a3edcc6c865f79a3d04785c21">flash_arc_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increments the selected anti-rollback counter.</p>
<dl class="section warning"><dt>Warning</dt><dd>If this function returns an error code other than FSP_SUCCESS, or power loss occurs during a call to this function, call <a class="el" href="group___f_l_a_s_h___h_p.html#ga36fc3d9dff4fa49aa3eb3f2b5512bba7">R_FLASH_HP_AntiRollbackCounterRefresh</a> to ensure the counter flash is in a valid state following the error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The counter is read internally before increment.</dd></dl>
<p>Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#a04bcaaac166052c618406a22df055ad3">flash_api_t::antiRollbackCounterIncrement</a></p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Counter incremented successfully </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_api_ctrl </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_ENABLED</td><td>The specified counter has not been configured (configuration is only required for ARC_NSEC) </td></tr>
    <tr><td class="paramname">FSP_ERR_OVERFLOW</td><td>The counter cannot be incremented because it is already at its max value </td></tr>
    <tr><td class="paramname">FSP_ERR_PE_FAILURE</td><td>Failed to enter or exit Data Flash P/E mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timed out waiting for the FCU to become ready. </td></tr>
    <tr><td class="paramname">FSP_ERR_CMD_LOCKED</td><td>FCU is in locked state, typically as a result of having received an illegal command </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Data flash programming is not enabled or selected anti-rollback counter is not supported on this MCU </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga36fc3d9dff4fa49aa3eb3f2b5512bba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36fc3d9dff4fa49aa3eb3f2b5512bba7">&#9670;&nbsp;</a></span>R_FLASH_HP_AntiRollbackCounterRefresh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_AntiRollbackCounterRefresh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#ga83b0266a3edcc6c865f79a3d04785c21">flash_arc_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Refreshes the selected anti-rollback counter flash area to ensure the flash is in a valid state even if an error occurred during counter increment processing.</p>
<p>This function must be called if errors or power failure occurred during counter increment.</p>
<p>Power failure can be detected by the application code by management of user-defined non-voltile flags during counter increment.</p>
<p>Until a refresh completes successfully, the value of the anti-rollback counter cannot be guaranteed and should not be read.</p>
<p>Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#aff7182230c963d80fbb4708be92e70d9">flash_api_t::antiRollbackCounterRefresh</a></p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Counter refreshed successfully </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_ENABLED</td><td>The specified counter has not been configured (configuration is only required for ARC_NSEC) </td></tr>
    <tr><td class="paramname">FSP_ERR_PE_FAILURE</td><td>Failed to enter or exit Data Flash P/E mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timed out waiting for the FCU to become ready. </td></tr>
    <tr><td class="paramname">FSP_ERR_CMD_LOCKED</td><td>FCU is in locked state, typically as a result of having received an illegal command </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Data flash programming is not enabled or Anti-Rollback counter is not supported on this MCU </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7c09ac07f12fdc6a16427a6e9413e798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c09ac07f12fdc6a16427a6e9413e798">&#9670;&nbsp;</a></span>R_FLASH_HP_AntiRollbackCounterRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_AntiRollbackCounterRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#ga83b0266a3edcc6c865f79a3d04785c21">flash_arc_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *const&#160;</td>
          <td class="paramname"><em>p_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the selected anti-rollback counter and returns the number of counter bits set.</p>
<p>Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#ae292bc9f330a52094347c2745705c001">flash_api_t::antiRollbackCounterRead</a></p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Counter read successfully into p_count </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_api_ctrl or p_count </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_ENABLED</td><td>The specified counter has not been configured (configuration is only required for ARC_NSEC) </td></tr>
    <tr><td class="paramname">FSP_ERR_PE_FAILURE</td><td>Failed to enter or exit Data Flash P/E mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timed out waiting for the FCU to become ready. </td></tr>
    <tr><td class="paramname">FSP_ERR_CMD_LOCKED</td><td>FCU is in locked state, typically as a result of having received an illegal command </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Data flash programming is not enabled or Anti-Rollback counter is not supported on this MCU </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4221ad70c3c8812487ab247e80277d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4221ad70c3c8812487ab247e80277d2c">&#9670;&nbsp;</a></span>R_FLASH_HP_UserLockableAreaWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_UserLockableAreaWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>src_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flash_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>num_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write to the user lockable area in flash</p>
<p>Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#a6e935b63452c47faaad9a1979f303e1c">flash_api_t::userLockableAreaWrite</a></p>
<dl class="section note"><dt>Note</dt><dd>BGO is not supported for user lockable area flash operations.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Operation successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>The Flash peripheral is busy with a prior on-going transaction. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The Flash API is not Open. </td></tr>
    <tr><td class="paramname">FSP_ERR_CMD_LOCKED</td><td>FCU is in locked state, typically as a result of attempting to Write an area that is protected by an Access Window. </td></tr>
    <tr><td class="paramname">FSP_ERR_WRITE_FAILED</td><td>Status is indicating a Programming error for the requested operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timed out waiting for FCU operation to complete. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_SIZE</td><td>Number of bytes provided was not a multiple of the programming size or exceeded the maximum range. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ADDRESS</td><td>Invalid address was input or address not on programming boundary. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl. </td></tr>
    <tr><td class="paramname">FSP_ERR_PE_FAILURE</td><td>Failed to enter or exit P/E mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v6.3.0 User's Manual Copyright Â© (2025) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
