<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: High-Performance Flash Driver (r_flash_hp)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v2.3.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___f_l_a_s_h___h_p.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">High-Performance Flash Driver (r_flash_hp)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3c593b353cc97d311fb599142b05dc65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#ga3c593b353cc97d311fb599142b05dc65">R_FLASH_HP_Open</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___f_l_a_s_h___a_p_i.html#structflash__cfg__t">flash_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:ga3c593b353cc97d311fb599142b05dc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf516a8b528062a3a47bc35f419879237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#gaf516a8b528062a3a47bc35f419879237">R_FLASH_HP_Write</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, uint32_t const src_address, uint32_t flash_address, uint32_t const num_bytes)</td></tr>
<tr class="separator:gaf516a8b528062a3a47bc35f419879237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa862e982d6e602726ad908e76b7227ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#gaa862e982d6e602726ad908e76b7227ab">R_FLASH_HP_Erase</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, uint32_t const address, uint32_t const num_blocks)</td></tr>
<tr class="separator:gaa862e982d6e602726ad908e76b7227ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf981c87f5e9dadab1be7241553ff305b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#gaf981c87f5e9dadab1be7241553ff305b">R_FLASH_HP_BlankCheck</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, uint32_t const address, uint32_t num_bytes, <a class="el" href="group___f_l_a_s_h___a_p_i.html#ga79d0373f9f1ae1d8bd99c40edb44a5b6">flash_result_t</a> *blank_check_result)</td></tr>
<tr class="separator:gaf981c87f5e9dadab1be7241553ff305b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga979f52ddca85b3fef0c42d1b857893e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#ga979f52ddca85b3fef0c42d1b857893e7">R_FLASH_HP_Close</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:ga979f52ddca85b3fef0c42d1b857893e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68025e44839e70c533b8e5bd325fc64a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#ga68025e44839e70c533b8e5bd325fc64a">R_FLASH_HP_StatusGet</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___f_l_a_s_h___a_p_i.html#gab551389322a209cca1dcc1a7b2440f7a">flash_status_t</a> *const p_status)</td></tr>
<tr class="separator:ga68025e44839e70c533b8e5bd325fc64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27c1c44f16fac40b8258696a88929f80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#ga27c1c44f16fac40b8258696a88929f80">R_FLASH_HP_AccessWindowSet</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, uint32_t const start_addr, uint32_t const end_addr)</td></tr>
<tr class="separator:ga27c1c44f16fac40b8258696a88929f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d274fe4ee10e0aba086d6dd2baad8a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#ga0d274fe4ee10e0aba086d6dd2baad8a9">R_FLASH_HP_AccessWindowClear</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:ga0d274fe4ee10e0aba086d6dd2baad8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05d2e2d0290e251b34355aa1395dd3a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#ga05d2e2d0290e251b34355aa1395dd3a0">R_FLASH_HP_IdCodeSet</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, uint8_t const *const p_id_code, <a class="el" href="group___f_l_a_s_h___a_p_i.html#ga5879fbdf1d24018416c1c7ccf448b64f">flash_id_code_mode_t</a> mode)</td></tr>
<tr class="separator:ga05d2e2d0290e251b34355aa1395dd3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e269255ca9448da5d7b0a745992f6de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#ga4e269255ca9448da5d7b0a745992f6de">R_FLASH_HP_Reset</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:ga4e269255ca9448da5d7b0a745992f6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad766079d801d722527eb6834fc662e8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#gad766079d801d722527eb6834fc662e8a">R_FLASH_HP_UpdateFlashClockFreq</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:gad766079d801d722527eb6834fc662e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95b5a01a9c462a38f52397315a346a3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#ga95b5a01a9c462a38f52397315a346a3e">R_FLASH_HP_StartUpAreaSelect</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___f_l_a_s_h___a_p_i.html#gac8629165c2d649fbbf8c9854c3c7d20b">flash_startup_area_swap_t</a> swap_type, bool is_temporary)</td></tr>
<tr class="separator:ga95b5a01a9c462a38f52397315a346a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2932aac9082f6418d518b9cbc7cdef01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#ga2932aac9082f6418d518b9cbc7cdef01">R_FLASH_HP_CallbackSet</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, void(*p_callback)(<a class="el" href="group___f_l_a_s_h___a_p_i.html#structflash__callback__args__t">flash_callback_args_t</a> *), void const *const p_context, <a class="el" href="group___f_l_a_s_h___a_p_i.html#structflash__callback__args__t">flash_callback_args_t</a> *const p_callback_memory)</td></tr>
<tr class="separator:ga2932aac9082f6418d518b9cbc7cdef01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3335f3f8b174db9b86b3773993f341c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#ga3335f3f8b174db9b86b3773993f341c6">R_FLASH_HP_InfoGet</a> (<a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___f_l_a_s_h___a_p_i.html#structflash__info__t">flash_info_t</a> *const p_info)</td></tr>
<tr class="separator:ga3335f3f8b174db9b86b3773993f341c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the flash memory on RA high-performance MCUs. This module implements the <a class="el" href="group___f_l_a_s_h___a_p_i.html">Flash Interface</a>. </p>
<h1><a class="anchor" id="r-flash-hp-overview"></a>
Overview</h1>
<p>The Flash HAL module APIs allow an application to write, erase and blank check both the data and ROM flash areas that reside within the MCU. The amount of flash memory available varies across MCU parts.</p>
<h2><a class="anchor" id="r-flash-hp-features"></a>
Features</h2>
<p>The R_FLASH_HP module has the following key features:</p><ul>
<li>Blocking and non-blocking erasing, writing and blank-checking of data flash.<a class="anchor" id="um_flash_data_flash_blank_check_non_blocking"></a><a class="anchor" id="um_flash_data_flash_erase_non_blocking"></a><a class="anchor" id="um_flash_data_flash_write_non_blocking"></a></li>
<li>Blocking erasing, writing and blank-checking of code flash.</li>
<li>Callback functions for completion of non-blocking data flash operations.</li>
<li>Access window (write protection) for ROM Flash, allowing only specified areas of code flash to be erased or written.</li>
<li>Boot block-swapping.</li>
<li>ID code programming support.</li>
</ul>
<h1><a class="anchor" id="r-flash-hp-configuration"></a>
Configuration</h1>
<p><h2>Build Time Configurations for r_flash_hp</h2>
The following build time configurations are defined in fsp_cfg/r_flash_hp_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr>
<td>Code Flash Programming Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Controls whether or not code-flash programming is enabled. Disabling reduces the amount of ROM and RAM used by the API. </td></tr>
<tr>
<td>Data Flash Programming Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>Controls whether or not data-flash programming is enabled. Disabling reduces the amount of ROM used by the API. </td></tr>
</table>
 <h2>Configurations for Driver &gt; Storage &gt; Flash Driver on r_flash_hp</h2>
This module can be added to the Stacks tab via New Stack &gt; Driver &gt; Storage &gt; Flash Driver on r_flash_hp. Non-secure callable guard functions can be generated for this module by right clicking the module in the RA Configuration tool and checking the "Non-secure Callable" box.<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Name</td><td>Name must be a valid C symbol</td><td>g_flash0 </td><td>Module name. </td></tr>
<tr>
<td>Data Flash Background Operation</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>Enabling allows Flash API calls that reference data-flash to return immediately, with the operation continuing in the background. </td></tr>
<tr>
<td>Callback</td><td>Name must be a valid C symbol</td><td>NULL </td><td>A user callback function can be specified. Callback function called when a dataflash BGO operation completes or errors. </td></tr>
<tr>
<td>Flash Ready Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select the flash ready interrupt priority. </td></tr>
<tr>
<td>Flash Error Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select the flash error interrupt priority. </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-flash-hp-clock-configuration"></a>
Clock Configuration</h2>
<p>Flash uses FCLK as the clock source depending on the MCU. When writing and erasing the clock source must be at least 4 MHz.</p>
<h2><a class="anchor" id="r-flash-hp-pin-configuration"></a>
Pin Configuration</h2>
<p>This module does not use I/O pins.</p>
<h1><a class="anchor" id="r-flash-hp-usage_notes"></a>
Usage Notes</h1>
<dl class="section warning"><dt>Warning</dt><dd>It is highly recommended that the developer reviews sections 5 and 6 of the Flash Memory section of the target MCUs Hardware Userâ€™s Manual prior to using the r_flash_hp module. In particular, understanding ID Code and Access Window functionality can help avoid unrecoverable flash scenarios.</dd></dl>
<h2><a class="anchor" id="r-flash-hp-data-precautions"></a>
Data Flash Background Operation (BGO) Precautions</h2>
<p>When using the data flash BGO (Background Operation) mode, you can still access the user ROM, RAM and external memory. You must ensure that the data flash is not accessed during a data flash operation. This includes interrupts that may access the data flash.</p>
<h2><a class="anchor" id="r-flash-hp-code-precautions"></a>
Code Flash Precautions</h2>
<p>Code flash cannot be accessed while writing, erasing or blank checking code flash. Code flash cannot be accessed while modifying the access window, selecting the startup area or setting the ID code. In order to support modifying code flash all supporting code must reside in RAM. This is only done when code flash programming is enabled. BGO mode is not supported for code flash, so a code flash operation will not return before the operation has completed. By default, the vector table resides in the code flash. If an interrupt occurs during the code flash operation, then code flash will be accessed to fetch the interrupt's starting address and an error will occur. The simplest work-around is to disable interrupts during code flash operations. Another option is to copy the vector table to RAM, update the VTOR (Vector Table Offset Register) accordingly and ensure that any interrupt service routines execute out of RAM. Similarly, you must insure that if in a multi-threaded environment, threads running from code flash cannot become active while a code flash operation is in progress.</p>
<h2><a class="anchor" id="r-flash-hp-flash-clock"></a>
Flash Clock (FCLK)</h2>
<p><a class="anchor" id="um_flash_fclk_frequency_change"></a>The flash clock source is the clock used by the Flash peripheral in performing all Flash operations. As part of the <a class="el" href="group___f_l_a_s_h___a_p_i.html#a8166d0d1e4f3a59b8bf7f9e89fef9e44">flash_api_t::open</a> function the Flash clock source is checked will return FSP_ERR_FCLK if it is invalid. Once the Flash API has been opened, if the flash clock source frequency is changed, the <a class="el" href="group___f_l_a_s_h___a_p_i.html#ae357c91afece41b956ece618eb82c1a1">flash_api_t::updateFlashClockFreq</a> API function must be called to inform the API of the change. Failure to do so could result in flash operation failures and possibly damage the part.</p>
<h2><a class="anchor" id="r-flash-hp-interrupts"></a>
Interrupts</h2>
<p><a class="anchor" id="um_flash_data_flash_bgo_callbacks"></a><a class="anchor" id="um_flash_tz_callback"></a>Enable the flash ready interrupt only if you plan to use the data flash BGO. In this mode, the application can initiate a data flash operation and then be asynchronously notified of its completion, or an error, using a user supplied-callback function. The callback function is passed a structure containing event information that indicates the source of the callback event (for example, <a class="el" href="group___f_l_a_s_h___a_p_i.html#gga44753f7d426ae0121c94a307a95314a5a47cf4f3983c35ca46fcfabeb1903e068">flash_api_t::FLASH_EVENT_ERASE_COMPLETE</a>) When the FLASH FRDYI interrupt is enabled, the corresponding ISR will be defined in the flash driver. The ISR will call a user-callback function if one was registered with the <a class="el" href="group___f_l_a_s_h___a_p_i.html#a8166d0d1e4f3a59b8bf7f9e89fef9e44">flash_api_t::open</a> API. </p><dl class="section note"><dt>Note</dt><dd>The Flash HP supports an additional flash-error interrupt and if the BGO mode is enabled for the FLASH HP then both the Flash Ready Interrupt and Flash Error Interrupts must be enabled (assigned a priority).</dd></dl>
<h2><a class="anchor" id="r-flash-hp-limitations"></a>
Limitations</h2>
<ul>
<li>Write operations must be aligned on page boundaries and must be a multiple of the page boundary size.</li>
<li>Erase operations will erase the entire block the provided address resides in.</li>
<li>Data flash is better suited for storing data as it can be erased and written to while code is still executing from code flash. Data flash is also guaranteed for a larger number of reprogramming/erasure cycles than code flash.</li>
<li>Read values of erased data flash blocks are not guaranteed to be 0xFF. Blank check should be used to determine if memory has been erased but not yet programmed.</li>
</ul>
<h1><a class="anchor" id="r-flash-hp-examples"></a>
Examples</h1>
<h2>High-Performance Flash Basic Example</h2>
<p>This is a basic example of erasing and writing to data flash and code flash.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FLASH_DF_BLOCK_0               0x40100000U </span><span class="comment">/*   64 B:  0x40100000 - 0x4010003F */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">#define FLASH_CF_BLOCK_8               0x00010000  </span><span class="comment">/*   32 KB: 0x00010000 - 0x00017FFF */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">#define FLASH_DATA_BLOCK_SIZE          (1024)</span></div><div class="line"><span class="preprocessor">#define FLASH_HP_EXAMPLE_WRITE_SIZE    32</span></div><div class="line">uint8_t        g_dest[TRANSFER_LENGTH];</div><div class="line">uint8_t        g_src[TRANSFER_LENGTH];</div><div class="line"><a class="code" href="group___f_l_a_s_h___a_p_i.html#ga79d0373f9f1ae1d8bd99c40edb44a5b6">flash_result_t</a> blank_check_result;</div><div class="line"><span class="keywordtype">void</span> r_flash_hp_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Initialize p_src to known data */</span></div><div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; TRANSFER_LENGTH; i++)</div><div class="line">    {</div><div class="line">        g_src[i] = (uint8_t) (<span class="charliteral">&#39;A&#39;</span> + (i % 26));</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Open the flash hp instance. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___f_l_a_s_h___h_p.html#ga3c593b353cc97d311fb599142b05dc65">R_FLASH_HP_Open</a>(&amp;g_flash_ctrl, &amp;g_flash_cfg);</div><div class="line"></div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Erase 1 block of data flash starting at block 0. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___h_p.html#gaa862e982d6e602726ad908e76b7227ab">R_FLASH_HP_Erase</a>(&amp;g_flash_ctrl, FLASH_DF_BLOCK_0, 1);</div><div class="line"></div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Check if block 0 is erased. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___h_p.html#gaf981c87f5e9dadab1be7241553ff305b">R_FLASH_HP_BlankCheck</a>(&amp;g_flash_ctrl, FLASH_DF_BLOCK_0, FLASH_DATA_BLOCK_SIZE, &amp;blank_check_result);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Verify the previously erased area is blank */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___f_l_a_s_h___a_p_i.html#gga79d0373f9f1ae1d8bd99c40edb44a5b6a0a2fa6cbf8b10c2aa1dfc0033f24717f">FLASH_RESULT_NOT_BLANK</a> == blank_check_result)</div><div class="line">    {</div><div class="line">        handle_error(<a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#ggadfb1288da0fcc7ae1dc88c58601374f8a61a8e059198001f46af73f2930e6c144">FSP_ERR_BLANK_CHECK_FAILED</a>);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Write 32 bytes to the first block of data flash. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___h_p.html#gaf516a8b528062a3a47bc35f419879237">R_FLASH_HP_Write</a>(&amp;g_flash_ctrl, (uint32_t) g_src, FLASH_DF_BLOCK_0, FLASH_HP_EXAMPLE_WRITE_SIZE);</div><div class="line"></div><div class="line"></div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (0 != memcmp(g_src, (uint8_t *) FLASH_DF_BLOCK_0, FLASH_HP_EXAMPLE_WRITE_SIZE))</div><div class="line">    {</div><div class="line">        handle_error(<a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#ggadfb1288da0fcc7ae1dc88c58601374f8a23d4ede168571c3084157c0f99f6c60c">FSP_ERR_WRITE_FAILED</a>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Disable interrupts to prevent vector table access while code flash is in P/E mode. */</span></div><div class="line">    __disable_irq();</div><div class="line"></div><div class="line">    <span class="comment">/* Erase 1 block of code flash starting at block 10. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___h_p.html#gaa862e982d6e602726ad908e76b7227ab">R_FLASH_HP_Erase</a>(&amp;g_flash_ctrl, FLASH_CF_BLOCK_8, 1);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    <span class="comment">/* Write 32 bytes to the first block of data flash. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___h_p.html#gaf516a8b528062a3a47bc35f419879237">R_FLASH_HP_Write</a>(&amp;g_flash_ctrl, (uint32_t) g_src, FLASH_CF_BLOCK_8, FLASH_HP_EXAMPLE_WRITE_SIZE);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable interrupts after code flash operations are complete. */</span></div><div class="line">    __enable_irq();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (0 != memcmp(g_src, (uint8_t *) FLASH_CF_BLOCK_8, FLASH_HP_EXAMPLE_WRITE_SIZE))</div><div class="line">    {</div><div class="line">        handle_error(<a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#ggadfb1288da0fcc7ae1dc88c58601374f8a23d4ede168571c3084157c0f99f6c60c">FSP_ERR_WRITE_FAILED</a>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>High-Performance Flash Advanced Example</h2>
<p>This example demonstrates using BGO to do non-blocking operations on the data flash.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span>               interrupt_called;</div><div class="line"><a class="code" href="group___f_l_a_s_h___a_p_i.html#ga44753f7d426ae0121c94a307a95314a5">flash_event_t</a>      flash_event;</div><div class="line"><span class="keyword">static</span> <a class="code" href="group___f_l_a_s_h___a_p_i.html#structflash__cfg__t">flash_cfg_t</a> g_flash_bgo_example_cfg =</div><div class="line">{</div><div class="line">    .<a class="code" href="group___f_l_a_s_h___a_p_i.html#ac80ffd6402722097911dc6da638cd54d">p_callback</a>     = flash_callback,</div><div class="line">    .p_context      = 0,</div><div class="line">    .p_extend       = NULL,</div><div class="line">    .data_flash_bgo = <span class="keyword">true</span>,            </div><div class="line">    .ipl            = 5,</div><div class="line">    .irq            = BSP_VECTOR_FLASH_HP_FRDYI_ISR,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> r_flash_hp_bgo_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Initialize p_src to known data */</span></div><div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; TRANSFER_LENGTH; i++)</div><div class="line">    {</div><div class="line">        g_src[i] = (uint8_t) (<span class="charliteral">&#39;A&#39;</span> + (i % 26));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Open the flash hp instance. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___f_l_a_s_h___h_p.html#ga3c593b353cc97d311fb599142b05dc65">R_FLASH_HP_Open</a>(&amp;g_flash_ctrl, &amp;g_flash_bgo_example_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    interrupt_called = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Erase 1 block of data flash starting at block 0. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___h_p.html#gaa862e982d6e602726ad908e76b7227ab">R_FLASH_HP_Erase</a>(&amp;g_flash_ctrl, FLASH_DF_BLOCK_0, 1);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (!interrupt_called)</div><div class="line">    {</div><div class="line">        ;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___f_l_a_s_h___a_p_i.html#gga44753f7d426ae0121c94a307a95314a5a47cf4f3983c35ca46fcfabeb1903e068">FLASH_EVENT_ERASE_COMPLETE</a> != flash_event)</div><div class="line">    {</div><div class="line">        handle_error(<a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#ggadfb1288da0fcc7ae1dc88c58601374f8aedf5bd340743b4cad2a5b5370bdf3184">FSP_ERR_ERASE_FAILED</a>);</div><div class="line">    }</div><div class="line"></div><div class="line">    interrupt_called = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Write 32 bytes to the first block of data flash. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___h_p.html#gaf516a8b528062a3a47bc35f419879237">R_FLASH_HP_Write</a>(&amp;g_flash_ctrl, (uint32_t) g_src, FLASH_DF_BLOCK_0, FLASH_HP_EXAMPLE_WRITE_SIZE);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="group___f_l_a_s_h___a_p_i.html#gab551389322a209cca1dcc1a7b2440f7a">flash_status_t</a> status;</div><div class="line"></div><div class="line">    <span class="comment">/* Wait until the current flash operation completes. */</span></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        err = <a class="code" href="group___f_l_a_s_h___h_p.html#ga68025e44839e70c533b8e5bd325fc64a">R_FLASH_HP_StatusGet</a>(&amp;g_flash_ctrl, &amp;status);</div><div class="line">    } <span class="keywordflow">while</span> ((FSP_SUCCESS == err) &amp;&amp; (<a class="code" href="group___f_l_a_s_h___a_p_i.html#ggab551389322a209cca1dcc1a7b2440f7aa9f0e163a2cd4ec43acbe02344235882a">FLASH_STATUS_BUSY</a> == status));</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* If the interrupt wasn&#39;t called process the error. */</span></div><div class="line">    <span class="keywordflow">if</span> (!interrupt_called)</div><div class="line">    {</div><div class="line">        handle_error(<a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#ggadfb1288da0fcc7ae1dc88c58601374f8a23d4ede168571c3084157c0f99f6c60c">FSP_ERR_WRITE_FAILED</a>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* If the event wasn&#39;t a write complete process the error. */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___f_l_a_s_h___a_p_i.html#gga44753f7d426ae0121c94a307a95314a5a2a000e207e1a0db0f1a7c550599bb804">FLASH_EVENT_WRITE_COMPLETE</a> != flash_event)</div><div class="line">    {</div><div class="line">        handle_error(<a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#ggadfb1288da0fcc7ae1dc88c58601374f8a23d4ede168571c3084157c0f99f6c60c">FSP_ERR_WRITE_FAILED</a>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Verify the data was written correctly. */</span></div><div class="line">    <span class="keywordflow">if</span> (0 != memcmp(g_src, (uint8_t *) FLASH_DF_BLOCK_0, FLASH_HP_EXAMPLE_WRITE_SIZE))</div><div class="line">    {</div><div class="line">        handle_error(<a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#ggadfb1288da0fcc7ae1dc88c58601374f8a23d4ede168571c3084157c0f99f6c60c">FSP_ERR_WRITE_FAILED</a>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> flash_callback (<a class="code" href="group___f_l_a_s_h___a_p_i.html#structflash__callback__args__t">flash_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    interrupt_called = <span class="keyword">true</span>;</div><div class="line">    flash_event      = p_args-&gt;<a class="code" href="group___f_l_a_s_h___a_p_i.html#a85ce087229ae1cb0076dfb4e38238d7e">event</a>;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structflash__hp__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#structflash__hp__instance__ctrl__t">flash_hp_instance_ctrl_t</a></td></tr>
<tr class="separator:structflash__hp__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaf2df0780f6e32a857a43f00d2a34f5f6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#gaf2df0780f6e32a857a43f00d2a34f5f6">flash_bgo_operation_t</a> </td></tr>
<tr class="separator:gaf2df0780f6e32a857a43f00d2a34f5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structflash__hp__instance__ctrl__t" id="structflash__hp__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structflash__hp__instance__ctrl__t">&#9670;&nbsp;</a></span>flash_hp_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct flash_hp_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Flash HP instance control block. DO NOT INITIALIZE. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a0e9c6d859fd6f932e7d723c6c6a520e3"><td class="memItemLeft" align="right" valign="top"><a id="a0e9c6d859fd6f932e7d723c6c6a520e3"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#a0e9c6d859fd6f932e7d723c6c6a520e3">opened</a></td></tr>
<tr class="memdesc:a0e9c6d859fd6f932e7d723c6c6a520e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">To check whether api has been opened or not. <br /></td></tr>
<tr class="separator:a0e9c6d859fd6f932e7d723c6c6a520e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd09c39ddf5233ecdd713a14cdd4b4e"><td class="memItemLeft" align="right" valign="top"><a id="aecd09c39ddf5233ecdd713a14cdd4b4e"></a>
<a class="el" href="group___f_l_a_s_h___h_p.html#gaf2df0780f6e32a857a43f00d2a34f5f6">flash_bgo_operation_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___h_p.html#aecd09c39ddf5233ecdd713a14cdd4b4e">current_operation</a></td></tr>
<tr class="memdesc:aecd09c39ddf5233ecdd713a14cdd4b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation in progress, for example, FLASH_OPERATION_CF_ERASE. <br /></td></tr>
<tr class="separator:aecd09c39ddf5233ecdd713a14cdd4b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaf2df0780f6e32a857a43f00d2a34f5f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2df0780f6e32a857a43f00d2a34f5f6">&#9670;&nbsp;</a></span>flash_bgo_operation_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___f_l_a_s_h___h_p.html#gaf2df0780f6e32a857a43f00d2a34f5f6">flash_bgo_operation_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Possible Flash operation states </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga3c593b353cc97d311fb599142b05dc65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c593b353cc97d311fb599142b05dc65">&#9670;&nbsp;</a></span>R_FLASH_HP_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#structflash__cfg__t">flash_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the high performance flash peripheral. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#a8166d0d1e4f3a59b8bf7f9e89fef9e44">flash_api_t::open</a>.</p>
<p>The Open function initializes the Flash.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Open the flash hp instance. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___f_l_a_s_h___h_p.html#ga3c593b353cc97d311fb599142b05dc65">R_FLASH_HP_Open</a>(&amp;g_flash_ctrl, &amp;g_flash_cfg);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Initialization was successful and timer has started. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>The flash control block is already open. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl or p_cfg. </td></tr>
    <tr><td class="paramname">FSP_ERR_IRQ_BSP_DISABLED</td><td>Caller is requesting BGO but the Flash interrupts are not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_FCLK</td><td>FCLK must be a minimum of 4 MHz for Flash operations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf516a8b528062a3a47bc35f419879237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf516a8b528062a3a47bc35f419879237">&#9670;&nbsp;</a></span>R_FLASH_HP_Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>src_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flash_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>num_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes to the specified Code or Data Flash memory area. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#a01c35b7f1ad8a9bc3a932d4a05f2bcb6">flash_api_t::write</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Write 32 bytes to the first block of data flash. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___h_p.html#gaf516a8b528062a3a47bc35f419879237">R_FLASH_HP_Write</a>(&amp;g_flash_ctrl, (uint32_t) g_src, FLASH_DF_BLOCK_0, FLASH_HP_EXAMPLE_WRITE_SIZE);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Operation successful. If BGO is enabled this means the operation was started successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>The Flash peripheral is busy with a prior on-going transaction. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The Flash API is not Open. </td></tr>
    <tr><td class="paramname">FSP_ERR_CMD_LOCKED</td><td>FCU is in locked state, typically as a result of attempting to Write an area that is protected by an Access Window. </td></tr>
    <tr><td class="paramname">FSP_ERR_WRITE_FAILED</td><td>Status is indicating a Programming error for the requested operation. This may be returned if the requested Flash area is not blank. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timed out waiting for FCU operation to complete. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_SIZE</td><td>Number of bytes provided was not a multiple of the programming size or exceeded the maximum range. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ADDRESS</td><td>Invalid address was input or address not on programming boundary. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl. </td></tr>
    <tr><td class="paramname">FSP_ERR_PE_FAILURE</td><td>Failed to enter or exit P/E mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa862e982d6e602726ad908e76b7227ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa862e982d6e602726ad908e76b7227ab">&#9670;&nbsp;</a></span>R_FLASH_HP_Erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_Erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>num_blocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Erases the specified Code or Data Flash blocks. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#ac32a91bb4217997e2ca465463b644211">flash_api_t::erase</a> by the block_erase_address.</p>
<dl class="section note"><dt>Note</dt><dd>Code flash may contain blocks of different sizes. When erasing code flash it is important to take this into consideration to prevent erasing a larger address space than desired.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Erase 1 block of data flash starting at block 0. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___h_p.html#gaa862e982d6e602726ad908e76b7227ab">R_FLASH_HP_Erase</a>(&amp;g_flash_ctrl, FLASH_DF_BLOCK_0, 1);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful open. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_BLOCKS</td><td>Invalid number of blocks specified </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ADDRESS</td><td>Invalid address specified. If the address is in code flash then code flash programming must be enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>Other flash operation in progress, or API not initialized </td></tr>
    <tr><td class="paramname">FSP_ERR_CMD_LOCKED</td><td>FCU is in locked state, typically as a result of attempting to Erase an area that is protected by an Access Window. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The Flash API is not Open. </td></tr>
    <tr><td class="paramname">FSP_ERR_ERASE_FAILED</td><td>Status is indicating a Erase error. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timed out waiting for the FCU to become ready. </td></tr>
    <tr><td class="paramname">FSP_ERR_PE_FAILURE</td><td>Failed to enter or exit P/E mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf981c87f5e9dadab1be7241553ff305b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf981c87f5e9dadab1be7241553ff305b">&#9670;&nbsp;</a></span>R_FLASH_HP_BlankCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_BlankCheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#ga79d0373f9f1ae1d8bd99c40edb44a5b6">flash_result_t</a> *&#160;</td>
          <td class="paramname"><em>p_blank_check_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a blank check on the specified address area. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#a285a6f933817c94e26a5aa11c48a1b3c">flash_api_t::blankCheck</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Check if block 0 is erased. */</span></div><div class="line">    err = <a class="code" href="group___f_l_a_s_h___h_p.html#gaf981c87f5e9dadab1be7241553ff305b">R_FLASH_HP_BlankCheck</a>(&amp;g_flash_ctrl, FLASH_DF_BLOCK_0, FLASH_DATA_BLOCK_SIZE, &amp;blank_check_result);</div><div class="line">    handle_error(err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Blank check operation completed with result in p_blank_check_result, or blank check started and in-progess (BGO mode). </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ADDRESS</td><td>Invalid data flash address was input. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_SIZE</td><td>'num_bytes' was either too large or not aligned for the CF/DF boundary size. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>Other flash operation in progress or API not initialized. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl. </td></tr>
    <tr><td class="paramname">FSP_ERR_CMD_LOCKED</td><td>FCU is in locked state, typically as a result of attempting to Erase an area that is protected by an Access Window. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The Flash API is not Open. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timed out waiting for the FCU to become ready. </td></tr>
    <tr><td class="paramname">FSP_ERR_PE_FAILURE</td><td>Failed to enter or exit P/E mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_BLANK_CHECK_FAILED</td><td>Blank check operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga979f52ddca85b3fef0c42d1b857893e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga979f52ddca85b3fef0c42d1b857893e7">&#9670;&nbsp;</a></span>R_FLASH_HP_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases any resources that were allocated by the Open() or any subsequent Flash operations. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#a038ae85f83322bc1e71a8f3937b26c5d">flash_api_t::close</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful close. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl or p_cfg. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga68025e44839e70c533b8e5bd325fc64a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68025e44839e70c533b8e5bd325fc64a">&#9670;&nbsp;</a></span>R_FLASH_HP_StatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_StatusGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gab551389322a209cca1dcc1a7b2440f7a">flash_status_t</a> *const&#160;</td>
          <td class="paramname"><em>p_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the FLASH peripheral for its status. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#a5533acb74f21270a17a013d149c32a58">flash_api_t::statusGet</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <a class="code" href="group___f_l_a_s_h___a_p_i.html#gab551389322a209cca1dcc1a7b2440f7a">flash_status_t</a> status;</div><div class="line"></div><div class="line">    <span class="comment">/* Wait until the current flash operation completes. */</span></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        err = <a class="code" href="group___f_l_a_s_h___h_p.html#ga68025e44839e70c533b8e5bd325fc64a">R_FLASH_HP_StatusGet</a>(&amp;g_flash_ctrl, &amp;status);</div><div class="line">    } <span class="keywordflow">while</span> ((FSP_SUCCESS == err) &amp;&amp; (<a class="code" href="group___f_l_a_s_h___a_p_i.html#ggab551389322a209cca1dcc1a7b2440f7aa9f0e163a2cd4ec43acbe02344235882a">FLASH_STATUS_BUSY</a> == status));</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>FLASH peripheral is ready to use. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The Flash API is not Open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga27c1c44f16fac40b8258696a88929f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27c1c44f16fac40b8258696a88929f80">&#9670;&nbsp;</a></span>R_FLASH_HP_AccessWindowSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_AccessWindowSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>start_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>end_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure an access window for the Code Flash memory using the provided start and end address. An access window defines a contiguous area in Code Flash for which programming/erase is enabled. This area is on block boundaries. The block containing start_addr is the first block. The block containing end_addr is the last block. The access window then becomes first block &ndash;&gt; last block inclusive. Anything outside this range of Code Flash is then write protected. </p><dl class="section note"><dt>Note</dt><dd>If the start address and end address are set to the same value, then the access window is effectively removed. This accomplishes the same functionality as <a class="el" href="group___f_l_a_s_h___h_p.html#ga0d274fe4ee10e0aba086d6dd2baad8a9">R_FLASH_HP_AccessWindowClear()</a>.</dd></dl>
<p>Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#ab8f7f57d6c9b1d3a08281eee4edc0683">flash_api_t::accessWindowSet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Access window successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ADDRESS</td><td>Invalid settings for start_addr and/or end_addr. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>FLASH peripheral is busy with a prior operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Code Flash Programming is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Flash API has not yet been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_PE_FAILURE</td><td>Failed to enter or exit Code Flash P/E mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timed out waiting for the FCU to become ready. </td></tr>
    <tr><td class="paramname">FSP_ERR_WRITE_FAILED</td><td>Status is indicating a Programming error for the requested operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_CMD_LOCKED</td><td>FCU is in locked state, typically as a result of having received an illegal command. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0d274fe4ee10e0aba086d6dd2baad8a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d274fe4ee10e0aba086d6dd2baad8a9">&#9670;&nbsp;</a></span>R_FLASH_HP_AccessWindowClear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_AccessWindowClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove any access window that is currently configured in the Code Flash. Subsequent to this call all Code Flash is writable. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#a47d162b634f769385c2d39c4cbc6217b">flash_api_t::accessWindowClear</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Access window successfully removed. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>FLASH peripheral is busy with a prior operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Code Flash Programming is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Flash API has not yet been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_PE_FAILURE</td><td>Failed to enter or exit Code Flash P/E mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timed out waiting for the FCU to become ready. </td></tr>
    <tr><td class="paramname">FSP_ERR_WRITE_FAILED</td><td>Status is indicating a Programming error for the requested operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_CMD_LOCKED</td><td>FCU is in locked state, typically as a result of having received an illegal command. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga05d2e2d0290e251b34355aa1395dd3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05d2e2d0290e251b34355aa1395dd3a0">&#9670;&nbsp;</a></span>R_FLASH_HP_IdCodeSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_IdCodeSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *const&#160;</td>
          <td class="paramname"><em>p_id_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#ga5879fbdf1d24018416c1c7ccf448b64f">flash_id_code_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#aa27024990278c87ac8ea489c400bab5e">flash_api_t::idCodeSet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>ID Code successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>FLASH peripheral is busy with a prior operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Code Flash Programming is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Flash API has not yet been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_PE_FAILURE</td><td>Failed to enter or exit Code Flash P/E mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timed out waiting for the FCU to become ready. </td></tr>
    <tr><td class="paramname">FSP_ERR_WRITE_FAILED</td><td>Status is indicating a Programming error for the requested operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_CMD_LOCKED</td><td>FCU is in locked state, typically as a result of having received an illegal command. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4e269255ca9448da5d7b0a745992f6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e269255ca9448da5d7b0a745992f6de">&#9670;&nbsp;</a></span>R_FLASH_HP_Reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the FLASH peripheral. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#af87f6e3215253ad33a0c961c79979da0">flash_api_t::reset</a>.</p>
<p>No attempt is made to check if the flash is busy before executing the reset since the assumption is that a reset will terminate any existing operation.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Flash circuit successfully reset. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_PE_FAILURE</td><td>Failed to enter or exit P/E mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timed out waiting for the FCU to become ready. </td></tr>
    <tr><td class="paramname">FSP_ERR_CMD_LOCKED</td><td>FCU is in locked state, typically as a result of having received an illegal command. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad766079d801d722527eb6834fc662e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad766079d801d722527eb6834fc662e8a">&#9670;&nbsp;</a></span>R_FLASH_HP_UpdateFlashClockFreq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_UpdateFlashClockFreq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicate to the already open Flash API that the FCLK has changed. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#ae357c91afece41b956ece618eb82c1a1">flash_api_t::updateFlashClockFreq</a>.</p>
<p>This could be the case if the application has changed the system clock, and therefore the FCLK. Failure to call this function subsequent to changing the FCLK could result in damage to the flash macro.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Start-up area successfully toggled. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>Flash is busy with an on-going operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Flash API has not yet been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_FCLK</td><td>FCLK is not within the acceptable range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga95b5a01a9c462a38f52397315a346a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95b5a01a9c462a38f52397315a346a3e">&#9670;&nbsp;</a></span>R_FLASH_HP_StartUpAreaSelect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_StartUpAreaSelect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac8629165c2d649fbbf8c9854c3c7d20b">flash_startup_area_swap_t</a>&#160;</td>
          <td class="paramname"><em>swap_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_temporary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Selects which block, Default (Block 0) or Alternate (Block 1), is used as the startup area block. The provided parameters determine which block will become the active startup block and whether that action will be immediate (but temporary), or permanent subsequent to the next reset. Doing a temporary switch might appear to have limited usefulness. If there is an access window in place such that Block 0 is write protected, then one could do a temporary switch, update the block and switch them back without having to touch the access window. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#af01c458da5ffbd29ee404ccc5e8e6869">flash_api_t::startupAreaSelect</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Start-up area successfully toggled. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>FLASH peripheral is busy with a prior operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Code Flash Programming is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_PE_FAILURE</td><td>Failed to enter or exit Code Flash P/E mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Timed out waiting for the FCU to become ready. </td></tr>
    <tr><td class="paramname">FSP_ERR_WRITE_FAILED</td><td>Status is indicating a Programming error for the requested operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_CMD_LOCKED</td><td>FCU is in locked state, typically as a result of having received an illegal command. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2932aac9082f6418d518b9cbc7cdef01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2932aac9082f6418d518b9cbc7cdef01">&#9670;&nbsp;</a></span>R_FLASH_HP_CallbackSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_CallbackSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="group___f_l_a_s_h___a_p_i.html#structflash__callback__args__t">flash_callback_args_t</a> *)&#160;</td>
          <td class="paramname"><em>p_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>p_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#structflash__callback__args__t">flash_callback_args_t</a> *const&#160;</td>
          <td class="paramname"><em>p_callback_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the user callback with the option to provide memory for the callback argument structure. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#adc5094e84cb696f0a1d954f8a25dfbee">flash_api_t::callbackSet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Callback updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_NO_CALLBACK_MEMORY</td><td>p_callback is non-secure and p_callback_memory is either secure or NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3335f3f8b174db9b86b3773993f341c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3335f3f8b174db9b86b3773993f341c6">&#9670;&nbsp;</a></span>R_FLASH_HP_InfoGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_FLASH_HP_InfoGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#gac4a1fa08b027086853668911ce51c705">flash_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h___a_p_i.html#structflash__info__t">flash_info_t</a> *const&#160;</td>
          <td class="paramname"><em>p_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the information about the flash regions. Implements <a class="el" href="group___f_l_a_s_h___a_p_i.html#aa1168146a81e1cbeab18848c110bf0a2">flash_api_t::infoGet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful retrieved the request information. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL provided for p_ctrl or p_info. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v2.3.0 User's Manual Copyright Â© (2021) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
