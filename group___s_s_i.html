<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: Serial Sound Interface (r_ssi)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v1.1.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___s_s_i.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">Serial Sound Interface (r_ssi)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga11eda7ae877dbff4d650b4bc5847bb72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_s_i.html#ga11eda7ae877dbff4d650b4bc5847bb72">R_SSI_Open</a> (<a class="el" href="group___i2_s___a_p_i.html#ga0fa2b29e32a127c3151b9da8b91e67d6">i2s_ctrl_t</a> *const p_ctrl, <a class="el" href="group___i2_s___a_p_i.html#structi2s__cfg__t">i2s_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:ga11eda7ae877dbff4d650b4bc5847bb72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaece1c2abe43d44acb9078a073b62c186"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_s_i.html#gaece1c2abe43d44acb9078a073b62c186">R_SSI_Stop</a> (<a class="el" href="group___i2_s___a_p_i.html#ga0fa2b29e32a127c3151b9da8b91e67d6">i2s_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:gaece1c2abe43d44acb9078a073b62c186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff322c2f867c9c0518da4a3d47d10242"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_s_i.html#gaff322c2f867c9c0518da4a3d47d10242">R_SSI_StatusGet</a> (<a class="el" href="group___i2_s___a_p_i.html#ga0fa2b29e32a127c3151b9da8b91e67d6">i2s_ctrl_t</a> *const p_ctrl, <a class="el" href="group___i2_s___a_p_i.html#structi2s__status__t">i2s_status_t</a> *const p_status)</td></tr>
<tr class="separator:gaff322c2f867c9c0518da4a3d47d10242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50467e833da72f35c1dcf5f74059da18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_s_i.html#ga50467e833da72f35c1dcf5f74059da18">R_SSI_Write</a> (<a class="el" href="group___i2_s___a_p_i.html#ga0fa2b29e32a127c3151b9da8b91e67d6">i2s_ctrl_t</a> *const p_ctrl, void const *const p_src, uint32_t const bytes)</td></tr>
<tr class="separator:ga50467e833da72f35c1dcf5f74059da18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4920c995f4b40edcf21a9287b63d669a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_s_i.html#ga4920c995f4b40edcf21a9287b63d669a">R_SSI_Read</a> (<a class="el" href="group___i2_s___a_p_i.html#ga0fa2b29e32a127c3151b9da8b91e67d6">i2s_ctrl_t</a> *const p_ctrl, void *const p_dest, uint32_t const bytes)</td></tr>
<tr class="separator:ga4920c995f4b40edcf21a9287b63d669a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec5fe3772ecc9fca9b85126f6d2f3f49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_s_i.html#gaec5fe3772ecc9fca9b85126f6d2f3f49">R_SSI_WriteRead</a> (<a class="el" href="group___i2_s___a_p_i.html#ga0fa2b29e32a127c3151b9da8b91e67d6">i2s_ctrl_t</a> *const p_ctrl, void const *const p_src, void *const p_dest, uint32_t const bytes)</td></tr>
<tr class="separator:gaec5fe3772ecc9fca9b85126f6d2f3f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd323f1e3ef5f11745645b8297889b9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_s_i.html#gacd323f1e3ef5f11745645b8297889b9b">R_SSI_Mute</a> (<a class="el" href="group___i2_s___a_p_i.html#ga0fa2b29e32a127c3151b9da8b91e67d6">i2s_ctrl_t</a> *const p_ctrl, <a class="el" href="group___i2_s___a_p_i.html#ga59e0c765fddd3ab6aba0d87aaaff0b3b">i2s_mute_t</a> const mute_enable)</td></tr>
<tr class="separator:gacd323f1e3ef5f11745645b8297889b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga377334858b5b5c7757c0bdce3bcacbf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_s_i.html#ga377334858b5b5c7757c0bdce3bcacbf0">R_SSI_Close</a> (<a class="el" href="group___i2_s___a_p_i.html#ga0fa2b29e32a127c3151b9da8b91e67d6">i2s_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:ga377334858b5b5c7757c0bdce3bcacbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabee978c13fde54ee541adba77a39dbae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_s_i.html#gabee978c13fde54ee541adba77a39dbae">R_SSI_VersionGet</a> (<a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#unionfsp__version__t">fsp_version_t</a> *const p_version)</td></tr>
<tr class="separator:gabee978c13fde54ee541adba77a39dbae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the SSIE peripheral on RA MCUs. This module implements the <a class="el" href="group___i2_s___a_p_i.html">I2S Interface</a>. </p>
<h1><a class="anchor" id="r-ssi-overview"></a>
Overview</h1>
<h2><a class="anchor" id="r-ssi-features"></a>
Features</h2>
<p>The SSI module supports the following features:</p>
<ul>
<li><a class="anchor" id="um_ssi_receive_audio_data"></a>Transmission and reception of uncompressed audio data using the standard I2S protocol in master mode</li>
<li><a class="anchor" id="um_ssi_full_duplex"></a>Full-duplex I2S communication (channel 0 only)</li>
<li><a class="anchor" id="um_ssi_hardware_acceleration_using_dtc"></a>Integration with the DTC transfer module</li>
<li><a class="anchor" id="um_ssi_internal_audio_clock_connection"></a>Internal connection to GPT GTIOC1A timer output to generate the audio clock</li>
<li><a class="anchor" id="um_ssi_user_event_notification"></a>Callback function notification when all data is loaded into the SSI FIFO</li>
</ul>
<h1><a class="anchor" id="r-ssi-configuration"></a>
Configuration</h1>
<p><a class="anchor" id="um_ssi_driver_configurations"></a> <h2>Build Time Configurations for r_ssi</h2>
The following build time configurations are defined in fsp_cfg/r_ssi_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr>
<td>DTC Support</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>If code for DTC transfer support is included in the build. </td></tr>
</table>
 <h2>Configurations for Driver &gt; Connectivity &gt; I2S Driver on r_ssi</h2>
This module can be added to the Stacks tab via New Stack &gt; Driver &gt; Connectivity &gt; I2S Driver on r_ssi:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Name</td><td>Name must be a valid C symbol</td><td>g_i2s0 </td><td>Module name. </td></tr>
<tr>
<td>Channel</td><td>Value must be an integer between 0 and 1</td><td>0 </td><td>Specify the I2S channel. </td></tr>
<tr>
<td>Bit Depth</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
8 Bits</li>
<li>
16 Bits</li>
<li>
18 Bits</li>
<li>
20 Bits</li>
<li>
22 Bits</li>
<li>
24 Bits</li>
<li>
32 Bits</li>
</ul>
</td><td>16 Bits </td><td>Select the bit depth of one sample of audio data. </td></tr>
<tr>
<td>Word Length</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
8 Bits</li>
<li>
16 Bits</li>
<li>
24 Bits</li>
<li>
32 Bits</li>
<li>
48 Bits</li>
<li>
64 Bits</li>
<li>
128 Bits</li>
<li>
256 Bits</li>
</ul>
</td><td>16 Bits </td><td>Select the word length of audio data. Must be at least as large as Data bits. </td></tr>
<tr>
<td>WS Continue Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Enable WS continue mode to output the word select (WS) pin even when transmission is idle. </td></tr>
<tr>
<td>Bit Clock Source</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
AUDIO_CLK</li>
<li>
GTIOC1A</li>
</ul>
</td><td>AUDIO_CLK </td><td>Select AUDIO_CLK for external signal to AUDIO_CLK input pin or GTIOC1A for internal connection to GPT channel 1 GTIOC1A. </td></tr>
<tr>
<td>Bit Clock Divider</td><td>Refer to the RA Configuration tool for available options.</td><td>Audio Clock / 1 </td><td>Select divider used to generate bit clock from audio clock. </td></tr>
<tr>
<td>Callback</td><td>Name must be a valid C symbol</td><td>NULL </td><td>A user callback function can be provided. If this callback function is provided, it will be called from all three interrupt service routines (ISR). </td></tr>
<tr>
<td>Transmit Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select the transmit interrupt priority. </td></tr>
<tr>
<td>Receive Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select the receive interrupt priority. </td></tr>
<tr>
<td>Idle/Error Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select the Idle/Error interrupt priority. </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-ssi-clock-configuration"></a>
Clock Configuration</h2>
<p>The SSI peripheral runs on PCLKB. The PCLKB frequency can be configured on the <b>Clocks</b> tab of the RA Configuration editor. The SSI audio clock can optionally be supplied from an external source through the AUDIO_CLK pin in master mode.</p>
<h2><a class="anchor" id="r-ssi-pin-configuration"></a>
Pin Configuration</h2>
<p>The SSI uses the following pins:</p><ul>
<li>AUDIO_CLK (optional, master mode only): The AUDIO_CLK pin is used to supply the audio clock from an external source.</li>
<li>SSIBCKn: Bit clock pin for channel n</li>
<li>SSILRCKn/SSIFSn: Channel selection pin for channel n</li>
<li>SSIRXD0: Reception pin for channel 0</li>
<li>SSITXD0: Transmission pin for channel 0</li>
<li>SSIDATA1: Transmission or reception pin for channel 1</li>
</ul>
<h1><a class="anchor" id="r-ssi-usage_notes"></a>
Usage Notes</h1>
<h2>SSI Frames</h2>
<p>An SSI frame is 2 samples worth of data. The frame boundary (end of previous frame, start of next frame) is on the falling edge of the SSILRCKn signal.</p>
<h2>Audio Data</h2>
<p>Only uncompressed PCM data is supported.</p>
<p>Data arrays have the following size, alignment, and length based on the "Bit Depth" setting:</p>
<table class="doxtable">
<tr>
<th>Bit Depth </th><th>Array Data Type </th><th>Required Alignment </th><th>Required Length (bytes)  </th></tr>
<tr>
<td>8 Bits </td><td>8-bit integer </td><td>1 byte alignment </td><td>Multiple of 2 </td></tr>
<tr>
<td>16 Bits </td><td>16-bit integer </td><td>2 byte alignment </td><td>Multiple of 4 </td></tr>
<tr>
<td>18 Bits </td><td>32-bit integer, right justified </td><td>4 byte alignment </td><td>Multiple of 8 </td></tr>
<tr>
<td>20 Bits </td><td>32-bit integer, right justified </td><td>4 byte alignment </td><td>Multiple of 8 </td></tr>
<tr>
<td>22 Bits </td><td>32-bit integer, right justified </td><td>4 byte alignment </td><td>Multiple of 8 </td></tr>
<tr>
<td>24 Bits </td><td>32-bit integer, right justified </td><td>4 byte alignment </td><td>Multiple of 8 </td></tr>
<tr>
<td>32 Bits </td><td>32-bit integer </td><td>4 byte alignment </td><td>Multiple of 8 </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>The length of the array must be a multiple of 2 when the data type is the recommended data type. The 2 represents the frame size (left and right channel) of I2S communication. The SSIE peripheral does not support odd read/write lengths in I2S mode.</dd></dl>
<h2>Audio Clock</h2>
<p>The audio clock is only required for master mode.</p>
<h3>Audio Clock Frequency</h3>
<p>The bit clock frequency is the product of the sampling frequency and channels and bits per system word:</p>
<p>bit_clock (Hz) = sampling_frequency (Hz) * channels * system_word_bits</p>
<p>I2S data always has 2 channels.</p>
<p>For example, the bit clock for transmitting 2 channels of 16-bit data (using a 16-bit system word) at 44100 Hz would be:</p>
<p>44100 * 2 * 16 = 1,411,200 Hz</p>
<p>The audio clock frequency is used to generate the bit clock frequency. It must be a multiple of the bit clock frequency. Refer to the Bit Clock Divider configuration for divider options. The input audio clock frequency must be:</p>
<p>audio_clock (Hz) = desired_bit_clock (Hz) * bit_clock_divider</p>
<p>To get a bit clock of 1.4 MHz from an audio clock of 2.8 MHz, select the divider Audio Clock / 2.</p>
<h3>Audio Clock Source</h3>
<p>The audio clock source can come from:</p><ul>
<li><a class="anchor" id="um_ssi_external_input_clock"></a> An external source input to the AUDIO_CLK pin</li>
<li><a class="anchor" id="um_ssi_timer_generates_audio_clock"></a> An internal connection to the GPT channel 1 A output (GTIOC1A)</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>When using the GTIOC1A output, the GPT channel must be set to channel 1, Pin Output Support must be Enabled, and GTIOCA Output Enabled must be True.</dd></dl>
<h2><a class="anchor" id="r-ssi-limitations"></a>
Limitations</h2>
<p>Developers should be aware of the following limitations when using the SSI:</p>
<ul>
<li>When using channel 1, full duplex communication is not possible. Only tranmission or reception is possible.</li>
<li>SSI must go idle before changing the communication mode (between read only, write only, and full duplex)</li>
</ul>
<h1><a class="anchor" id="r-ssi-examples"></a>
Examples</h1>
<h2>Basic Example</h2>
<p>This is a basic example of minimal use of the SSI in an application.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define SSI_EXAMPLE_SAMPLES_TO_TRANSFER    (1024)</span></div><div class="line"><span class="preprocessor">#define SSI_EXAMPLE_TONE_FREQUENCY_HZ      (800)</span></div><div class="line">int16_t g_src[SSI_EXAMPLE_SAMPLES_TO_TRANSFER];</div><div class="line">int16_t g_dest[SSI_EXAMPLE_SAMPLES_TO_TRANSFER];</div><div class="line"><span class="keywordtype">void</span> ssi_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Create a stereo sine wave. Using formula sample = sin(2 * pi * tone_frequency * t / sampling_frequency) */</span></div><div class="line">    uint32_t freq = SSI_EXAMPLE_TONE_FREQUENCY_HZ;</div><div class="line">    <span class="keywordflow">for</span> (uint32_t t = 0; t &lt; SSI_EXAMPLE_SAMPLES_TO_TRANSFER / 2; t += 1)</div><div class="line">    {</div><div class="line">        <span class="keywordtype">float</span> input = (((float) (freq * t)) * (M_TWOPI)) / SSI_EXAMPLE_AUDIO_SAMPLING_FREQUENCY_HZ;</div><div class="line">        g_src[2 * t]     = (int16_t) ((INT16_MAX * sinf(input)));</div><div class="line">        g_src[2 * t + 1] = (int16_t) ((INT16_MAX * sinf(input)));</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the module. */</span></div><div class="line">    err = <a class="code" href="group___s_s_i.html#ga11eda7ae877dbff4d650b4bc5847bb72">R_SSI_Open</a>(&amp;g_i2s_ctrl, &amp;g_i2s_cfg);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Transfer data. */</span></div><div class="line">    (void) <a class="code" href="group___s_s_i.html#gaec5fe3772ecc9fca9b85126f6d2f3f49">R_SSI_WriteRead</a>(&amp;g_i2s_ctrl,</div><div class="line">                           (uint8_t *) &amp;g_src[0],</div><div class="line">                           (uint8_t *) &amp;g_dest[0],</div><div class="line">                           SSI_EXAMPLE_SAMPLES_TO_TRANSFER * <span class="keyword">sizeof</span>(int16_t));</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Streaming Example</h2>
<p>This is an example of using SSI to stream audio data. This application uses a double buffer to store PCM sine wave data. It starts transmitting in the main loop, then loads the next buffer if it is ready in the callback. If the next buffer is not ready, a flag is set in the callback so the application knows to restart transmission in the main loop.</p>
<p>This example also checks the return code of <a class="el" href="group___s_s_i.html#ga50467e833da72f35c1dcf5f74059da18">R_SSI_Write()</a> because <a class="el" href="group___s_s_i.html#ga50467e833da72f35c1dcf5f74059da18">R_SSI_Write()</a> can return an error if a transmit overflow occurs before the FIFO is reloaded. If a transmit overflow occurs before the FIFO is reloaded, the SSI will be stopped in the error interrupt, and it cannot be restarted until the I2S_EVENT_IDLE callback is received.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define SSI_STREAMING_EXAMPLE_AUDIO_SAMPLING_FREQUENCY_HZ    (22050)</span></div><div class="line"><span class="preprocessor">#define SSI_STREAMING_EXAMPLE_SAMPLES_PER_CHUNK              (1024)</span></div><div class="line"><span class="preprocessor">#define SSI_STREAMING_EXAMPLE_TONE_FREQUENCY_HZ              (800)</span></div><div class="line"></div><div class="line">int16_t       g_stream_src[2][SSI_EXAMPLE_SAMPLES_TO_TRANSFER];</div><div class="line">uint32_t      g_buffer_index           = 0;</div><div class="line"><span class="keyword">volatile</span> <span class="keywordtype">bool</span> g_send_data_in_main_loop = <span class="keyword">true</span>;</div><div class="line"><span class="keyword">volatile</span> <span class="keywordtype">bool</span> g_data_ready             = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="comment">/* Example callback called when SSI is ready for more data. */</span></div><div class="line"><span class="keywordtype">void</span> ssi_example_callback (<a class="code" href="group___i2_s___a_p_i.html#structi2s__callback__args__t">i2s_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="comment">/* Reload the FIFO if we hit the transmit watermark or restart transmission if the SSI is idle because it was</span></div><div class="line"><span class="comment">     * stopped after a transmit FIFO overflow. */</span></div><div class="line">    <span class="keywordflow">if</span> ((<a class="code" href="group___i2_s___a_p_i.html#ggaee54a6afc2869dd7371211e8b1f9d13fa23ea8cfcfe77f00283cec425394d9dc8">I2S_EVENT_TX_EMPTY</a> == p_args-&gt;<a class="code" href="group___i2_s___a_p_i.html#a035583e3102b475a20517aca81920cd7">event</a>) || (<a class="code" href="group___i2_s___a_p_i.html#ggaee54a6afc2869dd7371211e8b1f9d13fabf494b429dd658534ea8dabc1db4c117">I2S_EVENT_IDLE</a> == p_args-&gt;<a class="code" href="group___i2_s___a_p_i.html#a035583e3102b475a20517aca81920cd7">event</a>))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (g_data_ready)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Reload FIFO and handle errors. */</span></div><div class="line">            ssi_example_write();</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            <span class="comment">/* Data was not ready yet, send it in the main loop. */</span></div><div class="line">            g_send_data_in_main_loop = <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Load the transmit FIFO and check for error conditions. */</span></div><div class="line"><span class="keywordtype">void</span> ssi_example_write (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Transfer data. This call is non-blocking. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___s_s_i.html#ga50467e833da72f35c1dcf5f74059da18">R_SSI_Write</a>(&amp;g_i2s_ctrl,</div><div class="line">                                (uint8_t *) &amp;g_stream_src[g_buffer_index][0],</div><div class="line">                                SSI_STREAMING_EXAMPLE_SAMPLES_PER_CHUNK * <span class="keyword">sizeof</span>(int16_t));</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Switch the buffer after data is sent. */</span></div><div class="line">        g_buffer_index = !g_buffer_index;</div><div class="line"></div><div class="line">        <span class="comment">/* Allow loop to calculate next buffer only if transmission was successful. */</span></div><div class="line">        g_data_ready = <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Getting here most likely means a transmit overflow occurred before the FIFO could be reloaded. The</span></div><div class="line"><span class="comment">         * application must wait until the SSI is idle, then restart transmission. In this example, the idle</span></div><div class="line"><span class="comment">         * callback transmits data or resets the flag g_send_data_in_main_loop. */</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Calculate samples. This example is just a sine wave. For this type of data, it would be better to calculate</span></div><div class="line"><span class="comment"> * one period and loop it. This example should be updated for the audio data used by the application. */</span></div><div class="line"><span class="keywordtype">void</span> ssi_example_calculate_samples (uint32_t buffer_index)</div><div class="line">{</div><div class="line">    <span class="keyword">static</span> uint32_t t = 0U;</div><div class="line"></div><div class="line">    <span class="comment">/* Create a stereo sine wave. Using formula sample = sin(2 * pi * tone_frequency * t / sampling_frequency) */</span></div><div class="line">    uint32_t freq = SSI_STREAMING_EXAMPLE_TONE_FREQUENCY_HZ;</div><div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; SSI_STREAMING_EXAMPLE_SAMPLES_PER_CHUNK / 2; i += 1)</div><div class="line">    {</div><div class="line">        <span class="keywordtype">float</span> input = (((float) (freq * t)) * M_TWOPI) / SSI_STREAMING_EXAMPLE_AUDIO_SAMPLING_FREQUENCY_HZ;</div><div class="line">        t++;</div><div class="line"></div><div class="line">        <span class="comment">/* Store sample twice, once for left channel and once for right channel. */</span></div><div class="line">        int16_t sample = (int16_t) ((INT16_MAX * sinf(input)));</div><div class="line">        g_stream_src[buffer_index][2 * i]     = sample;</div><div class="line">        g_stream_src[buffer_index][2 * i + 1] = sample;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Data is ready to be sent in the interrupt. */</span></div><div class="line">    g_data_ready = <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> ssi_streaming_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the module. */</span></div><div class="line">    err = <a class="code" href="group___s_s_i.html#ga11eda7ae877dbff4d650b4bc5847bb72">R_SSI_Open</a>(&amp;g_i2s_ctrl, &amp;g_i2s_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Prepare data in a buffer that is not currently used for transmission. */</span></div><div class="line">        ssi_example_calculate_samples(g_buffer_index);</div><div class="line"></div><div class="line">        <span class="comment">/* Send data in main loop the first time, and if it was not ready in the interrupt. */</span></div><div class="line">        <span class="keywordflow">if</span> (g_send_data_in_main_loop)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Clear flag. */</span></div><div class="line">            g_send_data_in_main_loop = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            <span class="comment">/* Reload FIFO and handle errors. */</span></div><div class="line">            ssi_example_write();</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* If the next buffer is ready, wait for the data to be sent in the interrupt. */</span></div><div class="line">        <span class="keywordflow">while</span> (g_data_ready)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Do nothing. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structssi__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_s_i.html#structssi__instance__ctrl__t">ssi_instance_ctrl_t</a></td></tr>
<tr class="separator:structssi__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structssi__extended__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_s_i.html#structssi__extended__cfg__t">ssi_extended_cfg_t</a></td></tr>
<tr class="separator:structssi__extended__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga57213e467410bf6c3afe0c2338820260"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_s_i.html#ga57213e467410bf6c3afe0c2338820260">ssi_audio_clock_t</a> </td></tr>
<tr class="separator:ga57213e467410bf6c3afe0c2338820260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2ee4147d471591bc86faf6ae993ccff"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_s_i.html#gab2ee4147d471591bc86faf6ae993ccff">ssi_clock_div_t</a> </td></tr>
<tr class="separator:gab2ee4147d471591bc86faf6ae993ccff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structssi__instance__ctrl__t" id="structssi__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structssi__instance__ctrl__t">&#9670;&nbsp;</a></span>ssi_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ssi_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Channel instance control block. DO NOT INITIALIZE. Initialization occurs when <a class="el" href="group___i2_s___a_p_i.html#a126cf17d3f087c894b25e519583e3c7a">i2s_api_t::open</a> is called. </p>
</div>
</div>
</div>
<a name="structssi__extended__cfg__t" id="structssi__extended__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structssi__extended__cfg__t">&#9670;&nbsp;</a></span>ssi_extended_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ssi_extended_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>SSI configuration extension. This extension is optional. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ab814181502963ee5a0fb311326d97352"></a><a class="el" href="group___s_s_i.html#ga57213e467410bf6c3afe0c2338820260">ssi_audio_clock_t</a></td>
<td class="fieldname">
audio_clock</td>
<td class="fielddoc">
Audio clock source, default is SSI_AUDIO_CLOCK_EXTERNAL. </td></tr>
<tr><td class="fieldtype">
<a id="a93f1671ec0d6ad6a07fb1783d409722f"></a><a class="el" href="group___s_s_i.html#gab2ee4147d471591bc86faf6ae993ccff">ssi_clock_div_t</a></td>
<td class="fieldname">
bit_clock_div</td>
<td class="fielddoc">
Select bit clock division ratio. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga57213e467410bf6c3afe0c2338820260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57213e467410bf6c3afe0c2338820260">&#9670;&nbsp;</a></span>ssi_audio_clock_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_s_i.html#ga57213e467410bf6c3afe0c2338820260">ssi_audio_clock_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Audio clock source. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga57213e467410bf6c3afe0c2338820260a70d00a0392b530b169f91eb676b0526f"></a>SSI_AUDIO_CLOCK_EXTERNAL&#160;</td><td class="fielddoc"><p>Audio clock source is the AUDIO_CLK input pin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga57213e467410bf6c3afe0c2338820260aecaf4e604947446acc0ca94f49f649b7"></a>SSI_AUDIO_CLOCK_GTIOC1A&#160;</td><td class="fielddoc"><p>Audio clock source is internal connection to GPT channel 1 output. </p>
</td></tr>
</table>

</div>
</div>
<a id="gab2ee4147d471591bc86faf6ae993ccff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2ee4147d471591bc86faf6ae993ccff">&#9670;&nbsp;</a></span>ssi_clock_div_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_s_i.html#gab2ee4147d471591bc86faf6ae993ccff">ssi_clock_div_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bit clock division ratio. Bit clock frequency = audio clock frequency / bit clock division ratio. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab2ee4147d471591bc86faf6ae993ccffa700c7eaaa55e0b68bc7b082d1cba5bf4"></a>SSI_CLOCK_DIV_1&#160;</td><td class="fielddoc"><p>Clock divisor 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab2ee4147d471591bc86faf6ae993ccffa3ceda17546469bf6c786efde8828330e"></a>SSI_CLOCK_DIV_2&#160;</td><td class="fielddoc"><p>Clock divisor 2. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab2ee4147d471591bc86faf6ae993ccffa84f40ee433ad40a4a2303647fb551364"></a>SSI_CLOCK_DIV_4&#160;</td><td class="fielddoc"><p>Clock divisor 4. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab2ee4147d471591bc86faf6ae993ccffaf27bc1e14d1efa7445c86a428245aea1"></a>SSI_CLOCK_DIV_6&#160;</td><td class="fielddoc"><p>Clock divisor 6. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab2ee4147d471591bc86faf6ae993ccffadd024930cecf9f65496d91aa6d83c0b1"></a>SSI_CLOCK_DIV_8&#160;</td><td class="fielddoc"><p>Clock divisor 8. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab2ee4147d471591bc86faf6ae993ccffad1287e8879b6f20ba464f54a05059bda"></a>SSI_CLOCK_DIV_12&#160;</td><td class="fielddoc"><p>Clock divisor 12. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab2ee4147d471591bc86faf6ae993ccffa76fac1402c41cb3bfa327eba33030ff9"></a>SSI_CLOCK_DIV_16&#160;</td><td class="fielddoc"><p>Clock divisor 16. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab2ee4147d471591bc86faf6ae993ccffaa362b026a15144220ca483ace290a07a"></a>SSI_CLOCK_DIV_24&#160;</td><td class="fielddoc"><p>Clock divisor 24. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab2ee4147d471591bc86faf6ae993ccffa79d7abb9bc7bdfdb7676f0fe1a1ba793"></a>SSI_CLOCK_DIV_32&#160;</td><td class="fielddoc"><p>Clock divisor 32. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab2ee4147d471591bc86faf6ae993ccffabbc43787e347945e45540dc7172a6145"></a>SSI_CLOCK_DIV_48&#160;</td><td class="fielddoc"><p>Clock divisor 48. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab2ee4147d471591bc86faf6ae993ccffaba8011505d83509719d7ea5341810582"></a>SSI_CLOCK_DIV_64&#160;</td><td class="fielddoc"><p>Clock divisor 64. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab2ee4147d471591bc86faf6ae993ccffaa10369f78b86cd6edf9fa06577d66099"></a>SSI_CLOCK_DIV_96&#160;</td><td class="fielddoc"><p>Clock divisor 96. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab2ee4147d471591bc86faf6ae993ccffa864e2106d49bfaa32d9e966dc6093351"></a>SSI_CLOCK_DIV_128&#160;</td><td class="fielddoc"><p>Clock divisor 128. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga11eda7ae877dbff4d650b4bc5847bb72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11eda7ae877dbff4d650b4bc5847bb72">&#9670;&nbsp;</a></span>R_SSI_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SSI_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_s___a_p_i.html#ga0fa2b29e32a127c3151b9da8b91e67d6">i2s_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_s___a_p_i.html#structi2s__cfg__t">i2s_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens the SSI. Implements <a class="el" href="group___i2_s___a_p_i.html#a126cf17d3f087c894b25e519583e3c7a">i2s_api_t::open</a>.</p>
<p>This function sets this clock divisor and the configurations specified in <a class="el" href="group___i2_s___a_p_i.html#structi2s__cfg__t">i2s_cfg_t</a>. It also opens the timer and transfer instances if they are provided.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Ready for I2S communication. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>The pointer to p_ctrl or p_cfg is null. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>The control block has already been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_IP_CHANNEL_NOT_PRESENT</td><td>Channel number is not available on this MCU. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html">Common Error Codes</a> or functions called by this function for other possible return codes. This function calls:<ul>
<li><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a84d48960cdfe867ef54fd4635a85ceeb">transfer_api_t::open</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaece1c2abe43d44acb9078a073b62c186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaece1c2abe43d44acb9078a073b62c186">&#9670;&nbsp;</a></span>R_SSI_Stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SSI_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_s___a_p_i.html#ga0fa2b29e32a127c3151b9da8b91e67d6">i2s_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops SSI. Implements <a class="el" href="group___i2_s___a_p_i.html#a3a101cfd39c85cca163c5daf6bf29e34">i2s_api_t::stop</a>.</p>
<p>This function disables both transmission and reception, and disables any transfer instances used.</p>
<p>The SSI will stop on the next frame boundary. Do not restart SSI until it is idle.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>I2S communication stop request issued. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>The pointer to p_ctrl was null. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The channel is not opened. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html">Common Error Codes</a> or lower level drivers for other possible return codes. </dd></dl>

</div>
</div>
<a id="gaff322c2f867c9c0518da4a3d47d10242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff322c2f867c9c0518da4a3d47d10242">&#9670;&nbsp;</a></span>R_SSI_StatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SSI_StatusGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_s___a_p_i.html#ga0fa2b29e32a127c3151b9da8b91e67d6">i2s_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_s___a_p_i.html#structi2s__status__t">i2s_status_t</a> *const&#160;</td>
          <td class="paramname"><em>p_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets SSI status and stores it in provided pointer p_status. Implements <a class="el" href="group___i2_s___a_p_i.html#a1f88823bc677660a18881e9a348e6af0">i2s_api_t::statusGet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Information stored successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>The p_instance_ctrl or p_status parameter was null. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The channel is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga50467e833da72f35c1dcf5f74059da18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50467e833da72f35c1dcf5f74059da18">&#9670;&nbsp;</a></span>R_SSI_Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SSI_Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_s___a_p_i.html#ga0fa2b29e32a127c3151b9da8b91e67d6">i2s_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>p_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes data buffer to SSI. Implements <a class="el" href="group___i2_s___a_p_i.html#a686e36c470790ae87da1ec6d3aee1058">i2s_api_t::write</a>.</p>
<p>This function resets the transfer if the transfer interface is used, or writes the length of data that fits in the FIFO then stores the remaining write buffer in the control block to be written in the ISR.</p>
<p>Write() cannot be called if another write(), read() or writeRead() operation is in progress. Write can be called when the SSI is idle, or after the I2S_EVENT_TX_EMPTY event.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Write initiated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>The pointer to p_ctrl or p_src was null, or bytes requested was 0. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>Another transfer is in progress, data was not written. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The channel is not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNDERFLOW</td><td>A transmit underflow error is pending. Wait for the SSI to go idle before resuming communication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html">Common Error Codes</a> or functions called by this function for other possible return codes. This function calls:<ul>
<li><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a9c096c8d0e78dfbf8b3809a4598b8619">transfer_api_t::reset</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga4920c995f4b40edcf21a9287b63d669a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4920c995f4b40edcf21a9287b63d669a">&#9670;&nbsp;</a></span>R_SSI_Read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SSI_Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_s___a_p_i.html#ga0fa2b29e32a127c3151b9da8b91e67d6">i2s_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>p_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads data into provided buffer. Implements <a class="el" href="group___i2_s___a_p_i.html#ae4d0afd7d33ccf206e4dc3ca5227ecd9">i2s_api_t::read</a>.</p>
<p>This function resets the transfer if the transfer interface is used, or reads the length of data available in the FIFO then stores the remaining read buffer in the control block to be filled in the ISR.</p>
<p>Read() cannot be called if another write(), read() or writeRead() operation is in progress. Read can be called when the SSI is idle, or after the I2S_EVENT_RX_FULL event.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Read initiated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>Peripheral is in the wrong mode or not idle. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>The pointer to p_ctrl or p_dest was null, or bytes requested was 0. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The channel is not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_OVERFLOW</td><td>A receive overflow error is pending. Wait for the SSI to go idle before resuming communication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html">Common Error Codes</a> or functions called by this function for other possible return codes. This function calls:<ul>
<li><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a9c096c8d0e78dfbf8b3809a4598b8619">transfer_api_t::reset</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaec5fe3772ecc9fca9b85126f6d2f3f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec5fe3772ecc9fca9b85126f6d2f3f49">&#9670;&nbsp;</a></span>R_SSI_WriteRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SSI_WriteRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_s___a_p_i.html#ga0fa2b29e32a127c3151b9da8b91e67d6">i2s_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>p_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>p_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes from source buffer and reads data into destination buffer. Implements <a class="el" href="group___i2_s___a_p_i.html#a0268adf9536947ac5cd8ac2795416a18">i2s_api_t::writeRead</a>.</p>
<p>This function calls R_SSI_Write and R_SSI_Read.</p>
<p>writeRead() cannot be called if another write(), read() or writeRead() operation is in progress. writeRead() can be called when the SSI is idle, or after the I2S_EVENT_RX_FULL event.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Write and read initiated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>Peripheral is in the wrong mode or not idle. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input parameter was invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The channel is not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNDERFLOW</td><td>A transmit underflow error is pending. Wait for the SSI to go idle before resuming communication. </td></tr>
    <tr><td class="paramname">FSP_ERR_OVERFLOW</td><td>A receive overflow error is pending. Wait for the SSI to go idle before resuming communication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html">Common Error Codes</a> or functions called by this function for other possible return codes. This function calls:<ul>
<li><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a9c096c8d0e78dfbf8b3809a4598b8619">transfer_api_t::reset</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gacd323f1e3ef5f11745645b8297889b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd323f1e3ef5f11745645b8297889b9b">&#9670;&nbsp;</a></span>R_SSI_Mute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SSI_Mute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_s___a_p_i.html#ga0fa2b29e32a127c3151b9da8b91e67d6">i2s_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_s___a_p_i.html#ga59e0c765fddd3ab6aba0d87aaaff0b3b">i2s_mute_t</a> const&#160;</td>
          <td class="paramname"><em>mute_enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mutes SSI on the next frame boundary. Implements <a class="el" href="group___i2_s___a_p_i.html#ade8bbdbcd534fb6c85d54f770b851d5f">i2s_api_t::mute</a>.</p>
<p>Data is still written while mute is enabled, but the transmit line outputs zeros.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Transmission is muted. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>The pointer to p_ctrl was null. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The channel is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga377334858b5b5c7757c0bdce3bcacbf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga377334858b5b5c7757c0bdce3bcacbf0">&#9670;&nbsp;</a></span>R_SSI_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SSI_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_s___a_p_i.html#ga0fa2b29e32a127c3151b9da8b91e67d6">i2s_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes SSI. Implements <a class="el" href="group___i2_s___a_p_i.html#a8c2a70075e8e8b976cf1664f034cc68e">i2s_api_t::close</a>.</p>
<p>This function powers down the SSI and closes the lower level timer and transfer drivers if they are used.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Device closed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>The pointer to p_ctrl was null. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The channel is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabee978c13fde54ee541adba77a39dbae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabee978c13fde54ee541adba77a39dbae">&#9670;&nbsp;</a></span>R_SSI_VersionGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SSI_VersionGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#unionfsp__version__t">fsp_version_t</a> *const&#160;</td>
          <td class="paramname"><em>p_version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets driver version based on compile time macros.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful close. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>The parameter p_version is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v1.1.0 User's Manual Copyright  (2020) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
