<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: JPEG Codec (r_jpeg)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
    $(document).ready(function() {
        $("tr.tree_lvl_1").nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
		$("tr.tree_lvl_1").data("expanded","0");
		$("tr.tree_lvl_2").data("expanded","0");
		$("tr.tree_lvl_3").data("expanded","0");
		$("tr.tree_lvl_4").data("expanded","0");
		$("tr.tree_lvl_5").data("expanded","0");
        $("tr.tree_lvl_1").click(function() {
		    var lvl_1_is_open = $(this).data("expanded");
		    if (lvl_1_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2, tr.tree_lvl_1_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_2").click(function() {
		    var lvl_2_is_open = $(this).data("expanded");
		    if (lvl_2_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3, tr.tree_lvl_2_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_3").click(function() {
		    var lvl_3_is_open = $(this).data("expanded");
		    if (lvl_3_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_3_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_4").click(function() {
		    var lvl_4_is_open = $(this).data("expanded");
		    if (lvl_4_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5, tr.tree_lvl_4_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_5").click(function() {
		    var lvl_5_is_open = $(this).data("expanded");
		    if (lvl_5_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4_item,tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
     });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v6.2.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">

    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text">
      </span>
      <span class="right">
          &nbsp;
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___j_p_e_g.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body.
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len));
            }
          }
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element.
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<div class="title">JPEG Codec (r_jpeg)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___g_r_a_p_h_i_c_s___m_o_d_u_l_e_s.html">Graphics</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga34766994da3769a1f5cd3e7f22652b43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___j_p_e_g.html#ga34766994da3769a1f5cd3e7f22652b43">R_JPEG_Open</a> (<a class="el" href="group___j_p_e_g___a_p_i.html#gadcda3a404659199f5fc9b90a8eb4b543">jpeg_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___j_p_e_g___a_p_i.html#structjpeg__cfg__t">jpeg_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:ga34766994da3769a1f5cd3e7f22652b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d304aad5fbb148f8bd7ed71f878e53d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___j_p_e_g.html#ga6d304aad5fbb148f8bd7ed71f878e53d">R_JPEG_OutputBufferSet</a> (<a class="el" href="group___j_p_e_g___a_p_i.html#gadcda3a404659199f5fc9b90a8eb4b543">jpeg_ctrl_t</a> *p_api_ctrl, void *p_output_buffer, uint32_t output_buffer_size)</td></tr>
<tr class="separator:ga6d304aad5fbb148f8bd7ed71f878e53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaed65a4fe2f87a3c30dc817d311056f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___j_p_e_g.html#gaaed65a4fe2f87a3c30dc817d311056f0">R_JPEG_InputBufferSet</a> (<a class="el" href="group___j_p_e_g___a_p_i.html#gadcda3a404659199f5fc9b90a8eb4b543">jpeg_ctrl_t</a> *const p_api_ctrl, void *p_data_buffer, uint32_t data_buffer_size)</td></tr>
<tr class="separator:gaaed65a4fe2f87a3c30dc817d311056f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae339672b9122a431c66a695858877463"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___j_p_e_g.html#gae339672b9122a431c66a695858877463">R_JPEG_DecodeLinesDecodedGet</a> (<a class="el" href="group___j_p_e_g___a_p_i.html#gadcda3a404659199f5fc9b90a8eb4b543">jpeg_ctrl_t</a> *p_api_ctrl, uint32_t *p_lines)</td></tr>
<tr class="separator:gae339672b9122a431c66a695858877463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3246bd6af57284f48d8c5061257bfeed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___j_p_e_g.html#ga3246bd6af57284f48d8c5061257bfeed">R_JPEG_DecodeImageSubsampleSet</a> (<a class="el" href="group___j_p_e_g___a_p_i.html#gadcda3a404659199f5fc9b90a8eb4b543">jpeg_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___j_p_e_g___a_p_i.html#gac10fc46a5178859abd5d686389c5242c">jpeg_decode_subsample_t</a> horizontal_subsample, <a class="el" href="group___j_p_e_g___a_p_i.html#gac10fc46a5178859abd5d686389c5242c">jpeg_decode_subsample_t</a> vertical_subsample)</td></tr>
<tr class="separator:ga3246bd6af57284f48d8c5061257bfeed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62ffba3d7256310ec46dff12b798983e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___j_p_e_g.html#ga62ffba3d7256310ec46dff12b798983e">R_JPEG_DecodeHorizontalStrideSet</a> (<a class="el" href="group___j_p_e_g___a_p_i.html#gadcda3a404659199f5fc9b90a8eb4b543">jpeg_ctrl_t</a> *p_api_ctrl, uint32_t horizontal_stride)</td></tr>
<tr class="separator:ga62ffba3d7256310ec46dff12b798983e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d68546c7a9f31f72b96cf17086bdfe4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___j_p_e_g.html#ga3d68546c7a9f31f72b96cf17086bdfe4">R_JPEG_DecodeImageSizeGet</a> (<a class="el" href="group___j_p_e_g___a_p_i.html#gadcda3a404659199f5fc9b90a8eb4b543">jpeg_ctrl_t</a> *p_api_ctrl, uint16_t *p_horizontal_size, uint16_t *p_vertical_size)</td></tr>
<tr class="separator:ga3d68546c7a9f31f72b96cf17086bdfe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1ed6685a29aa94b4fc5a6764c72c2a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___j_p_e_g.html#gae1ed6685a29aa94b4fc5a6764c72c2a5">R_JPEG_DecodePixelFormatGet</a> (<a class="el" href="group___j_p_e_g___a_p_i.html#gadcda3a404659199f5fc9b90a8eb4b543">jpeg_ctrl_t</a> *p_api_ctrl, <a class="el" href="group___j_p_e_g___a_p_i.html#ga3aed73edf47174b12b8b99e41437d696">jpeg_color_space_t</a> *p_color_space)</td></tr>
<tr class="separator:gae1ed6685a29aa94b4fc5a6764c72c2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cff298a8d044d4a7ea04c577a9170ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___j_p_e_g.html#ga6cff298a8d044d4a7ea04c577a9170ca">R_JPEG_EncodeImageSizeSet</a> (<a class="el" href="group___j_p_e_g___a_p_i.html#gadcda3a404659199f5fc9b90a8eb4b543">jpeg_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___j_p_e_g___a_p_i.html#structjpeg__encode__image__size__t">jpeg_encode_image_size_t</a> *p_image_size)</td></tr>
<tr class="separator:ga6cff298a8d044d4a7ea04c577a9170ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab669afd6c669dabba75e3510fc9f5bda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___j_p_e_g.html#gab669afd6c669dabba75e3510fc9f5bda">R_JPEG_ModeSet</a> (<a class="el" href="group___j_p_e_g___a_p_i.html#gadcda3a404659199f5fc9b90a8eb4b543">jpeg_ctrl_t</a> *const p_api_ctrl, jpeg_mode_t mode)</td></tr>
<tr class="separator:gab669afd6c669dabba75e3510fc9f5bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b41824f40d6c66c59a6c5ad908cbdce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___j_p_e_g.html#ga0b41824f40d6c66c59a6c5ad908cbdce">R_JPEG_Close</a> (<a class="el" href="group___j_p_e_g___a_p_i.html#gadcda3a404659199f5fc9b90a8eb4b543">jpeg_ctrl_t</a> *p_api_ctrl)</td></tr>
<tr class="separator:ga0b41824f40d6c66c59a6c5ad908cbdce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d62e16ee0c22a4ca2c3853ec81c7928"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___j_p_e_g.html#ga1d62e16ee0c22a4ca2c3853ec81c7928">R_JPEG_StatusGet</a> (<a class="el" href="group___j_p_e_g___a_p_i.html#gadcda3a404659199f5fc9b90a8eb4b543">jpeg_ctrl_t</a> *p_api_ctrl, <a class="el" href="group___j_p_e_g___a_p_i.html#ga16543f6924ee246961b2d293ca92ec36">jpeg_status_t</a> *p_status)</td></tr>
<tr class="separator:ga1d62e16ee0c22a4ca2c3853ec81c7928"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the JPEG peripheral on RA MCUs. This module implements the <a class="el" href="group___j_p_e_g___a_p_i.html">JPEG Codec Interface</a>. </p>
<h1><a class="anchor" id="r-jpeg-overview"></a>
Overview</h1>
<p>The JPEG Codec is a hardware block providing accelerated JPEG image encode and decode functionality independent of the CPU. Images can optionally be partially processed facilitating streaming applications.</p>
<h2><a class="anchor" id="r-jpeg-features"></a>
Features</h2>
<p>The JPEG Codec provides a number of options useful in a variety of applications:</p>
<ul>
<li>Basic encoding and decoding<a class="anchor" id="um_jpeg_decode_baseline_jpeg_image_decompression"></a><a class="anchor" id="um_r_jpeg_encode_baseline_jpeg_image_compression"></a></li>
<li>Streaming input and/or output<a class="anchor" id="um_jpeg_decode_output_streaming"></a><a class="anchor" id="um_jpeg_decode_input_streaming"></a><a class="anchor" id="um_r_jpeg_encode_input_streaming"></a></li>
<li>Decoding JPEGs of unknown size<a class="anchor" id="um_jpeg_decode_get_jpeg_image_information"></a></li>
<li>Shrink (sub-sample) an image during the decoding process<a class="anchor" id="um_jpeg_decode_set_output_sub_sampling"></a></li>
<li>Rearrange input and output byte order (byte, word and/or longword swap)<a class="anchor" id="um_jpeg_decode_set_input_data_swap"></a><a class="anchor" id="um_jpeg_decode_set_output_data_swap"></a></li>
<li>JPEG error detection<a class="anchor" id="um_jpeg_decode_error_detection"></a></li>
</ul>
<p>The specifications for the codec are as follows:</p>
<p><a class="anchor" id="um_jpeg_decode_output_format_argb8888"></a><a class="anchor" id="um_jpeg_decode_output_format_rgb565"></a><a class="anchor" id="um_jpeg_decode_get_jpeg_pixel_format_ycbcr"></a><a class="anchor" id="um_jpeg_decode_input_format_ycbcr444"></a><a class="anchor" id="um_jpeg_decode_input_format_ycbcr420"></a><a class="anchor" id="um_jpeg_decode_input_format_ycbcr411"></a><a class="anchor" id="um_jpeg_decode_input_format_ycbcr422"></a><a class="anchor" id="um_jpeg_decode_event_notification"></a><a class="anchor" id="um_jpeg_decode_get_status"></a><a class="anchor" id="um_jpeg_decode_set_memory_stride"></a><a class="anchor" id="um_jpeg_decode_get_pixel_format_of_jpeg_image"></a><a class="anchor" id="um_jpeg_decode_oversize_image_width_detection"></a><a class="anchor" id="um_jpeg_decode_set_alpha_channel_in_output_rgb_data"></a><a class="anchor" id="um_jpeg_decode_get_number_of_decoded_lines"></a> <a class="anchor" id="um_r_jpeg_encode_input_image_address_setting"></a><a class="anchor" id="um_r_jpeg_encode_quantization_and_huffman_table_initialization"></a><a class="anchor" id="um_r_jpeg_encode_image_output_address"></a><a class="anchor" id="um_r_jpeg_encode_image_parameter_setting"></a> <a class="anchor" id="um_r_jpeg_mode_selection"></a> </p><table class="doxtable">
<tr>
<th>Feature </th><th>Options  </th></tr>
<tr>
<td>Decompression input formats </td><td>Baseline JPEG Y'CbCr 4:4:4, 4:2:2, 4:2:0 and 4:1:1 </td></tr>
<tr>
<td>Decompression output formats </td><td>ARGB8888, RGB565 </td></tr>
<tr>
<td>Compression input formats </td><td>Raw Y'CbCr 4:2:2 only </td></tr>
<tr>
<td>Compression output formats </td><td>Baseline JPEG Y'CbCr 4:2:2 only </td></tr>
<tr>
<td>Byte reordering </td><td>Byte, halfword and/or word swapping on input and output </td></tr>
<tr>
<td>Interrupt sources </td><td>Image size acquired, input/output data pause, decode complete, error </td></tr>
<tr>
<td>Compatible image sizes </td><td>See <a class="el" href="group___j_p_e_g.html#r-jpeg-limitations-mcu">Minimum Coded Unit (MCU)</a> below </td></tr>
</table>
<h1><a class="anchor" id="r-jpeg-configuration"></a>
Configuration</h1>
<p><h2>Build Time Configurations for r_jpeg</h2>
The following build time configurations are defined in fsp_cfg/r_jpeg_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected, code for parameter checking is included in the build. </td></tr>
<tr class="tree_none">
<td>Decode Support</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>If selected, code for decoding JPEG images is included in the build. </td></tr>
<tr class="tree_none">
<td>Encode Support</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>If selected, code for encoding JPEG images is included in the build. </td></tr>
</table>
</p>
<p><h2>Configurations for Graphics &gt; JPEG Codec (r_jpeg)</h2>
This module can be added to the Stacks tab via New Stack &gt; Graphics &gt; JPEG Codec (r_jpeg).<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> General  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Name</td><td>Name must be a valid C symbol</td><td>g_jpeg0 </td><td>Module name. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Default mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Decode</li>
<li>
Encode</li>
</ul>
</td><td>Decode </td><td>Set the mode to use when calling R_JPEG_Open. This parameter is only used when both Encode and Decode support are enabled. </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Decode  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Input byte order</td><td>MCU Specific Options</td><td></td><td>Select the byte order of the input data for decoding. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Output byte order</td><td>MCU Specific Options</td><td></td><td>Select the byte order of the output data for decoding. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Output color format</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
ARGB8888 (32-bit)</li>
<li>
RGB565 (16-bit)</li>
</ul>
</td><td>RGB565 (16-bit) </td><td>Select the output pixel format for decode operations. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Output alpha (ARGB8888 only)</td><td>Value must be an 8-bit integer (0-255)</td><td>255 </td><td>Specify the alpha value to apply to each output pixel when ARGB8888 format is chosen. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Callback</td><td>Name must be a valid C symbol</td><td>NULL </td><td>If a callback function is provided it will be called from the interrupt service routine (ISR) each time a related IRQ triggers. </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Encode  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Horizontal resolution</td><td>Value cannot be greater than 65535 and must be a non-negative integer divisible by 16</td><td>480 </td><td>Horizontal resolution of the raw image (in pixels). This value can be configured at runtime via R_JPEG_ImageSizeSet. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Vertical resolution</td><td>Value cannot be greater than 65535 and must be a non-negative integer divisible by 8</td><td>272 </td><td>Vertical resolution of the raw image. This value can be configured at runtime via R_JPEG_ImageSizeSet. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Horizontal stride</td><td>Value cannot be greater than 65535 and must be a non-negative integer</td><td>480 </td><td>Horizontal stride of the raw image buffer (in pixels). This value can be configured at runtime via R_JPEG_ImageSizeSet. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Input byte order</td><td>MCU Specific Options</td><td></td><td>Select the byte order of the input data for encoding. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Output byte order</td><td>MCU Specific Options</td><td></td><td>Select the byte order of the output data for encoding. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Reset interval</td><td>Value cannot be greater than 65535 and must be a non-negative integer</td><td>512 </td><td>Set the number of MCUs between RST markers. A value of 0 will disable DRI and RST marker output. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Quality factor</td><td>Value must be between 1 and 100 and must be an integer</td><td>50 </td><td>Set the quality factor for encoding (1-100). Lower values produce smaller images at the cost of image quality. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Callback</td><td>Name must be a valid C symbol</td><td>NULL </td><td>If a callback function is provided it will be called from the interrupt service routine (ISR) each time a related IRQ triggers. </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Interrupts  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Decode Process Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select the decompression interrupt priority. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Data Transfer Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select the data transfer interrupt priority. </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-jpeg-clock-configuration"></a>
Clock Configuration</h2>
<p>The peripheral clock for this module is PCLKA. No clocks are provided by this module.</p>
<h2><a class="anchor" id="r-jpeg-pin-configuration"></a>
Pin Configuration</h2>
<p>This module does not have any input or output pin connections. </p><hr/>
<h1><a class="anchor" id="r-jpeg-usage_notes"></a>
Usage Notes</h1>
<h2><a class="anchor" id="r-jpeg-usage_overview"></a>
Overview</h2>
<p>The JPEG Codec contains both decode and encode hardware. While these two functions are largely independent in configuration only one can be used at a time.</p>
<p>To switch from decode to encode mode (or vice versa) use <a class="el" href="group___j_p_e_g.html#gab669afd6c669dabba75e3510fc9f5bda">R_JPEG_ModeSet</a> while the JPEG Codec is idle.</p>
<h2><a class="anchor" id="r-jpeg-status"></a>
Status</h2>
<p>The status value (<a class="el" href="group___j_p_e_g___a_p_i.html#ga16543f6924ee246961b2d293ca92ec36">jpeg_status_t</a>) provided by the callback and by <a class="el" href="group___j_p_e_g.html#ga1d62e16ee0c22a4ca2c3853ec81c7928">R_JPEG_StatusGet</a> is a bitfield that encompasses all potential status indication conditions. One or more statuses can be set simultaneously.</p>
<h2><a class="anchor" id="r-jpeg-decode"></a>
Decoding Process</h2>
<p>JPEG decoding can be performed in several ways depending on the application:</p>
<ul>
<li>To perform the simplest decode operation where all dimensions are known:<ul>
<li>Set the input buffer, stride and output buffer then wait for a callback with status <a class="el" href="group___j_p_e_g___a_p_i.html#gga16543f6924ee246961b2d293ca92ec36ac90637a7c3ea7d4867526c51249fac4d">JPEG_STATUS_OPERATION_COMPLETE</a>.</li>
</ul>
</li>
<li>To pause after decoding the JPEG header (in order to acquire image dimensions and secure an output buffer):<ul>
<li>Call <a class="el" href="group___j_p_e_g.html#gaaed65a4fe2f87a3c30dc817d311056f0">R_JPEG_InputBufferSet</a> before setting the output buffer and wait for a callback with status <a class="el" href="group___j_p_e_g___a_p_i.html#gga16543f6924ee246961b2d293ca92ec36a6da7cb3ae07290d77d5257f07032ae50">JPEG_STATUS_IMAGE_SIZE_READY</a>.</li>
</ul>
</li>
<li>To decode a partial JPEG image then pause until the next chunk is available:<ul>
<li>Specify a size smaller than the full JPEG data when calling <a class="el" href="group___j_p_e_g.html#gaaed65a4fe2f87a3c30dc817d311056f0">R_JPEG_InputBufferSet</a>.</li>
</ul>
</li>
<li>To pause decoding once an output buffer is filled:<ul>
<li>Specify a size smaller than the full decoded image when calling <a class="el" href="group___j_p_e_g.html#ga6d304aad5fbb148f8bd7ed71f878e53d">R_JPEG_OutputBufferSet</a>.</li>
</ul>
</li>
</ul>
<p>The flowchart below illustrates the steps necessary to handle any decode operation. The statuses given in <span style="color:blue">blue</span> are part of <a class="el" href="group___j_p_e_g___a_p_i.html#ga16543f6924ee246961b2d293ca92ec36">jpeg_status_t</a> with the JPEG_DECODE_STATUS prefix omitted.</p>
<div class="image">
<object type="image/svg+xml" data="decode_flowchart.svg">decode_flowchart.svg</object>
<div class="caption">
JPEG Decode Operational Flow</div></div>
 <h2><a class="anchor" id="r-jpeg-encode"></a>
Encoding Process</h2>
<p>As compared to decoding, encoding is fairly straightforward. The only option available is to stream input data if desired. The flowchart below details the steps needed to compress an image.</p>
<div class="image">
<object type="image/svg+xml" data="encode_flowchart.svg">encode_flowchart.svg</object>
<div class="caption">
JPEG Encode Operational Flow</div></div>
 <h2><a class="anchor" id="r-jpeg-failures"></a>
Handling Failed Operations</h2>
<p>If an encode or decode operation fails or times out while the codec is running, the peripheral must be reset before it is used again. To reset the JPEG Codec simply close and re-open the module by calling <a class="el" href="group___j_p_e_g.html#ga0b41824f40d6c66c59a6c5ad908cbdce">R_JPEG_Close</a> followed by <a class="el" href="group___j_p_e_g.html#ga34766994da3769a1f5cd3e7f22652b43">R_JPEG_Open</a>.</p>
<h2><a class="anchor" id="r-jpeg-limitations"></a>
Limitations</h2>
<p>Developers should be aware of the following limitations when using the JPEG API.</p>
<h3><a class="anchor" id="r-jpeg-limitations-mcu"></a>
Minimum Coded Unit (MCU)</h3>
<p>The JPEG Codec can only correctly process images that are an even increment of minimum coded units (MCUs). In other words, depending on the format the width and height of an image to be encoded or decoded must be divisible by the following:</p>
<table class="doxtable">
<tr>
<th>Format </th><th>Horizontal </th><th>Vertical  </th></tr>
<tr>
<td>Y'CbCr 4:4:4 </td><td>8 pixels </td><td>8 lines </td></tr>
<tr>
<td>Y'CbCr 4:2:2 </td><td>16 pixels </td><td>8 lines </td></tr>
<tr>
<td>Y'CbCr 4:1:1 </td><td>32 pixels </td><td>8 lines </td></tr>
<tr>
<td>Y'CbCr 4:2:0 </td><td>16 pixels </td><td>16 lines </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Because encoding is limited to Y'CbCr 4:2:2, raw pixel input data must always be in whole increments of 16x8 pixels.</dd></dl>
<h3><a class="anchor" id="r-jpeg-limitations-encode-format"></a>
Encoding Input Format</h3>
<p>The encoding unit only supports Y'CbCr 4:2:2 input. Raw RGB888 data can be converted to this format as follows:</p>
<div class="fragment"><div class="line"></div><div class="line">    y  =       (0.299000f * r) + (0.587000f * g) + (0.114000f * b);</div><div class="line">    cb = 128 - (0.168736f * r) - (0.331264f * g) + (0.500000f * b);</div><div class="line">    cr = 128 + (0.500000f * r) - (0.418688f * g) - (0.081312f * b);</div><div class="line"></div></div><!-- fragment --><p> While these equations are mathematically simple they do use the floating-point unit. To speed things up we can multiply the coefficients by 256 and divide the sum by 256...</p>
<div class="fragment"><div class="line"></div><div class="line">    y  =       ((76.5440f * r) + (150.272f * g) + (29.1840f * b)) / 256;</div><div class="line">    cb = 128 - ((43.1964f * r) - (84.8036f * g) + (128.000f * b)) / 256;</div><div class="line">    cr = 128 + ((128.000f * r) - (107.184f * g) - (20.8159f * b)) / 256;</div><div class="line"></div></div><!-- fragment --><p> ...which allows the formulas to be calculated entirely with shifts and addition (coefficients rounded to the nearest integer):</p>
<div class="fragment"><div class="line"></div><div class="line">    y  =       (   (r &lt;&lt; 6) + (r &lt;&lt; 3) + (r &lt;&lt; 2) + r</div><div class="line">                 + (g &lt;&lt; 7) + (g &lt;&lt; 4) + (g &lt;&lt; 2) + (g &lt;&lt; 1)</div><div class="line">                 + (b &lt;&lt; 4) + (b &lt;&lt; 3) + (b &lt;&lt; 2) + b</div><div class="line">               ) &gt;&gt; 8;</div><div class="line"></div><div class="line">    cb = 128 - (   (r &lt;&lt; 5) + (r &lt;&lt; 3) + (r &lt;&lt; 1) + r</div><div class="line">                 + (g &lt;&lt; 6) + (g &lt;&lt; 4) + (g &lt;&lt; 2) + g</div><div class="line">                 - (b &lt;&lt; 7)</div><div class="line">               ) &gt;&gt; 8;</div><div class="line"></div><div class="line">    cr = 128 + (   (r &lt;&lt; 7)</div><div class="line">                 - (g &lt;&lt; 6) - (g &lt;&lt; 5) - (g &lt;&lt; 3) - (g &lt;&lt; 1) - g</div><div class="line">                 - (b &lt;&lt; 4) - (b &lt;&lt; 2) - b)</div><div class="line">               ) &gt;&gt; 8;</div><div class="line"></div></div><!-- fragment --><p> To compose the final Y'CbCr 4:2:2 data the chroma of every two pixels must be averaged. <b>In addition, the JPEG Codec expects chrominance values to be in the range -127..127 instead of the standard 1..255.</b></p>
<div class="fragment"><div class="line"></div><div class="line">    cb = (uint8_t) ((int8_t) ((cb0 + cb1 + 1) &gt;&gt; 1) - 128);</div><div class="line">    cr = (uint8_t) ((int8_t) ((cr0 + cr1 + 1) &gt;&gt; 1) - 128);</div><div class="line"></div></div><!-- fragment --><p> Finally, the below equation composes two 4:2:2 output pixels at a time with standard byte order (<code>JPEG_DATA_ORDER_NORMAL</code>):</p>
<div class="fragment"><div class="line"></div><div class="line">    out = y0 + (cb &lt;&lt; 8) + (y1 &lt;&lt; 16) + (cr &lt;&lt; 24);</div><div class="line"></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>RGB565 pixels must be upscaled to RGB888 before using the above formulas. Refer to the below example on <a class="el" href="group___j_p_e_g.html#r-jpeg-examples-ycbcr">Y'CbCr Conversion</a> for implementation details.</dd></dl>
<h1><a class="anchor" id="r-jpeg-examples"></a>
Examples</h1>
<h2><a class="anchor" id="r-jpeg-examples-decode"></a>
Basic Decode Example</h2>
<p>This is a basic example showing the minimum code required to initialize the JPEG Codec and decode an image.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> jpeg_decode_basic (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err;</div><div class="line"></div><div class="line">    <span class="comment">/* Open JPEG Codec */</span></div><div class="line">    err = <a class="code" href="group___j_p_e_g.html#ga34766994da3769a1f5cd3e7f22652b43">R_JPEG_Open</a>(&amp;g_jpeg_ctrl, &amp;g_jpeg_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Set input buffer */</span></div><div class="line">    err = <a class="code" href="group___j_p_e_g.html#gaaed65a4fe2f87a3c30dc817d311056f0">R_JPEG_InputBufferSet</a>(&amp;g_jpeg_ctrl, JPEG_PTR, JPEG_SIZE_BYTES);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Set horizontal stride of output buffer */</span></div><div class="line">    err = <a class="code" href="group___j_p_e_g.html#ga62ffba3d7256310ec46dff12b798983e">R_JPEG_DecodeHorizontalStrideSet</a>(&amp;g_jpeg_ctrl, JPEG_HSIZE);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Set output buffer */</span></div><div class="line">    err = <a class="code" href="group___j_p_e_g.html#ga6d304aad5fbb148f8bd7ed71f878e53d">R_JPEG_OutputBufferSet</a>(&amp;g_jpeg_ctrl, decode_buffer, <span class="keyword">sizeof</span>(decode_buffer));</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for decode completion */</span></div><div class="line">    <a class="code" href="group___j_p_e_g___a_p_i.html#ga16543f6924ee246961b2d293ca92ec36">jpeg_status_t</a> status = (<a class="code" href="group___j_p_e_g___a_p_i.html#ga16543f6924ee246961b2d293ca92ec36">jpeg_status_t</a>) 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (!(status &amp; (<a class="code" href="group___j_p_e_g___a_p_i.html#gga16543f6924ee246961b2d293ca92ec36ac90637a7c3ea7d4867526c51249fac4d">JPEG_STATUS_OPERATION_COMPLETE</a> | <a class="code" href="group___j_p_e_g___a_p_i.html#gga16543f6924ee246961b2d293ca92ec36a3a0763f9ec7b19a9d9165413a8422cf6">JPEG_STATUS_ERROR</a>)))</div><div class="line">    {</div><div class="line">        err = <a class="code" href="group___j_p_e_g.html#ga1d62e16ee0c22a4ca2c3853ec81c7928">R_JPEG_StatusGet</a>(&amp;g_jpeg_ctrl, &amp;status);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="r-jpeg-examples-decode-streaming"></a>
Streaming Input/Output Example</h2>
<p>In this example JPEG data is read in 512-byte chunks. Decoding is paused when a chunk is read and once the JPEG header is decoded. The image is decoded 16 lines at a time.</p>
<dl class="section note"><dt>Note</dt><dd>Streaming is always bypassed when a given buffer's size encompasses the entire input or output image, respectively. Though this example decodes via smaller chunks the input and output data are still contiguous for ease of demonstration. Refer to the comments for further insight as to how to implement streaming with different JPEG/output buffer size combinations.</dd></dl>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define JPEG_INPUT_SIZE_BYTES    512U</span></div><div class="line"></div><div class="line"><span class="comment">/* JPEG Codec status */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <a class="code" href="group___j_p_e_g___a_p_i.html#ga16543f6924ee246961b2d293ca92ec36">jpeg_status_t</a> g_jpeg_status = <a class="code" href="group___j_p_e_g___a_p_i.html#gga16543f6924ee246961b2d293ca92ec36abba794c803930866203bfe367642df25">JPEG_STATUS_NONE</a>;</div><div class="line"></div><div class="line"><span class="comment">/* JPEG event flag */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> uint8_t jpeg_event = 0;</div><div class="line"></div><div class="line"><span class="comment">/* Callback function for JPEG decode interrupts */</span></div><div class="line"><span class="keywordtype">void</span> jpeg_decode_callback (<a class="code" href="group___j_p_e_g___a_p_i.html#structjpeg__callback__args__t">jpeg_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="comment">/* Get JPEG Codec status */</span></div><div class="line">    g_jpeg_status = p_args-&gt;<a class="code" href="group___j_p_e_g___a_p_i.html#a5e74ded10676c413e76915719eac3c91">status</a>;</div><div class="line"></div><div class="line">    <span class="comment">/* Set JPEG flag */</span></div><div class="line">    jpeg_event = 1;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Simple wait that returns 1 if no event happened within the timeout period */</span></div><div class="line"><span class="keyword">static</span> uint8_t jpeg_event_wait (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint32_t timeout_timer = JPEG_EVENT_TIMEOUT;</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (!jpeg_event &amp;&amp; --timeout_timer)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Spin here until an event callback or timeout */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    jpeg_event = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> timeout_timer ? 0 : 1;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Decode a JPEG image to a buffer using streaming input and output */</span></div><div class="line"><span class="keywordtype">void</span> jpeg_decode_streaming (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint8_t     * p_jpeg  = (uint8_t *) JPEG_PTR;</div><div class="line">    <a class="code" href="group___j_p_e_g___a_p_i.html#ga16543f6924ee246961b2d293ca92ec36">jpeg_status_t</a> status  = (<a class="code" href="group___j_p_e_g___a_p_i.html#ga16543f6924ee246961b2d293ca92ec36">jpeg_status_t</a>) 0;</div><div class="line">    uint8_t       timeout = 0;</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>     err;</div><div class="line"></div><div class="line">    <span class="comment">/* Number of input bytes to read at a time */</span></div><div class="line">    uint32_t input_bytes = JPEG_INPUT_SIZE_BYTES;</div><div class="line"></div><div class="line">    <span class="comment">/* Open JPEG unit and start decode */</span></div><div class="line">    err = <a class="code" href="group___j_p_e_g.html#ga34766994da3769a1f5cd3e7f22652b43">R_JPEG_Open</a>(&amp;g_jpeg_ctrl, &amp;g_jpeg_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (!(status &amp; <a class="code" href="group___j_p_e_g___a_p_i.html#gga16543f6924ee246961b2d293ca92ec36a3a0763f9ec7b19a9d9165413a8422cf6">JPEG_STATUS_ERROR</a>) &amp;&amp; !timeout)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Set the input buffer to read `input_bytes` bytes at a time */</span></div><div class="line">        err = <a class="code" href="group___j_p_e_g.html#gaaed65a4fe2f87a3c30dc817d311056f0">R_JPEG_InputBufferSet</a>(&amp;g_jpeg_ctrl, p_jpeg, input_bytes);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">        <span class="comment">/* This delay is required for streaming input mode to function correctly.</span></div><div class="line"><span class="comment">         * (Without this delay the JPEG Codec will not correctly locate markers in the file header.) */</span></div><div class="line">        <a class="code" href="group___b_s_p___m_c_u.html#gaf3219448adfd1531cf69f68697ab184b">R_BSP_SoftwareDelay</a>(10, <a class="code" href="group___b_s_p___m_c_u.html#ggafd98e2a6f080d6a52a3ef72e3d731b2baa0312618f2508347a9a815b5887c12ae">BSP_DELAY_UNITS_MICROSECONDS</a>);</div><div class="line"></div><div class="line">        <span class="comment">/* Wait for a callback */</span></div><div class="line">        timeout = jpeg_event_wait();</div><div class="line"></div><div class="line">        <span class="comment">/* Get the status from the callback */</span></div><div class="line">        status = g_jpeg_status;</div><div class="line"></div><div class="line">        <span class="comment">/* Break if the header has finished decoding */</span></div><div class="line">        <span class="keywordflow">if</span> (status &amp; <a class="code" href="group___j_p_e_g___a_p_i.html#gga16543f6924ee246961b2d293ca92ec36a6da7cb3ae07290d77d5257f07032ae50">JPEG_STATUS_IMAGE_SIZE_READY</a>)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Move pointer to next block of input data (if needed) */</span></div><div class="line">        p_jpeg = (uint8_t *) ((uint32_t) p_jpeg + input_bytes);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Get image size */</span></div><div class="line">    uint16_t horizontal;</div><div class="line">    uint16_t vertical;</div><div class="line">    err = <a class="code" href="group___j_p_e_g.html#ga3d68546c7a9f31f72b96cf17086bdfe4">R_JPEG_DecodeImageSizeGet</a>(&amp;g_jpeg_ctrl, &amp;horizontal, &amp;vertical);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Prepare output data buffer here if needed (already allocated in this example) */</span></div><div class="line">    uint8_t * p_output = decode_buffer;</div><div class="line"></div><div class="line">    <span class="comment">/* Set horizontal stride */</span></div><div class="line">    err = <a class="code" href="group___j_p_e_g.html#ga62ffba3d7256310ec46dff12b798983e">R_JPEG_DecodeHorizontalStrideSet</a>(&amp;g_jpeg_ctrl, horizontal);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Calculate the number of bytes that will fit in the buffer (16 lines in this example) */</span></div><div class="line">    uint32_t output_size = horizontal * 16U * 4U;</div><div class="line"></div><div class="line">    <span class="comment">/* Start decoding by setting the output buffer */</span></div><div class="line">    err = <a class="code" href="group___j_p_e_g.html#ga6d304aad5fbb148f8bd7ed71f878e53d">R_JPEG_OutputBufferSet</a>(&amp;g_jpeg_ctrl, p_output, output_size);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (!(status &amp; JPEG_STATUS_ERROR) &amp;&amp; !timeout)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait for a callback */</span></div><div class="line">        timeout = jpeg_event_wait();</div><div class="line"></div><div class="line">        <span class="comment">/* Get the status from the callback */</span></div><div class="line">        status = g_jpeg_status;</div><div class="line"></div><div class="line">        <span class="comment">/* Break if decoding is complete */</span></div><div class="line">        <span class="keywordflow">if</span> (status &amp; <a class="code" href="group___j_p_e_g___a_p_i.html#gga16543f6924ee246961b2d293ca92ec36ac90637a7c3ea7d4867526c51249fac4d">JPEG_STATUS_OPERATION_COMPLETE</a>)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (status &amp; <a class="code" href="group___j_p_e_g___a_p_i.html#gga16543f6924ee246961b2d293ca92ec36a5394271c79d092343320eb5abdf824d3">JPEG_STATUS_OUTPUT_PAUSE</a>)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Draw the JPEG work buffer to the framebuffer here (if needed) */</span></div><div class="line"></div><div class="line">            <span class="comment">/* Move pointer to next block of output data (if needed) */</span></div><div class="line">            p_output += output_size;</div><div class="line"></div><div class="line">            <span class="comment">/* Set the output buffer to the next 16-line block */</span></div><div class="line">            err = <a class="code" href="group___j_p_e_g.html#ga6d304aad5fbb148f8bd7ed71f878e53d">R_JPEG_OutputBufferSet</a>(&amp;g_jpeg_ctrl, p_output, output_size);</div><div class="line">            assert(FSP_SUCCESS == err);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (status &amp; <a class="code" href="group___j_p_e_g___a_p_i.html#gga16543f6924ee246961b2d293ca92ec36aaf5d858b56dc734e60bc429a5dbe7427">JPEG_STATUS_INPUT_PAUSE</a>)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Get next block of input data */</span></div><div class="line">            p_jpeg = (uint8_t *) ((uint32_t) p_jpeg + input_bytes);</div><div class="line"></div><div class="line">            <span class="comment">/* Set the new input buffer pointer */</span></div><div class="line">            err = <a class="code" href="group___j_p_e_g.html#gaaed65a4fe2f87a3c30dc817d311056f0">R_JPEG_InputBufferSet</a>(&amp;g_jpeg_ctrl, p_jpeg, input_bytes);</div><div class="line">            assert(FSP_SUCCESS == err);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Close driver to allow encode operations if needed */</span></div><div class="line">    err = <a class="code" href="group___j_p_e_g.html#ga0b41824f40d6c66c59a6c5ad908cbdce">R_JPEG_Close</a>(&amp;g_jpeg_ctrl);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="r-jpeg-examples-encode"></a>
Encode Example</h2>
<p>This is a basic example showing the minimum code required to initialize the JPEG Codec and encode an image.</p>
<dl class="section note"><dt>Note</dt><dd>This example assumes image dimensions are provided in the configuration. If this is not the case, <a class="el" href="group___j_p_e_g.html#ga6cff298a8d044d4a7ea04c577a9170ca">R_JPEG_EncodeImageSizeSet</a> must be used to set the size before calling <a class="el" href="group___j_p_e_g.html#gaaed65a4fe2f87a3c30dc817d311056f0">R_JPEG_InputBufferSet</a>.</dd></dl>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> jpeg_encode_basic (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err;</div><div class="line"></div><div class="line">    <span class="comment">/* Open JPEG Codec */</span></div><div class="line">    err = <a class="code" href="group___j_p_e_g.html#ga34766994da3769a1f5cd3e7f22652b43">R_JPEG_Open</a>(&amp;g_jpeg_ctrl, &amp;g_jpeg_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Set output buffer */</span></div><div class="line">    err = <a class="code" href="group___j_p_e_g.html#ga6d304aad5fbb148f8bd7ed71f878e53d">R_JPEG_OutputBufferSet</a>(&amp;g_jpeg_ctrl, jpeg_buffer, <span class="keyword">sizeof</span>(jpeg_buffer));</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Set input buffer */</span></div><div class="line">    err = <a class="code" href="group___j_p_e_g.html#gaaed65a4fe2f87a3c30dc817d311056f0">R_JPEG_InputBufferSet</a>(&amp;g_jpeg_ctrl, RAW_YCBCR_IMAGE_PTR, IMAGE_SIZE_BYTES);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for decode completion */</span></div><div class="line">    <a class="code" href="group___j_p_e_g___a_p_i.html#ga16543f6924ee246961b2d293ca92ec36">jpeg_status_t</a> status = (<a class="code" href="group___j_p_e_g___a_p_i.html#ga16543f6924ee246961b2d293ca92ec36">jpeg_status_t</a>) 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (!(status &amp; JPEG_STATUS_OPERATION_COMPLETE))</div><div class="line">    {</div><div class="line">        err = <a class="code" href="group___j_p_e_g.html#ga1d62e16ee0c22a4ca2c3853ec81c7928">R_JPEG_StatusGet</a>(&amp;g_jpeg_ctrl, &amp;status);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="r-jpeg-examples-streaming"></a>
Streaming Encode Example</h2>
<p>In this example the raw input data is provided in smaller chunks. This can help significantly reduce buffer size and improve throughput when streaming in raw data from an outside source.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">/* Callback function for JPEG encode interrupts */</span></div><div class="line"><span class="keywordtype">void</span> jpeg_encode_callback (<a class="code" href="group___j_p_e_g___a_p_i.html#structjpeg__callback__args__t">jpeg_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="comment">/* Get JPEG Codec status */</span></div><div class="line">    g_jpeg_status = p_args-&gt;<a class="code" href="group___j_p_e_g___a_p_i.html#a5e74ded10676c413e76915719eac3c91">status</a>;</div><div class="line"></div><div class="line">    <span class="comment">/* Set JPEG flag */</span></div><div class="line">    jpeg_event = 1;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> jpeg_encode_streaming (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint8_t   timeout = 0;</div><div class="line">    uint8_t * p_chunk = (uint8_t *) RAW_YCBCR_IMAGE_PTR;</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err;</div><div class="line"></div><div class="line">    <span class="comment">/* Open JPEG Codec */</span></div><div class="line">    err = <a class="code" href="group___j_p_e_g.html#ga34766994da3769a1f5cd3e7f22652b43">R_JPEG_Open</a>(&amp;g_jpeg_ctrl, &amp;g_jpeg_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Set output buffer */</span></div><div class="line">    err = <a class="code" href="group___j_p_e_g.html#ga6d304aad5fbb148f8bd7ed71f878e53d">R_JPEG_OutputBufferSet</a>(&amp;g_jpeg_ctrl, jpeg_buffer, <span class="keyword">sizeof</span>(jpeg_buffer));</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Set the image size */</span></div><div class="line">    <a class="code" href="group___j_p_e_g___a_p_i.html#structjpeg__encode__image__size__t">jpeg_encode_image_size_t</a> image_size;</div><div class="line"></div><div class="line">    image_size.<a class="code" href="group___j_p_e_g___a_p_i.html#a8bb383e5229bca70346d4018eaea2458">horizontal_resolution</a>    = X_RESOLUTION;</div><div class="line">    image_size.<a class="code" href="group___j_p_e_g___a_p_i.html#a46d7f920adfd6dc7144b8672decf7b79">vertical_resolution</a>      = Y_RESOLUTION;</div><div class="line">    image_size.<a class="code" href="group___j_p_e_g___a_p_i.html#a486d9445ff9e5ef2418ebc11e831aae5">horizontal_stride_pixels</a> = H_STRIDE;</div><div class="line"></div><div class="line">    err = <a class="code" href="group___j_p_e_g.html#ga6cff298a8d044d4a7ea04c577a9170ca">R_JPEG_EncodeImageSizeSet</a>(&amp;g_jpeg_ctrl, &amp;image_size);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Calculate the size of the input data chunk (16 lines in this example) */</span></div><div class="line">    uint32_t chunk_size = H_STRIDE * 16U * YCBCR_BYTES_PER_PIXEL;</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (!timeout)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Set the input buffer */</span></div><div class="line">        err = <a class="code" href="group___j_p_e_g.html#gaaed65a4fe2f87a3c30dc817d311056f0">R_JPEG_InputBufferSet</a>(&amp;g_jpeg_ctrl, p_chunk, chunk_size);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">        <span class="comment">/* Wait for a callback */</span></div><div class="line">        timeout = jpeg_event_wait();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (g_jpeg_status &amp; JPEG_STATUS_OPERATION_COMPLETE)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Encode complete */</span></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (g_jpeg_status &amp; JPEG_STATUS_INPUT_PAUSE)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Load next block of input data here (if needed) */</span></div><div class="line">            p_chunk += chunk_size;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="r-jpeg-examples-ycbcr"></a>
Y'CbCr Conversion</h2>
<p>The below function is provided as a reference for how to convert RGB values to Y'CbCr for use with the JPEG Codec.</p>
<dl class="section note"><dt>Note</dt><dd>This function is only partially optimized for clarity. Further appllication-specific size- or speed-based optimizations should be considered when implementing in an actual project.</dd></dl>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define RGB565_G_MASK    0x07E0</span></div><div class="line"><span class="preprocessor">#define RGB565_B_MASK    0x001F</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define C_0              128</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> e_pixel_format</div><div class="line">{</div><div class="line">    PIXEL_FORMAT_ARGB8888,</div><div class="line">    PIXEL_FORMAT_RGB565</div><div class="line">} pixel_format_t;</div><div class="line"></div><div class="line"><span class="comment">/* 5-bit to 8-bit LUT */</span></div><div class="line"><span class="keyword">const</span> uint8_t lut_32[] =</div><div class="line">{</div><div class="line">    0,   8,   16,  25,  33,  41,  49,  58,</div><div class="line">    66,  74,  82,  90,  99,  107, 115, 123,</div><div class="line">    132, 140, 148, 156, 165, 173, 181, 189,</div><div class="line">    197, 206, 214, 222, 230, 239, 247, 255</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* 6-bit to 8-bit LUT */</span></div><div class="line"><span class="keyword">const</span> uint8_t lut_64[] =</div><div class="line">{</div><div class="line">    0,   4,   8,   12,  16,  20,  24,  28,</div><div class="line">    32,  36,  40,  45,  49,  53,  57,  61,</div><div class="line">    65,  69,  73,  77,  81,  85,  89,  93,</div><div class="line">    97,  101, 105, 109, 113, 117, 121, 125,</div><div class="line">    130, 134, 138, 142, 146, 150, 154, 158,</div><div class="line">    162, 166, 170, 174, 178, 182, 186, 190,</div><div class="line">    194, 198, 202, 206, 210, 215, 219, 223,</div><div class="line">    227, 231, 235, 239, 243, 247, 251, 255</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> bitmap_rgb2ycbcr(uint32_t * out, uint8_t * in, uint32_t len, pixel_format_t format);</div><div class="line"></div><div class="line"><span class="comment">/***********************************************************************************************************************</span></div><div class="line"><span class="comment"> * Convert an RGB buffer to Y&#39;CbCr 4:2:2.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * NOTE: The width (in pixels) of the image to be converted must be divisible by 2.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Parameters:</span></div><div class="line"><span class="comment"> *   out       Pointer to output buffer</span></div><div class="line"><span class="comment"> *   in        Pointer to input buffer</span></div><div class="line"><span class="comment"> *   len       Length of input buffer (in pixels)</span></div><div class="line"><span class="comment"> *   format    Input buffer format (ARGB8888 or RGB565)</span></div><div class="line"><span class="comment"> **********************************************************************************************************************/</span></div><div class="line"><span class="keywordtype">void</span> bitmap_rgb2ycbcr (uint32_t * out, uint8_t * in, uint32_t len, pixel_format_t format)</div><div class="line">{</div><div class="line">    uint16_t in0;</div><div class="line">    uint16_t in1;</div><div class="line"></div><div class="line">    uint32_t r0;</div><div class="line">    uint32_t g0;</div><div class="line">    uint32_t b0;</div><div class="line">    uint32_t r1;</div><div class="line">    uint32_t g1;</div><div class="line">    uint32_t b1;</div><div class="line"></div><div class="line">    uint8_t y0;</div><div class="line">    uint8_t y1;</div><div class="line">    uint8_t cb0;</div><div class="line">    uint8_t cr0;</div><div class="line">    uint8_t cb1;</div><div class="line">    uint8_t cr1;</div><div class="line"></div><div class="line">    <span class="comment">/* Divide length by 2 as we&#39;re working with two pixels at a time */</span></div><div class="line">    len &gt;&gt;= 1;</div><div class="line"></div><div class="line">    <span class="comment">/* Perform the conversion */</span></div><div class="line">    <span class="keywordflow">while</span> (len)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Get R, G and B channel values */</span></div><div class="line">        <span class="keywordflow">if</span> (format == PIXEL_FORMAT_RGB565)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Get next two 16-bit values */</span></div><div class="line">            in0 = *((uint16_t *) in);</div><div class="line">            in += 2;</div><div class="line">            in1 = *((uint16_t *) in);</div><div class="line">            in += 2;</div><div class="line"></div><div class="line">            <span class="comment">/* Decompose into individual channels */</span></div><div class="line">            r0 = in0 &gt;&gt; 11;</div><div class="line">            g0 = (in0 &amp; RGB565_G_MASK) &gt;&gt; 5;</div><div class="line">            b0 = in0 &amp; RGB565_B_MASK;</div><div class="line">            r1 = in1 &gt;&gt; 11;</div><div class="line">            g1 = (in1 &amp; RGB565_G_MASK) &gt;&gt; 5;</div><div class="line">            b1 = in1 &amp; RGB565_B_MASK;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            <span class="comment">/* Get each ARGB8888 channel in sequence, skipping alpha */</span></div><div class="line">            b0 = *in++;</div><div class="line">            g0 = *in++;</div><div class="line">            r0 = *in++;</div><div class="line">            in++;</div><div class="line">            b1 = *in++;</div><div class="line">            g1 = *in++;</div><div class="line">            r1 = *in++;</div><div class="line">            in++;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Convert RGB565 data to RGB888 */</span></div><div class="line">        <span class="keywordflow">if</span> (PIXEL_FORMAT_RGB565 == format)</div><div class="line">        {</div><div class="line">            r0 = lut_32[r0];</div><div class="line">            g0 = lut_64[g0];</div><div class="line">            b0 = lut_32[b0];</div><div class="line"></div><div class="line">            r1 = lut_32[r1];</div><div class="line">            g1 = lut_64[g1];</div><div class="line">            b1 = lut_32[b1];</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Calculate Y&#39;CbCr 4:4:4 values for the two pixels */</span></div><div class="line">        <span class="comment">/* Algorithm based on method shown here: https://sistenix.com/rgb2ycbcr.html */</span></div><div class="line">        <span class="comment">/* Original coefficients from https://en.wikipedia.org/wiki/YCbCr#JPEG_conversion */</span></div><div class="line">        y0 = (uint8_t) (((r0 &lt;&lt; 6) + (r0 &lt;&lt; 3) + (r0 &lt;&lt; 2) + r0 +</div><div class="line">                         (g0 &lt;&lt; 7) + (g0 &lt;&lt; 4) + (g0 &lt;&lt; 2) + (g0 &lt;&lt; 1) +</div><div class="line">                         (b0 &lt;&lt; 4) + (b0 &lt;&lt; 3) + (b0 &lt;&lt; 2) + b0</div><div class="line">                         ) &gt;&gt; 8);</div><div class="line"></div><div class="line">        cb0 = (uint8_t) (C_0 - (((r0 &lt;&lt; 5) + (r0 &lt;&lt; 3) + (r0 &lt;&lt; 1) + r0 +</div><div class="line">                                 (g0 &lt;&lt; 6) + (g0 &lt;&lt; 4) + (g0 &lt;&lt; 2) + g0 -</div><div class="line">                                 (b0 &lt;&lt; 7)</div><div class="line">                                 ) &gt;&gt; 8));</div><div class="line"></div><div class="line">        cr0 = (uint8_t) (C_0 + (((r0 &lt;&lt; 7) -</div><div class="line">                                 (g0 &lt;&lt; 6) - (g0 &lt;&lt; 5) - (g0 &lt;&lt; 3) - (g0 &lt;&lt; 1) - g0 -</div><div class="line">                                 (b0 &lt;&lt; 4) - (b0 &lt;&lt; 2) - b0</div><div class="line">                                 ) &gt;&gt; 8));</div><div class="line"></div><div class="line">        y1 = (uint8_t) (((r1 &lt;&lt; 6) + (r1 &lt;&lt; 3) + (r1 &lt;&lt; 2) + r1 +</div><div class="line">                         (g1 &lt;&lt; 7) + (g1 &lt;&lt; 4) + (g1 &lt;&lt; 2) + (g1 &lt;&lt; 1) +</div><div class="line">                         (b1 &lt;&lt; 4) + (b1 &lt;&lt; 3) + (b1 &lt;&lt; 2) + b1</div><div class="line">                         ) &gt;&gt; 8);</div><div class="line"></div><div class="line">        cb1 = (uint8_t) (C_0 - (((r1 &lt;&lt; 5) + (r1 &lt;&lt; 3) + (r1 &lt;&lt; 1) + r1 +</div><div class="line">                                 (g1 &lt;&lt; 6) + (g1 &lt;&lt; 4) + (g1 &lt;&lt; 2) + g1 -</div><div class="line">                                 (b1 &lt;&lt; 7)</div><div class="line">                                 ) &gt;&gt; 8));</div><div class="line"></div><div class="line">        cr1 = (uint8_t) (C_0 + (((r1 &lt;&lt; 7) -</div><div class="line">                                 (g1 &lt;&lt; 6) - (g1 &lt;&lt; 5) - (g1 &lt;&lt; 3) - (g1 &lt;&lt; 1) - g1 -</div><div class="line">                                 (b1 &lt;&lt; 4) - (b1 &lt;&lt; 2) - b1</div><div class="line">                                 ) &gt;&gt; 8));</div><div class="line"></div><div class="line">        <span class="comment">/* The above code is based on the floating point method shown here: */</span></div><div class="line"></div><div class="line">        <span class="comment">// y0  = (uint8_t) ((0.299F * (float) r0) + (0.587F * (float) g0) + (0.114F * (float) b0));</span></div><div class="line">        <span class="comment">// y1  = (uint8_t) ((0.299F * (float) r1) + (0.587F * (float) g1) + (0.114F * (float) b1));</span></div><div class="line">        <span class="comment">// cb0 = (uint8_t) (128.0F - (0.168736F * (float) r0) - (0.331264F * (float) g0) + (0.5F * (float) b0));</span></div><div class="line">        <span class="comment">// cb1 = (uint8_t) (128.0F - (0.168736F * (float) r1) - (0.331264F * (float) g1) + (0.5F * (float) b1));</span></div><div class="line">        <span class="comment">// cr0 = (uint8_t) (128.0F + (0.5F * (float) r0) - (0.418688F * (float) g0) - (0.081312F * (float) b0));</span></div><div class="line">        <span class="comment">// cr1 = (uint8_t) (128.0F + (0.5F * (float) r1) - (0.418688F * (float) g1) - (0.081312F * (float) b1));</span></div><div class="line"></div><div class="line">        <span class="comment">/* NOTE: The JPEG Codec expects signed instead of unsigned chrominance values. */</span></div><div class="line">        <span class="comment">/* Convert chrominance to -127..127 instead of 1..255 */</span></div><div class="line">        cb0 = (uint8_t) ((int8_t) ((cb0 + cb1 + 1) &gt;&gt; 1) - C_0);</div><div class="line">        cr0 = (uint8_t) ((int8_t) ((cr0 + cr1 + 1) &gt;&gt; 1) - C_0);</div><div class="line"></div><div class="line">        <span class="comment">/* Convert the two 4:4:4 values into 4:2:2 by averaging the chroma, then write to output */</span></div><div class="line">        *out++ = (uint32_t) (y0 + (cb0 &lt;&lt; 8) + (y1 &lt;&lt; 16) + (cr0 &lt;&lt; 24));</div><div class="line"></div><div class="line">        len--;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structjpeg__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___j_p_e_g.html#structjpeg__instance__ctrl__t">jpeg_instance_ctrl_t</a></td></tr>
<tr class="separator:structjpeg__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structjpeg__instance__ctrl__t" id="structjpeg__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structjpeg__instance__ctrl__t">&#9670;&nbsp;</a></span>jpeg_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct jpeg_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>JPEG Codec module control block. DO NOT INITIALIZE. Initialization occurs when jpep_api_t::open is called. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ae96981ea57e4e02eb9594c763bbf2521"></a>uint32_t</td>
<td class="fieldname">
open</td>
<td class="fielddoc">
JPEG Codec driver status. </td></tr>
<tr><td class="fieldtype">
<a id="a29a574d4336eab2e51fe39e5a01fc491"></a><a class="el" href="group___j_p_e_g___a_p_i.html#ga16543f6924ee246961b2d293ca92ec36">jpeg_status_t</a></td>
<td class="fieldname">
status</td>
<td class="fielddoc">
JPEG Codec operational status. </td></tr>
<tr><td class="fieldtype">
<a id="ad8447c7bb6e8280470df12ef2e45e897"></a><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a></td>
<td class="fieldname">
error_code</td>
<td class="fielddoc">
JPEG Codec error code (if any). </td></tr>
<tr><td class="fieldtype">
<a id="af0678e5b5e4d905fad7731ac0099f1c8"></a>jpeg_mode_t</td>
<td class="fieldname">
mode</td>
<td class="fielddoc">
Current mode (decode or encode). </td></tr>
<tr><td class="fieldtype">
<a id="a94de72f08051adebbba9899d3599c246"></a>uint32_t</td>
<td class="fieldname">
horizontal_stride_bytes</td>
<td class="fielddoc">
Horizontal Stride settings. </td></tr>
<tr><td class="fieldtype">
<a id="a4fa3d9ee206b15ae564a7b0d15a358c2"></a>uint32_t</td>
<td class="fieldname">
output_buffer_size</td>
<td class="fielddoc">
Output buffer size. </td></tr>
<tr><td class="fieldtype">
<a id="ace2d09fc342e0a371614fde1eb2ca495"></a><a class="el" href="group___j_p_e_g___a_p_i.html#structjpeg__cfg__t">jpeg_cfg_t</a> const  *</td>
<td class="fieldname">
p_cfg</td>
<td class="fielddoc">
JPEG Decode configuration struct. </td></tr>
<tr><td class="fieldtype">
<a id="a774a2dce69eaa0eed7974ed06cd7926b"></a>void const  *</td>
<td class="fieldname">
p_extend</td>
<td class="fielddoc">
JPEG Codec hardware dependent configuration */. </td></tr>
<tr><td class="fieldtype">
<a id="adb9e421bf95cd85a3449895c2a37ff0e"></a><a class="el" href="group___j_p_e_g___a_p_i.html#gaf255735f7f96e62d09a5af50736fe97c">jpeg_decode_pixel_format_t</a></td>
<td class="fieldname">
pixel_format</td>
<td class="fielddoc">
Pixel format. </td></tr>
<tr><td class="fieldtype">
<a id="a900d2d361a81cbef4cc8a4b2529c68cf"></a>uint16_t</td>
<td class="fieldname">
total_lines_decoded</td>
<td class="fielddoc">
Track the number of lines decoded so far. </td></tr>
<tr><td class="fieldtype">
<a id="aed09b4b05354237a464ed4a869dcca2b"></a><a class="el" href="group___j_p_e_g___a_p_i.html#gac10fc46a5178859abd5d686389c5242c">jpeg_decode_subsample_t</a></td>
<td class="fieldname">
horizontal_subsample</td>
<td class="fielddoc">
Horizontal sub-sample setting. </td></tr>
<tr><td class="fieldtype">
<a id="af61ee8139d094bdee8b67e3693fb7cdd"></a>uint16_t</td>
<td class="fieldname">
lines_to_encode</td>
<td class="fielddoc">
Number of lines to encode. </td></tr>
<tr><td class="fieldtype">
<a id="a9f90954e1af2ed22f8d84e75525ac88f"></a>uint16_t</td>
<td class="fieldname">
vertical_resolution</td>
<td class="fielddoc">
vertical size </td></tr>
<tr><td class="fieldtype">
<a id="a0d6fbc975cb2cbeee7e05bca0a6b5ee9"></a>uint16_t</td>
<td class="fieldname">
total_lines_encoded</td>
<td class="fielddoc">
Number of lines encoded. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga34766994da3769a1f5cd3e7f22652b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34766994da3769a1f5cd3e7f22652b43">&#9670;&nbsp;</a></span>R_JPEG_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_JPEG_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___j_p_e_g___a_p_i.html#gadcda3a404659199f5fc9b90a8eb4b543">jpeg_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___j_p_e_g___a_p_i.html#structjpeg__cfg__t">jpeg_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the JPEG Codec module. </p><dl class="section note"><dt>Note</dt><dd>This function configures the JPEG Codec for operation and sets up the registers for data format and pixel format based on user-supplied configuration parameters. Interrupts are enabled to support callbacks.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>JPEG Codec module is properly configured and is ready to take input data. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>JPEG Codec is already open. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to the control block or the configuration structure is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_IRQ_BSP_DISABLED</td><td>JEDI interrupt does not have an IRQ number. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ARGUMENT</td><td>(Encode only) Quality factor, horizontal resolution and/or vertical resolution are invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ALIGNMENT</td><td>(Encode only) The horizontal resolution (at 16bpp) is not divisible by 8 bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6d304aad5fbb148f8bd7ed71f878e53d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d304aad5fbb148f8bd7ed71f878e53d">&#9670;&nbsp;</a></span>R_JPEG_OutputBufferSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_JPEG_OutputBufferSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___j_p_e_g___a_p_i.html#gadcda3a404659199f5fc9b90a8eb4b543">jpeg_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_output_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>output_buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assign a buffer to the JPEG Codec for storing output data. </p><dl class="section note"><dt>Note</dt><dd>In Decode mode, the number of image lines to be decoded depends on the size of the buffer and the horizontal stride settings. Once the output buffer size is known, the horizontal stride value is known, and the input pixel format is known (the input pixel format is obtained by the JPEG decoder from the JPEG headers), the driver automatically computes the number of lines that can be decoded into the output buffer. After these lines are decoded, the JPEG engine pauses and a callback function is triggered, so the application is able to provide the next buffer for the JPEG module to resume the operation.</dd></dl>
<p>The JPEG decoding operation automatically starts after both the input buffer and the output buffer are set and the output buffer is big enough to hold at least eight lines of decoded image data.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The output buffer is properly assigned to JPEG codec device. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to the control block or output_buffer is NULL or output_buffer_size is 0. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ALIGNMENT</td><td>Buffer starting address is not 8-byte aligned. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>JPEG not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_JPEG_UNSUPPORTED_IMAGE_SIZE</td><td>The number of horizontal pixels exceeds horizontal memory stride. </td></tr>
    <tr><td class="paramname">FSP_ERR_JPEG_BUFFERSIZE_NOT_ENOUGH</td><td>Invalid buffer size. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>The output buffer cannot be changed during codec operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaed65a4fe2f87a3c30dc817d311056f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaed65a4fe2f87a3c30dc817d311056f0">&#9670;&nbsp;</a></span>R_JPEG_InputBufferSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_JPEG_InputBufferSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___j_p_e_g___a_p_i.html#gadcda3a404659199f5fc9b90a8eb4b543">jpeg_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_data_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data_buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assign an input data buffer to the JPEG codec for processing. </p><dl class="section note"><dt>Note</dt><dd>After the amount of data is processed, the JPEG driver triggers a callback function with the flag JPEG_PRV_OPERATION_INPUT_PAUSE set. The application supplies the next chunk of data to the driver so processing can resume.</dd>
<dd>
The JPEG decoding operation automatically starts after both the input buffer and the output buffer are set, and the output buffer is big enough to hold at least one line of decoded image data.</dd></dl>
<p>If zero is provided for the decode data buffer size the JPEG Codec will never pause for more input data and will continue to read until either an image has been fully decoded or an error condition occurs.</p>
<dl class="section note"><dt>Note</dt><dd>When encoding images the minimum data buffer size is 8 lines by 16 Y'CbCr 4:2:2 pixels (256 bytes). This corresponds to one minimum coded unit (MCU) of the resulting JPEG output.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The input data buffer is properly assigned to JPEG Codec device. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to the control block is NULL, or the pointer to the input_buffer is NULL, or the input_buffer_size is 0. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ALIGNMENT</td><td>Buffer starting address is not 8-byte aligned. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>JPEG not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>The input buffer cannot be changed while the codec is running. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_CALL</td><td>In encode mode the output buffer must be set first. </td></tr>
    <tr><td class="paramname">FSP_ERR_JPEG_IMAGE_SIZE_ERROR</td><td>The buffer size is smaller than the minimum coded unit (MCU). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae339672b9122a431c66a695858877463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae339672b9122a431c66a695858877463">&#9670;&nbsp;</a></span>R_JPEG_DecodeLinesDecodedGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_JPEG_DecodeLinesDecodedGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___j_p_e_g___a_p_i.html#gadcda3a404659199f5fc9b90a8eb4b543">jpeg_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_lines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of lines decoded into the output buffer. </p><dl class="section note"><dt>Note</dt><dd>Use this function to retrieve the number of image lines written to the output buffer after a partial decode operation. Combined with the horizontal stride settings and the output pixel format the application can compute the amount of data to read from the output buffer.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Line count successfully returned. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to the control block or p_lines is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>JPEG not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3246bd6af57284f48d8c5061257bfeed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3246bd6af57284f48d8c5061257bfeed">&#9670;&nbsp;</a></span>R_JPEG_DecodeImageSubsampleSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_JPEG_DecodeImageSubsampleSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___j_p_e_g___a_p_i.html#gadcda3a404659199f5fc9b90a8eb4b543">jpeg_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___j_p_e_g___a_p_i.html#gac10fc46a5178859abd5d686389c5242c">jpeg_decode_subsample_t</a>&#160;</td>
          <td class="paramname"><em>horizontal_subsample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___j_p_e_g___a_p_i.html#gac10fc46a5178859abd5d686389c5242c">jpeg_decode_subsample_t</a>&#160;</td>
          <td class="paramname"><em>vertical_subsample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure horizontal and vertical subsampling. </p><dl class="section note"><dt>Note</dt><dd>This function can be used to scale the output of decoded image data.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Horizontal subsample value is properly configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to the control block is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>JPEG not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga62ffba3d7256310ec46dff12b798983e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62ffba3d7256310ec46dff12b798983e">&#9670;&nbsp;</a></span>R_JPEG_DecodeHorizontalStrideSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_JPEG_DecodeHorizontalStrideSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___j_p_e_g___a_p_i.html#gadcda3a404659199f5fc9b90a8eb4b543">jpeg_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>horizontal_stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure horizontal stride setting for decode operations. </p><dl class="section note"><dt>Note</dt><dd>If the image size is known prior to the open call and/or the output buffer stride is constant, pass the horizontal stride value in the <a class="el" href="group___j_p_e_g___a_p_i.html#structjpeg__cfg__t">jpeg_cfg_t</a> structure. Otherwise, after the image size becomes available use this function to set the output buffer horizontal stride value.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Horizontal stride value is properly configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to the control block is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ALIGNMENT</td><td>Horizontal stride is zero or is not 8-byte aligned. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>JPEG not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3d68546c7a9f31f72b96cf17086bdfe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d68546c7a9f31f72b96cf17086bdfe4">&#9670;&nbsp;</a></span>R_JPEG_DecodeImageSizeGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_JPEG_DecodeImageSizeGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___j_p_e_g___a_p_i.html#gadcda3a404659199f5fc9b90a8eb4b543">jpeg_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>p_horizontal_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>p_vertical_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtain the size of an image being decoded.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The image size is available and the horizontal and vertical values are stored in the memory pointed to by p_horizontal_size and p_vertical_size. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to the control block is NULL and/or size is not ready. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>JPEG is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae1ed6685a29aa94b4fc5a6764c72c2a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1ed6685a29aa94b4fc5a6764c72c2a5">&#9670;&nbsp;</a></span>R_JPEG_DecodePixelFormatGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_JPEG_DecodePixelFormatGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___j_p_e_g___a_p_i.html#gadcda3a404659199f5fc9b90a8eb4b543">jpeg_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___j_p_e_g___a_p_i.html#ga3aed73edf47174b12b8b99e41437d696">jpeg_color_space_t</a> *&#160;</td>
          <td class="paramname"><em>p_color_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the color format of the JPEG being decoded.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The color format was successfully retrieved. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to the control block is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>JPEG is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6cff298a8d044d4a7ea04c577a9170ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cff298a8d044d4a7ea04c577a9170ca">&#9670;&nbsp;</a></span>R_JPEG_EncodeImageSizeSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_JPEG_EncodeImageSizeSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___j_p_e_g___a_p_i.html#gadcda3a404659199f5fc9b90a8eb4b543">jpeg_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___j_p_e_g___a_p_i.html#structjpeg__encode__image__size__t">jpeg_encode_image_size_t</a> *&#160;</td>
          <td class="paramname"><em>p_image_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the image dimensions for an encode operation. </p><dl class="section note"><dt>Note</dt><dd>Image dimensions must be set before setting the input buffer.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Image size was successfully written to the JPEG Codec. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to the control block or p_image_size is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ALIGNMENT</td><td>Horizontal stride is not 8-byte aligned. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ARGUMENT</td><td>Horizontal or vertical resolution is invalid or zero. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>JPEG not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>Image parameters cannot be changed while the codec is running. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab669afd6c669dabba75e3510fc9f5bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab669afd6c669dabba75e3510fc9f5bda">&#9670;&nbsp;</a></span>R_JPEG_ModeSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_JPEG_ModeSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___j_p_e_g___a_p_i.html#gadcda3a404659199f5fc9b90a8eb4b543">jpeg_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">jpeg_mode_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Switch between encode and decode mode (or vice-versa). </p><dl class="section note"><dt>Note</dt><dd>The codec must not be idle in order to switch modes.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Mode changed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_api_ctrl is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>JPEG Codec is currently in use. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ARGUMENT</td><td>(Encode only) Quality factor, horizontal resolution and/or vertical resolution are invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ALIGNMENT</td><td>(Encode only) The horizontal resolution (at 16bpp) is not divisible by 8 bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0b41824f40d6c66c59a6c5ad908cbdce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b41824f40d6c66c59a6c5ad908cbdce">&#9670;&nbsp;</a></span>R_JPEG_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_JPEG_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___j_p_e_g___a_p_i.html#gadcda3a404659199f5fc9b90a8eb4b543">jpeg_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cancel an outstanding JPEG codec operation and close the device.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The JPEG unit is stopped and the driver is closed. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to the control block is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>JPEG not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1d62e16ee0c22a4ca2c3853ec81c7928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d62e16ee0c22a4ca2c3853ec81c7928">&#9670;&nbsp;</a></span>R_JPEG_StatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_JPEG_StatusGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___j_p_e_g___a_p_i.html#gadcda3a404659199f5fc9b90a8eb4b543">jpeg_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___j_p_e_g___a_p_i.html#ga16543f6924ee246961b2d293ca92ec36">jpeg_status_t</a> *&#160;</td>
          <td class="paramname"><em>p_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the status of the JPEG codec. This function can also be used to poll the device.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The status information is successfully retrieved. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to the control block or p_status is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>JPEG is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v6.2.0 User's Manual Copyright © (2025) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
