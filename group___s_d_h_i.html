<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: SD/MMC Host Interface (r_sdhi)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v3.1.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">
 
    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text"> 
      </span>
      <span class="right">
          &nbsp; 
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___s_d_h_i.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() { 
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body. 
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works 
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len)); 
            }
          } 
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }    
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element. 
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;  
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SD/MMC Host Interface (r_sdhi)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga37b6d1c11d0f6d92ef6ae985a420ffbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_h_i.html#ga37b6d1c11d0f6d92ef6ae985a420ffbb">R_SDHI_Open</a> (<a class="el" href="group___s_d_m_m_c___a_p_i.html#ga81be65bcaee41616f4702b84eb51a499">sdmmc_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___s_d_m_m_c___a_p_i.html#structsdmmc__cfg__t">sdmmc_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:ga37b6d1c11d0f6d92ef6ae985a420ffbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabacaaf35153339d0931c6c0932eca4e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_h_i.html#gabacaaf35153339d0931c6c0932eca4e3">R_SDHI_MediaInit</a> (<a class="el" href="group___s_d_m_m_c___a_p_i.html#ga81be65bcaee41616f4702b84eb51a499">sdmmc_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___s_d_m_m_c___a_p_i.html#structsdmmc__device__t">sdmmc_device_t</a> *const p_device)</td></tr>
<tr class="separator:gabacaaf35153339d0931c6c0932eca4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga400250f503190acfb97e58a561feec69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_h_i.html#ga400250f503190acfb97e58a561feec69">R_SDHI_Read</a> (<a class="el" href="group___s_d_m_m_c___a_p_i.html#ga81be65bcaee41616f4702b84eb51a499">sdmmc_ctrl_t</a> *const p_api_ctrl, uint8_t *const p_dest, uint32_t const start_sector, uint32_t const sector_count)</td></tr>
<tr class="separator:ga400250f503190acfb97e58a561feec69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb1d35740c235c80edf43549fa3427d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_h_i.html#gabb1d35740c235c80edf43549fa3427d7">R_SDHI_Write</a> (<a class="el" href="group___s_d_m_m_c___a_p_i.html#ga81be65bcaee41616f4702b84eb51a499">sdmmc_ctrl_t</a> *const p_api_ctrl, uint8_t const *const p_source, uint32_t const start_sector, uint32_t const sector_count)</td></tr>
<tr class="separator:gabb1d35740c235c80edf43549fa3427d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga844604588f44e8aa4495d27ffca74b0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_h_i.html#ga844604588f44e8aa4495d27ffca74b0d">R_SDHI_ReadIo</a> (<a class="el" href="group___s_d_m_m_c___a_p_i.html#ga81be65bcaee41616f4702b84eb51a499">sdmmc_ctrl_t</a> *const p_api_ctrl, uint8_t *const p_data, uint32_t const function, uint32_t const address)</td></tr>
<tr class="separator:ga844604588f44e8aa4495d27ffca74b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga111f9479ed25bba03ade5c6c40248e44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_h_i.html#ga111f9479ed25bba03ade5c6c40248e44">R_SDHI_WriteIo</a> (<a class="el" href="group___s_d_m_m_c___a_p_i.html#ga81be65bcaee41616f4702b84eb51a499">sdmmc_ctrl_t</a> *const p_api_ctrl, uint8_t *const p_data, uint32_t const function, uint32_t const address, <a class="el" href="group___s_d_m_m_c___a_p_i.html#ga55695633a9591a08f956911271fba9fd">sdmmc_io_write_mode_t</a> const read_after_write)</td></tr>
<tr class="separator:ga111f9479ed25bba03ade5c6c40248e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd18fd8115dff4bfda4dadd5468783fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_h_i.html#gafd18fd8115dff4bfda4dadd5468783fd">R_SDHI_ReadIoExt</a> (<a class="el" href="group___s_d_m_m_c___a_p_i.html#ga81be65bcaee41616f4702b84eb51a499">sdmmc_ctrl_t</a> *const p_api_ctrl, uint8_t *const p_dest, uint32_t const function, uint32_t const address, uint32_t *const count, <a class="el" href="group___s_d_m_m_c___a_p_i.html#gabce3d8ad0d84595d7579a5c5efa4306e">sdmmc_io_transfer_mode_t</a> transfer_mode, <a class="el" href="group___s_d_m_m_c___a_p_i.html#gafa20c01a4dbbd10b3de7fde3ab252df3">sdmmc_io_address_mode_t</a> address_mode)</td></tr>
<tr class="separator:gafd18fd8115dff4bfda4dadd5468783fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa73674cc979a40b00e4aed1ed9b5aa34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_h_i.html#gaa73674cc979a40b00e4aed1ed9b5aa34">R_SDHI_WriteIoExt</a> (<a class="el" href="group___s_d_m_m_c___a_p_i.html#ga81be65bcaee41616f4702b84eb51a499">sdmmc_ctrl_t</a> *const p_api_ctrl, uint8_t const *const p_source, uint32_t const function, uint32_t const address, uint32_t const count, <a class="el" href="group___s_d_m_m_c___a_p_i.html#gabce3d8ad0d84595d7579a5c5efa4306e">sdmmc_io_transfer_mode_t</a> transfer_mode, <a class="el" href="group___s_d_m_m_c___a_p_i.html#gafa20c01a4dbbd10b3de7fde3ab252df3">sdmmc_io_address_mode_t</a> address_mode)</td></tr>
<tr class="separator:gaa73674cc979a40b00e4aed1ed9b5aa34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17fa126d6fb356bfc3e13d7384582504"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_h_i.html#ga17fa126d6fb356bfc3e13d7384582504">R_SDHI_IoIntEnable</a> (<a class="el" href="group___s_d_m_m_c___a_p_i.html#ga81be65bcaee41616f4702b84eb51a499">sdmmc_ctrl_t</a> *const p_api_ctrl, bool enable)</td></tr>
<tr class="separator:ga17fa126d6fb356bfc3e13d7384582504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bebd1e0295bac31b76888d4fca94f90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_h_i.html#ga6bebd1e0295bac31b76888d4fca94f90">R_SDHI_StatusGet</a> (<a class="el" href="group___s_d_m_m_c___a_p_i.html#ga81be65bcaee41616f4702b84eb51a499">sdmmc_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___s_d_m_m_c___a_p_i.html#structsdmmc__status__t">sdmmc_status_t</a> *const p_status)</td></tr>
<tr class="separator:ga6bebd1e0295bac31b76888d4fca94f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad954571b08da622a4b232680190b4313"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_h_i.html#gad954571b08da622a4b232680190b4313">R_SDHI_Erase</a> (<a class="el" href="group___s_d_m_m_c___a_p_i.html#ga81be65bcaee41616f4702b84eb51a499">sdmmc_ctrl_t</a> *const p_api_ctrl, uint32_t const start_sector, uint32_t const sector_count)</td></tr>
<tr class="separator:gad954571b08da622a4b232680190b4313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78d9f9f873c52843f778fd700ef38936"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_h_i.html#ga78d9f9f873c52843f778fd700ef38936">R_SDHI_CallbackSet</a> (<a class="el" href="group___s_d_m_m_c___a_p_i.html#ga81be65bcaee41616f4702b84eb51a499">sdmmc_ctrl_t</a> *const p_api_ctrl, void(*p_callback)(<a class="el" href="group___s_d_m_m_c___a_p_i.html#structsdmmc__callback__args__t">sdmmc_callback_args_t</a> *), void const *const p_context, <a class="el" href="group___s_d_m_m_c___a_p_i.html#structsdmmc__callback__args__t">sdmmc_callback_args_t</a> *const p_callback_memory)</td></tr>
<tr class="separator:ga78d9f9f873c52843f778fd700ef38936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76e778c7c058c3ca09f63f05c30d00c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_h_i.html#ga76e778c7c058c3ca09f63f05c30d00c1">R_SDHI_Close</a> (<a class="el" href="group___s_d_m_m_c___a_p_i.html#ga81be65bcaee41616f4702b84eb51a499">sdmmc_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:ga76e778c7c058c3ca09f63f05c30d00c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the SD/MMC Host Interface (SDHI) peripheral on RA MCUs. This module implements the <a class="el" href="group___s_d_m_m_c___a_p_i.html">SD/MMC Interface</a>. </p>
<h1><a class="anchor" id="r-sdhi-overview"></a>
Overview</h1>
<h2><a class="anchor" id="r-sdhi-features"></a>
Features</h2>
<ul>
<li>Supports the following memory devices: SDSC (SD Standard Capacity), SDHC (SD High Capacity), SDXC (SD Extended Capacity) and eMMC (embedded Multi Media Card)<a class="anchor" id="um_sdmmc_sdhcsdxc_cards"></a><a class="anchor" id="um_sdmmc_sdsc_cards"></a><ul>
<li>Supports reading, writing and erasing SD memory devices</li>
<li>Supports 1, 4 or 8-bit data bus (8-bit bus is supported for eMMC only)<a class="anchor" id="um_sdmmc_bus_width"></a></li>
<li>Supports detection of device write protection (SD cards only)<a class="anchor" id="um_sdmmc_write_unsupported_if_write_protected"></a><a class="anchor" id="um_sdmmc_erase_unsupported_if_write_protected"></a></li>
<li>Supports high speed mode<a class="anchor" id="um_sdmmc_high_speed_emmc"></a></li>
</ul>
</li>
<li>Automatically configures the clock to the maximum clock rate supported by both host (MCU) and device<a class="anchor" id="um_sdmmc_clock_configuration"></a></li>
<li>Supports hardware acceleration using DMAC or DTC<a class="anchor" id="um_sdmmc_sector_write_dma"></a><a class="anchor" id="um_sdmmc_sector_read_dma"></a></li>
<li>Supports callback notification when an operation completes or an error occurs<a class="anchor" id="um_sdmmc_operation_complete_notification"></a><a class="anchor" id="um_sdmmc_error_notification"></a> </li>
</ul>
<h1><a class="anchor" id="r-sdhi-configuration"></a>
Configuration</h1>
<p><h2>Build Time Configurations for r_sdhi</h2>
The following build time configurations are defined in fsp_cfg/r_sdhi_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr>
<td>Unaligned Access Support</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Enabled </td><td>If enabled, code for supporting buffers that are not aligned on a 4-byte boundary is included in the build. Only disable this if all buffers passed to the driver are 4-byte aligned. </td></tr>
<tr>
<td>SD Support</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Enabled </td><td>If selected code for SD card support is included in the build. </td></tr>
<tr>
<td>eMMC Support</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>If selected code for eMMC device support is included in the build. </td></tr>
</table>
 <h2>Configurations for Driver &gt; Storage &gt; SD/MMC Driver on r_sdhi</h2>
This module can be added to the Stacks tab via New Stack &gt; Driver &gt; Storage &gt; SD/MMC Driver on r_sdhi. Non-secure callable guard functions can be generated for this module by right clicking the module in the RA Configuration tool and checking the "Non-secure Callable" box.<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Name</td><td>Name must be a valid C symbol</td><td>g_sdmmc0 </td><td>Module name. </td></tr>
<tr>
<td>Channel</td><td>Value must be a non-negative integer</td><td>0 </td><td>Select the channel. </td></tr>
<tr>
<td>Bus Width</td><td>MCU Specific Options</td><td></td><td>Select the bus width. </td></tr>
<tr>
<td>Block Size</td><td>Value must be an integer between 1 and 512</td><td>512 </td><td>Select the media block size. Must be 512 for SD cards or eMMC devices. Must be 1-512 for SDIO. </td></tr>
<tr>
<td>Card Detection</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Not Used</li>
<li>
CD Pin</li>
</ul>
</td><td>CD Pin </td><td>Select the card detection method. </td></tr>
<tr>
<td>Write Protection</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Not Used</li>
<li>
WP Pin</li>
</ul>
</td><td>WP Pin </td><td>Select whether or not to use the write protect pin. Select Not Used if the MCU or device does not have a write protect pin. </td></tr>
<tr>
<td>Callback</td><td>Name must be a valid C symbol</td><td>NULL </td><td>A user callback function can be provided. If this callback function is provided, it will be called from the interrupt service routine (ISR). </td></tr>
<tr>
<td>Access Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select the access interrupt priority. </td></tr>
<tr>
<td>Card Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select the card interrupt priority. </td></tr>
<tr>
<td>DTC Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select the DTC interrupt priority. </td></tr>
</table>
</p>
<h2>Interrupt Configurations:</h2>
<p>The following interrupts are required to use the r_sdhi module:</p>
<p>Using SD/MMC with DTC:</p><ul>
<li>Access Interrupt</li>
<li>DTC Interrupt</li>
</ul>
<p>Using SD/MMC with DMAC:</p><ul>
<li>Access Interrupt</li>
<li>DMAC Interrupt (in DMAC instance)</li>
</ul>
<p>The Card interrupt is optional and only available on MCU packages that have the SDnCD pin (n = channel number).</p>
<h2><a class="anchor" id="r-sdhi-clock-configuration"></a>
Clock Configuration</h2>
<p>The SDMMC MCU peripheral (SDHI) uses the PCLKA for its clock source. The SDMMC driver selects the optimal built-in divider based on the PCLKA frequency and the maximum clock rate allowed by the device obtained at media initialization.</p>
<h2><a class="anchor" id="r-sdhi-pin-configuration"></a>
Pin Configuration</h2>
<p>The SDMMC driver supports the following pins (n = channel number):</p><ul>
<li>SDnCLK</li>
<li>SDnCMD</li>
<li>SDnDAT0</li>
<li>SDnDAT1</li>
<li>SDnDAT2</li>
<li>SDnDAT3</li>
<li>SDnDAT4 (not available on all MCUs)</li>
<li>SDnDAT5 (not available on all MCUs)</li>
<li>SDnDAT6 (not available on all MCUs)</li>
<li>SDnDAT7 (not available on all MCUs)</li>
<li>SDnCD (not available on all MCUs)</li>
<li>SDnWP</li>
</ul>
<p>The drive capacity for each pin should be set to "Medium" or "High" for most hardware designs. This can be configured in the <b>Pins</b> tab of the RA Configuration editor by selecting the pin under Pin Selection -&gt; Ports.</p>
<h1><a class="anchor" id="r-sdhi-usage_notes"></a>
Usage Notes</h1>
<h2>Card Detection</h2>
<p><a class="anchor" id="um_sdmmc_card_removal_notification"></a><a class="anchor" id="um_sdmmc_card_insertion_notification"></a> When Card Detection is configured to "CD Pin" in the RA Configuration editor, interrupt flags are cleared and card detection is enabled during <a class="el" href="group___s_d_h_i.html#ga37b6d1c11d0f6d92ef6ae985a420ffbb">R_SDHI_Open()</a>.</p>
<p><a class="el" href="group___s_d_h_i.html#ga6bebd1e0295bac31b76888d4fca94f90">R_SDHI_StatusGet()</a> can be called to retrieve the current status of the card (including whether a card is present). If the Card Interrupt Priority is enabled, a callback is called when a card is inserted or removed.</p>
<p>If a card is removed and reinserted, <a class="el" href="group___s_d_h_i.html#gabacaaf35153339d0931c6c0932eca4e3">R_SDHI_MediaInit()</a> must be called before reading from the card or writing to the card.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group___s_d_h_i.html#ga6bebd1e0295bac31b76888d4fca94f90">R_SDHI_StatusGet()</a> should be used to initially determine the card state after opening the interface.</dd></dl>
<h2>DMA Request Interrupt Priority</h2>
<p>When data transfers are not 4-byte aligned or not a multiple of 4 bytes, a software copy of the block size (up to 512 bytes) is done in the DMA Request interrupt. This blocks all other interrupts that are a lower or equal priority to the access interrupt until the software copy is complete.</p>
<h2>Timing Notes for R_SDHI_MediaInit</h2>
<p><a class="anchor" id="um_sdmmc_initialization"></a> The <a class="el" href="group___s_d_h_i.html#gabacaaf35153339d0931c6c0932eca4e3">R_SDHI_MediaInit()</a> API completes the entire device identification and configuration process. This involves several command-response cycles at a bus width of 1 bit and a bus speed of 400 kHz or less.</p>
<h2><a class="anchor" id="r-sdhi-limitations"></a>
Limitations</h2>
<p>Developers should be aware of the following limitations when using the SDHI:</p>
<h3>Blocking Calls</h3>
<p>The following functions block execution until the response is received for at least one command:</p><ul>
<li><a class="el" href="group___s_d_h_i.html#gabacaaf35153339d0931c6c0932eca4e3">R_SDHI_MediaInit</a></li>
<li><a class="el" href="group___s_d_h_i.html#gad954571b08da622a4b232680190b4313">R_SDHI_Erase</a></li>
</ul>
<p>Once the function returns the status of the operation can be determined via <a class="el" href="group___s_d_h_i.html#ga6bebd1e0295bac31b76888d4fca94f90">R_SDHI_StatusGet</a> or through receipt of a callback.</p>
<dl class="section note"><dt>Note</dt><dd>Due to the variability in clocking configurations it is recommended to determine blocking delays experimentally on the target system.</dd></dl>
<h3>Data Alignment and Size</h3>
<p>Data transfers should be 4-byte aligned and a multiple of 4 bytes in size whenever possible. This recommendation applies to the read(), write(), readIoExt(), and writeIoExt() APIs. When data transfers are 4-byte aligned and a multiple of 4-bytes, the r_sdhi driver is zero copy and takes full advantage of hardware acceleration by the DMAC or DTC. When data transfers are not 4-byte aligned or not a multiple of 4 bytes an extra CPU interrupt is required for each block transferred and a software copy is used to move data to the destination buffer.</p>
<h1><a class="anchor" id="r-sdhi-examples"></a>
Examples</h1>
<h2>Basic Example</h2>
<p>This is a basic example of minimal use of the r_sdhi in an application.</p>
<div class="fragment"><div class="line">uint8_t  g_dest[SDHI_MAX_BLOCK_SIZE] BSP_ALIGN_VARIABLE(4);</div><div class="line">uint8_t  g_src[SDHI_MAX_BLOCK_SIZE]  BSP_ALIGN_VARIABLE(4);</div><div class="line">uint32_t g_transfer_complete = 0;</div><div class="line"><span class="keywordtype">void</span> r_sdhi_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Initialize g_src to known data */</span></div><div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; SDHI_MAX_BLOCK_SIZE; i++)</div><div class="line">    {</div><div class="line">        g_src[i] = (uint8_t) (<span class="charliteral">&#39;A&#39;</span> + (i % 26));</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Open the SDHI driver. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___s_d_h_i.html#ga37b6d1c11d0f6d92ef6ae985a420ffbb">R_SDHI_Open</a>(&amp;g_sdmmc0_ctrl, &amp;g_sdmmc0_cfg);</div><div class="line"></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* A device shall be ready to accept the first command within 1ms from detecting VDD min. Reference section 6.4.1.1</span></div><div class="line"><span class="comment">     * &quot;Power Up Time of Card&quot; in the SD Physical Layer Simplified Specification Version 6.00. */</span></div><div class="line">    <a class="code" href="group___b_s_p___m_c_u.html#gaf3219448adfd1531cf69f68697ab184b">R_BSP_SoftwareDelay</a>(1U, <a class="code" href="group___b_s_p___m_c_u.html#ggafd98e2a6f080d6a52a3ef72e3d731b2ba59fcc4e8d51046d4a1bd63c87ac64913">BSP_DELAY_UNITS_MILLISECONDS</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the SD card.  This should not be done until the card is plugged in for SD devices. */</span></div><div class="line">    err = <a class="code" href="group___s_d_h_i.html#gabacaaf35153339d0931c6c0932eca4e3">R_SDHI_MediaInit</a>(&amp;g_sdmmc0_ctrl, NULL);</div><div class="line"></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    err = <a class="code" href="group___s_d_h_i.html#gabb1d35740c235c80edf43549fa3427d7">R_SDHI_Write</a>(&amp;g_sdmmc0_ctrl, g_src, 3, 1);</div><div class="line"></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (!g_transfer_complete)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait for transfer. */</span></div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    err = <a class="code" href="group___s_d_h_i.html#ga400250f503190acfb97e58a561feec69">R_SDHI_Read</a>(&amp;g_sdmmc0_ctrl, g_dest, 3, 1);</div><div class="line"></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (!g_transfer_complete)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait for transfer. */</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* The callback is called when a transfer completes. */</span></div><div class="line"><span class="keywordtype">void</span> r_sdhi_example_callback (<a class="code" href="group___s_d_m_m_c___a_p_i.html#structsdmmc__callback__args__t">sdmmc_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___s_d_m_m_c___a_p_i.html#ggacf3d8d33331e1ae9810f56d2410ea524a07f4a417555c6cae25fc3d0ccfba499b">SDMMC_EVENT_TRANSFER_COMPLETE</a> == p_args-&gt;<a class="code" href="group___s_d_m_m_c___a_p_i.html#a0d7d301a941f2d863035acb5574719e3">event</a>)</div><div class="line">    {</div><div class="line">        g_transfer_complete = 1;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Card Detection Example</h2>
<p>This is an example of using SDHI when the card may not be plugged in. The card detection interrupt must be enabled to use this example.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> g_card_inserted = <span class="keyword">false</span>;</div><div class="line"><span class="keywordtype">void</span> r_sdhi_card_detect_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Open the SDHI driver. This enables the card detection interrupt. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___s_d_h_i.html#ga37b6d1c11d0f6d92ef6ae985a420ffbb">R_SDHI_Open</a>(&amp;g_sdmmc0_ctrl, &amp;g_sdmmc0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Check if card is inserted. */</span></div><div class="line">    <a class="code" href="group___s_d_m_m_c___a_p_i.html#structsdmmc__status__t">sdmmc_status_t</a> status;</div><div class="line">    err = <a class="code" href="group___s_d_h_i.html#ga6bebd1e0295bac31b76888d4fca94f90">R_SDHI_StatusGet</a>(&amp;g_sdmmc0_ctrl, &amp;status);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!status.<a class="code" href="group___s_d_m_m_c___a_p_i.html#a5cba3f15b550023a08fa16e446cf2a35">card_inserted</a>)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">while</span> (!g_card_inserted)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for a card insertion interrupt. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* A device shall be ready to accept the first command within 1ms from detecting VDD min. Reference section 6.4.1.1</span></div><div class="line"><span class="comment">     * &quot;Power Up Time of Card&quot; in the SD Physical Layer Simplified Specification Version 6.00. */</span></div><div class="line">    <a class="code" href="group___b_s_p___m_c_u.html#gaf3219448adfd1531cf69f68697ab184b">R_BSP_SoftwareDelay</a>(1U, <a class="code" href="group___b_s_p___m_c_u.html#ggafd98e2a6f080d6a52a3ef72e3d731b2ba59fcc4e8d51046d4a1bd63c87ac64913">BSP_DELAY_UNITS_MILLISECONDS</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the SD card after card insertion is detected. */</span></div><div class="line">    err = <a class="code" href="group___s_d_h_i.html#gabacaaf35153339d0931c6c0932eca4e3">R_SDHI_MediaInit</a>(&amp;g_sdmmc0_ctrl, NULL);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* The callback is called when a card detection event occurs if the card detection interrupt is enabled. */</span></div><div class="line"><span class="keywordtype">void</span> r_sdhi_card_detect_example_callback (<a class="code" href="group___s_d_m_m_c___a_p_i.html#structsdmmc__callback__args__t">sdmmc_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___s_d_m_m_c___a_p_i.html#ggacf3d8d33331e1ae9810f56d2410ea524af72a094283f5c4ed2bda7d27ec19df80">SDMMC_EVENT_CARD_INSERTED</a> == p_args-&gt;<a class="code" href="group___s_d_m_m_c___a_p_i.html#a0d7d301a941f2d863035acb5574719e3">event</a>)</div><div class="line">    {</div><div class="line">        g_card_inserted = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___s_d_m_m_c___a_p_i.html#ggacf3d8d33331e1ae9810f56d2410ea524a878321ce4dc90270cc95f3019ee1aad6">SDMMC_EVENT_CARD_REMOVED</a> == p_args-&gt;<a class="code" href="group___s_d_m_m_c___a_p_i.html#a0d7d301a941f2d863035acb5574719e3">event</a>)</div><div class="line">    {</div><div class="line">        g_card_inserted = <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h2 class="groupheader">Function Documentation</h2>
<a id="ga37b6d1c11d0f6d92ef6ae985a420ffbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37b6d1c11d0f6d92ef6ae985a420ffbb">&#9670;&nbsp;</a></span>R_SDHI_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SDHI_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_d_m_m_c___a_p_i.html#ga81be65bcaee41616f4702b84eb51a499">sdmmc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_d_m_m_c___a_p_i.html#structsdmmc__cfg__t">sdmmc_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens the driver. Resets SDHI, and enables card detection interrupts if card detection is enabled. <a class="el" href="group___s_d_h_i.html#gabacaaf35153339d0931c6c0932eca4e3">R_SDHI_MediaInit</a> must be called after this function before any other functions can be used.</p>
<p>Implements <a class="el" href="group___s_d_m_m_c___a_p_i.html#afa538bb4e713dfc116e12417376c5ce4">sdmmc_api_t::open()</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Open the SDHI driver. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___s_d_h_i.html#ga37b6d1c11d0f6d92ef6ae985a420ffbb">R_SDHI_Open</a>(&amp;g_sdmmc0_ctrl, &amp;g_sdmmc0_cfg);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Module is now open. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null Pointer or block size is not in the valid range of 1-512. Block size must be 512 bytes for SD cards and eMMC devices. It is configurable for SDIO only. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Driver has already been opened with this instance of the control structure. </td></tr>
    <tr><td class="paramname">FSP_ERR_IRQ_BSP_DISABLED</td><td>Access interrupt is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_IP_CHANNEL_NOT_PRESENT</td><td>Requested channel does not exist on this MCU. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabacaaf35153339d0931c6c0932eca4e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabacaaf35153339d0931c6c0932eca4e3">&#9670;&nbsp;</a></span>R_SDHI_MediaInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SDHI_MediaInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_d_m_m_c___a_p_i.html#ga81be65bcaee41616f4702b84eb51a499">sdmmc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_d_m_m_c___a_p_i.html#structsdmmc__device__t">sdmmc_device_t</a> *const&#160;</td>
          <td class="paramname"><em>p_device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the SDHI hardware and completes identification and configuration for the SD or eMMC device. This procedure requires several sequential commands. This function blocks until all identification and configuration commands are complete.</p>
<p>Implements <a class="el" href="group___s_d_m_m_c___a_p_i.html#a2e756a69a66f0a6ae00eaa8a33f36243">sdmmc_api_t::mediaInit()</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* A device shall be ready to accept the first command within 1ms from detecting VDD min. Reference section 6.4.1.1</span></div><div class="line"><span class="comment">     * &quot;Power Up Time of Card&quot; in the SD Physical Layer Simplified Specification Version 6.00. */</span></div><div class="line">    <a class="code" href="group___b_s_p___m_c_u.html#gaf3219448adfd1531cf69f68697ab184b">R_BSP_SoftwareDelay</a>(1U, <a class="code" href="group___b_s_p___m_c_u.html#ggafd98e2a6f080d6a52a3ef72e3d731b2ba59fcc4e8d51046d4a1bd63c87ac64913">BSP_DELAY_UNITS_MILLISECONDS</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the SD card.  This should not be done until the card is plugged in for SD devices. */</span></div><div class="line">    err = <a class="code" href="group___s_d_h_i.html#gabacaaf35153339d0931c6c0932eca4e3">R_SDHI_MediaInit</a>(&amp;g_sdmmc0_ctrl, NULL);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Module is now ready for read/write access. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null Pointer or block size is not in the valid range of 1-512. Block size must be 512 bytes for SD cards and eMMC devices. It is configurable for SDIO only. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver has not been initialized. </td></tr>
    <tr><td class="paramname">FSP_ERR_CARD_INIT_FAILED</td><td>Device was not identified as an SD card, eMMC device, or SDIO card. </td></tr>
    <tr><td class="paramname">FSP_ERR_RESPONSE</td><td>Device did not respond or responded with an error. </td></tr>
    <tr><td class="paramname">FSP_ERR_DEVICE_BUSY</td><td>Device is holding DAT0 low (device is busy) or another operation is ongoing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga400250f503190acfb97e58a561feec69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga400250f503190acfb97e58a561feec69">&#9670;&nbsp;</a></span>R_SDHI_Read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SDHI_Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_d_m_m_c___a_p_i.html#ga81be65bcaee41616f4702b84eb51a499">sdmmc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>p_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>start_sector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>sector_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads data from an SD or eMMC device. Up to 0x10000 sectors can be read at a time. Implements <a class="el" href="group___s_d_m_m_c___a_p_i.html#a932862661f24778adfa5302e1bc1f7ae">sdmmc_api_t::read()</a>.</p>
<p>A callback with the event SDMMC_EVENT_TRANSFER_COMPLETE is called when the read data is available.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    err = <a class="code" href="group___s_d_h_i.html#ga400250f503190acfb97e58a561feec69">R_SDHI_Read</a>(&amp;g_sdmmc0_ctrl, g_dest, 3, 1);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Data read successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL pointer. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver has not been initialized. </td></tr>
    <tr><td class="paramname">FSP_ERR_CARD_NOT_INITIALIZED</td><td>Card was unplugged. </td></tr>
    <tr><td class="paramname">FSP_ERR_DEVICE_BUSY</td><td>Driver is busy with a previous operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabb1d35740c235c80edf43549fa3427d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb1d35740c235c80edf43549fa3427d7">&#9670;&nbsp;</a></span>R_SDHI_Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SDHI_Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_d_m_m_c___a_p_i.html#ga81be65bcaee41616f4702b84eb51a499">sdmmc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *const&#160;</td>
          <td class="paramname"><em>p_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>start_sector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>sector_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes data to an SD or eMMC device. Up to 0x10000 sectors can be written at a time. Implements <a class="el" href="group___s_d_m_m_c___a_p_i.html#a5294db71da024eb9721ea38723ef5508">sdmmc_api_t::write()</a>.</p>
<p>A callback with the event SDMMC_EVENT_TRANSFER_COMPLETE is called when the all data has been written and the device is no longer holding DAT0 low to indicate it is busy.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    err = <a class="code" href="group___s_d_h_i.html#gabb1d35740c235c80edf43549fa3427d7">R_SDHI_Write</a>(&amp;g_sdmmc0_ctrl, g_src, 3, 1);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Card write finished successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Handle or Source address is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver has not been initialized. </td></tr>
    <tr><td class="paramname">FSP_ERR_CARD_NOT_INITIALIZED</td><td>Card was unplugged. </td></tr>
    <tr><td class="paramname">FSP_ERR_DEVICE_BUSY</td><td>Driver is busy with a previous operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_CARD_WRITE_PROTECTED</td><td>SD card is Write Protected. </td></tr>
    <tr><td class="paramname">FSP_ERR_WRITE_FAILED</td><td>Write operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga844604588f44e8aa4495d27ffca74b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga844604588f44e8aa4495d27ffca74b0d">&#9670;&nbsp;</a></span>R_SDHI_ReadIo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SDHI_ReadIo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_d_m_m_c___a_p_i.html#ga81be65bcaee41616f4702b84eb51a499">sdmmc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The Read function reads a one byte register from an SDIO card. Implements <a class="el" href="group___s_d_m_m_c___a_p_i.html#a24e4210d2ec82b9524d91ee080bae26e">sdmmc_api_t::readIo()</a>.</p>
<p>This function blocks until the command is sent and the response is received. p_data contains the register value read when this function returns.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Data read successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL pointer. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver has not been initialized. </td></tr>
    <tr><td class="paramname">FSP_ERR_CARD_NOT_INITIALIZED</td><td>Card was unplugged. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>SDIO support disabled in SDHI_CFG_SDIO_SUPPORT_ENABLE. </td></tr>
    <tr><td class="paramname">FSP_ERR_RESPONSE</td><td>Device did not respond or responded with an error. </td></tr>
    <tr><td class="paramname">FSP_ERR_DEVICE_BUSY</td><td>Device is holding DAT0 low (device is busy) or another operation is ongoing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga111f9479ed25bba03ade5c6c40248e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga111f9479ed25bba03ade5c6c40248e44">&#9670;&nbsp;</a></span>R_SDHI_WriteIo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SDHI_WriteIo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_d_m_m_c___a_p_i.html#ga81be65bcaee41616f4702b84eb51a499">sdmmc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_d_m_m_c___a_p_i.html#ga55695633a9591a08f956911271fba9fd">sdmmc_io_write_mode_t</a> const&#160;</td>
          <td class="paramname"><em>read_after_write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a one byte register to an SDIO card. Implements <a class="el" href="group___s_d_m_m_c___a_p_i.html#a99dfa8f5b48ee979c98f638c341a1ebb">sdmmc_api_t::writeIo()</a>.</p>
<p>This function blocks until the command is sent and the response is received. The register has been written when this function returns. If read_after_write is true, p_data contains the register value read when this function returns.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Card write finished successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Handle or Source address is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver has not been initialized. </td></tr>
    <tr><td class="paramname">FSP_ERR_CARD_NOT_INITIALIZED</td><td>Card was unplugged. </td></tr>
    <tr><td class="paramname">FSP_ERR_WRITE_FAILED</td><td>Write operation failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>SDIO support disabled in SDHI_CFG_SDIO_SUPPORT_ENABLE. </td></tr>
    <tr><td class="paramname">FSP_ERR_RESPONSE</td><td>Device did not respond or responded with an error. </td></tr>
    <tr><td class="paramname">FSP_ERR_DEVICE_BUSY</td><td>Device is holding DAT0 low (device is busy) or another operation is ongoing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafd18fd8115dff4bfda4dadd5468783fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd18fd8115dff4bfda4dadd5468783fd">&#9670;&nbsp;</a></span>R_SDHI_ReadIoExt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SDHI_ReadIoExt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_d_m_m_c___a_p_i.html#ga81be65bcaee41616f4702b84eb51a499">sdmmc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>p_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *const&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_d_m_m_c___a_p_i.html#gabce3d8ad0d84595d7579a5c5efa4306e">sdmmc_io_transfer_mode_t</a>&#160;</td>
          <td class="paramname"><em>transfer_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_d_m_m_c___a_p_i.html#gafa20c01a4dbbd10b3de7fde3ab252df3">sdmmc_io_address_mode_t</a>&#160;</td>
          <td class="paramname"><em>address_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads data from an SDIO card function. Implements <a class="el" href="group___s_d_m_m_c___a_p_i.html#a9f70fd005c73c7e65366aacf5e3b249f">sdmmc_api_t::readIoExt()</a>.</p>
<p>This function blocks until the command is sent and the response is received. A callback with the event SDMMC_EVENT_TRANSFER_COMPLETE is called when the read data is available.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Data read successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL pointer, or count is not in the valid range of 1-512 for byte mode or 1-511 for block mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver has not been initialized. </td></tr>
    <tr><td class="paramname">FSP_ERR_CARD_NOT_INITIALIZED</td><td>Card was unplugged. </td></tr>
    <tr><td class="paramname">FSP_ERR_DEVICE_BUSY</td><td>Driver is busy with a previous operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>SDIO support disabled in SDHI_CFG_SDIO_SUPPORT_ENABLE. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa73674cc979a40b00e4aed1ed9b5aa34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa73674cc979a40b00e4aed1ed9b5aa34">&#9670;&nbsp;</a></span>R_SDHI_WriteIoExt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SDHI_WriteIoExt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_d_m_m_c___a_p_i.html#ga81be65bcaee41616f4702b84eb51a499">sdmmc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *const&#160;</td>
          <td class="paramname"><em>p_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_d_m_m_c___a_p_i.html#gabce3d8ad0d84595d7579a5c5efa4306e">sdmmc_io_transfer_mode_t</a>&#160;</td>
          <td class="paramname"><em>transfer_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_d_m_m_c___a_p_i.html#gafa20c01a4dbbd10b3de7fde3ab252df3">sdmmc_io_address_mode_t</a>&#160;</td>
          <td class="paramname"><em>address_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes data to an SDIO card function. Implements <a class="el" href="group___s_d_m_m_c___a_p_i.html#a085fee74e5231b23d6ecd9120caf3fa9">sdmmc_api_t::writeIoExt()</a>.</p>
<p>This function blocks until the command is sent and the response is received. A callback with the event SDMMC_EVENT_TRANSFER_COMPLETE is called when the all data has been written.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Card write finished successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL pointer, or count is not in the valid range of 1-512 for byte mode or 1-511 for block mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver has not been initialized. </td></tr>
    <tr><td class="paramname">FSP_ERR_CARD_NOT_INITIALIZED</td><td>Card was unplugged. </td></tr>
    <tr><td class="paramname">FSP_ERR_DEVICE_BUSY</td><td>Driver is busy with a previous operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_WRITE_FAILED</td><td>Write operation failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>SDIO support disabled in SDHI_CFG_SDIO_SUPPORT_ENABLE. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga17fa126d6fb356bfc3e13d7384582504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17fa126d6fb356bfc3e13d7384582504">&#9670;&nbsp;</a></span>R_SDHI_IoIntEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SDHI_IoIntEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_d_m_m_c___a_p_i.html#ga81be65bcaee41616f4702b84eb51a499">sdmmc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables or disables the SDIO Interrupt. Implements <a class="el" href="group___s_d_m_m_c___a_p_i.html#a3a7228d697b714229e37a1bf54352f5a">sdmmc_api_t::ioIntEnable()</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Card enabled or disabled SDIO interrupts successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver has not been initialized. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL pointer. </td></tr>
    <tr><td class="paramname">FSP_ERR_DEVICE_BUSY</td><td>Driver is busy with a previous operation. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>SDIO support disabled in SDHI_CFG_SDIO_SUPPORT_ENABLE. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6bebd1e0295bac31b76888d4fca94f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bebd1e0295bac31b76888d4fca94f90">&#9670;&nbsp;</a></span>R_SDHI_StatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SDHI_StatusGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_d_m_m_c___a_p_i.html#ga81be65bcaee41616f4702b84eb51a499">sdmmc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_d_m_m_c___a_p_i.html#structsdmmc__status__t">sdmmc_status_t</a> *const&#160;</td>
          <td class="paramname"><em>p_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides driver status. Implements <a class="el" href="group___s_d_m_m_c___a_p_i.html#a5bb1be42ac391c9016bd3f6efb3a6b68">sdmmc_api_t::statusGet()</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Status stored in p_status. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>NULL pointer. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver has not been initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad954571b08da622a4b232680190b4313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad954571b08da622a4b232680190b4313">&#9670;&nbsp;</a></span>R_SDHI_Erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SDHI_Erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_d_m_m_c___a_p_i.html#ga81be65bcaee41616f4702b84eb51a499">sdmmc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>start_sector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>sector_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Erases sectors of an SD card or eMMC device. Implements <a class="el" href="group___s_d_m_m_c___a_p_i.html#adeb37ae1b226f926ffe36f5dc19f47b2">sdmmc_api_t::erase()</a>.</p>
<p>This function blocks until the erase command is sent. Poll the status to determine when erase is complete.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Erase operation requested. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL or an argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver has not been initialized. </td></tr>
    <tr><td class="paramname">FSP_ERR_CARD_NOT_INITIALIZED</td><td>Card was unplugged. </td></tr>
    <tr><td class="paramname">FSP_ERR_CARD_WRITE_PROTECTED</td><td>SD card is Write Protected. </td></tr>
    <tr><td class="paramname">FSP_ERR_RESPONSE</td><td>Device did not respond or responded with an error. </td></tr>
    <tr><td class="paramname">FSP_ERR_DEVICE_BUSY</td><td>Device is holding DAT0 low (device is busy) or another operation is ongoing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga78d9f9f873c52843f778fd700ef38936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78d9f9f873c52843f778fd700ef38936">&#9670;&nbsp;</a></span>R_SDHI_CallbackSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SDHI_CallbackSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_d_m_m_c___a_p_i.html#ga81be65bcaee41616f4702b84eb51a499">sdmmc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="group___s_d_m_m_c___a_p_i.html#structsdmmc__callback__args__t">sdmmc_callback_args_t</a> *)&#160;</td>
          <td class="paramname"><em>p_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>p_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_d_m_m_c___a_p_i.html#structsdmmc__callback__args__t">sdmmc_callback_args_t</a> *const&#160;</td>
          <td class="paramname"><em>p_callback_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the user callback with the option to provide memory for the callback argument structure. Implements <a class="el" href="group___s_d_m_m_c___a_p_i.html#a7e8903825189ff782fd28316f49d6e7e">sdmmc_api_t::callbackSet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Callback updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_NO_CALLBACK_MEMORY</td><td>p_callback is non-secure and p_callback_memory is either secure or NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga76e778c7c058c3ca09f63f05c30d00c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76e778c7c058c3ca09f63f05c30d00c1">&#9670;&nbsp;</a></span>R_SDHI_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SDHI_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_d_m_m_c___a_p_i.html#ga81be65bcaee41616f4702b84eb51a499">sdmmc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes an open SD/MMC device. Implements <a class="el" href="group___s_d_m_m_c___a_p_i.html#a36c443d21eb54717d3658aada3ba1720">sdmmc_api_t::close()</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful close. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>The parameter p_ctrl is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver has not been initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v3.1.0 User's Manual Copyright  (2021) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
