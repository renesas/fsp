<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: SMCI (r_sci_smci)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
    $(document).ready(function() {
        $("tr.tree_lvl_1").nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
		$("tr.tree_lvl_1").data("expanded","0");
		$("tr.tree_lvl_2").data("expanded","0");
		$("tr.tree_lvl_3").data("expanded","0");
		$("tr.tree_lvl_4").data("expanded","0");
		$("tr.tree_lvl_5").data("expanded","0");
        $("tr.tree_lvl_1").click(function() {
		    var lvl_1_is_open = $(this).data("expanded");
		    if (lvl_1_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2, tr.tree_lvl_1_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_2").click(function() {
		    var lvl_2_is_open = $(this).data("expanded");
		    if (lvl_2_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3, tr.tree_lvl_2_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_3").click(function() {
		    var lvl_3_is_open = $(this).data("expanded");
		    if (lvl_3_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_3_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_4").click(function() {
		    var lvl_4_is_open = $(this).data("expanded");
		    if (lvl_4_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5, tr.tree_lvl_4_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_5").click(function() {
		    var lvl_5_is_open = $(this).data("expanded");
		    if (lvl_5_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4_item,tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
     });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v6.2.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">

    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text">
      </span>
      <span class="right">
          &nbsp;
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___s_c_i___s_m_c_i.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body.
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len));
            }
          }
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element.
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<div class="title">SMCI (r_sci_smci)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___c_o_n_n_e_c_t_i_v_i_t_y___m_o_d_u_l_e_s.html">Connectivity</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga05be62c30141f682d49a90eb4302e167"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_i___s_m_c_i.html#ga05be62c30141f682d49a90eb4302e167">R_SCI_SMCI_Open</a> (<a class="el" href="group___s_m_c_i___a_p_i.html#ga57de10ab58c1265be3227fa2f8cf9fd1">smci_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___s_m_c_i___a_p_i.html#structsmci__cfg__t">smci_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:ga05be62c30141f682d49a90eb4302e167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad02034ac85b6154383c9cdcd42b278c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_i___s_m_c_i.html#gad02034ac85b6154383c9cdcd42b278c6">R_SCI_SMCI_Write</a> (<a class="el" href="group___s_m_c_i___a_p_i.html#ga57de10ab58c1265be3227fa2f8cf9fd1">smci_ctrl_t</a> *const p_api_ctrl, uint8_t const *const p_src, uint32_t const bytes)</td></tr>
<tr class="separator:gad02034ac85b6154383c9cdcd42b278c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01e8705f673194e6dd12504d21351510"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_i___s_m_c_i.html#ga01e8705f673194e6dd12504d21351510">R_SCI_SMCI_Read</a> (<a class="el" href="group___s_m_c_i___a_p_i.html#ga57de10ab58c1265be3227fa2f8cf9fd1">smci_ctrl_t</a> *const p_api_ctrl, uint8_t *const p_dest, uint32_t const bytes)</td></tr>
<tr class="separator:ga01e8705f673194e6dd12504d21351510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab49a2b71354a30df79c1d19c7479200d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_i___s_m_c_i.html#gab49a2b71354a30df79c1d19c7479200d">R_SCI_SMCI_TransferModeSet</a> (<a class="el" href="group___s_m_c_i___a_p_i.html#ga57de10ab58c1265be3227fa2f8cf9fd1">smci_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___s_m_c_i___a_p_i.html#structsmci__transfer__mode__t">smci_transfer_mode_t</a> const *const p_transfer_mode_params)</td></tr>
<tr class="separator:gab49a2b71354a30df79c1d19c7479200d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae93d0d470c41b66250dc452bf2907b22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_i___s_m_c_i.html#gae93d0d470c41b66250dc452bf2907b22">R_SCI_SMCI_BaudSet</a> (<a class="el" href="group___s_m_c_i___a_p_i.html#ga57de10ab58c1265be3227fa2f8cf9fd1">smci_ctrl_t</a> *const p_api_ctrl, void const *const p_baud_setting)</td></tr>
<tr class="separator:gae93d0d470c41b66250dc452bf2907b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d600ae7699ba4988e007a03aa28c93e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_i___s_m_c_i.html#ga3d600ae7699ba4988e007a03aa28c93e">R_SCI_SMCI_StatusGet</a> (<a class="el" href="group___s_m_c_i___a_p_i.html#ga57de10ab58c1265be3227fa2f8cf9fd1">smci_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___s_m_c_i___a_p_i.html#structsmci__status__t">smci_status_t</a> *const p_status)</td></tr>
<tr class="separator:ga3d600ae7699ba4988e007a03aa28c93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64d56497dd40550887bfdffa9edc7089"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_i___s_m_c_i.html#ga64d56497dd40550887bfdffa9edc7089">R_SCI_SMCI_ClockControl</a> (<a class="el" href="group___s_m_c_i___a_p_i.html#ga57de10ab58c1265be3227fa2f8cf9fd1">smci_ctrl_t</a> *const p_api_ctrl, bool clock_enable)</td></tr>
<tr class="separator:ga64d56497dd40550887bfdffa9edc7089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1161f78bfb6b8b83aafd3353377a3f0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_i___s_m_c_i.html#ga1161f78bfb6b8b83aafd3353377a3f0d">R_SCI_SMCI_CallbackSet</a> (<a class="el" href="group___s_m_c_i___a_p_i.html#ga57de10ab58c1265be3227fa2f8cf9fd1">smci_ctrl_t</a> *const p_api_ctrl, void(*p_callback)(<a class="el" href="group___s_m_c_i___a_p_i.html#structsmci__callback__args__t">smci_callback_args_t</a> *), void *const p_context, <a class="el" href="group___s_m_c_i___a_p_i.html#structsmci__callback__args__t">smci_callback_args_t</a> *const p_callback_memory)</td></tr>
<tr class="separator:ga1161f78bfb6b8b83aafd3353377a3f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dd22a1d0b7720dbe84a888897320c8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_i___s_m_c_i.html#ga2dd22a1d0b7720dbe84a888897320c8c">R_SCI_SMCI_Close</a> (<a class="el" href="group___s_m_c_i___a_p_i.html#ga57de10ab58c1265be3227fa2f8cf9fd1">smci_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:ga2dd22a1d0b7720dbe84a888897320c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59cb52f2d340fddc4abfdda54e0f660f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_i___s_m_c_i.html#ga59cb52f2d340fddc4abfdda54e0f660f">R_SCI_SMCI_BaudCalculate</a> (<a class="el" href="group___s_m_c_i___a_p_i.html#structsmci__speed__params__t">smci_speed_params_t</a> const *const p_speed_params, uint32_t baud_rate_error_x_1000, void *const p_baud_setting)</td></tr>
<tr class="separator:ga59cb52f2d340fddc4abfdda54e0f660f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the SCI peripheral on RA MCUs. This module implements the <a class="el" href="group___s_m_c_i___a_p_i.html">SMCI Interface</a>. </p>
<h1><a class="anchor" id="r-sci-smci-overview"></a>
Overview</h1>
<h2><a class="anchor" id="r-sci-smci-features"></a>
Features</h2>
<p>The SCI SMCI module supports the following features:</p><ul>
<li>Abort in-progress read/write operations<a class="anchor" id="um_sci_smci_close"></a><a class="anchor" id="um_sci_smci_statusget"></a></li>
<li>Interrupt-driven data transmission and reception<a class="anchor" id="um_sci_smci_interruptBasedtransmission"></a></li>
<li>Invoking the user-callback function with an event code (RX/TX complete, RX char, error, etc)<a class="anchor" id="um_sci_smci_callbackset"></a></li>
<li>Transfer mode (normal and block) and data convention type change at run time.<a class="anchor" id="um_sci_smci_transfer_mode_set"></a></li>
<li>All channels with SMCI support shall be configurable by the driver<a class="anchor" id="um_sci_smci_multiple_channel_support"></a></li>
<li>Baud-rate (and ETU) calculation and change based on ISO7816 asynchronous parameters at run-time. ETU is 1/baud.<a class="anchor" id="um_sci_smci_baudcalculate"></a><a class="anchor" id="um_sci_smci_baudset"></a></li>
<li>Error notifications of parity error, error signal reception (guard time) and overrun.<a class="anchor" id="um_sci_smci_errorhandling"></a></li>
<li>Clock output control<a class="anchor" id="um_sci_smci_clockset"></a> </li>
</ul>
<h1><a class="anchor" id="r-sci-smci-configuration"></a>
Configuration</h1>
<p><h2>Build Time Configurations for r_sci_smci</h2>
The following build time configurations are defined in fsp_cfg/r_sci_smci_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
</table>
 <h2>Configurations for Connectivity &gt; SMCI (r_sci_smci)</h2>
This module can be added to the Stacks tab via New Stack &gt; Connectivity &gt; SMCI (r_sci_smci). Non-secure callable guard functions can be generated for this module by right clicking the module in the RA Configuration tool and checking the "Non-secure Callable" box.<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> General  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Name</td><td>Name must be a valid C symbol</td><td>g_smci0 </td><td>Module name. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Channel</td><td>Value must be a non-negative integer</td><td>0 </td><td>Select the SCI channel. </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Baud  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Baud Rate</td><td>Value must be an integer greater than 0</td><td>9600 </td><td>Enter the desired baud rate.<br />
<br />
If the requested baud rate cannot be achieved, the settings with the smallest percent error are used. The theoretical calculated baud rate and percent error are printed in a comment in the generated <a class="el" href="group___s_c_i___u_a_r_t.html#structbaud__setting__t">baud_setting_t</a> structure. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Clock conversion integer</td><td>Refer to the RA Configuration tool for available options.</td><td>F=372 fmax=5MHz D=1 </td><td>Clock rate conversion integer is one of transmission parameters defined by ISO7816-3 as F and also decodes to f-max of the output clock. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Max Error (%)</td><td>Must be a valid non negative integer with a maximum configurable value of 100</td><td>5 </td><td>Maximum percent error allowed during baud calculation. This is used by the algorithm to determine whether or not to consider using less accurate alternative register settings.<br />
<br />
NOTE: The baud calculation does not show an error in the tool if this percent error was not achieved. The calculated percent error is recorded in a comment in the generated <a class="el" href="group___s_c_i___u_a_r_t.html#structbaud__setting__t">baud_setting_t</a> structure. </td></tr>
<tr class="tree_lvl_1">
<td class="tree_lvl_1" colspan="4"><span class="chevron-collapsed"></span> Interrupts  </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Callback</td><td>Name must be a valid C symbol</td><td>user_smci_callback </td><td>A user callback function can be provided. If this callback function is provided, it will be called from the interrupt service routine (ISR). </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Receive Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select the receive interrupt priority. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Transmit Data Empty Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select the transmit interrupt priority. </td></tr>
<tr class="tree_lvl_1_item">
<td class="tree_lvl_1_cell">Error Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select the error interrupt priority. </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-sci-smci-clock-configuration"></a>
Clock Configuration</h2>
<p>The clock for this module is derived from the following peripheral clock for each MCU group:<br />
</p><table class="doxtable">
<tr>
<th>MCU Group</th><th>Peripheral Clock </th></tr>
<tr>
<td>RA2A1</td><td>PCLKB</td></tr>
<tr>
<td>RA2A2</td><td>PCLKB</td></tr>
<tr>
<td>RA2E1</td><td>PCLKB</td></tr>
<tr>
<td>RA2E2</td><td>PCLKB</td></tr>
<tr>
<td>RA2E3</td><td>PCLKB</td></tr>
<tr>
<td>RA2L1</td><td>PCLKB</td></tr>
<tr>
<td>RA2L2</td><td>PCLKB</td></tr>
<tr>
<td>RA2T1</td><td>PCLKB</td></tr>
<tr>
<td>RA4C1</td><td>PCLKA</td></tr>
<tr>
<td>RA4E1</td><td>PCLKA</td></tr>
<tr>
<td>RA4E2</td><td>PCLKA</td></tr>
<tr>
<td>RA4L1</td><td>PCLKA</td></tr>
<tr>
<td>RA4M1</td><td>PCLKA</td></tr>
<tr>
<td>RA4M2</td><td>PCLKA</td></tr>
<tr>
<td>RA4M3</td><td>PCLKA</td></tr>
<tr>
<td>RA4T1</td><td>PCLKA</td></tr>
<tr>
<td>RA4W1</td><td>PCLKA</td></tr>
<tr>
<td>RA6E1</td><td>PCLKA</td></tr>
<tr>
<td>RA6E2</td><td>PCLKA</td></tr>
<tr>
<td>RA6M1</td><td>PCLKA</td></tr>
<tr>
<td>RA6M2</td><td>PCLKA</td></tr>
<tr>
<td>RA6M3</td><td>PCLKA</td></tr>
<tr>
<td>RA6M4</td><td>PCLKA</td></tr>
<tr>
<td>RA6M5</td><td>PCLKA</td></tr>
<tr>
<td>RA6T1</td><td>PCLKA</td></tr>
<tr>
<td>RA6T3</td><td>PCLKA</td></tr>
</table>
</p>
<p>The clock source for the baud-rate clock generator is the PCLK. It is scaled by the SMR_SMCI.CKS bits to achieve the requested baud rate. This is done in R_SCI_SMCI_BaudSet routine.<a class="anchor" id="um_sci_smci_clock_configuration"></a> </p>
<h2><a class="anchor" id="r-sci-smci-pin-configuration"></a>
Pin Configuration</h2>
<p>This module uses TXDx and RXDx to communicate to external devices. TXDx and RXDx need to be tied together and pulled up to VCC externally via a pullup resistor and connected to the DATA line of a connected card.</p>
<p>The SmartCard clock signal is generated by the SMCI module on the SCKx pin. The clock frequency produced by the module is <code>(baudrate * F) / D</code>. The ISO specification defines the valid maximum frequency range as 4Mhz to 20MHz; only certain combinations of Fi, Di and f(max) are allowed.</p>
<p>When writing the application for the driver, the application developer must also allocate a software controlled Reset line via a GPIO. This will allow the reliable receipt of the ATR message. Optionally, VCC and VPP can also be controlled by a GPIO output, so that cold starts can be forced.</p>
<h1><a class="anchor" id="r-sci-smci-usage_notes"></a>
Usage Notes</h1>
<p>The SMCI module is compliant to ISO7816-3. SMCI is a half duplex interface. Direct convention in T0 mode is the default. The driver supports both direct and indirect (inverted) modes of transmission. It also supports GSM mode in which the output clock can be enabled and disabled while the interface is still active. If it is known that the device connected is a device in inverse convention, the convention can be changed with <a class="el" href="group___s_m_c_i___a_p_i.html#a0d6fb54665f8d10237d1bf87488f42b2">smci_api_t::transferModeSet()</a> after calling open.</p>
<p>The MCU creates the clock for the attached SMCI device based on the initial baudrate setting. Upon reset the SmartCard device advertises the Di and Fi parameters as well as the max clock speed it can handle. The Di and Fi parameters dictate at what rate the SmartCard device can sample the data line as a function of the supplied clock generated by the RA MCU. Only certain combinations of D and F are supported by the SMCI on SCI module. Only combinations where the the ratio of S=F/D corresponds to a value of S of 32, 64, 93, 128, 186, 256, 372, or 512 (for example see Table "Base clock settings in smart card interface mode" in the SCI section of the relevant hardware manual).</p>
<p>The baud rate (1/ETU) can be changed while the device is open to allow for speed negotiation based on the attached device's capabilities.</p>
<p>The SMCI module does not contain a FIFO, and as such the receipt of multi-byte data has to be handled by interrupt initiated callback. The application developer must develop their callback so that the receipt of data is handled sufficiently without receiver overrun. If the read routine is called with a length=0, every receive interrupt will initiate a call to the user's callback. If the read is called with a non-zero length... the interrupt will fill the user's read buffer and initiate the callback after the last byte is complete. In many cases, the user can send an event from their callback so that the reading routine can wait for the event with a timeout. If a timeout occurs, the user can return the read state machine to an idle state by calling the read routine with a length of 0.</p>
<h2><a class="anchor" id="r-sci-smci-limitations"></a>
Limitations</h2>
<h1><a class="anchor" id="r-sci-smci-examples"></a>
Examples</h1>
<h2>SCI SMCI Example</h2>
<div class="fragment"><div class="line">uint8_t  g_dest[TRANSFER_LENGTH];</div><div class="line">uint8_t  g_src[TRANSFER_LENGTH];</div><div class="line">uint8_t  g_out_of_band_received[TRANSFER_LENGTH];</div><div class="line">uint32_t g_transfer_complete = 0;</div><div class="line">uint32_t g_receive_complete  = 0;</div><div class="line">uint32_t g_out_of_band_index = 0;</div><div class="line"><span class="keywordtype">void</span> r_sci_smci_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Initialize g_src to known data */</span></div><div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; TRANSFER_LENGTH; i++)</div><div class="line">    {</div><div class="line">        g_src[i] = (uint8_t) (<span class="charliteral">&#39;A&#39;</span> + (i % 26));</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Open the smci instance with initial configuration. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___s_c_i___s_m_c_i.html#ga05be62c30141f682d49a90eb4302e167">R_SCI_SMCI_Open</a>(&amp;g_smci0_ctrl, &amp;g_smci0_cfg);</div><div class="line"></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Need to have clock on inorder to receive or transmit*/</span></div><div class="line">    <a class="code" href="group___s_c_i___s_m_c_i.html#ga64d56497dd40550887bfdffa9edc7089">R_SCI_SMCI_ClockControl</a>(&amp;g_smci0_ctrl, <span class="keyword">true</span>);</div><div class="line"></div><div class="line"></div><div class="line">    err = <a class="code" href="group___s_c_i___s_m_c_i.html#ga01e8705f673194e6dd12504d21351510">R_SCI_SMCI_Read</a>(&amp;g_smci0_ctrl, g_dest, TRANSFER_LENGTH);</div><div class="line"></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    err = <a class="code" href="group___s_c_i___s_m_c_i.html#gad02034ac85b6154383c9cdcd42b278c6">R_SCI_SMCI_Write</a>(&amp;g_smci0_ctrl, g_src, TRANSFER_LENGTH);</div><div class="line"></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (!g_transfer_complete)</div><div class="line">    {</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (!g_receive_complete)</div><div class="line">    {</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> user_smci_callback (<a class="code" href="group___s_m_c_i___a_p_i.html#structsmci__callback__args__t">smci_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="comment">/* Handle the SMCI event */</span></div><div class="line">    <span class="keywordflow">switch</span> (p_args-&gt;<a class="code" href="group___s_m_c_i___a_p_i.html#ad4350398420bfc484382c51fe6d7a45f">event</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Received a character */</span></div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___s_m_c_i___a_p_i.html#ggaa4182189b3196a6fd900d0498837ffe0afeede5c8b61e49e217a9cd3650d753b5">SMCI_EVENT_RX_CHAR</a>:</div><div class="line">        {</div><div class="line">            <span class="comment">/* Only put the next character in the receive buffer if there is space for it */</span></div><div class="line">            <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(g_out_of_band_received) &gt; g_out_of_band_index)</div><div class="line">            {</div><div class="line">                <span class="comment">/* Write either the next one or two bytes depending on the receive data size */</span></div><div class="line">                g_out_of_band_received[g_out_of_band_index++] = p_args-&gt;<a class="code" href="group___s_m_c_i___a_p_i.html#a8793eceeb57502f91db935dee7e73d78">data</a>;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Receive complete */</span></div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___s_m_c_i___a_p_i.html#ggaa4182189b3196a6fd900d0498837ffe0afe55cbb059f0927458c135e06745d241">SMCI_EVENT_RX_COMPLETE</a>:</div><div class="line">        {</div><div class="line">            g_receive_complete = 1;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Transmit complete */</span></div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___s_m_c_i___a_p_i.html#ggaa4182189b3196a6fd900d0498837ffe0aa8e228fba65d991db52a54a54f360a8a">SMCI_EVENT_TX_COMPLETE</a>:</div><div class="line">        {</div><div class="line">            g_transfer_complete = 1;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">        {</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h2>SCI SMCI Baud Set Example</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define SCI_SMCI_BAUDRATE_28800              (28800)</span></div><div class="line"><span class="preprocessor">#define SCI_SMCI_BAUDRATE_ERROR_PERCENT_5    (5000)</span></div><div class="line"><span class="keywordtype">void</span> r_sci_smci_baud_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___s_m_c_i___a_p_i.html#structsmci__speed__params__t">smci_speed_params_t</a> speed_settings;</div><div class="line">    <a class="code" href="group___s_c_i___s_m_c_i.html#structsmci__baud__setting__t">smci_baud_setting_t</a> baud_setting;</div><div class="line"></div><div class="line"></div><div class="line">    speed_settings.<a class="code" href="group___s_m_c_i___a_p_i.html#a5c866965929776f3cfae03ad3d121234">baudrate</a> = SCI_SMCI_BAUDRATE_28800;</div><div class="line">    speed_settings.<a class="code" href="group___s_m_c_i___a_p_i.html#a20ab30399e1128ec9cc6c9df0da11e77">fi</a>       = <a class="code" href="group___s_m_c_i___a_p_i.html#ggaf3ce6b7f8d14861c050c192f69d961fbad75afc725f816f4a5dc349c49dee5d91">SMCI_CLOCK_CONVERSION_INTEGER_512_5</a>;</div><div class="line">    speed_settings.<a class="code" href="group___s_m_c_i___a_p_i.html#a318d491043ce8d20bd563573fc237522">di</a>       = <a class="code" href="group___s_m_c_i___a_p_i.html#ggadd6e0bc7d0dc581c5f24068321bd6ac5ade5dbdcbbb6642a35519c6b656fbf2b8">SMCI_BAUDRATE_ADJUSTMENT_INTEGER_4</a>;</div><div class="line"></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___s_c_i___s_m_c_i.html#ga59cb52f2d340fddc4abfdda54e0f660f">R_SCI_SMCI_BaudCalculate</a>(&amp;speed_settings, SCI_SMCI_BAUDRATE_ERROR_PERCENT_5, &amp;baud_setting);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    err = <a class="code" href="group___s_c_i___s_m_c_i.html#gae93d0d470c41b66250dc452bf2907b22">R_SCI_SMCI_BaudSet</a>(&amp;g_smci0_ctrl, (<span class="keywordtype">void</span> *) &amp;baud_setting);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structsci__smci__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_i___s_m_c_i.html#structsci__smci__instance__ctrl__t">sci_smci_instance_ctrl_t</a></td></tr>
<tr class="separator:structsci__smci__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsmci__baud__setting__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_i___s_m_c_i.html#structsmci__baud__setting__t">smci_baud_setting_t</a></td></tr>
<tr class="separator:structsmci__baud__setting__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsci__smci__extended__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_i___s_m_c_i.html#structsci__smci__extended__cfg__t">sci_smci_extended_cfg_t</a></td></tr>
<tr class="separator:structsci__smci__extended__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structsci__smci__instance__ctrl__t" id="structsci__smci__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structsci__smci__instance__ctrl__t">&#9670;&nbsp;</a></span>sci_smci_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sci_smci_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>SMCI instance control block. </p>
</div>
</div>
</div>
<a name="structsmci__baud__setting__t" id="structsmci__baud__setting__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structsmci__baud__setting__t">&#9670;&nbsp;</a></span>smci_baud_setting_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct smci_baud_setting_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Register settings to achieve a desired baud rate in Smart Card mode </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a60a791bd1b70495b092b7ee21ad5344b"></a>uint32_t</td>
<td class="fieldname">
computed_baud_rate</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aaee82365851ec0b8b24bb27566f046a7"></a>union <a class="el" href="group___s_c_i___s_m_c_i.html#unionsmci__baud__setting__t_8____unnamed____">smci_baud_setting_t</a></td>
<td class="fieldname">
__unnamed__</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a54015b14162dd619b8cf66eb593da0ae"></a>uint8_t</td>
<td class="fieldname">
scmr_bcp2: 1</td>
<td class="fielddoc">
BCP2 setting in Smart Card Mode Register. </td></tr>
<tr><td class="fieldtype">
<a id="a6c71b9459d823f344735ff959861be98"></a>uint8_t</td>
<td class="fieldname">
brr</td>
<td class="fielddoc">
Bit Rate Register setting. </td></tr>
</table>

</div>
</div>
<a name="structsci__smci__extended__cfg__t" id="structsci__smci__extended__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structsci__smci__extended__cfg__t">&#9670;&nbsp;</a></span>sci_smci_extended_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sci_smci_extended_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>SMCI on SCI device Configuration </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a2f7d2f1e579917ffdd5ba316120fd342"></a><a class="el" href="group___s_c_i___s_m_c_i.html#structsmci__baud__setting__t">smci_baud_setting_t</a> *</td>
<td class="fieldname">
p_smci_baud_setting</td>
<td class="fielddoc">
Register settings for a desired baud rate. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga05be62c30141f682d49a90eb4302e167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05be62c30141f682d49a90eb4302e167">&#9670;&nbsp;</a></span>R_SCI_SMCI_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SCI_SMCI_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_m_c_i___a_p_i.html#ga57de10ab58c1265be3227fa2f8cf9fd1">smci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_m_c_i___a_p_i.html#structsmci__cfg__t">smci_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the Smart Card Interface driver based on the input configurations. The interface stays in the clock-off state without enabling reception at the end of this function. ISO7816-3 default communication parameters are used to initial ize SMCI port speed and parameters, as the ATR message is always sent in that format. Only if Inverse convention is expected should the transfer mode be changed after reset. Implements <a class="el" href="group___s_m_c_i___a_p_i.html#ac847fa0d02bccd62dc798dc43275e208">smci_api_t::open</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_api_ctrl</td><td>Pointer to SMCI control block that is to be opened </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_cfg</td><td>Pointer to the config structure that shall be used to set parameters of the SMCI baud calculations needed to be have done and set into p_cfg-&gt;p_extend-&gt;p_smci_baud_setting</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Channel opened successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to SMCI control block or configuration structure is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_IP_CHANNEL_NOT_PRESENT</td><td>The requested channel does not exist on this MCU. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Control block has already been opened or channel is being used by another instance. Call close() then open() to reconfigure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html">Common Error Codes</a> or functions called by this function for other possible return codes. </dd></dl>

</div>
</div>
<a id="gad02034ac85b6154383c9cdcd42b278c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad02034ac85b6154383c9cdcd42b278c6">&#9670;&nbsp;</a></span>R_SCI_SMCI_Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SCI_SMCI_Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_m_c_i___a_p_i.html#ga57de10ab58c1265be3227fa2f8cf9fd1">smci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *const&#160;</td>
          <td class="paramname"><em>p_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transmits user specified number of bytes from the source buffer pointer. Implements <a class="el" href="group___s_m_c_i___a_p_i.html#a0b49045db38b2e480d8e7c347a5d4cbd">smci_api_t::write</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_api_ctrl</td><td>Pointer to SMCI control block that is to be opened </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_src</td><td>Pointer to buffer that will be written out </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bytes</td><td>Number of bytes to be transferred</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Data transmission started successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to SMCI control block is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>A SMCI transmission is in progress</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html">Common Error Codes</a> or functions called by this function for other possible return codes. </dd></dl>

</div>
</div>
<a id="ga01e8705f673194e6dd12504d21351510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01e8705f673194e6dd12504d21351510">&#9670;&nbsp;</a></span>R_SCI_SMCI_Read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SCI_SMCI_Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_m_c_i___a_p_i.html#ga57de10ab58c1265be3227fa2f8cf9fd1">smci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>p_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Receives user specified number of bytes into destination buffer pointer. Receiving is done at the isr level as there is no FIFO. If 0 is passed in as the length, reception will always invoke the user callback. Implements <a class="el" href="group___s_m_c_i___a_p_i.html#a1762ea269babbbb1cc92d8b195127b00">smci_api_t::read</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_api_ctrl</td><td>Pointer to SMCI control block that is to be opened </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_dest</td><td>Pointer to the buffer top be read into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bytes</td><td>Number of bytes to copy from the SMCI receive register</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Data reception successfully ends. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to SMCI control block or read buffer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>A previous read operation is still in progress.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html">Common Error Codes</a> or functions called by this function for other possible return codes. </dd></dl>

</div>
</div>
<a id="gab49a2b71354a30df79c1d19c7479200d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab49a2b71354a30df79c1d19c7479200d">&#9670;&nbsp;</a></span>R_SCI_SMCI_TransferModeSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SCI_SMCI_TransferModeSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_m_c_i___a_p_i.html#ga57de10ab58c1265be3227fa2f8cf9fd1">smci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_m_c_i___a_p_i.html#structsmci__transfer__mode__t">smci_transfer_mode_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_transfer_mode_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the settings of block transfer mode and data transfer convention. The SCMR and SMR_SMCI registers will be set according to the input arguments of protocol type, data convention type, and mode. Implements <a class="el" href="group___s_m_c_i___a_p_i.html#a0d6fb54665f8d10237d1bf87488f42b2">smci_api_t::transferModeSet</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_api_ctrl</td><td>Pointer to SMCI control block that is to be modified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_transfer_mode_params</td><td>Pointer to SMCI settings like protocol, convention, and gsm_mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This terminates any in-progress transmission and reception.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Transfer mode and data transfer direction was successfully changed. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>Unable to change transfer mode as device has clock off or is actively RX or TX </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer was passed as a parameter </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html">Common Error Codes</a> or functions called by this function for other possible return codes. </dd></dl>

</div>
</div>
<a id="gae93d0d470c41b66250dc452bf2907b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae93d0d470c41b66250dc452bf2907b22">&#9670;&nbsp;</a></span>R_SCI_SMCI_BaudSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SCI_SMCI_BaudSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_m_c_i___a_p_i.html#ga57de10ab58c1265be3227fa2f8cf9fd1">smci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>p_baud_setting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the baud rate and clock output. p_baud_setting is a pointer to a <a class="el" href="group___s_c_i___s_m_c_i.html#structsmci__baud__setting__t">smci_baud_setting_t</a> structure that needs to have already been filled by R_SCI_SMCI_BaudCalculate Implements <a class="el" href="group___s_m_c_i___a_p_i.html#a8d5f3d07f5f746a977e8dff3c3ee1d4c">smci_api_t::baudSet</a></p>
<dl class="section warning"><dt>Warning</dt><dd>This terminates any in-progress transmission.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_api_ctrl</td><td>Pointer to SMCI control block that is to be modified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_baud_setting</td><td>Pointer to baud setting information to be written to the SMCI hardware registers</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Baud rate was successfully changed. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to SMCI control block or p_baud_setting is NUL </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ARGUMENT</td><td>The p_baud_setting does not seem to be set correctly </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3d600ae7699ba4988e007a03aa28c93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d600ae7699ba4988e007a03aa28c93e">&#9670;&nbsp;</a></span>R_SCI_SMCI_StatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SCI_SMCI_StatusGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_m_c_i___a_p_i.html#ga57de10ab58c1265be3227fa2f8cf9fd1">smci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_m_c_i___a_p_i.html#structsmci__status__t">smci_status_t</a> *const&#160;</td>
          <td class="paramname"><em>p_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides the state of the driver and the # of bytes received since read was called Implements <a class="el" href="group___s_m_c_i___a_p_i.html#af9ee15358ff516dc2113002475c8768a">smci_api_t::statusGet</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_api_ctrl</td><td>Pointer to SMCI control block of this SMCI instance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_status</td><td>Pointer structure that will be filled in with status info</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Information stored in provided p_info. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to SMCI control block, or info structure is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga64d56497dd40550887bfdffa9edc7089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64d56497dd40550887bfdffa9edc7089">&#9670;&nbsp;</a></span>R_SCI_SMCI_ClockControl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SCI_SMCI_ClockControl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_m_c_i___a_p_i.html#ga57de10ab58c1265be3227fa2f8cf9fd1">smci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clock_enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable or disable the clock signal that is provided by interface the baud rate. When the clock is enabled, reception is enabled at the end of this function. Clock output control as defined in "Clock Output Control" of "Operation in Smart Card Interface Mode" in the SCI section of the relevant hardware manual. Implements <a class="el" href="group___s_m_c_i___a_p_i.html#ad5770c33d3cd5488a8b80356b03bd4b1">smci_api_t::clockControl</a></p>
<dl class="section warning"><dt>Warning</dt><dd>This terminates any in-progress transmission and reception.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_api_ctrl</td><td>Pointer to SMCI control block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clock_enable</td><td>true=Enable or false=disable the Smart Card Interface clock</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Clock output setting was successfully changed. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to SMCI control block is NULL </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>Clock cannot be disabled if GSM mode isnt active </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1161f78bfb6b8b83aafd3353377a3f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1161f78bfb6b8b83aafd3353377a3f0d">&#9670;&nbsp;</a></span>R_SCI_SMCI_CallbackSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SCI_SMCI_CallbackSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_m_c_i___a_p_i.html#ga57de10ab58c1265be3227fa2f8cf9fd1">smci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="group___s_m_c_i___a_p_i.html#structsmci__callback__args__t">smci_callback_args_t</a> *)&#160;</td>
          <td class="paramname"><em>p_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>p_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_m_c_i___a_p_i.html#structsmci__callback__args__t">smci_callback_args_t</a> *const&#160;</td>
          <td class="paramname"><em>p_callback_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the user callback and has option of providing memory for callback structure. Implements <a class="el" href="group___s_m_c_i___a_p_i.html#a6b6ed317a0786bf7ff7c409bde5e5548">smci_api_t::callbackSet</a></p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Callback updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_NO_CALLBACK_MEMORY</td><td>p_callback is non-secure and p_callback_memory is either secure or NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2dd22a1d0b7720dbe84a888897320c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2dd22a1d0b7720dbe84a888897320c8c">&#9670;&nbsp;</a></span>R_SCI_SMCI_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SCI_SMCI_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_m_c_i___a_p_i.html#ga57de10ab58c1265be3227fa2f8cf9fd1">smci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Aborts any in progress transfers. Disables interrupts, receiver, and transmitter. Implements <a class="el" href="group___s_m_c_i___a_p_i.html#ae15c4e9a6bd3cdc5b3d3194ec30bcf93">smci_api_t::close</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_api_ctrl</td><td>Pointer to SMCI control block that is reqested to close</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Channel successfully closed. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to SMCI control block is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga59cb52f2d340fddc4abfdda54e0f660f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59cb52f2d340fddc4abfdda54e0f660f">&#9670;&nbsp;</a></span>R_SCI_SMCI_BaudCalculate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SCI_SMCI_BaudCalculate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_m_c_i___a_p_i.html#structsmci__speed__params__t">smci_speed_params_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_speed_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baud_rate_error_x_1000</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>p_baud_setting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates baud rate register settings. Evaluates and determines the best possible settings set to the baud rate related registers. And then updates the SCI registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_speed_params</td><td>structure including speed defining paramets, baud, F, D, and max frequency </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baud_rate_error_x_1000</td><td>&lt;baud_rate_percent_error&gt; x 1000 required for module to function. Absolute max baud_rate_error is 20000 (20%) according to the ISO spec. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_baud_setting</td><td>Baud setting information stored here if successful</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Baud rate setting calculation successful </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_speed params or p_baud is a null pointer </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ARGUMENT</td><td>Baud rate is '0', freq is '0', or error in calculated baud rate is larger than 20%. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v6.2.0 User's Manual Copyright © (2025) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
