<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: SDADC Channel Configuration (r_sdadc)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
    $(document).ready(function() {
        $("tr.tree_lvl_1").nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
		$("tr.tree_lvl_1").data("expanded","0");
		$("tr.tree_lvl_2").data("expanded","0");
		$("tr.tree_lvl_3").data("expanded","0");
		$("tr.tree_lvl_4").data("expanded","0");
		$("tr.tree_lvl_5").data("expanded","0");
        $("tr.tree_lvl_1").click(function() {
		    var lvl_1_is_open = $(this).data("expanded");
		    if (lvl_1_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2, tr.tree_lvl_1_item").show(); 
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed"); 
				$(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        }); 
		$("tr.tree_lvl_2").click(function() {
		    var lvl_2_is_open = $(this).data("expanded");
		    if (lvl_2_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3, tr.tree_lvl_2_item").show(); 
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();                
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_3").click(function() {
		    var lvl_3_is_open = $(this).data("expanded");
		    if (lvl_3_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_3_item").show(); 
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").data("expanded","0");				
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_4").click(function() {
		    var lvl_4_is_open = $(this).data("expanded");
		    if (lvl_4_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5, tr.tree_lvl_4_item").show(); 
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");	
				$(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").data("expanded","0");				
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        }); 
		$("tr.tree_lvl_5").click(function() {
		    var lvl_5_is_open = $(this).data("expanded");
		    if (lvl_5_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5_item").show(); 
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4_item,tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();                
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        }); 
     }); 
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v5.2.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">
 
    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text"> 
      </span>
      <span class="right">
          &nbsp; 
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___s_d_a_d_c.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() { 
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body. 
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works 
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len)); 
            }
          } 
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }    
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element. 
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;  
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">SDADC Channel Configuration (r_sdadc)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___a_n_a_l_o_g___m_o_d_u_l_e_s.html">Analog</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga57663247dadf8d0ca835f1d674985e8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_a_d_c.html#ga57663247dadf8d0ca835f1d674985e8b">R_SDADC_Open</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#structadc__cfg__t">adc_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:ga57663247dadf8d0ca835f1d674985e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a7002fc86458bbd74ac178bbaaaff68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_a_d_c.html#ga0a7002fc86458bbd74ac178bbaaaff68">R_SDADC_ScanCfg</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, void const *const p_extend)</td></tr>
<tr class="separator:ga0a7002fc86458bbd74ac178bbaaaff68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f0d9f978b33d4bf19d6522ea3701032"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_a_d_c.html#ga4f0d9f978b33d4bf19d6522ea3701032">R_SDADC_InfoGet</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#structadc__info__t">adc_info_t</a> *p_adc_info)</td></tr>
<tr class="separator:ga4f0d9f978b33d4bf19d6522ea3701032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21a9d4b48c9a260b4515572e3f6cacdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_a_d_c.html#ga21a9d4b48c9a260b4515572e3f6cacdd">R_SDADC_ScanStart</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:ga21a9d4b48c9a260b4515572e3f6cacdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62382aeba24d64d3ba7e6eb1c8a1b187"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_a_d_c.html#ga62382aeba24d64d3ba7e6eb1c8a1b187">R_SDADC_ScanGroupStart</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#gaee17c30275c1c9376cc485a62ea121eb">adc_group_mask_t</a> group_id)</td></tr>
<tr class="separator:ga62382aeba24d64d3ba7e6eb1c8a1b187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35cdadbf61f92ee76fbbc3c5584b850b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_a_d_c.html#ga35cdadbf61f92ee76fbbc3c5584b850b">R_SDADC_ScanStop</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:ga35cdadbf61f92ee76fbbc3c5584b850b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebb38f07bd7922342597c2d453957433"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_a_d_c.html#gaebb38f07bd7922342597c2d453957433">R_SDADC_StatusGet</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#structadc__status__t">adc_status_t</a> *p_status)</td></tr>
<tr class="separator:gaebb38f07bd7922342597c2d453957433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6af5f96116f06d57982fb1cdc8d416b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_a_d_c.html#gaf6af5f96116f06d57982fb1cdc8d416b">R_SDADC_Read</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const reg_id, uint16_t *const p_data)</td></tr>
<tr class="separator:gaf6af5f96116f06d57982fb1cdc8d416b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77dc084a35379f65d2e2084e9a9c5806"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_a_d_c.html#ga77dc084a35379f65d2e2084e9a9c5806">R_SDADC_Read32</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const reg_id, uint32_t *const p_data)</td></tr>
<tr class="separator:ga77dc084a35379f65d2e2084e9a9c5806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf89d5f194cf841e12f1db6f869a4cf18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_a_d_c.html#gaf89d5f194cf841e12f1db6f869a4cf18">R_SDADC_OffsetSet</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const reg_id, int32_t const offset)</td></tr>
<tr class="separator:gaf89d5f194cf841e12f1db6f869a4cf18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c8c90f3182823e0b8a76fab5612d181"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_a_d_c.html#ga9c8c90f3182823e0b8a76fab5612d181">R_SDADC_Calibrate</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const p_ctrl, void const *p_extend)</td></tr>
<tr class="separator:ga9c8c90f3182823e0b8a76fab5612d181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd3903592611777a4bdd0bf0e6488da8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_a_d_c.html#gacd3903592611777a4bdd0bf0e6488da8">R_SDADC_Close</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:gacd3903592611777a4bdd0bf0e6488da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the SDADC24 peripheral on RA MCUs. This module implements the <a class="el" href="group___a_d_c___a_p_i.html">ADC Interface</a>. </p>
<h1><a class="anchor" id="r-sdadc-overview"></a>
Overview</h1>
<h2><a class="anchor" id="r-sdadc-features"></a>
Features</h2>
<p>The SDADC module supports the following features:</p>
<ul>
<li>24 bit maximum resolution</li>
<li>Configure scans to include:<ul>
<li>Multiple analog channels</li>
<li>Outputs of OPAMP0 (P side) and OPAMP1 (N side) of SDADC channel 4</li>
</ul>
</li>
<li>Configurable scan start trigger:<ul>
<li>Software scan triggers</li>
<li>Hardware scan triggers (timer expiration, for example)</li>
</ul>
</li>
<li>Configurable scan mode:<ul>
<li>Single scan mode, where each trigger starts a single scan</li>
<li>Continuous scan mode, where all channels are scanned continuously</li>
</ul>
</li>
<li>Supports averaging converted samples</li>
<li>Optional callback when single conversion, entire scan, or calibration completes<a class="anchor" id="um_sdadc_conversion_complete_notification"></a><a class="anchor" id="um_sdadc_scan_end_notification"></a><a class="anchor" id="um_sdadc_pga_calibration_complete_notification"></a></li>
<li>Supports reading converted data<a class="anchor" id="um_sdadc_reading_conversion_data"></a></li>
<li>Sample and hold support</li>
</ul>
<h2><a class="anchor" id="r-sdadc-selecting-an-adc"></a>
Selecting an ADC</h2>
<p>All RA MCUs have an <a class="el" href="group___a_d_c.html">ADC (r_adc)</a>. Only select RA MCUs have an SDADC. When selecting between them, consider these factors. Refer to the hardware manual for details.</p>
<table class="doxtable">
<tr>
<th></th><th>ADC </th><th>SDADC  </th></tr>
<tr>
<td>Availability</td><td>Available on all RA MCUs.</td><td>Available on select RA MCUs. </td></tr>
<tr>
<td>Resolution</td><td>The ADC has a maximum resolution of 12, 14, or 16 bits depending on the MCU.</td><td>The SDADC has a maximum accuracy of 24 bits. </td></tr>
<tr>
<td>Number of Channels</td><td>The ADC has more channels than the SDADC.</td><td>The SDADC 5 channels, one of which is tied to OPAMP0 and OPAMP1. </td></tr>
<tr>
<td>Frequency</td><td>The ADC sampling time is shorter (more samples per second).</td><td>The SDADC sampling time is longer (fewer samples per second). </td></tr>
<tr>
<td>Settling Time</td><td>The ADC does not have a settling time when switching between channels.</td><td>The SDADC requires a settling time when switching between channels. </td></tr>
</table>
<h1><a class="anchor" id="r-sdadc-configuration"></a>
Configuration</h1>
<p><a class="anchor" id="um_sdadc_pga_configuration_differential_input"></a><a class="anchor" id="um_sdadc_configure_reference_voltage"></a><a class="anchor" id="um_sdadc_configure_single_scan_mode"></a><a class="anchor" id="um_sdadc_configure_software_trigger"></a><a class="anchor" id="um_sdadc_configure_the_hardware_trigger"></a><a class="anchor" id="um_sdadc_configure_continuous_mode"></a><a class="anchor" id="um_sdadc_configure_averaging"></a><a class="anchor" id="um_sdadc_configure_24_bit_resolution"></a><a class="anchor" id="um_sdadc_configure_16_bit_resolution"></a><a class="anchor" id="um_sdadc_configure_alignment"></a><a class="anchor" id="um_sdadc_select_channels"></a><a class="anchor" id="um_sdadc_pga_configuration_oversampling"></a><a class="anchor" id="um_sdadc_pga_configuration_gain"></a><a class="anchor" id="um_sdadc_pga_configuration_single_end_input"></a><a class="anchor" id="um_sdadc_pga_configuration_polarity"></a><a class="anchor" id="um_sdadc_pga_configuration_inverted_signal"></a><a class="anchor" id="um_sdadc_pga_configuration_number_of_conversions"></a><a class="anchor" id="um_sdadc_pga_configuration_offset"></a> <h2>Build Time Configurations for r_sdadc</h2>
The following build time configurations are defined in fsp_cfg/r_sdadc_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
</table>
 <h2>Configurations for Analog &gt; ADC (r_sdadc)</h2>
This module can be added to the Stacks tab via New Stack &gt; Analog &gt; ADC (r_sdadc).<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Name</td><td>Name must be a valid C symbol</td><td>g_adc0 </td><td>Module name. </td></tr>
<tr class="tree_none">
<td>Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Single Scan</li>
<li>
Continuous Scan</li>
</ul>
</td><td>Continuous Scan </td><td>In single scan mode, all channels are converted once per start trigger, and conversion stops after all enabled channels are scanned. In continuous scan mode, conversion starts after a start trigger, then continues until stopped in software. </td></tr>
<tr class="tree_none">
<td>Resolution</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
16 Bit</li>
<li>
24 Bit</li>
</ul>
</td><td>24 Bit </td><td>Select 24-bit or 16-bit resolution. </td></tr>
<tr class="tree_none">
<td>Alignment</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Right</li>
<li>
Left</li>
</ul>
</td><td>Right </td><td>Select left or right alignment. </td></tr>
<tr class="tree_none">
<td>Trigger</td><td>MCU Specific Options</td><td></td><td>Select conversion start trigger. Conversion can be started in software, or conversion can be started when a hardware event occurs if the hardware event is linked to the SDADC peripheral using the ELC API. </td></tr>
<tr class="tree_none">
<td>Vref Source</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Internal</li>
<li>
External</li>
</ul>
</td><td>Internal </td><td>Vref can be source internally and output on the SBIAS pin, or Vref can be input from VREFI. </td></tr>
<tr class="tree_none">
<td>Vref Voltage</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
0.8 V</li>
<li>
1.0 V</li>
<li>
1.2 V</li>
<li>
1.4 V</li>
<li>
1.6 V</li>
<li>
1.8 V</li>
<li>
2.0 V</li>
<li>
2.2 V</li>
<li>
2.4 V</li>
</ul>
</td><td>1.0 V </td><td>Select Vref voltage. If Vref is input externally, the voltage on VREFI must match the voltage selected within 3%. </td></tr>
<tr class="tree_none">
<td>Callback</td><td>Name must be a valid C symbol</td><td>NULL </td><td>Enter the name of the callback function to be called when conversion completes or a scan ends. </td></tr>
<tr class="tree_none">
<td>Conversion End Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>[Required] Select the interrupt priority for the conversion end interrupt. </td></tr>
<tr class="tree_none">
<td>Scan End Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>[Optional] Select the interrupt priority for the scan end interrupt. </td></tr>
<tr class="tree_none">
<td>Calibration End Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>[Optional] Select the interrupt priority for the calibration end interrupt. </td></tr>
</table>
 <h2>Configurations for Analog &gt; SDADC Channel Configuration (r_sdadc)</h2>
<table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Input</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Differential</li>
<li>
Single Ended</li>
</ul>
</td><td>Differential </td><td>Select differential or single-ended input. </td></tr>
<tr class="tree_none">
<td>Stage 1 Gain</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1</li>
<li>
2</li>
<li>
3</li>
<li>
4</li>
<li>
8</li>
</ul>
</td><td>1 </td><td>Select the gain for stage 1 of the PGA. Must be 1 for single-ended input. </td></tr>
<tr class="tree_none">
<td>Stage 2 Gain</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1</li>
<li>
2</li>
<li>
4</li>
<li>
8</li>
</ul>
</td><td>1 </td><td>Select the gain for stage 2 of the PGA. Must be 1 for single-ended input. </td></tr>
<tr class="tree_none">
<td>Oversampling Ratio</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
64</li>
<li>
128</li>
<li>
256</li>
<li>
512</li>
<li>
1024</li>
<li>
2048</li>
</ul>
</td><td>256 </td><td>Select the oversampling ratio for the PGA. Must be 256 for single-ended input. </td></tr>
<tr class="tree_none">
<td>Polarity (Valid for Single-Ended Input Only)</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Positive</li>
<li>
Negative</li>
</ul>
</td><td>Positive </td><td>Select positive or negative polarity for single-ended input. VBIAS (1.0 V typical) is connected on the opposite input. </td></tr>
<tr class="tree_none">
<td>Conversions to Average per Result</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Do Not Average (Interrupt after Each Conversion)</li>
<li>
Average 8</li>
<li>
Average 16</li>
<li>
Average 32</li>
<li>
Average 64</li>
</ul>
</td><td>Do Not Average (Interrupt after Each Conversion) </td><td>Select the number of conversions to average for each result. The ADC_EVENT_CONVERSION_END event occurs after each average, or after each individual conversion if averaging is disabled. </td></tr>
<tr class="tree_none">
<td>Invert (Valid for Negative Single-Ended Input Only)</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Result Not Inverted</li>
<li>
Result Inverted</li>
</ul>
</td><td>Result Not Inverted </td><td>Select whether to invert negative single-ended input. When the result is inverted, the lowest measurable voltage gives a result of 0, and the highest measurable voltage gives a result of 2^resolution - 1. </td></tr>
<tr class="tree_none">
<td>Number of Conversions Per Scan</td><td>Refer to the RA Configuration tool for available options.</td><td>1 </td><td>Number of conversions on this channel before AUTOSCAN moves to the next channel. When all conversions of all channels are complete, the ADC_EVENT_SCAN_END event occurs. </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-sdadc-clock-configuration"></a>
Clock Configuration</h2>
<p>The SDADC clock clock is configurable on the clocks tab.</p>
<p>The SDADC clock must be 4 MHz when the SDADC is used.</p>
<h2><a class="anchor" id="r-sdadc-pin-configuration"></a>
Pin Configuration</h2>
<p>The ANSDnP (n = 0-3) pins are analog input channels that can be used with the SDADC.</p>
<h1><a class="anchor" id="r-sdadc-usage-notes"></a>
Usage Notes</h1>
<h2><a class="anchor" id="r-sdadc-scan-procedure"></a>
Scan Procedure</h2>
<p>In this document, the term "scan" refers to the AUTOSCAN feature of the SDADC, which works as follows:</p>
<ol type="1">
<li>Conversions are performed on enabled channels in ascending order of channel number. All conversions required for a single channel are completed before the sequencer moves to the next channel.</li>
<li>Conversions are performed at the rate (in Hz) of the SDADC oversampling clock frequency / oversampling ratio (configured per channel). FSP uses the normal mode SDADC oversampling clock frequency.</li>
<li>If averaging is enabled for the channel, the number of conversions to average are performed before each conversion end interrupt occurs.</li>
<li><p class="startli">If the number of conversions for the channel is more than 1, SDADC performs the number of conversions requested. These are performed consecutively. There is a settling time associated with switching channels. Performing all of the requested conversions for each channel at a time avoids this settling time after the first conversion.</p>
<p class="startli">If averaging is enabled for the channel, each averaged result counts as a single conversion.</p>
</li>
<li>Continues to the next enabled channel only after completing all conversions requested.</li>
<li>After all enabled channels are scanned, a scan end interrupt occurs. The driver supports single-scan and continuous scan operation modes.<ul>
<li>Single-scan mode performs one scan per trigger (hardware trigger or software start using <a class="el" href="group___s_d_a_d_c.html#ga21a9d4b48c9a260b4515572e3f6cacdd">R_SDADC_ScanStart</a>).<a class="anchor" id="um_sdadc_starting_a_scan"></a></li>
<li>In continuous scan mode, the scan is restarted after each scan completes. A single trigger is required to start continuous operation of the SDADC.</li>
</ul>
</li>
</ol>
<h3>When Interrupts Are Not Enabled</h3>
<p>If interrupts are not enabled, the <a class="el" href="group___s_d_a_d_c.html#gaebb38f07bd7922342597c2d453957433">R_SDADC_StatusGet()</a> API can be used to poll the SDADC to determine when the scan has completed. The <a class="el" href="group___s_d_a_d_c.html#gaf6af5f96116f06d57982fb1cdc8d416b">R_SDADC_Read()</a> API function is used to access the converted SDADC result. This applies to both normal scans and calibration scans.</p>
<h2>Calibration</h2>
<p>Calibration is required to use the SDADC if any channel is configured for differential mode. Call <a class="el" href="group___s_d_a_d_c.html#ga9c8c90f3182823e0b8a76fab5612d181">R_SDADC_Calibrate()</a> after open, and prior to any other function, then wait for a calibration complete event before using the SDADC. <a class="el" href="group___s_d_a_d_c.html#ga9c8c90f3182823e0b8a76fab5612d181">R_SDADC_Calibrate()</a> should not be called if all channels are configured for single-ended mode.</p>
<h1><a class="anchor" id="r-sdadc-examples"></a>
Examples</h1>
<h2>Basic Example</h2>
<p>This is a basic example of minimal use of the SDADC in an application.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> sdadc_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___s_d_a_d_c.html#ga57663247dadf8d0ca835f1d674985e8b">R_SDADC_Open</a>(&amp;g_adc0_ctrl, &amp;g_adc0_cfg);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Calibrate all differential channels. */</span></div><div class="line">    <a class="code" href="group___s_d_a_d_c.html#structsdadc__calibrate__args__t">sdadc_calibrate_args_t</a> calibrate_args;</div><div class="line">    calibrate_args.<a class="code" href="group___s_d_a_d_c.html#a34dd19f52c580e9b02bb9677d059e88b">mode</a>    = <a class="code" href="group___s_d_a_d_c.html#ggaaea93412ee94494d96a4194efa8ff416acd9e2bd2c45ae86bb253b3f8a3942f92">SDADC_CALIBRATION_INTERNAL_GAIN_OFFSET</a>;</div><div class="line">    calibrate_args.<a class="code" href="group___s_d_a_d_c.html#a85c193be51c71d8975b9e9623b351479">channel</a> = <a class="code" href="group___a_d_c___a_p_i.html#ggaafc4060027875f8fe46242b0656d7814a69dddf5b6edfe54ac25b653d8f62d104">ADC_CHANNEL_0</a>;</div><div class="line">    err = <a class="code" href="group___s_d_a_d_c.html#ga9c8c90f3182823e0b8a76fab5612d181">R_SDADC_Calibrate</a>(&amp;g_adc0_ctrl, &amp;calibrate_args);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Wait for calibration to complete. */</span></div><div class="line">    <a class="code" href="group___a_d_c___a_p_i.html#structadc__status__t">adc_status_t</a> status;</div><div class="line">    status.<a class="code" href="group___a_d_c___a_p_i.html#a276869569116678c7838ef506fceb77b">state</a> = <a class="code" href="group___a_d_c___a_p_i.html#gga2783ab2e29809bf0a50bc66c6fa8d3c6abe1c11b191e48669cc5129aca45800d7">ADC_STATE_SCAN_IN_PROGRESS</a>;</div><div class="line">    <span class="keywordflow">while</span> (<a class="code" href="group___a_d_c___a_p_i.html#gga2783ab2e29809bf0a50bc66c6fa8d3c6abe1c11b191e48669cc5129aca45800d7">ADC_STATE_SCAN_IN_PROGRESS</a> == status.<a class="code" href="group___a_d_c___a_p_i.html#a276869569116678c7838ef506fceb77b">state</a>)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___s_d_a_d_c.html#gaebb38f07bd7922342597c2d453957433">R_SDADC_StatusGet</a>(&amp;g_adc0_ctrl, &amp;status);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* In software trigger mode, start a scan by calling R_SDADC_ScanStart(). In other modes, enable external</span></div><div class="line"><span class="comment">     * triggers by calling R_SDADC_ScanStart(). */</span></div><div class="line">    (void) <a class="code" href="group___s_d_a_d_c.html#ga21a9d4b48c9a260b4515572e3f6cacdd">R_SDADC_ScanStart</a>(&amp;g_adc0_ctrl);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Wait for conversion to complete. */</span></div><div class="line">    status.<a class="code" href="group___a_d_c___a_p_i.html#a276869569116678c7838ef506fceb77b">state</a> = <a class="code" href="group___a_d_c___a_p_i.html#gga2783ab2e29809bf0a50bc66c6fa8d3c6abe1c11b191e48669cc5129aca45800d7">ADC_STATE_SCAN_IN_PROGRESS</a>;</div><div class="line">    <span class="keywordflow">while</span> (<a class="code" href="group___a_d_c___a_p_i.html#gga2783ab2e29809bf0a50bc66c6fa8d3c6abe1c11b191e48669cc5129aca45800d7">ADC_STATE_SCAN_IN_PROGRESS</a> == status.<a class="code" href="group___a_d_c___a_p_i.html#a276869569116678c7838ef506fceb77b">state</a>)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___s_d_a_d_c.html#gaebb38f07bd7922342597c2d453957433">R_SDADC_StatusGet</a>(&amp;g_adc0_ctrl, &amp;status);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Read converted data. */</span></div><div class="line">    uint32_t channel1_conversion_result;</div><div class="line">    <a class="code" href="group___s_d_a_d_c.html#ga77dc084a35379f65d2e2084e9a9c5806">R_SDADC_Read32</a>(&amp;g_adc0_ctrl, <a class="code" href="group___a_d_c___a_p_i.html#ggaafc4060027875f8fe46242b0656d7814a203b48944d019f4fda969a6fc2a9e492">ADC_CHANNEL_1</a>, &amp;channel1_conversion_result);</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Using DTC or DMAC with the SDADC</h2>
<p>If desired, the DTC or DMAC can be used to store each conversion result in a circular buffer. An example configuration is below.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">/* Example DTC transfer settings to used with SDADC. */</span></div><div class="line"></div><div class="line"><span class="comment">/* The transfer length should match the total number of conversions per scan. This example assumes the SDADC is</span></div><div class="line"><span class="comment"> * configured to scan channel 1 three times, then channel 2 and channel 4 once, for a total of 5 conversions. */</span></div><div class="line"><span class="preprocessor">#define SDADC_EXAMPLE_TRANSFER_LENGTH    (5)</span></div><div class="line"></div><div class="line">uint32_t g_sdadc_example_buffer[SDADC_EXAMPLE_TRANSFER_LENGTH];</div><div class="line"></div><div class="line"><a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__info__t">transfer_info_t</a> g_sdadc_transfer_info =</div><div class="line">{</div><div class="line">    .transfer_settings_word_b.dest_addr_mode = <a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ggadce62e6c2407d6ffd5a94636736f7c51a7665741e25c4cc78fd24745efbd2eaad">TRANSFER_ADDR_MODE_INCREMENTED</a>,</div><div class="line">    .transfer_settings_word_b.repeat_area    = <a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#gga769464d2068881ccb44573c96167812ba77aeeab30b003de23742e40a57f19239">TRANSFER_REPEAT_AREA_DESTINATION</a>,</div><div class="line">    .transfer_settings_word_b.irq            = <a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ggad71bdadb7f486bb5d3ca6ff508dc0b08ada378ad830e44cc0c25d4fe2413e11de">TRANSFER_IRQ_END</a>,</div><div class="line">    .transfer_settings_word_b.chain_mode     = <a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#gga68f81dc8b9ca46fbe3a1e556c020436dae974453c306b4959252905e362d75067">TRANSFER_CHAIN_MODE_DISABLED</a>,</div><div class="line">    .transfer_settings_word_b.src_addr_mode  = <a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ggadce62e6c2407d6ffd5a94636736f7c51abf18f9b3701e9e91f44055ee47d0ca47">TRANSFER_ADDR_MODE_FIXED</a>,</div><div class="line">    .transfer_settings_word_b.mode           = <a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ggadfb7c2a6a73bfdf993e50505aa92992fa607c41bfd08797c08a5ee9bd4dfb9c8b">TRANSFER_MODE_REPEAT</a>,</div><div class="line"></div><div class="line">    <span class="comment">/* NOTE: The data transferred will contain a 24-bit converted value in bits 23:0. Bit 24 contains a status flag</span></div><div class="line"><span class="comment">     * indicating if the result overflowed or not. Bits 27:25 contain the channel number + 1. The settings for</span></div><div class="line"><span class="comment">     * resolution and alignment and ignored when DTC or DMAC is used. */</span></div><div class="line">    .transfer_settings_word_b.size           = <a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#gga6c224e5afb174f3f6ea9eddbb9da8b12a18482bfa86e737cde78042be4db54412">TRANSFER_SIZE_4_BYTE</a>,</div><div class="line"></div><div class="line">    <span class="comment">/* NOTE: It is strongly recommended to enable averaging on all channels or no channels when using DTC with SDADC</span></div><div class="line"><span class="comment">     * because the result register is different when averaging is used. If averaging is enabled on all channels,</span></div><div class="line"><span class="comment">     * set transfer_info_t::p_src to &amp;R_SDADC-&gt;ADAR. */</span></div><div class="line">    .p_src  = (<span class="keywordtype">void</span> <span class="keyword">const</span> *) &amp;R_SDADC0-&gt;ADCR,</div><div class="line">    .p_dest = &amp;g_sdadc_example_buffer[0],</div><div class="line">    .length = SDADC_EXAMPLE_TRANSFER_LENGTH,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> sdadc_dtc_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___s_d_a_d_c.html#ga57663247dadf8d0ca835f1d674985e8b">R_SDADC_Open</a>(&amp;g_adc0_ctrl, &amp;g_adc0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Calibrate all differential channels. */</span></div><div class="line">    <a class="code" href="group___s_d_a_d_c.html#structsdadc__calibrate__args__t">sdadc_calibrate_args_t</a> calibrate_args;</div><div class="line">    calibrate_args.<a class="code" href="group___s_d_a_d_c.html#a34dd19f52c580e9b02bb9677d059e88b">mode</a>    = <a class="code" href="group___s_d_a_d_c.html#ggaaea93412ee94494d96a4194efa8ff416acd9e2bd2c45ae86bb253b3f8a3942f92">SDADC_CALIBRATION_INTERNAL_GAIN_OFFSET</a>;</div><div class="line">    calibrate_args.<a class="code" href="group___s_d_a_d_c.html#a85c193be51c71d8975b9e9623b351479">channel</a> = <a class="code" href="group___a_d_c___a_p_i.html#ggaafc4060027875f8fe46242b0656d7814a69dddf5b6edfe54ac25b653d8f62d104">ADC_CHANNEL_0</a>;</div><div class="line">    err = <a class="code" href="group___s_d_a_d_c.html#ga9c8c90f3182823e0b8a76fab5612d181">R_SDADC_Calibrate</a>(&amp;g_adc0_ctrl, &amp;calibrate_args);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for calibration to complete. */</span></div><div class="line">    <a class="code" href="group___a_d_c___a_p_i.html#structadc__status__t">adc_status_t</a> status;</div><div class="line">    status.<a class="code" href="group___a_d_c___a_p_i.html#a276869569116678c7838ef506fceb77b">state</a> = <a class="code" href="group___a_d_c___a_p_i.html#gga2783ab2e29809bf0a50bc66c6fa8d3c6abe1c11b191e48669cc5129aca45800d7">ADC_STATE_SCAN_IN_PROGRESS</a>;</div><div class="line">    <span class="keywordflow">while</span> (<a class="code" href="group___a_d_c___a_p_i.html#gga2783ab2e29809bf0a50bc66c6fa8d3c6abe1c11b191e48669cc5129aca45800d7">ADC_STATE_SCAN_IN_PROGRESS</a> == status.<a class="code" href="group___a_d_c___a_p_i.html#a276869569116678c7838ef506fceb77b">state</a>)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___s_d_a_d_c.html#gaebb38f07bd7922342597c2d453957433">R_SDADC_StatusGet</a>(&amp;g_adc0_ctrl, &amp;status);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* In software trigger mode, start a scan by calling R_SDADC_ScanStart(). In other modes, enable external</span></div><div class="line"><span class="comment">     * triggers by calling R_SDADC_ScanStart(). */</span></div><div class="line">    (void) <a class="code" href="group___s_d_a_d_c.html#ga21a9d4b48c9a260b4515572e3f6cacdd">R_SDADC_ScanStart</a>(&amp;g_adc0_ctrl);</div><div class="line"></div><div class="line">    <span class="comment">/* After each conversion, the converted data is transferred to the next index in g_sdadc_example_buffer. After</span></div><div class="line"><span class="comment">     * the entire scan completes, the index in g_sdadc_example_buffer resets. The data in g_sdadc_example_buffer</span></div><div class="line"><span class="comment">     * is:</span></div><div class="line"><span class="comment">     *  - g_sdadc_example_buffer[0] = SDADC channel 1 conversion 0</span></div><div class="line"><span class="comment">     *  - g_sdadc_example_buffer[1] = SDADC channel 1 conversion 1</span></div><div class="line"><span class="comment">     *  - g_sdadc_example_buffer[2] = SDADC channel 1 conversion 2</span></div><div class="line"><span class="comment">     *  - g_sdadc_example_buffer[3] = SDADC channel 2 conversion 0</span></div><div class="line"><span class="comment">     *  - g_sdadc_example_buffer[4] = SDADC channel 4 conversion 0</span></div><div class="line"><span class="comment">     */</span><span class="comment">/* At any point in the application after the first scan completes, the most recent data for channel 2 can be read</span></div><div class="line"><span class="comment">     * from the buffer like this. Shifting removes the unrelated bits in the result register and propagates the sign</span></div><div class="line"><span class="comment">     * bit so the value can be interpreted as a signed result. This assumes channel 2 is configured in differential</span></div><div class="line"><span class="comment">     * mode. */</span></div><div class="line">    int32_t channel_2_data = (int32_t) (g_sdadc_example_buffer[3] &lt;&lt; 8) &gt;&gt; 8;</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gaf0afcbc9a110ac9366a811d96ee06029">FSP_PARAMETER_NOT_USED</a>(channel_2_data);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structsdadc__calibrate__args__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_a_d_c.html#structsdadc__calibrate__args__t">sdadc_calibrate_args_t</a></td></tr>
<tr class="separator:structsdadc__calibrate__args__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsdadc__channel__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_a_d_c.html#structsdadc__channel__cfg__t">sdadc_channel_cfg_t</a></td></tr>
<tr class="separator:structsdadc__channel__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsdadc__scan__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_a_d_c.html#structsdadc__scan__cfg__t">sdadc_scan_cfg_t</a></td></tr>
<tr class="separator:structsdadc__scan__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsdadc__extended__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_a_d_c.html#structsdadc__extended__cfg__t">sdadc_extended_cfg_t</a></td></tr>
<tr class="separator:structsdadc__extended__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsdadc__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_a_d_c.html#structsdadc__instance__ctrl__t">sdadc_instance_ctrl_t</a></td></tr>
<tr class="separator:structsdadc__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga93e0cb757f0ead00a692eef5a06dca48"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_a_d_c.html#ga93e0cb757f0ead00a692eef5a06dca48">sdadc_vref_src_t</a> </td></tr>
<tr class="separator:ga93e0cb757f0ead00a692eef5a06dca48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52e6c45364c9f174d21b42962090cf5a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_a_d_c.html#ga52e6c45364c9f174d21b42962090cf5a">sdadc_vref_voltage_t</a> </td></tr>
<tr class="separator:ga52e6c45364c9f174d21b42962090cf5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93d9bacf1845e25c72a9f8a354da1083"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_a_d_c.html#ga93d9bacf1845e25c72a9f8a354da1083">sdadc_channel_input_t</a> </td></tr>
<tr class="separator:ga93d9bacf1845e25c72a9f8a354da1083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa76f2c251ce7683c1696d05e5e0f67db"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_a_d_c.html#gaa76f2c251ce7683c1696d05e5e0f67db">sdadc_channel_stage_1_gain_t</a> </td></tr>
<tr class="separator:gaa76f2c251ce7683c1696d05e5e0f67db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4718f5548b17c10b99741a3115afcb17"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_a_d_c.html#ga4718f5548b17c10b99741a3115afcb17">sdadc_channel_stage_2_gain_t</a> </td></tr>
<tr class="separator:ga4718f5548b17c10b99741a3115afcb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dca7248427ec13217415a08066aac82"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_a_d_c.html#ga3dca7248427ec13217415a08066aac82">sdadc_channel_oversampling_t</a> </td></tr>
<tr class="separator:ga3dca7248427ec13217415a08066aac82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74bb0f640145edbf82f07ccd9ef28244"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_a_d_c.html#ga74bb0f640145edbf82f07ccd9ef28244">sdadc_channel_polarity_t</a> </td></tr>
<tr class="separator:ga74bb0f640145edbf82f07ccd9ef28244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f7fea933d308bfc55dbca4f0f6ce630"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_a_d_c.html#ga6f7fea933d308bfc55dbca4f0f6ce630">sdadc_channel_average_t</a> </td></tr>
<tr class="separator:ga6f7fea933d308bfc55dbca4f0f6ce630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcd798ec2221d751622dce2c2fc3acf2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_a_d_c.html#gadcd798ec2221d751622dce2c2fc3acf2">sdadc_channel_inversion_t</a> </td></tr>
<tr class="separator:gadcd798ec2221d751622dce2c2fc3acf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga677ae3bb18c1bb15eb56d49a93a922eb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_a_d_c.html#ga677ae3bb18c1bb15eb56d49a93a922eb">sdadc_channel_count_formula_t</a> </td></tr>
<tr class="separator:ga677ae3bb18c1bb15eb56d49a93a922eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaea93412ee94494d96a4194efa8ff416"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_d_a_d_c.html#gaaea93412ee94494d96a4194efa8ff416">sdadc_calibration_t</a> </td></tr>
<tr class="separator:gaaea93412ee94494d96a4194efa8ff416"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structsdadc__calibrate__args__t" id="structsdadc__calibrate__args__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structsdadc__calibrate__args__t">&#9670;&nbsp;</a></span>sdadc_calibrate_args_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sdadc_calibrate_args_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Structure to pass to the <a class="el" href="group___a_d_c___a_p_i.html#a1020d90e58d3bf86cee2f46a62e62fc4">adc_api_t::calibrate</a> p_extend argument. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a85c193be51c71d8975b9e9623b351479"></a><a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a></td>
<td class="fieldname">
channel</td>
<td class="fielddoc">
Which channel to calibrate. </td></tr>
<tr><td class="fieldtype">
<a id="a34dd19f52c580e9b02bb9677d059e88b"></a><a class="el" href="group___s_d_a_d_c.html#gaaea93412ee94494d96a4194efa8ff416">sdadc_calibration_t</a></td>
<td class="fieldname">
mode</td>
<td class="fielddoc">
Calibration mode. </td></tr>
</table>

</div>
</div>
<a name="structsdadc__channel__cfg__t" id="structsdadc__channel__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structsdadc__channel__cfg__t">&#9670;&nbsp;</a></span>sdadc_channel_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sdadc_channel_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>SDADC per channel configuration. </p>
</div>
</div>
</div>
<a name="structsdadc__scan__cfg__t" id="structsdadc__scan__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structsdadc__scan__cfg__t">&#9670;&nbsp;</a></span>sdadc_scan_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sdadc_scan_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>SDADC active channel configuration </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a8716474123a86b0a04b8ec640baa3889"></a>uint32_t</td>
<td class="fieldname">
scan_mask</td>
<td class="fielddoc">
Channels/bits: bit 0 is ch0; bit 15 is ch15. </td></tr>
</table>

</div>
</div>
<a name="structsdadc__extended__cfg__t" id="structsdadc__extended__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structsdadc__extended__cfg__t">&#9670;&nbsp;</a></span>sdadc_extended_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sdadc_extended_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>SDADC configuration extension. This extension is required and must be provided in <a class="el" href="group___a_d_c___a_p_i.html#a5463ef8731c3b8a0094fbfff74c73449" title="Extension parameter for hardware specific settings. ">adc_cfg_t::p_extend</a>. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ac6e874d46c6a97309206f0f4c6148483"></a>uint8_t</td>
<td class="fieldname">
conv_end_ipl</td>
<td class="fielddoc">
Conversion end interrupt priority. </td></tr>
<tr><td class="fieldtype">
<a id="a7280730641c002684b926bb6e89e9036"></a>IRQn_Type</td>
<td class="fieldname">
conv_end_irq</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a5bce81fcaadfece5b5f900408bc04208"></a><a class="el" href="group___s_d_a_d_c.html#ga93e0cb757f0ead00a692eef5a06dca48">sdadc_vref_src_t</a></td>
<td class="fieldname">
vref_src</td>
<td class="fielddoc">
Source of Vref (internal or external) </td></tr>
<tr><td class="fieldtype">
<a id="ae674430c29c18997b4af8e474cd101de"></a><a class="el" href="group___s_d_a_d_c.html#ga52e6c45364c9f174d21b42962090cf5a">sdadc_vref_voltage_t</a></td>
<td class="fieldname">
vref_voltage</td>
<td class="fielddoc">
<p>Voltage of Vref, required for both internal and external Vref. If Vref is from an external source, the voltage must match the specified voltage within 3%. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a5c28187ae9ef4afde91991050772fd71"></a><a class="el" href="group___s_d_a_d_c.html#structsdadc__channel__cfg__t">sdadc_channel_cfg_t</a> const  *</td>
<td class="fieldname">
p_channel_cfgs[SDADC_MAX_NUM_CHANNELS]</td>
<td class="fielddoc">
Configuration for each channel, set to NULL if unused. </td></tr>
</table>

</div>
</div>
<a name="structsdadc__instance__ctrl__t" id="structsdadc__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structsdadc__instance__ctrl__t">&#9670;&nbsp;</a></span>sdadc_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sdadc_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>ADC instance control block. DO NOT INITIALIZE. Initialized in <a class="el" href="group___a_d_c___a_p_i.html#afa184c06541e3fd9f90fc12ed775f468">adc_api_t::open()</a>. </p>
</div>
</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga93e0cb757f0ead00a692eef5a06dca48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93e0cb757f0ead00a692eef5a06dca48">&#9670;&nbsp;</a></span>sdadc_vref_src_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_d_a_d_c.html#ga93e0cb757f0ead00a692eef5a06dca48">sdadc_vref_src_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Source of Vref. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga93e0cb757f0ead00a692eef5a06dca48a5c1af068fa9bf0d883c719168c88747e"></a>SDADC_VREF_SRC_INTERNAL&#160;</td><td class="fielddoc"><p>Vref is internally sourced, can be output as SBIAS. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga93e0cb757f0ead00a692eef5a06dca48a8576ccced5d83018886d054a0395d3fb"></a>SDADC_VREF_SRC_EXTERNAL&#160;</td><td class="fielddoc"><p>Vref is externally sourced from the VREFI pin. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga52e6c45364c9f174d21b42962090cf5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52e6c45364c9f174d21b42962090cf5a">&#9670;&nbsp;</a></span>sdadc_vref_voltage_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_d_a_d_c.html#ga52e6c45364c9f174d21b42962090cf5a">sdadc_vref_voltage_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Voltage of Vref. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga52e6c45364c9f174d21b42962090cf5aaf4b41056d73924ad87f111b21f63ec57"></a>SDADC_VREF_VOLTAGE_800_MV&#160;</td><td class="fielddoc"><p>Vref is 0.8 V. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga52e6c45364c9f174d21b42962090cf5aa442445b72a24adf127050f152acee7b5"></a>SDADC_VREF_VOLTAGE_1000_MV&#160;</td><td class="fielddoc"><p>Vref is 1.0 V. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga52e6c45364c9f174d21b42962090cf5aaf66c9d43e7ece638d59876a868628a44"></a>SDADC_VREF_VOLTAGE_1200_MV&#160;</td><td class="fielddoc"><p>Vref is 1.2 V. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga52e6c45364c9f174d21b42962090cf5aa026ad37a956bc62163b88b737f518f5e"></a>SDADC_VREF_VOLTAGE_1400_MV&#160;</td><td class="fielddoc"><p>Vref is 1.4 V. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga52e6c45364c9f174d21b42962090cf5aa168b535e7dcdee38fce558ea582e404e"></a>SDADC_VREF_VOLTAGE_1600_MV&#160;</td><td class="fielddoc"><p>Vref is 1.6 V. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga52e6c45364c9f174d21b42962090cf5aaaf05c983c71ec425d597484734e86b7e"></a>SDADC_VREF_VOLTAGE_1800_MV&#160;</td><td class="fielddoc"><p>Vref is 1.8 V. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga52e6c45364c9f174d21b42962090cf5aa54b3d8d1b7cdc9dbe11ef3d40575b2ac"></a>SDADC_VREF_VOLTAGE_2000_MV&#160;</td><td class="fielddoc"><p>Vref is 2.0 V. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga52e6c45364c9f174d21b42962090cf5aadfd660d318cbf2ce2a13b62b6d05ca07"></a>SDADC_VREF_VOLTAGE_2200_MV&#160;</td><td class="fielddoc"><p>Vref is 2.2 V. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga52e6c45364c9f174d21b42962090cf5aa15640782ba8e173ece610b9616837d3a"></a>SDADC_VREF_VOLTAGE_2400_MV&#160;</td><td class="fielddoc"><p>Vref is 2.4 V (only valid for external Vref) </p>
</td></tr>
</table>

</div>
</div>
<a id="ga93d9bacf1845e25c72a9f8a354da1083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93d9bacf1845e25c72a9f8a354da1083">&#9670;&nbsp;</a></span>sdadc_channel_input_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_d_a_d_c.html#ga93d9bacf1845e25c72a9f8a354da1083">sdadc_channel_input_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Per channel input mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga93d9bacf1845e25c72a9f8a354da1083a7899126875eb7f8e4e10fb0d55cf53af"></a>SDADC_CHANNEL_INPUT_DIFFERENTIAL&#160;</td><td class="fielddoc"><p>Differential input. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga93d9bacf1845e25c72a9f8a354da1083a1e8cb6fdd0176e4b1dc67896afb8e2cb"></a>SDADC_CHANNEL_INPUT_SINGLE_ENDED&#160;</td><td class="fielddoc"><p>Single-ended input. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaa76f2c251ce7683c1696d05e5e0f67db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa76f2c251ce7683c1696d05e5e0f67db">&#9670;&nbsp;</a></span>sdadc_channel_stage_1_gain_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_d_a_d_c.html#gaa76f2c251ce7683c1696d05e5e0f67db">sdadc_channel_stage_1_gain_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Per channel stage 1 gain options. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa76f2c251ce7683c1696d05e5e0f67dba0954dfce84aed200c2540fb348afe80f"></a>SDADC_CHANNEL_STAGE_1_GAIN_1&#160;</td><td class="fielddoc"><p>Gain of 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa76f2c251ce7683c1696d05e5e0f67dba2c9b1a64545ec3124a106d51040a7ec7"></a>SDADC_CHANNEL_STAGE_1_GAIN_2&#160;</td><td class="fielddoc"><p>Gain of 2. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa76f2c251ce7683c1696d05e5e0f67dba6d9ce141981cf473381d4c232f4419d5"></a>SDADC_CHANNEL_STAGE_1_GAIN_3&#160;</td><td class="fielddoc"><p>Gain of 3 (only valid for stage 1) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa76f2c251ce7683c1696d05e5e0f67dba2f7d99e1128f6400090693d03aa6a133"></a>SDADC_CHANNEL_STAGE_1_GAIN_4&#160;</td><td class="fielddoc"><p>Gain of 4. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa76f2c251ce7683c1696d05e5e0f67dbaa33ffb279a639d95c6b81818b73bb646"></a>SDADC_CHANNEL_STAGE_1_GAIN_8&#160;</td><td class="fielddoc"><p>Gain of 8. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga4718f5548b17c10b99741a3115afcb17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4718f5548b17c10b99741a3115afcb17">&#9670;&nbsp;</a></span>sdadc_channel_stage_2_gain_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_d_a_d_c.html#ga4718f5548b17c10b99741a3115afcb17">sdadc_channel_stage_2_gain_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Per channel stage 2 gain options. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4718f5548b17c10b99741a3115afcb17ac2e8d107c590f1b73c0fb47d28608fd9"></a>SDADC_CHANNEL_STAGE_2_GAIN_1&#160;</td><td class="fielddoc"><p>Gain of 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4718f5548b17c10b99741a3115afcb17aeb96d4b4d0c7a987682019d7600ee0f3"></a>SDADC_CHANNEL_STAGE_2_GAIN_2&#160;</td><td class="fielddoc"><p>Gain of 2. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4718f5548b17c10b99741a3115afcb17afd6800c01ed992557ba306d8f895d091"></a>SDADC_CHANNEL_STAGE_2_GAIN_4&#160;</td><td class="fielddoc"><p>Gain of 4. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4718f5548b17c10b99741a3115afcb17a8781111735fe7c644616711396876ab3"></a>SDADC_CHANNEL_STAGE_2_GAIN_8&#160;</td><td class="fielddoc"><p>Gain of 8. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga3dca7248427ec13217415a08066aac82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dca7248427ec13217415a08066aac82">&#9670;&nbsp;</a></span>sdadc_channel_oversampling_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_d_a_d_c.html#ga3dca7248427ec13217415a08066aac82">sdadc_channel_oversampling_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Per channel oversampling ratio. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3dca7248427ec13217415a08066aac82a551c5ad841d31c0ccdd28ac3c7883337"></a>SDADC_CHANNEL_OVERSAMPLING_64&#160;</td><td class="fielddoc"><p>Oversampling ratio of 64. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3dca7248427ec13217415a08066aac82a37891ebd8cf57e4ed7adae649136d8c4"></a>SDADC_CHANNEL_OVERSAMPLING_128&#160;</td><td class="fielddoc"><p>Oversampling ratio of 128. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3dca7248427ec13217415a08066aac82a887515b1f2d1a265f49685fb1e24e381"></a>SDADC_CHANNEL_OVERSAMPLING_256&#160;</td><td class="fielddoc"><p>Oversampling ratio of 256. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3dca7248427ec13217415a08066aac82af7fef934aad0af2597de115c1dc613b4"></a>SDADC_CHANNEL_OVERSAMPLING_512&#160;</td><td class="fielddoc"><p>Oversampling ratio of 512. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3dca7248427ec13217415a08066aac82a154907c40d46b28fe360cc1e615aeee4"></a>SDADC_CHANNEL_OVERSAMPLING_1024&#160;</td><td class="fielddoc"><p>Oversampling ratio of 1024. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3dca7248427ec13217415a08066aac82a861dbfa3485560c250ab1faf85af3c78"></a>SDADC_CHANNEL_OVERSAMPLING_2048&#160;</td><td class="fielddoc"><p>Oversampling ratio of 2048. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga74bb0f640145edbf82f07ccd9ef28244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74bb0f640145edbf82f07ccd9ef28244">&#9670;&nbsp;</a></span>sdadc_channel_polarity_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_d_a_d_c.html#ga74bb0f640145edbf82f07ccd9ef28244">sdadc_channel_polarity_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Per channel polarity, valid for single-ended input only. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga74bb0f640145edbf82f07ccd9ef28244a6e77daddf08dc3fc362f47722ea609af"></a>SDADC_CHANNEL_POLARITY_POSITIVE&#160;</td><td class="fielddoc"><p>Positive-side single-ended input. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga74bb0f640145edbf82f07ccd9ef28244a2b1227d90ad54e0f9e3d57bee2e153a8"></a>SDADC_CHANNEL_POLARITY_NEGATIVE&#160;</td><td class="fielddoc"><p>Negative-side single-ended input. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga6f7fea933d308bfc55dbca4f0f6ce630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f7fea933d308bfc55dbca4f0f6ce630">&#9670;&nbsp;</a></span>sdadc_channel_average_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_d_a_d_c.html#ga6f7fea933d308bfc55dbca4f0f6ce630">sdadc_channel_average_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Per channel number of conversions to average before conversion end callback. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6f7fea933d308bfc55dbca4f0f6ce630a12bb424f581a700f487343e90ff8501d"></a>SDADC_CHANNEL_AVERAGE_NONE&#160;</td><td class="fielddoc"><p>Do not average (callback for each conversion) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6f7fea933d308bfc55dbca4f0f6ce630a76ad399f1c11d9b562ea812eeb035682"></a>SDADC_CHANNEL_AVERAGE_8&#160;</td><td class="fielddoc"><p>Average 8 samples for each conversion end callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6f7fea933d308bfc55dbca4f0f6ce630a96101922ff90fe881bfb96c7c1219938"></a>SDADC_CHANNEL_AVERAGE_16&#160;</td><td class="fielddoc"><p>Average 16 samples for each conversion end callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6f7fea933d308bfc55dbca4f0f6ce630ac7e3bee6b7232d5a183fa756aa753063"></a>SDADC_CHANNEL_AVERAGE_32&#160;</td><td class="fielddoc"><p>Average 32 samples for each conversion end callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6f7fea933d308bfc55dbca4f0f6ce630a38fd67c20c786c7f9a7280fefea30622"></a>SDADC_CHANNEL_AVERAGE_64&#160;</td><td class="fielddoc"><p>Average 64 samples for each conversion end callback. </p>
</td></tr>
</table>

</div>
</div>
<a id="gadcd798ec2221d751622dce2c2fc3acf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcd798ec2221d751622dce2c2fc3acf2">&#9670;&nbsp;</a></span>sdadc_channel_inversion_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_d_a_d_c.html#gadcd798ec2221d751622dce2c2fc3acf2">sdadc_channel_inversion_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Per channel polarity, valid for negative-side single-ended input only. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadcd798ec2221d751622dce2c2fc3acf2a806423b83c912f77dc0ecac6e7768850"></a>SDADC_CHANNEL_INVERSION_OFF&#160;</td><td class="fielddoc"><p>Do not invert conversion result. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadcd798ec2221d751622dce2c2fc3acf2a734d7b242521de2c6404c487604dda41"></a>SDADC_CHANNEL_INVERSION_ON&#160;</td><td class="fielddoc"><p>Invert conversion result. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga677ae3bb18c1bb15eb56d49a93a922eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga677ae3bb18c1bb15eb56d49a93a922eb">&#9670;&nbsp;</a></span>sdadc_channel_count_formula_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_d_a_d_c.html#ga677ae3bb18c1bb15eb56d49a93a922eb">sdadc_channel_count_formula_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select a formula to specify the number of conversions. The following symbols are used in the formulas:</p><ul>
<li>N: Number of conversions</li>
<li>n: sdadc_channel_cfg_t::coefficient_n, do not set to 0 if m is 0</li>
<li>m: sdadc_channel_cfg_t::coefficient_m, do not set to 0 if n is 0</li>
</ul>
<p>Either m or n must be non-zero. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga677ae3bb18c1bb15eb56d49a93a922eba78ea76d1d11c597eaff246297350146e"></a>SDADC_CHANNEL_COUNT_FORMULA_EXPONENTIAL&#160;</td><td class="fielddoc"><p>N = 32 * (2 ^ n - 1) + m * 2 ^ n. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga677ae3bb18c1bb15eb56d49a93a922eba139230450ef82e18b8157a49157759af"></a>SDADC_CHANNEL_COUNT_FORMULA_LINEAR&#160;</td><td class="fielddoc"><p>N = (32 * n) + m. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaaea93412ee94494d96a4194efa8ff416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaea93412ee94494d96a4194efa8ff416">&#9670;&nbsp;</a></span>sdadc_calibration_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_d_a_d_c.html#gaaea93412ee94494d96a4194efa8ff416">sdadc_calibration_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calibration mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaaea93412ee94494d96a4194efa8ff416acd9e2bd2c45ae86bb253b3f8a3942f92"></a>SDADC_CALIBRATION_INTERNAL_GAIN_OFFSET&#160;</td><td class="fielddoc"><p>Use internal reference to calibrate offset and gain. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaea93412ee94494d96a4194efa8ff416a73f8e394317aac559a557192815ee334"></a>SDADC_CALIBRATION_EXTERNAL_OFFSET&#160;</td><td class="fielddoc"><p>Use external reference to calibrate offset. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaea93412ee94494d96a4194efa8ff416ab49a3e97be958cfc30b3cb5d50266b74"></a>SDADC_CALIBRATION_EXTERNAL_GAIN&#160;</td><td class="fielddoc"><p>Use external reference to calibrate gain. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga57663247dadf8d0ca835f1d674985e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57663247dadf8d0ca835f1d674985e8b">&#9670;&nbsp;</a></span>R_SDADC_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SDADC_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#structadc__cfg__t">adc_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies power to the SDADC and initializes the hardware based on the user configuration. As part of this initialization, the SDADC clock is configured and enabled. If an interrupt priority is non-zero, enables an interrupt which will call a callback to notify the user when a conversion, scan, or calibration is complete. <a class="el" href="group___s_d_a_d_c.html#ga9c8c90f3182823e0b8a76fab5612d181">R_SDADC_Calibrate()</a> must be called after this function before using the SDADC if any channels are used in differential mode. Implements <a class="el" href="group___a_d_c___a_p_i.html#afa184c06541e3fd9f90fc12ed775f468">adc_api_t::open()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function delays at least 2 ms as required by the SDADC power on procedure.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Configuration successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input pointer is NULL or an input parameter is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Control block is already open. </td></tr>
    <tr><td class="paramname">FSP_ERR_IRQ_BSP_DISABLED</td><td>A required interrupt is disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0a7002fc86458bbd74ac178bbaaaff68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a7002fc86458bbd74ac178bbaaaff68">&#9670;&nbsp;</a></span>R_SDADC_ScanCfg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SDADC_ScanCfg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>p_extend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the enabled channels of the ADC. Pass a pointer to <a class="el" href="group___s_d_a_d_c.html#structsdadc__scan__cfg__t">sdadc_scan_cfg_t</a> to p_extend. Implements <a class="el" href="group___a_d_c___a_p_i.html#a44289d7822720544751eb22e3d7d38ea">adc_api_t::scanCfg()</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Information stored in p_adc_info. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input pointer is NULL or an input parameter is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Instance control block is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4f0d9f978b33d4bf19d6522ea3701032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f0d9f978b33d4bf19d6522ea3701032">&#9670;&nbsp;</a></span>R_SDADC_InfoGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SDADC_InfoGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#structadc__info__t">adc_info_t</a> *&#160;</td>
          <td class="paramname"><em>p_adc_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the address of the lowest number configured channel, the total number of results to be read in order to read the results of all configured channels, the size of each result, and the ELC event enumerations. Implements <a class="el" href="group___a_d_c___a_p_i.html#acc68017ee284386b5d13c027bc10bf87">adc_api_t::infoGet()</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Information stored in p_adc_info. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input pointer was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Instance control block is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga21a9d4b48c9a260b4515572e3f6cacdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21a9d4b48c9a260b4515572e3f6cacdd">&#9670;&nbsp;</a></span>R_SDADC_ScanStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SDADC_ScanStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the SDADC is configured for hardware triggers, enables hardware triggers. Otherwise, starts a scan. Implements <a class="el" href="group___a_d_c___a_p_i.html#a2f9e091ca57ca2c58262f66ab5c341c9">adc_api_t::scanStart()</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Scan started or hardware triggers enabled successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input pointer was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Instance control block is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>A conversion or calibration is in progress. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga62382aeba24d64d3ba7e6eb1c8a1b187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62382aeba24d64d3ba7e6eb1c8a1b187">&#9670;&nbsp;</a></span>R_SDADC_ScanGroupStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SDADC_ScanGroupStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaee17c30275c1c9376cc485a62ea121eb">adc_group_mask_t</a>&#160;</td>
          <td class="paramname"><em>group_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group___a_d_c___a_p_i.html#a2f9e091ca57ca2c58262f66ab5c341c9">adc_api_t::scanStart</a> is not supported on the SDADC. Use scanStart instead.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Function not supported in this implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga35cdadbf61f92ee76fbbc3c5584b850b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35cdadbf61f92ee76fbbc3c5584b850b">&#9670;&nbsp;</a></span>R_SDADC_ScanStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SDADC_ScanStop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the SDADC is configured for hardware triggers, disables hardware triggers. Otherwise, stops any in-progress scan started by software. Implements <a class="el" href="group___a_d_c___a_p_i.html#a90346240a89666209a78bdcb020278bd">adc_api_t::scanStop()</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Scan stopped or hardware triggers disabled successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input pointer was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Instance control block is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaebb38f07bd7922342597c2d453957433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebb38f07bd7922342597c2d453957433">&#9670;&nbsp;</a></span>R_SDADC_StatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SDADC_StatusGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#structadc__status__t">adc_status_t</a> *&#160;</td>
          <td class="paramname"><em>p_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the status of a scan started by software, including calibration scans. It is not possible to determine the status of a scan started by a hardware trigger. Implements <a class="el" href="group___a_d_c___a_p_i.html#ae54bb53ea323ac24a3b63769e0196a57">adc_api_t::scanStatusGet()</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>No software scan or calibration is in progress. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input pointer was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Instance control block is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf6af5f96116f06d57982fb1cdc8d416b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6af5f96116f06d57982fb1cdc8d416b">&#9670;&nbsp;</a></span>R_SDADC_Read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SDADC_Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const&#160;</td>
          <td class="paramname"><em>reg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *const&#160;</td>
          <td class="paramname"><em>p_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the most recent conversion result from a channel. Truncates 24-bit results to the upper 16 bits. Implements <a class="el" href="group___a_d_c___a_p_i.html#a9a540c52a5052a12b3b879d78543efd5">adc_api_t::read()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The result stored in p_data is signed when the SDADC channel is configured in differential mode.</dd>
<dd>
Do not use this API if the conversion end interrupt (SDADC0_ADI) is used to trigger the DTC unless the interrupt mode is set to TRANSFER_IRQ_EACH.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Conversion result in p_data. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input pointer was NULL or an input parameter was invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Instance control block is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga77dc084a35379f65d2e2084e9a9c5806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77dc084a35379f65d2e2084e9a9c5806">&#9670;&nbsp;</a></span>R_SDADC_Read32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SDADC_Read32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const&#160;</td>
          <td class="paramname"><em>reg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *const&#160;</td>
          <td class="paramname"><em>p_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the most recent conversion result from a channel. Implements <a class="el" href="group___a_d_c___a_p_i.html#a81338d39975b7fe87d5e06c55a8c5dc5">adc_api_t::read32()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The result stored in p_data is signed when the SDADC channel is configured in differential mode. When the SDADC is configured for 24-bit resolution and right alignment, the sign bit is bit 23, and the upper 8 bits are 0. When the SDADC is configured for 16-bit resolution and right alignment, the sign bit is bit 15, and the upper 16 bits are 0.</dd>
<dd>
Do not use this API if the conversion end interrupt (SDADC0_ADI) is used to trigger the DTC unless the interrupt mode is set to TRANSFER_IRQ_EACH.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Conversion result in p_data. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input pointer was NULL or an input parameter was invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Instance control block is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf89d5f194cf841e12f1db6f869a4cf18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf89d5f194cf841e12f1db6f869a4cf18">&#9670;&nbsp;</a></span>R_SDADC_OffsetSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SDADC_OffsetSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const&#160;</td>
          <td class="paramname"><em>reg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t const&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the offset. Offset is applied after stage 1 of the input channel. Offset can only be applied when the channel is configured for differential input. Implements <a class="el" href="group___a_d_c___a_p_i.html#a305b2c2466cd88fdddf6134db542dc7e">adc_api_t::offsetSet()</a>.</p>
<p>Note: The offset is cleared if <a class="el" href="group___a_d_c___a_p_i.html#a1020d90e58d3bf86cee2f46a62e62fc4">adc_api_t::calibrate()</a> is called. The offset can be re-applied if necessary after the the callback with event ADC_EVENT_CALIBRATION_COMPLETE is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_ctrl</td><td>See p_instance_ctrl in <a class="el" href="group___a_d_c___a_p_i.html#a305b2c2466cd88fdddf6134db542dc7e">adc_api_t::offsetSet()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reg_id</td><td>See reg_id in <a class="el" href="group___a_d_c___a_p_i.html#a305b2c2466cd88fdddf6134db542dc7e">adc_api_t::offsetSet()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Must be between -15 and 15, offset (mV) = 10.9376 mV * offset_steps / stage 1 gain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Offset updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input pointer was NULL or an input parameter was invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>A conversion or calibration is in progress. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Instance control block is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9c8c90f3182823e0b8a76fab5612d181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c8c90f3182823e0b8a76fab5612d181">&#9670;&nbsp;</a></span>R_SDADC_Calibrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SDADC_Calibrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>p_extend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Requires <a class="el" href="group___s_d_a_d_c.html#structsdadc__calibrate__args__t">sdadc_calibrate_args_t</a> passed to p_extend. Calibrates the specified channel. Calibration is not required or supported for single-ended mode. Calibration must be completed for differential mode before using the SDADC. A callback with the event ADC_EVENT_CALIBRATION_COMPLETE is called when calibration completes. Implements <a class="el" href="group___a_d_c___a_p_i.html#a1020d90e58d3bf86cee2f46a62e62fc4">adc_api_t::calibrate()</a>.</p>
<p>During external offset calibration, apply a differential voltage of 0 to ANSDnP - ANSDnN, where n is the input channel and ANSDnP is OPAMP0 for channel 4 and ANSDnN is OPAMP1 for channel 4. Complete external offset calibration before external gain calibration.</p>
<p>During external gain calibration apply a voltage between 0.4 V / total_gain and 0.8 V / total_gain. The differential voltage applied during calibration is corrected to a conversion result of 0x7FFFFF, which is the maximum possible positive differential measurement.</p>
<p>This function clears the offset value. If offset is required after calibration, it must be reapplied after calibration is complete using <a class="el" href="group___a_d_c___a_p_i.html#a305b2c2466cd88fdddf6134db542dc7e">adc_api_t::offsetSet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Calibration began successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input pointer was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>A conversion or calibration is in progress. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Instance control block is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacd3903592611777a4bdd0bf0e6488da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd3903592611777a4bdd0bf0e6488da8">&#9670;&nbsp;</a></span>R_SDADC_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SDADC_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops any scan in progress, disables interrupts, and powers down the SDADC peripheral. Implements <a class="el" href="group___a_d_c___a_p_i.html#a83cce8ff1af572c11ef31442f2679124">adc_api_t::close()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function delays at least 3 us as required by the SDADC24 stop procedure.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Instance control block closed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input pointer was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Instance control block is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v5.2.0 User's Manual Copyright  (2024) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
