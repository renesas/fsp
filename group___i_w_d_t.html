<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: Independent Watchdog (r_iwdt)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
    $(document).ready(function() {
        $("tr.tree_lvl_1").nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
		$("tr.tree_lvl_1").data("expanded","0");
		$("tr.tree_lvl_2").data("expanded","0");
		$("tr.tree_lvl_3").data("expanded","0");
		$("tr.tree_lvl_4").data("expanded","0");
		$("tr.tree_lvl_5").data("expanded","0");
        $("tr.tree_lvl_1").click(function() {
		    var lvl_1_is_open = $(this).data("expanded");
		    if (lvl_1_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2, tr.tree_lvl_1_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_2,tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_2").click(function() {
		    var lvl_2_is_open = $(this).data("expanded");
		    if (lvl_2_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3, tr.tree_lvl_2_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_3,tr.tree_lvl_4,tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_3").click(function() {
		    var lvl_3_is_open = $(this).data("expanded");
		    if (lvl_3_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_3_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_4, tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_4").click(function() {
		    var lvl_4_is_open = $(this).data("expanded");
		    if (lvl_4_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5, tr.tree_lvl_4_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
                $(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).nextUntil("tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5").data("expanded","0");
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
		$("tr.tree_lvl_5").click(function() {
		    var lvl_5_is_open = $(this).data("expanded");
		    if (lvl_5_is_open == "0") {
                $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4,tr.tree_lvl_3,tr.tree_lvl_2,tr.tree_lvl_1,tr.tree_none", "tr.tree_lvl_5_item").show();
                $(this).find("span").removeClass("chevron-collapsed").addClass("chevron-expanded");
				$(this).data("expanded","1");
			} else {
			    $(this).nextUntil("tr.tree_lvl_5,tr.tree_lvl_4_item,tr.tree_lvl_4,tr.tree_lvl_3_item,tr.tree_lvl_3,tr.tree_lvl_2_item,tr.tree_lvl_2,tr.tree_lvl_1_item,tr.tree_lvl_1,tr.tree_none").hide();
				$(this).find("span").removeClass("chevron-expanded").addClass("chevron-collapsed");
				$(this).data("expanded","0");
			    }
        });
     });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v6.2.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">

    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text">
      </span>
      <span class="right">
          &nbsp;
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___i_w_d_t.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body.
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len));
            }
          }
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element.
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<div class="title">Independent Watchdog (r_iwdt)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___m_o_n_i_t_o_r_i_n_g___m_o_d_u_l_e_s.html">Monitoring</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga989ac08697fdbf8a0ca02f8fd3066080"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_w_d_t.html#ga989ac08697fdbf8a0ca02f8fd3066080">R_IWDT_Open</a> (<a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___w_d_t___a_p_i.html#structwdt__cfg__t">wdt_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:ga989ac08697fdbf8a0ca02f8fd3066080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74e708a8e45b1b93b2a9255d50007a4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_w_d_t.html#ga74e708a8e45b1b93b2a9255d50007a4d">R_IWDT_Refresh</a> (<a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:ga74e708a8e45b1b93b2a9255d50007a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9619fc0daddf190cda28ccae1213629d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_w_d_t.html#ga9619fc0daddf190cda28ccae1213629d">R_IWDT_StatusGet</a> (<a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___w_d_t___a_p_i.html#ga46c1d04f78b75ad1ad21314cac574935">wdt_status_t</a> *const p_status)</td></tr>
<tr class="separator:ga9619fc0daddf190cda28ccae1213629d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca4ac4abef1b4d4b3dd2982bc1b19278"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_w_d_t.html#gaca4ac4abef1b4d4b3dd2982bc1b19278">R_IWDT_StatusClear</a> (<a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const p_api_ctrl, const <a class="el" href="group___w_d_t___a_p_i.html#ga46c1d04f78b75ad1ad21314cac574935">wdt_status_t</a> status)</td></tr>
<tr class="separator:gaca4ac4abef1b4d4b3dd2982bc1b19278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e86ba83718eb70e72bfb892c39ddbb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_w_d_t.html#ga5e86ba83718eb70e72bfb892c39ddbb4">R_IWDT_CounterGet</a> (<a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const p_api_ctrl, uint32_t *const p_count)</td></tr>
<tr class="separator:ga5e86ba83718eb70e72bfb892c39ddbb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e029c3f446f09d7de668eb49709b439"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_w_d_t.html#ga7e029c3f446f09d7de668eb49709b439">R_IWDT_TimeoutGet</a> (<a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___w_d_t___a_p_i.html#structwdt__timeout__values__t">wdt_timeout_values_t</a> *const p_timeout)</td></tr>
<tr class="separator:ga7e029c3f446f09d7de668eb49709b439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga141c6ba5a6ecd096a1e752c5facd0c24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_w_d_t.html#ga141c6ba5a6ecd096a1e752c5facd0c24">R_IWDT_CallbackSet</a> (<a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const p_ctrl, void(*p_callback)(<a class="el" href="group___w_d_t___a_p_i.html#structwdt__callback__args__t">wdt_callback_args_t</a> *), void *const p_context, <a class="el" href="group___w_d_t___a_p_i.html#structwdt__callback__args__t">wdt_callback_args_t</a> *const p_callback_memory)</td></tr>
<tr class="separator:ga141c6ba5a6ecd096a1e752c5facd0c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the IWDT peripheral on RA MCUs. This module implements the <a class="el" href="group___w_d_t___a_p_i.html">WDT Interface</a>. </p>
<h1><a class="anchor" id="r-iwdt-overview"></a>
Overview</h1>
<p>The independent watchdog timer is used to recover from unexpected errors in an application. The timer must be refreshed periodically in the permitted count window by the application. If the count is allowed to underflow or refresh occurs outside of the valid refresh period, the IWDT resets the device or generates an NMI.</p>
<h2><a class="anchor" id="r-iwdt-features"></a>
Features</h2>
<p>The IWDT HAL module has the following key features:</p><ul>
<li>When the IWDT underflows or is refreshed outside of the permitted refresh window, one of the following events can occur:<ul>
<li>Resetting of the device<a class="anchor" id="um_wdt_configuration_for_reset_control"></a></li>
<li>Generation of an NMI<a class="anchor" id="um_wdt_nmi_callback_support"></a></li>
</ul>
</li>
<li>The WDT supports following modes:<sup>1</sup><ul>
<li>In auto start mode, the WDT begins counting at reset.<a class="anchor" id="um_wdt_auto_start_mode_support"></a></li>
<li>In register start mode, the WDT can be started from the application<sup>1</sup>.<a class="anchor" id="um_wdt_register_start_mode"></a> </li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="r-iwdt-selecting-a-watchdog"></a>
Selecting a Watchdog</h2>
<p>RA MCUs have two watchdog peripherals: the watchdog timer (WDT) and the independent watchdog timer (IWDT). When selecting between them, consider these factors:</p>
<table class="doxtable">
<tr>
<th></th><th>WDT </th><th>IWDT  </th></tr>
<tr>
<td>Start Mode</td><td>The WDT can be started from the application (register start mode) or configured by hardware to start automatically (auto start mode). </td><td>On most of MCUs, the IWDT can only be configured by hardware to start automatically<sup>1</sup>. </td></tr>
<tr>
<td>Clock Source</td><td>The WDT runs off a peripheral clock.</td><td>The IWDT has its own clock source which improves safety. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>1. Refer to the MCU hardware user's manual or datasheet to determine if IWDT supports register start mode.</dd></dl>
<h1><a class="anchor" id="r-iwdt-configuration"></a>
Configuration</h1>
<p>When using register start mode, configure the watchdog timer on the Stacks tab.</p>
<dl class="section note"><dt>Note</dt><dd>When using auto start mode, configurations on the <b>Stacks</b> tab are ignored. Configure the watchdog using the OFS settings on the BSP tab. These settings include the following:<ul>
<li>Start Mode</li>
<li>Timeout Period</li>
<li>Dedicated Clock Frequency Divisor</li>
<li>Window End Position</li>
<li>Window Start Position</li>
<li>Reset Interrupt Request Select</li>
<li>Stop Control</li>
</ul>
</dd>
<dd>
Review the OFS0 properties window to see additional details.</dd></dl>
<p><a class="anchor" id="um_wdt_nmi_callback_required"></a><a class="anchor" id="um_wdt_configuration_for_refresh_window_start_position"></a><a class="anchor" id="um_wdt_configuration_for_refresh_window_end_position"></a><a class="anchor" id="um_wdt_configuration_for_wdt_clock_division"></a><a class="anchor" id="um_wdt_configuration_for_wdt_timeout_period"></a> <h2>Build Time Configurations for r_iwdt</h2>
The following build time configurations are defined in fsp_cfg/r_iwdt_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr class="tree_none">
<td>Register Start NMI Support</td><td>MCU Specific Options</td><td></td><td>If enabled, code for NMI support in register start mode is included in the build. </td></tr>
</table>
 <h2>Configurations for Monitoring &gt; Independent Watchdog (r_iwdt)</h2>
This module can be added to the Stacks tab via New Stack &gt; Monitoring &gt; Independent Watchdog (r_iwdt). Non-secure callable guard functions can be generated for this module by right clicking the module in the RA Configuration tool and checking the "Non-secure Callable" box.<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr class="tree_none">
<td>Name</td><td>Name must be a valid C symbol</td><td>g_wdt0 </td><td>Module name. </td></tr>
<tr class="tree_none">
<td>Timeout</td><td>MCU Specific Options</td><td></td><td>Select the independent watchdog timeout in cycles. </td></tr>
<tr class="tree_none">
<td>Clock Division Ratio</td><td>MCU Specific Options</td><td></td><td>Select the independent watchdog clock divisor. </td></tr>
<tr class="tree_none">
<td>Window Start Position</td><td>MCU Specific Options</td><td></td><td>Select the allowed independent watchdog refresh start point in %. </td></tr>
<tr class="tree_none">
<td>Window End Position</td><td>MCU Specific Options</td><td></td><td>Select the allowed independent watchdog refresh end point in %. </td></tr>
<tr class="tree_none">
<td>Reset Control</td><td>MCU Specific Options</td><td></td><td>Select what happens when the independent watchdog timer expires. </td></tr>
<tr class="tree_none">
<td>Stop Control</td><td>MCU Specific Options</td><td></td><td>Select the independent watchdog state in low power mode. </td></tr>
<tr class="tree_none">
<td>NMI callback</td><td>Name must be a valid C symbol</td><td>NULL </td><td>A user callback function can be provided here. If this callback function is provided, it is called from the interrupt service routine (ISR) when the watchdog triggers. </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-iwdt-clock-configuration"></a>
Clock Configuration</h2>
<p>The IWDT clock is based on the IWDTCLK frequency. You can set the IWDTCLK frequency divider using the <b>BSP</b> tab of the RA Configuration editor.</p>
<h2><a class="anchor" id="r-iwdt-pin-configuration"></a>
Pin Configuration</h2>
<p>This module does not use I/O pins.</p>
<h1><a class="anchor" id="r-iwdt-usage_notes"></a>
Usage Notes</h1>
<h2><a class="anchor" id="r-iwdt-nmi-interrupt"></a>
NMI Interrupt</h2>
<p>The independent watchdog timer uses the NMI, which is enabled by default. No special configuration is required. When the NMI is triggered, the callback function registered during open is called.</p>
<dl class="section note"><dt>Note</dt><dd>When using the IWDT in software start mode with NMI and the timer underflows, the IWDT status must be reset by calling <a class="el" href="group___i_w_d_t.html#gaca4ac4abef1b4d4b3dd2982bc1b19278">R_IWDT_StatusClear</a> before restarting the timer via <a class="el" href="group___i_w_d_t.html#ga74e708a8e45b1b93b2a9255d50007a4d">R_IWDT_Refresh</a>.</dd></dl>
<h2>Period Calculation</h2>
<p>The IWDT operates from IWDTCLK. With a IWDTCLK of 15000 Hz, the maximum time from the last refresh to device reset or NMI generation will be just below 35 seconds as detailed below.</p>
<p>IWDTCLK = 15000 Hz<br />
Clock division ratio = IWDTCLK / 256<br />
Timeout period = 2048 cycles<br />
WDT clock frequency = 15000 Hz / 256 = 58.59 Hz<br />
Cycle time = 1 / 58.59 Hz = 17.067 ms<br />
Timeout = 17.067 ms x 2048 cycles = 34.95 seconds</p>
<h2><a class="anchor" id="r-iwdt-limitations"></a>
Limitations</h2>
<p>Developers should be aware of the following limitations when using the IWDT:</p>
<ul>
<li>When using a J-Link debugger the IWDT counter does not count and therefore will not reset the device or generate an NMI. To enable the watchdog to count and generate a reset or NMI while debugging, add this line of code in the application: <div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Enable the IWDT to count and generate NMI or reset when the</span></div><div class="line"><span class="comment">     * debugger is connected. */</span></div><div class="line">    R_DEBUG-&gt;DBGSTOPCR_b.DBGSTOP_IWDT = 0;</div><div class="line"></div></div><!-- fragment --></li>
<li>If the IWDT is configured to stop the counter in low power mode, then your application must restart the watchdog by calling <a class="el" href="group___i_w_d_t.html#ga74e708a8e45b1b93b2a9255d50007a4d">R_IWDT_Refresh()</a> after the MCU wakes from low power mode.</li>
</ul>
<h1><a class="anchor" id="r-iwdt-examples"></a>
Examples</h1>
<h2>IWDT Basic Example</h2>
<p>This is a basic example of minimal use of the IWDT in an application.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> iwdt_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* In auto start mode, the IWDT starts counting immediately when the MCU is powered on. */</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___i_w_d_t.html#ga989ac08697fdbf8a0ca02f8fd3066080">R_IWDT_Open</a>(&amp;g_iwdt0_ctrl, &amp;g_iwdt0_cfg);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Application work here. */</span></div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">/* Refresh before the counter underflows to prevent reset or NMI based on the setting. */</span></div><div class="line">        (void) <a class="code" href="group___i_w_d_t.html#ga74e708a8e45b1b93b2a9255d50007a4d">R_IWDT_Refresh</a>(&amp;g_iwdt0_ctrl);</div><div class="line"></div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>IWDT Advanced Example</h2>
<p>This example demonstrates using a start window and gives an example callback to handle an NMI generated by an underflow or refresh error.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define IWDT_TIMEOUT_COUNTS     (2048U)</span></div><div class="line"><span class="preprocessor">#define IWDT_MAX_COUNTER        (IWDT_TIMEOUT_COUNTS - 1U)</span></div><div class="line"><span class="preprocessor">#define IWDT_START_WINDOW_75    ((IWDT_MAX_COUNTER * 3) / 4)</span></div><div class="line"></div><div class="line"><span class="comment">/* Example callback called when a watchdog NMI occurs. */</span></div><div class="line"><span class="keywordtype">void</span> iwdt_callback (<a class="code" href="group___w_d_t___a_p_i.html#structwdt__callback__args__t">wdt_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gaf0afcbc9a110ac9366a811d96ee06029">FSP_PARAMETER_NOT_USED</a>(p_args);</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Determine the source of the NMI. */</span></div><div class="line">    <a class="code" href="group___w_d_t___a_p_i.html#ga46c1d04f78b75ad1ad21314cac574935">wdt_status_t</a> status = <a class="code" href="group___w_d_t___a_p_i.html#gga46c1d04f78b75ad1ad21314cac574935a0f1543f47bca7e987fe86ab04dd16e46">WDT_STATUS_NO_ERROR</a>;</div><div class="line">    err = <a class="code" href="group___i_w_d_t.html#ga9619fc0daddf190cda28ccae1213629d">R_IWDT_StatusGet</a>(&amp;g_iwdt0_ctrl, &amp;status);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Log source of NMI and any other debug information. */</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Clear the error flags. */</span></div><div class="line">    err = <a class="code" href="group___i_w_d_t.html#gaca4ac4abef1b4d4b3dd2982bc1b19278">R_IWDT_StatusClear</a>(&amp;g_iwdt0_ctrl, status);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Issue a software reset to reset the MCU. */</span></div><div class="line">    __NVIC_SystemReset();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> iwdt_advanced_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Enable the IWDT to count and generate NMI or reset when the</span></div><div class="line"><span class="comment">     * debugger is connected. */</span></div><div class="line">    R_DEBUG-&gt;DBGSTOPCR_b.DBGSTOP_IWDT = 0;</div><div class="line"></div><div class="line"><span class="preprocessor">#if defined(R_SYSTEM_RSTSR1_IWDTRF_Msk)</span></div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Check if the IWDTRF flag is set to know if the system is</span></div><div class="line"><span class="comment">     * recovering from a IWDT reset. */</span></div><div class="line">    <span class="keywordflow">if</span> (R_SYSTEM-&gt;RSTSR1_b.IWDTRF)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Clear the flag. */</span></div><div class="line">        R_SYSTEM-&gt;RSTSR1 = 0U;</div><div class="line">    }</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="comment">/* Open the module. */</span></div><div class="line">    err = <a class="code" href="group___i_w_d_t.html#ga989ac08697fdbf8a0ca02f8fd3066080">R_IWDT_Open</a>(&amp;g_iwdt0_ctrl, &amp;g_iwdt0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize other application code. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Do not call R_IWDT_Refresh() in auto start mode unless the</span></div><div class="line"><span class="comment">     * counter is in the acceptable refresh window. */</span></div><div class="line">    (void) <a class="code" href="group___i_w_d_t.html#ga74e708a8e45b1b93b2a9255d50007a4d">R_IWDT_Refresh</a>(&amp;g_iwdt0_ctrl);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Application work here. */</span></div><div class="line"></div><div class="line">        <span class="comment">/* (Optional) If there is a chance the application takes less time than</span></div><div class="line"><span class="comment">         * the start window, verify the IWDT counter is past the start window</span></div><div class="line"><span class="comment">         * before refreshing the IWDT. */</span></div><div class="line">        uint32_t iwdt_counter = 0U;</div><div class="line">        <span class="keywordflow">do</span></div><div class="line">        {</div><div class="line"></div><div class="line">            <span class="comment">/* Read the current IWDT counter value. */</span></div><div class="line">            err = <a class="code" href="group___i_w_d_t.html#ga5e86ba83718eb70e72bfb892c39ddbb4">R_IWDT_CounterGet</a>(&amp;g_iwdt0_ctrl, &amp;iwdt_counter);</div><div class="line">            assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">        } <span class="keywordflow">while</span> (iwdt_counter &gt;= IWDT_START_WINDOW_75);</div><div class="line"></div><div class="line">        <span class="comment">/* Refresh before the counter underflows to prevent reset or NMI. */</span></div><div class="line">        (void) <a class="code" href="group___i_w_d_t.html#ga74e708a8e45b1b93b2a9255d50007a4d">R_IWDT_Refresh</a>(&amp;g_iwdt0_ctrl);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structiwdt__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_w_d_t.html#structiwdt__instance__ctrl__t">iwdt_instance_ctrl_t</a></td></tr>
<tr class="separator:structiwdt__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structiwdt__instance__ctrl__t" id="structiwdt__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structiwdt__instance__ctrl__t">&#9670;&nbsp;</a></span>iwdt_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct iwdt_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>IWDT control block. DO NOT INITIALIZE. Initialization occurs when <a class="el" href="group___w_d_t___a_p_i.html#af03fc1703319e1adacabc412c7e3de31">wdt_api_t::open</a> is called. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:ae07ff8e66ee64e231841e8a578b76eff"><td class="memItemLeft" align="right" valign="top"><a id="ae07ff8e66ee64e231841e8a578b76eff"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_w_d_t.html#ae07ff8e66ee64e231841e8a578b76eff">wdt_open</a></td></tr>
<tr class="memdesc:ae07ff8e66ee64e231841e8a578b76eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the open() API has been successfully called. <br /></td></tr>
<tr class="separator:ae07ff8e66ee64e231841e8a578b76eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add20b0e08ec0f53e54e18f8b4c47d2c0"><td class="memItemLeft" align="right" valign="top"><a id="add20b0e08ec0f53e54e18f8b4c47d2c0"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_w_d_t.html#add20b0e08ec0f53e54e18f8b4c47d2c0">p_context</a></td></tr>
<tr class="memdesc:add20b0e08ec0f53e54e18f8b4c47d2c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placeholder for user data. Passed to the user callback in <a class="el" href="group___w_d_t___a_p_i.html#structwdt__callback__args__t">wdt_callback_args_t</a>. <br /></td></tr>
<tr class="separator:add20b0e08ec0f53e54e18f8b4c47d2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1051de77f0a7903177849ae4df6729ec"><td class="memItemLeft" align="right" valign="top"><a id="a1051de77f0a7903177849ae4df6729ec"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_w_d_t.html#a1051de77f0a7903177849ae4df6729ec">p_callback</a> )(<a class="el" href="group___w_d_t___a_p_i.html#structwdt__callback__args__t">wdt_callback_args_t</a> *p_args)</td></tr>
<tr class="memdesc:a1051de77f0a7903177849ae4df6729ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback provided when a WDT NMI ISR occurs. <br /></td></tr>
<tr class="separator:a1051de77f0a7903177849ae4df6729ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga989ac08697fdbf8a0ca02f8fd3066080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga989ac08697fdbf8a0ca02f8fd3066080">&#9670;&nbsp;</a></span>R_IWDT_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_IWDT_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#structwdt__cfg__t">wdt_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register the IWDT NMI callback.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___i_w_d_t.html#ga989ac08697fdbf8a0ca02f8fd3066080">R_IWDT_Open</a>(&amp;g_iwdt0_ctrl, &amp;g_iwdt0_cfg);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>IWDT successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null Pointer. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_ENABLED</td><td>An attempt to open the IWDT when the OFS0 register is not configured for auto-start mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Module is already open. This module can only be opened once. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_STATE</td><td>The security state of the NMI and the module do not match. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga74e708a8e45b1b93b2a9255d50007a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74e708a8e45b1b93b2a9255d50007a4d">&#9670;&nbsp;</a></span>R_IWDT_Refresh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_IWDT_Refresh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Refresh the Independent Watchdog Timer. If the refresh fails due to being performed outside of the permitted refresh period the device will either reset or trigger an NMI ISR to run.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">        <span class="comment">/* Refresh before the counter underflows to prevent reset or NMI based on the setting. */</span></div><div class="line">        (void) <a class="code" href="group___i_w_d_t.html#ga74e708a8e45b1b93b2a9255d50007a4d">R_IWDT_Refresh</a>(&amp;g_iwdt0_ctrl);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>IWDT successfully refreshed. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>One or more parameters are NULL pointers. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The driver has not been opened. Perform <a class="el" href="group___i_w_d_t.html#ga989ac08697fdbf8a0ca02f8fd3066080">R_IWDT_Open()</a> first. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9619fc0daddf190cda28ccae1213629d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9619fc0daddf190cda28ccae1213629d">&#9670;&nbsp;</a></span>R_IWDT_StatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_IWDT_StatusGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#ga46c1d04f78b75ad1ad21314cac574935">wdt_status_t</a> *const&#160;</td>
          <td class="paramname"><em>p_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the IWDT status flags.</p>
<p>Indicates both status and error conditions.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Determine the source of the NMI. */</span></div><div class="line">    <a class="code" href="group___w_d_t___a_p_i.html#ga46c1d04f78b75ad1ad21314cac574935">wdt_status_t</a> status = <a class="code" href="group___w_d_t___a_p_i.html#gga46c1d04f78b75ad1ad21314cac574935a0f1543f47bca7e987fe86ab04dd16e46">WDT_STATUS_NO_ERROR</a>;</div><div class="line">    err = <a class="code" href="group___i_w_d_t.html#ga9619fc0daddf190cda28ccae1213629d">R_IWDT_StatusGet</a>(&amp;g_iwdt0_ctrl, &amp;status);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>IWDT status successfully read. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The driver has not been opened. Perform <a class="el" href="group___i_w_d_t.html#ga989ac08697fdbf8a0ca02f8fd3066080">R_IWDT_Open()</a> first. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>This function is only valid if the IWDT generates an NMI when an error occurs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When the IWDT is configured to output a reset on underflow or refresh error reading the status and error flags serves no purpose as they will always indicate that no underflow has occurred and there is no refresh error. Reading the status and error flags is only valid when interrupt request output is enabled. </dd></dl>

</div>
</div>
<a id="gaca4ac4abef1b4d4b3dd2982bc1b19278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca4ac4abef1b4d4b3dd2982bc1b19278">&#9670;&nbsp;</a></span>R_IWDT_StatusClear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_IWDT_StatusClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___w_d_t___a_p_i.html#ga46c1d04f78b75ad1ad21314cac574935">wdt_status_t</a>&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the IWDT status and error flags. Implements <a class="el" href="group___w_d_t___a_p_i.html#af66d798489c7ace801fee8b5a9c833c2">wdt_api_t::statusClear</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Clear the error flags. */</span></div><div class="line">    err = <a class="code" href="group___i_w_d_t.html#gaca4ac4abef1b4d4b3dd2982bc1b19278">R_IWDT_StatusClear</a>(&amp;g_iwdt0_ctrl, status);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>IWDT flag(s) successfully cleared. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The driver has not been opened. Perform <a class="el" href="group___i_w_d_t.html#ga989ac08697fdbf8a0ca02f8fd3066080">R_IWDT_Open()</a> first. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>This function is only valid if the IWDT generates an NMI when an error occurs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When the IWDT is configured to output a reset on underflow or refresh error reading the status and error flags serves no purpose as they will always indicate that no underflow has occurred and there is no refresh error. Reading the status and error flags is only valid when interrupt request output is enabled. </dd></dl>

</div>
</div>
<a id="ga5e86ba83718eb70e72bfb892c39ddbb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e86ba83718eb70e72bfb892c39ddbb4">&#9670;&nbsp;</a></span>R_IWDT_CounterGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_IWDT_CounterGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *const&#160;</td>
          <td class="paramname"><em>p_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the current count value of the IWDT. Implements <a class="el" href="group___w_d_t___a_p_i.html#a724c02d7265d5eaa846cf97a3556f5d6">wdt_api_t::counterGet</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">            <span class="comment">/* Read the current IWDT counter value. */</span></div><div class="line">            err = <a class="code" href="group___i_w_d_t.html#ga5e86ba83718eb70e72bfb892c39ddbb4">R_IWDT_CounterGet</a>(&amp;g_iwdt0_ctrl, &amp;iwdt_counter);</div><div class="line">            assert(FSP_SUCCESS == err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>IWDT current count successfully read. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The driver has not been opened. Perform <a class="el" href="group___i_w_d_t.html#ga989ac08697fdbf8a0ca02f8fd3066080">R_IWDT_Open()</a> first. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7e029c3f446f09d7de668eb49709b439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e029c3f446f09d7de668eb49709b439">&#9670;&nbsp;</a></span>R_IWDT_TimeoutGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_IWDT_TimeoutGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#structwdt__timeout__values__t">wdt_timeout_values_t</a> *const&#160;</td>
          <td class="paramname"><em>p_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read timeout information for the watchdog timer. Implements <a class="el" href="group___w_d_t___a_p_i.html#ac2b6d848e8be0ff1a0a1be43289ad925">wdt_api_t::timeoutGet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>IWDT timeout information retrieved successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>One or more parameters are NULL pointers. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The driver has not been opened. Perform <a class="el" href="group___i_w_d_t.html#ga989ac08697fdbf8a0ca02f8fd3066080">R_IWDT_Open()</a> first. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga141c6ba5a6ecd096a1e752c5facd0c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga141c6ba5a6ecd096a1e752c5facd0c24">&#9670;&nbsp;</a></span>R_IWDT_CallbackSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_IWDT_CallbackSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="group___w_d_t___a_p_i.html#structwdt__callback__args__t">wdt_callback_args_t</a> *)&#160;</td>
          <td class="paramname"><em>p_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>p_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#structwdt__callback__args__t">wdt_callback_args_t</a> *const&#160;</td>
          <td class="paramname"><em>p_callback_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the user callback and has option of providing memory for callback structure. Implements <a class="el" href="group___w_d_t___a_p_i.html#a92f2416b138202a68fe551dd1a247c10">wdt_api_t::callbackSet</a></p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Callback updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_NO_CALLBACK_MEMORY</td><td>p_callback is non-secure and p_callback_memory is either secure or NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v6.2.0 User's Manual Copyright © (2025) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
