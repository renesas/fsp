<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: Watchdog Timer (r_wdt)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v1.3.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___w_d_t.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<div class="title">Watchdog Timer (r_wdt)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaff080d0dcc993cfbe7e99771396feffb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#gaff080d0dcc993cfbe7e99771396feffb">R_WDT_Refresh</a> (<a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:gaff080d0dcc993cfbe7e99771396feffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad64d0778fd0ceccb13a7287bb0d1fca8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#gad64d0778fd0ceccb13a7287bb0d1fca8">R_WDT_Open</a> (<a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const p_ctrl, <a class="el" href="group___w_d_t___a_p_i.html#structwdt__cfg__t">wdt_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:gad64d0778fd0ceccb13a7287bb0d1fca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd5b9ff42df96b9fd4603dda47b946cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#gacd5b9ff42df96b9fd4603dda47b946cb">R_WDT_StatusClear</a> (<a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const p_ctrl, const <a class="el" href="group___w_d_t___a_p_i.html#ga46c1d04f78b75ad1ad21314cac574935">wdt_status_t</a> status)</td></tr>
<tr class="separator:gacd5b9ff42df96b9fd4603dda47b946cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17bf328598042575cbe4f126f59bbc1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#ga17bf328598042575cbe4f126f59bbc1b">R_WDT_StatusGet</a> (<a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const p_ctrl, <a class="el" href="group___w_d_t___a_p_i.html#ga46c1d04f78b75ad1ad21314cac574935">wdt_status_t</a> *const p_status)</td></tr>
<tr class="separator:ga17bf328598042575cbe4f126f59bbc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6b4f726ecfe6795c7887dc1226450ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#gaf6b4f726ecfe6795c7887dc1226450ca">R_WDT_CounterGet</a> (<a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const p_ctrl, uint32_t *const p_count)</td></tr>
<tr class="separator:gaf6b4f726ecfe6795c7887dc1226450ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6e98a5b526d81651da1ffeda3f70263"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#gac6e98a5b526d81651da1ffeda3f70263">R_WDT_TimeoutGet</a> (<a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const p_ctrl, <a class="el" href="group___w_d_t___a_p_i.html#structwdt__timeout__values__t">wdt_timeout_values_t</a> *const p_timeout)</td></tr>
<tr class="separator:gac6e98a5b526d81651da1ffeda3f70263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga680a10e61b40517672ab1bd76d3941cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#ga680a10e61b40517672ab1bd76d3941cc">R_WDT_VersionGet</a> (<a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#unionfsp__version__t">fsp_version_t</a> *const p_version)</td></tr>
<tr class="separator:ga680a10e61b40517672ab1bd76d3941cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the WDT peripheral on RA MCUs. This module implements the <a class="el" href="group___w_d_t___a_p_i.html">WDT Interface</a>. </p>
<h1><a class="anchor" id="r-wdt-overview"></a>
Overview</h1>
<p>The watchdog timer is used to recover from unexpected errors in an application. The watchdog timer must be refreshed periodically in the permitted count window by the application. If the count is allowed to underflow or refresh occurs outside of the valid refresh period, the WDT resets the device or generates an NMI.</p>
<div class="image">
<img src="r_wdt_operation_example.png" alt="r_wdt_operation_example.png"/>
<div class="caption">
Watchdog Timer Operation Example</div></div>
 <h2><a class="anchor" id="r-wdt-features"></a>
Features</h2>
<p>The WDT HAL module has the following key features:</p><ul>
<li>When the WDT underflows or is refreshed outside of the permitted refresh window, one of the following events can occur:<ul>
<li>Resetting of the device<a class="anchor" id="um_wdt_configuration_for_reset_control"></a></li>
<li>Generation of an NMI<a class="anchor" id="um_wdt_nmi_callback_support"></a></li>
</ul>
</li>
<li>The WDT has two supported modes:<ul>
<li>In auto start mode, the WDT begins counting at reset.<a class="anchor" id="um_wdt_register_start_mode"></a></li>
<li>In register start mode, the WDT can be started from the application.<a class="anchor" id="um_wdt_auto_start_mode_support"></a> </li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="r-wdt-selecting-a-watchdog"></a>
Selecting a Watchdog</h2>
<p>RA MCUs have two watchdog peripherals: the watchdog timer (WDT) and the independent watchdog timer (IWDT). When selecting between them, consider these factors:</p>
<table class="doxtable">
<tr>
<th></th><th>WDT </th><th>IWDT  </th></tr>
<tr>
<td>Start Mode</td><td>The WDT can be started from the application (register start mode) or configured by hardware to start automatically (auto start mode). </td><td>The IWDT can only be configured by hardware to start automatically. </td></tr>
<tr>
<td>Clock Source</td><td>The WDT runs off a peripheral clock.</td><td>The IWDT has its own clock source which improves safety. </td></tr>
</table>
<h1><a class="anchor" id="r-wdt-configuration"></a>
Configuration</h1>
<p>When using register start mode, configure the watchdog timer on the Stacks tab.</p>
<dl class="section note"><dt>Note</dt><dd>When using auto start mode, configurations on the <b>Stacks</b> tab are ignored. Configure the watchdog using the OFS settings on the BSP tab.</dd></dl>
<p><a class="anchor" id="um_wdt_nmi_callback_required"></a><a class="anchor" id="um_wdt_configuration_for_refresh_window_start_position"></a><a class="anchor" id="um_wdt_configuration_for_refresh_window_end_position"></a><a class="anchor" id="um_wdt_configuration_for_wdt_clock_division"></a><a class="anchor" id="um_wdt_configuration_for_wdt_timeout_period"></a> <h2>Build Time Configurations for r_wdt</h2>
The following build time configurations are defined in fsp_cfg/r_wdt_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr>
<td>Register Start NMI Support</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>If enabled, code for NMI support in register start mode is included in the build. </td></tr>
</table>
 <h2>Configurations for Driver &gt; Monitoring &gt; Watchdog Driver on r_wdt</h2>
This module can be added to the Stacks tab via New Stack &gt; Driver &gt; Monitoring &gt; Watchdog Driver on r_wdt:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Name</td><td>Name must be a valid C symbol</td><td>g_wdt0 </td><td>Module name. </td></tr>
<tr>
<td>Timeout</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1,024 Cycles</li>
<li>
4,096 Cycles</li>
<li>
8,192 Cycles</li>
<li>
16,384 Cycles</li>
</ul>
</td><td>16,384 Cycles </td><td>Select the watchdog timeout in cycles. </td></tr>
<tr>
<td>Clock Division Ratio</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
PCLK/4</li>
<li>
PCLK/64</li>
<li>
PCLK/128</li>
<li>
PCLK/512</li>
<li>
PCLK/2048</li>
<li>
PCLK/8192</li>
</ul>
</td><td>PCLK/8192 </td><td>Select the watchdog clock divisor. </td></tr>
<tr>
<td>Window Start Position</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
100% (Window Position Not Specified)</li>
<li>
75%</li>
<li>
50%</li>
<li>
25</li>
</ul>
</td><td>100% (Window Position Not Specified) </td><td>Select the allowed watchdog refresh start point. </td></tr>
<tr>
<td>Window End Position</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
0% (Window Position Not Specified)</li>
<li>
25%</li>
<li>
50%</li>
<li>
75%</li>
</ul>
</td><td>0% (Window Position Not Specified) </td><td>Select the allowed watchdog refresh end point. </td></tr>
<tr>
<td>Reset Control</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Reset Output</li>
<li>
NMI Generated</li>
</ul>
</td><td>Reset Output </td><td>Select what happens when the watchdog timer expires. </td></tr>
<tr>
<td>Stop Control</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
WDT Count Enabled in Low Power Mode</li>
<li>
WDT Count Disabled in Low Power Mode</li>
</ul>
</td><td>WDT Count Disabled in Low Power Mode </td><td>Select the watchdog state in low power mode. </td></tr>
<tr>
<td>NMI Callback</td><td>Name must be a valid C symbol</td><td>NULL </td><td>A user callback function must be provided if the WDT is configured to generate an NMI when the timer underflows or a refresh error occurs. If this callback function is provided, it will be called from the NMI handler each time the watchdog triggers. </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-wdt-clock-configuration"></a>
Clock Configuration</h2>
<p>The WDT clock is based on the PCLKB frequency. You can set the PCLKB frequency using the <b>Clocks</b> tab of the RA Configuration editor or by using the CGC Interface at run-time. The maximum timeout period with PCLKB running at 60 MHz is approximately 2.2 seconds.</p>
<h2><a class="anchor" id="r-wdt-pin-configuration"></a>
Pin Configuration</h2>
<p>This module does not use I/O pins.</p>
<h1><a class="anchor" id="r-wdt-usage_notes"></a>
Usage Notes</h1>
<h2><a class="anchor" id="r-wdt-nmi-interrupt"></a>
NMI Interrupt</h2>
<p>The watchdog timer uses the NMI, which is enabled by default. No special configuration is required. When the NMI is triggered, the callback function registered during open is called.</p>
<dl class="section note"><dt>Note</dt><dd>When using the WDT in software start mode with NMI and the timer underflows, the WDT status must be reset by calling <a class="el" href="group___w_d_t.html#gacd5b9ff42df96b9fd4603dda47b946cb">R_WDT_StatusClear</a> before restarting the timer via <a class="el" href="group___w_d_t.html#gaff080d0dcc993cfbe7e99771396feffb">R_WDT_Refresh</a>.</dd></dl>
<h2>Period Calculation</h2>
<p>The WDT operates from PCLKB. With a PCLKB of 60 MHz, the maximum time from the last refresh to device reset or NMI generation will be just over 2.2 seconds as detailed below.</p>
<p>PLCKB = 60 MHz<br />
Clock division ratio = PCLKB / 8192<br />
Timeout period = 16384 cycles<br />
WDT clock frequency = 60 MHz / 8192 = 7.324 kHz<br />
Cycle time = 1 / 7.324 kHz = 136.53 us<br />
Timeout = 136.53 us x 16384 cycles = 2.23 seconds</p>
<h2><a class="anchor" id="r-wdt-limitations"></a>
Limitations</h2>
<p>Developers should be aware of the following limitations when using the WDT:</p>
<ul>
<li>When using a J-Link debugger the WDT counter does not count and therefore will not reset the device or generate an NMI. To enable the watchdog to count and generate a reset or NMI while debugging, add this line of code in the application: <div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Enable the WDT to count and generate NMI or reset when the</span></div><div class="line"><span class="comment">     * debugger is connected. */</span></div><div class="line">    R_DEBUG-&gt;DBGSTOPCR_b.DBGSTOP_WDT = 0;</div><div class="line"></div></div><!-- fragment --></li>
<li>If the WDT is configured to stop the counter in low power mode, then your application must restart the watchdog by calling <a class="el" href="group___w_d_t.html#gaff080d0dcc993cfbe7e99771396feffb">R_WDT_Refresh()</a> after the MCU wakes from low power mode.</li>
</ul>
<h1><a class="anchor" id="r-wdt-examples"></a>
Examples</h1>
<h2>WDT Basic Example</h2>
<p>This is a basic example of minimal use of the WDT in an application.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> wdt_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* In auto start mode, the WDT starts counting immediately when the MCU is powered on. */</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___w_d_t.html#gad64d0778fd0ceccb13a7287bb0d1fca8">R_WDT_Open</a>(&amp;g_wdt0_ctrl, &amp;g_wdt0_cfg);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    <span class="comment">/* In register start mode, start the watchdog by calling R_WDT_Refresh. */</span></div><div class="line">    err = <a class="code" href="group___w_d_t.html#gaff080d0dcc993cfbe7e99771396feffb">R_WDT_Refresh</a>(&amp;g_wdt0_ctrl);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Application work here. */</span></div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">/* Refresh before the counter underflows to prevent reset or NMI. */</span></div><div class="line">        err = <a class="code" href="group___w_d_t.html#gaff080d0dcc993cfbe7e99771396feffb">R_WDT_Refresh</a>(&amp;g_wdt0_ctrl);</div><div class="line">        handle_error(err);</div><div class="line"></div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>WDT Advanced Example</h2>
<p>This example demonstrates using a start window and gives an example callback to handle an NMI generated by an underflow or refresh error.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define WDT_TIMEOUT_COUNTS     (16384U)</span></div><div class="line"><span class="preprocessor">#define WDT_MAX_COUNTER        (WDT_TIMEOUT_COUNTS - 1U)</span></div><div class="line"><span class="preprocessor">#define WDT_START_WINDOW_75    ((WDT_MAX_COUNTER * 3) / 4)</span></div><div class="line"></div><div class="line"><span class="comment">/* Example callback called when a watchdog NMI occurs. */</span></div><div class="line"><span class="keywordtype">void</span> wdt_callback (<a class="code" href="group___w_d_t___a_p_i.html#structwdt__callback__args__t">wdt_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gaf0afcbc9a110ac9366a811d96ee06029">FSP_PARAMETER_NOT_USED</a>(p_args);</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Determine the source of the NMI. */</span></div><div class="line">    <a class="code" href="group___w_d_t___a_p_i.html#ga46c1d04f78b75ad1ad21314cac574935">wdt_status_t</a> status = <a class="code" href="group___w_d_t___a_p_i.html#gga46c1d04f78b75ad1ad21314cac574935a0f1543f47bca7e987fe86ab04dd16e46">WDT_STATUS_NO_ERROR</a>;</div><div class="line">    err = <a class="code" href="group___w_d_t.html#ga17bf328598042575cbe4f126f59bbc1b">R_WDT_StatusGet</a>(&amp;g_wdt0_ctrl, &amp;status);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Log source of NMI and any other debug information. */</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Clear the error flags. */</span></div><div class="line">    err = <a class="code" href="group___w_d_t.html#gacd5b9ff42df96b9fd4603dda47b946cb">R_WDT_StatusClear</a>(&amp;g_wdt0_ctrl, status);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* (Register start mode) In register start mode, call R_WDT_Refresh() to</span></div><div class="line"><span class="comment">     * continue using the watchdog after an error. */</span></div><div class="line">    err = <a class="code" href="group___w_d_t.html#gaff080d0dcc993cfbe7e99771396feffb">R_WDT_Refresh</a>(&amp;g_wdt0_ctrl);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Issue a software reset to reset the MCU. */</span></div><div class="line">    __NVIC_SystemReset();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> wdt_advanced_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Enable the WDT to count and generate NMI or reset when the</span></div><div class="line"><span class="comment">     * debugger is connected. */</span></div><div class="line">    R_DEBUG-&gt;DBGSTOPCR_b.DBGSTOP_WDT = 0;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Check if the WDTRF flag is set to know if the system is</span></div><div class="line"><span class="comment">     * recovering from a WDT reset. */</span></div><div class="line">    <span class="keywordflow">if</span> (R_SYSTEM-&gt;RSTSR1_b.WDTRF)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Clear the flag. */</span></div><div class="line">        R_SYSTEM-&gt;RSTSR1 = 0U;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Open the module. */</span></div><div class="line">    err = <a class="code" href="group___w_d_t.html#gad64d0778fd0ceccb13a7287bb0d1fca8">R_WDT_Open</a>(&amp;g_wdt0_ctrl, &amp;g_wdt0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize other application code. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* (Register start mode) Call R_WDT_Refresh() to start the WDT in register</span></div><div class="line"><span class="comment">     * start mode.  Do not call R_WDT_Refresh() in auto start mode unless the</span></div><div class="line"><span class="comment">     * counter is in the acceptable refresh window. */</span></div><div class="line">    err = <a class="code" href="group___w_d_t.html#gaff080d0dcc993cfbe7e99771396feffb">R_WDT_Refresh</a>(&amp;g_wdt0_ctrl);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Application work here. */</span></div><div class="line"></div><div class="line">        <span class="comment">/* (Optional) If there is a chance the application takes less time than</span></div><div class="line"><span class="comment">         * the start window, verify the WDT counter is past the start window</span></div><div class="line"><span class="comment">         * before refreshing the WDT. */</span></div><div class="line">        uint32_t wdt_counter = 0U;</div><div class="line">        <span class="keywordflow">do</span></div><div class="line">        {</div><div class="line"></div><div class="line">            <span class="comment">/* Read the current WDT counter value. */</span></div><div class="line">            err = <a class="code" href="group___w_d_t.html#gaf6b4f726ecfe6795c7887dc1226450ca">R_WDT_CounterGet</a>(&amp;g_wdt0_ctrl, &amp;wdt_counter);</div><div class="line">            handle_error(err);</div><div class="line"></div><div class="line">        } <span class="keywordflow">while</span> (wdt_counter &gt;= WDT_START_WINDOW_75);</div><div class="line"></div><div class="line">        <span class="comment">/* Refresh before the counter underflows to prevent reset or NMI. */</span></div><div class="line">        err = <a class="code" href="group___w_d_t.html#gaff080d0dcc993cfbe7e99771396feffb">R_WDT_Refresh</a>(&amp;g_wdt0_ctrl);</div><div class="line">        handle_error(err);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structwdt__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#structwdt__instance__ctrl__t">wdt_instance_ctrl_t</a></td></tr>
<tr class="separator:structwdt__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structwdt__instance__ctrl__t" id="structwdt__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structwdt__instance__ctrl__t">&#9670;&nbsp;</a></span>wdt_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct wdt_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>WDT private control block. DO NOT MODIFY. Initialization occurs when <a class="el" href="group___w_d_t.html#gad64d0778fd0ceccb13a7287bb0d1fca8">R_WDT_Open()</a> is called. </p>
</div>
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaff080d0dcc993cfbe7e99771396feffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff080d0dcc993cfbe7e99771396feffb">&#9670;&nbsp;</a></span>R_WDT_Refresh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_WDT_Refresh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Refresh the watchdog timer. Implements <a class="el" href="group___w_d_t___a_p_i.html#a0d1533024396b8280b7240c781a09a44">wdt_api_t::refresh</a>.</p>
<p>In addition to refreshing the watchdog counter this function can be used to start the counter in register start mode.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">        <span class="comment">/* Refresh before the counter underflows to prevent reset or NMI. */</span></div><div class="line">        err = <a class="code" href="group___w_d_t.html#gaff080d0dcc993cfbe7e99771396feffb">R_WDT_Refresh</a>(&amp;g_wdt0_ctrl);</div><div class="line">        handle_error(err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>WDT successfully refreshed. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Instance control block is not initialized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function only returns FSP_SUCCESS. If the refresh fails due to being performed outside of the permitted refresh period the device will either reset or trigger an NMI ISR to run. </dd></dl>

</div>
</div>
<a id="gad64d0778fd0ceccb13a7287bb0d1fca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad64d0778fd0ceccb13a7287bb0d1fca8">&#9670;&nbsp;</a></span>R_WDT_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_WDT_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#structwdt__cfg__t">wdt_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure the WDT in register start mode. In auto-start_mode the NMI callback can be registered. Implements <a class="el" href="group___w_d_t___a_p_i.html#af03fc1703319e1adacabc412c7e3de31">wdt_api_t::open</a>.</p>
<p>This function should only be called once as WDT configuration registers can only be written to once so subsequent calls will have no effect.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___w_d_t.html#gad64d0778fd0ceccb13a7287bb0d1fca8">R_WDT_Open</a>(&amp;g_wdt0_ctrl, &amp;g_wdt0_cfg);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>WDT successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer, or one or more configuration options is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Module is already open. This module can only be opened once.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In auto start mode the only valid configuration option is for registering the callback for the NMI ISR if NMI output has been selected. </dd></dl>

</div>
</div>
<a id="gacd5b9ff42df96b9fd4603dda47b946cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd5b9ff42df96b9fd4603dda47b946cb">&#9670;&nbsp;</a></span>R_WDT_StatusClear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_WDT_StatusClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___w_d_t___a_p_i.html#ga46c1d04f78b75ad1ad21314cac574935">wdt_status_t</a>&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the WDT status and error flags. Implements <a class="el" href="group___w_d_t___a_p_i.html#af66d798489c7ace801fee8b5a9c833c2">wdt_api_t::statusClear</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Clear the error flags. */</span></div><div class="line">    err = <a class="code" href="group___w_d_t.html#gacd5b9ff42df96b9fd4603dda47b946cb">R_WDT_StatusClear</a>(&amp;g_wdt0_ctrl, status);</div><div class="line">    handle_error(err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>WDT flag(s) successfully cleared. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Instance control block is not initialized. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>This function is only valid if the watchdog generates an NMI when an error occurs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When the WDT is configured to output a reset on underflow or refresh error reading the status and error flags serves no purpose as they will always indicate that no underflow has occurred and there is no refresh error. Reading the status and error flags is only valid when interrupt request output is enabled. </dd></dl>

</div>
</div>
<a id="ga17bf328598042575cbe4f126f59bbc1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17bf328598042575cbe4f126f59bbc1b">&#9670;&nbsp;</a></span>R_WDT_StatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_WDT_StatusGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#ga46c1d04f78b75ad1ad21314cac574935">wdt_status_t</a> *const&#160;</td>
          <td class="paramname"><em>p_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the WDT status flags. Implements <a class="el" href="group___w_d_t___a_p_i.html#a317b972273cef3bc94087727b3ee17c5">wdt_api_t::statusGet</a>.</p>
<p>Indicates both status and error conditions.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Determine the source of the NMI. */</span></div><div class="line">    <a class="code" href="group___w_d_t___a_p_i.html#ga46c1d04f78b75ad1ad21314cac574935">wdt_status_t</a> status = <a class="code" href="group___w_d_t___a_p_i.html#gga46c1d04f78b75ad1ad21314cac574935a0f1543f47bca7e987fe86ab04dd16e46">WDT_STATUS_NO_ERROR</a>;</div><div class="line">    err = <a class="code" href="group___w_d_t.html#ga17bf328598042575cbe4f126f59bbc1b">R_WDT_StatusGet</a>(&amp;g_wdt0_ctrl, &amp;status);</div><div class="line">    handle_error(err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>WDT status successfully read. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Instance control block is not initialized. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>This function is only valid if the watchdog generates an NMI when an error occurs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When the WDT is configured to output a reset on underflow or refresh error reading the status and error flags serves no purpose as they will always indicate that no underflow has occurred and there is no refresh error. Reading the status and error flags is only valid when interrupt request output is enabled. </dd></dl>

</div>
</div>
<a id="gaf6b4f726ecfe6795c7887dc1226450ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6b4f726ecfe6795c7887dc1226450ca">&#9670;&nbsp;</a></span>R_WDT_CounterGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_WDT_CounterGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *const&#160;</td>
          <td class="paramname"><em>p_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the current count value of the WDT. Implements <a class="el" href="group___w_d_t___a_p_i.html#a724c02d7265d5eaa846cf97a3556f5d6">wdt_api_t::counterGet</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">            <span class="comment">/* Read the current WDT counter value. */</span></div><div class="line">            err = <a class="code" href="group___w_d_t.html#gaf6b4f726ecfe6795c7887dc1226450ca">R_WDT_CounterGet</a>(&amp;g_wdt0_ctrl, &amp;wdt_counter);</div><div class="line">            handle_error(err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>WDT current count successfully read. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Instance control block is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac6e98a5b526d81651da1ffeda3f70263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6e98a5b526d81651da1ffeda3f70263">&#9670;&nbsp;</a></span>R_WDT_TimeoutGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_WDT_TimeoutGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#structwdt__timeout__values__t">wdt_timeout_values_t</a> *const&#160;</td>
          <td class="paramname"><em>p_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read timeout information for the watchdog timer. Implements <a class="el" href="group___w_d_t___a_p_i.html#ac2b6d848e8be0ff1a0a1be43289ad925">wdt_api_t::timeoutGet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>WDT timeout information retrieved successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null Pointer. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Instance control block is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga680a10e61b40517672ab1bd76d3941cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga680a10e61b40517672ab1bd76d3941cc">&#9670;&nbsp;</a></span>R_WDT_VersionGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_WDT_VersionGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#unionfsp__version__t">fsp_version_t</a> *const&#160;</td>
          <td class="paramname"><em>p_version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return WDT HAL driver version. Implements <a class="el" href="group___w_d_t___a_p_i.html#a68032fbfd5bf74052918b358be31b219">wdt_api_t::versionGet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Version information successfully read. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v1.3.0 User's Manual Copyright Â© (2020) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
